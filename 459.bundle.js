/*! For license information see: https://cbunt.ing/oss-licenses.json */
"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[459],{8844:(e,t,n)=>{n.d(t,{A:()=>c});var r=n(1321);function a(e){return"string"==typeof e?e:e()}class i{constructor(e,t){this.else=e=>this.res??a(e),this.toString=()=>this.res??"",e&&(this.res=a(t))}elif(e,t){return e&&(this.res??=a(t)),this}get[Symbol.toStringTag](){return this.toString()}}function o(e,t=0){return()=>e(t++)}var s=n(3723);function l(e){const{ifdef:t}=function(e){return{ifdef:(t,n)=>new i((e&t)===t,n),ifndef:(t,n)=>new i((e&t)!==t,n)}}(e),n=o((e=>`@location(${e})`)),a=o((e=>`@location(${e})`)),l=o((e=>`\n        @group(1) @binding(${e})\n    `)),u=`\n        ${a()} pos: vec3f,\n        ${a()} camPos: vec3f,\n        ${a()} uv: vec2f,\n\n        ${t(r.Ot.VertexNormals,(()=>`\n            ${a()} tangent: vec4f,\n            ${a()} normal: vec3f,\n        `))}\n\n        ${t(r.Ot.VertexColors,(()=>`\n            ${a()} color: vec4f,\n        `))}\n    `;return`\n        ${s.A.code(0)}\n\n        struct ForwardOut {\n            @location(0) normal: vec4f,\n            @location(1) albedo: vec4f,\n            @location(2) emission: vec4f,\n            @location(3) metallicRoughness: vec4f,\n        }\n\n        struct MaterialProperties {\n            baseColorFactor: vec4f,\n            metallicFactor: f32,\n            roughnessFactor: f32,\n\n            ${t(r.Ot.AlphaCutoff,"alphaCutoff: f32,")}\n            ${t(r.Ot.Emissive,"emissiveFactor: vec3f,")}\n        }\n\n        ${l()} var<uniform> material: MaterialProperties;\n\n        ${l()} var baseColorSampler: sampler;\n        ${l()} var baseColorTexture: texture_2d<f32>;\n\n        ${l()} var normalSampler: sampler;\n        ${l()} var normalTexture: texture_2d<f32>;\n\n        ${l()} var metallicRoughnessSampler: sampler;\n        ${l()} var metallicRoughnessTexture: texture_2d<f32>;\n\n        ${t(r.Ot.Emissive,(()=>`\n            ${l()} var emissionSampler: sampler;\n            ${l()} var emissionTexture: texture_2d<f32>;\n        `))}\n\n        struct ModelProperties {\n            modelToWorldMatrix: mat4x4f,\n\n            ${t(r.Ot.VertexNormals,"normalMatrix: mat3x3f,")}\n        }\n\n        @group(2) @binding(0) var<storage, read> instances : array<ModelProperties>;\n\n        struct VertIn {\n            @builtin(instance_index) instance: u32,\n            ${n()} pos: vec3f,\n            ${n()} uv: vec2f,\n\n            ${t(r.Ot.VertexNormals,(()=>`\n                ${n()} tangent: vec4f,\n                ${n()} normal: vec3f,\n            `))}\n\n            ${t(r.Ot.VertexColors,(()=>`\n                ${n()} color: vec4f,\n            `))}\n        }\n\n        struct VertOut {\n            ${u}\n            @builtin(position) Position: vec4f,\n        }\n\n        struct FragIn {\n            ${u}\n\n            ${t(r.Ot.VertexNormals|r.Ot.DoubleSided,"\n                @builtin(front_facing) front_facing: bool,\n            ")}\n        }\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @vertex \n        fn vs(inData: VertIn) -> VertOut {\n            var vsOut: VertOut;\n            let instance = instances[inData.instance];\n            let worldPos = instance.modelToWorldMatrix * vec4f(inData.pos, 1);\n            vsOut.pos = worldPos.xyz;\n            vsOut.Position = globals.worldToClip * worldPos;\n            vsOut.camPos = globals.inverseWorldToView[3].xyz;\n            vsOut.uv = inData.uv;\n\n            ${t(r.Ot.VertexNormals,"\n                vsOut.normal = normalize(instance.normalMatrix * inData.normal);\n                let wsTangent = normalize((instance.modelToWorldMatrix * vec4(inData.tangent.xyz, 0.0)).xyz);\n                vsOut.tangent = vec4(wsTangent, inData.tangent.w);\n            ")}\n\n            return vsOut;\n        }\n\n        // much of this code is adapted from https://learnopengl.com/PBR\n        @fragment\n        fn fs(inData: FragIn) -> ForwardOut {\n            var out: ForwardOut;\n            let rawColor = textureSample(baseColorTexture, baseColorSampler, inData.uv);\n\n            ${t(r.Ot.AlphaCutoff,`\n                var alpha = rawColor.a * material.baseColorFactor.a;\n\n                ${t(r.Ot.VertexColors,"\n                    alpha *= inData.color.a;\n                ")}\n\n                if (alpha <= material.alphaCutoff) { \n                    discard;\n                }\n            `)}\n\n            out.albedo = vec4f(rawColor.rgb * material.baseColorFactor.rgb, 1);\n\n            ${t(r.Ot.VertexColors,"\n                out.albedo *= vec4f(inData.color.rgb, 1);\n            ")}\n\n            let metallicRoughness = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, inData.uv);\n            out.metallicRoughness.r = saturate(metallicRoughness.b * material.metallicFactor);\n            out.metallicRoughness.g = saturate(metallicRoughness.g * material.roughnessFactor);\n\n            ${t(r.Ot.VertexNormals,`\n                let normalSample = textureSample(normalTexture, normalSampler, inData.uv).xyz;\n                let tangentNormal = normalize(normalSample * 2.0 - 1.0);\n                let bitangent =inData.tangent.w * cross(inData.normal, inData.tangent.xyz);\n                let tbn = mat3x3f(normalize(inData.tangent.xyz), bitangent, normalize(inData.normal));\n                var normal = normalize(tbn * tangentNormal);\n\n                ${t(r.Ot.DoubleSided,"\n                    if (!inData.front_facing) { normal *= -1.0; }\n                ")}\n            `).else("\n                let fdx = dpdx(inData.pos);\n                let fdy = dpdy(inData.pos);\n                let normal = normalize(cross(fdy, fdx));\n            ")}\n\n            out.normal = vec4f(normal, 1);\n\n            ${t(r.Ot.Emissive,"\n                let emission = textureSample(emissionTexture, emissionSampler, inData.uv).rgb;\n                out.emission = vec4f(emission, 1);\n            ")}\n\n            return out;\n        }\n    `}class u{constructor(e,t,n){this.device=e,this.gbuffer=t,this.globals=n,this.pipelineLayouts={},this.primitiveStates={},this.vertexLayouts={},this.shaderModules={},this.bindgroupLayouts={},this.samplers={},this.forwardBindgroupLayout=this.device.createBindGroupLayout({label:"forward material",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]})}getSampler(e){const t=JSON.stringify(e);return this.samplers[t]??=this.device.createSampler(e),this.samplers[t]}getVertexLayout(e){const t=e&r.V3;if(null==this.vertexLayouts[t]){const e=[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}];let n=20,a=2;t&r.Ot.VertexNormals&&(e.push({shaderLocation:a,offset:n,format:"float32x4"}),e.push({shaderLocation:a+1,offset:n+16,format:"float32x3"}),a+=2,n+=28),t&r.Ot.VertexColors&&(e.push({shaderLocation:a,offset:n,format:"float32x4"}),n+=16),this.vertexLayouts[t]={attributes:e,arrayStride:n,stepMode:"vertex"}}return this.vertexLayouts[t]}getForwardPipelineLayout(e){const t=e&r.FO;return this.pipelineLayouts[t]??=this.device.createPipelineLayout({label:r.UZ(t),bindGroupLayouts:[this.globals.bindGroupLayout,this.getMaterialBindGroup(e),this.forwardBindgroupLayout]}),this.pipelineLayouts[t]}getShaderModule(e){const t=e&r.Q7;return this.shaderModules[t]??=this.device.createShaderModule({label:r.UZ(t),code:l(t)}),this.shaderModules[t]}getPrimitiveState(e){const t=e&r.XY;return this.primitiveStates[t]??={topology:u.flagToTopology[e&r.Py],cullMode:t&r.Ot.DoubleSided?"none":"back",frontFace:t&r.Ot.ClockwiseWinding?"cw":"ccw"},this.primitiveStates[t]}getMaterialBindGroup(e){const t=e&r.Wq;return this.bindgroupLayouts[t]??=this.device.createBindGroupLayout(function(e){const t=[];function n(e){t.push({...e,binding:t.length,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.VERTEX})}return n({buffer:{type:"uniform"}}),n({sampler:{}}),n({texture:{viewDimension:"2d"}}),n({sampler:{}}),n({texture:{viewDimension:"2d"}}),n({sampler:{}}),n({texture:{viewDimension:"2d"}}),e&r.Ot.Emissive&&(n({sampler:{}}),n({texture:{viewDimension:"2d"}})),{label:(0,r.UZ)(e),entries:t}}(t)),this.bindgroupLayouts[t]}}u.flagToTopology={[r.Ot.TriangleList]:"triangle-list",[r.Ot.TriangleStrip]:"triangle-strip",[r.Ot.PointList]:"point-list",[r.Ot.LineList]:"line-list",[r.Ot.LineStrip]:"line-strip"};const c=u},1321:(e,t,n)=>{var r;n.d(t,{FO:()=>c,Ot:()=>r,P7:()=>m,Py:()=>a,Q7:()=>o,UZ:()=>d,V3:()=>l,Wq:()=>u,XY:()=>i}),function(e){e[e.Defaults=0]="Defaults",e[e.VertexNormals=1]="VertexNormals",e[e.VertexColors=2]="VertexColors",e[e.AlphaCutoff=4]="AlphaCutoff",e[e.Emissive=8]="Emissive",e[e.DoubleSided=16]="DoubleSided",e[e.ClockwiseWinding=32]="ClockwiseWinding",e[e.TriangleList=0]="TriangleList",e[e.TriangleStrip=64]="TriangleStrip",e[e.PointList=128]="PointList",e[e.LineList=192]="LineList",e[e.LineStrip=256]="LineStrip",e[e.Unindexed=320]="Unindexed"}(r||(r={}));const a=17472,i=a|r.DoubleSided|r.ClockwiseWinding,o=~(a|r.ClockwiseWinding),s=r.VertexNormals,l=r.VertexNormals|r.VertexColors,u=r.AlphaCutoff|r.Emissive,c=s|(u|r.DoubleSided);function d(e){return function(e){return Object.entries(r).flatMap((([t,n])=>"number"==typeof n&&n&e?t:[]))}(e).toString()}function m(e){let t=e;return t&r.DoubleSided&&(t&=~r.ClockwiseWinding),t}},3723:(e,t,n)=>{n.d(t,{A:()=>o});var r=n(3519);const a="global uniforms";class i{constructor(e){this.deviceBuffer=e.createBuffer(i.bufferDescriptor),this.bindGroupLayout=e.createBindGroupLayout(i.layoutDescriptor),this.bindGroupDescriptor={label:a,layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:this.deviceBuffer,offset:0,size:i.bufferSize}}]},this.bindgroup=e.createBindGroup(this.bindGroupDescriptor)}updateDeviceBuffer(e,t){t.cacheView(),e.writeBuffer(this.deviceBuffer,0,t.buffer)}}i.code=e=>`\n        struct GlobalUniforms {\n            worldToView: mat4x4f,\n            viewToClip: mat4x4f,\n            worldToClip: mat4x4f,\n            inverseWorldToView: mat4x4f,\n            inverseViewToClip: mat4x4f,\n            inverseWorldToClip: mat4x4f,\n        }\n\n        @group(${e}) @binding(0) var<uniform> globals: GlobalUniforms;\n    `,i.bufferSize=r.A.bufferLength,i.layoutDescriptor={label:a,entries:[{binding:0,buffer:{minBindingSize:i.bufferSize},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}]},i.bufferDescriptor={label:a,size:i.bufferSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};const o=i},1447:(e,t,n)=>{n.d(t,{A:()=>s});var r=n(7590),a=n(71),i=n(5225);const o=(e,t)=>`\n    ${r.X}\n    ${r.V}\n\n    override STEPS: i32 = 4;\n\n    struct Params {\n        offset: u32,\n        sigmas: array<f32>,\n    }\n\n    @group(0) @binding(0) var previousMip: texture_2d_array<f32>;\n\n    @group(0) @binding(1) \n    var outputTexture: texture_storage_2d_array<${t}, write>;\n\n    // sigma[0] reserved for work offset\n    @group(0) @binding(2) var<storage> params: Params;\n    \n    @compute @workgroup_size(${e}, 1, 1)\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\n        let mipSize = textureDimensions(outputTexture).x;\n\n        let idx = gid.x + params.offset;\n        let faceSize = mipSize * mipSize;\n        let faceIdx = idx % faceSize;\n        let coord = vec3u(\n            faceIdx % mipSize, \n            faceIdx / mipSize, \n            idx / faceSize,\n        ); \n\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \n            return; \n        }\n\n        let previousSize = textureDimensions(previousMip).x;\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\n        let pos = toWorldDir(vec3u(coord), mipSize);\n\n        let size = arrayLength(&params.sigmas);\n        let level = size - u32(ceil(log2(f32(previousSize))));\n        let sigma = params.sigmas[level];\n        let guassian_factor = -0.5 / (sigma * sigma);\n\n        var weight = 0.0;\n        var res = vec3(0.0);\n\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\n                if (sample.z == INVALID_FACE) { continue; }\n\n                let samplePos = toWorldDir(sample, previousSize);\n                let x = max(0.0, acos(dot(samplePos, pos)));\n                let w = exp(x * x * guassian_factor);\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\n\n                res += color.rgb * w;\n                weight += w;\n            }\n        }\n\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\n    }\n`;async function s({device:e,texture:t,outputTextureLabel:n,inPlace:r=!1,minWidth:l=8,steps:u=4,maxOpsPerPass:c=113639424,label:d=s.name,delayWork:m}){const{width:f,format:p}=t,h=r?t.mipLevelCount:Math.log2(f)-Math.log2(l)+1;if(h<=1)return t;const v=Math.min(e.limits.maxComputeWorkgroupSizeX,e.limits.maxComputeInvocationsPerWorkgroup),g=e.createShaderModule({label:d,code:o(v,p)}),y=e.createBindGroupLayout({label:d,entries:[{binding:0,texture:{viewDimension:"2d-array"},visibility:GPUShaderStage.COMPUTE},{binding:1,storageTexture:{access:"write-only",viewDimension:"2d-array",format:p},visibility:GPUShaderStage.COMPUTE},{binding:2,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.COMPUTE}]}),b=e.createComputePipeline({label:d,layout:e.createPipelineLayout({label:d,bindGroupLayouts:[y]}),compute:{module:g,entryPoint:"main",constants:{STEPS:Math.ceil(u)}}});let x=t;if(!r){const r={width:f,height:f,depthOrArrayLayers:6};x=e.createTexture({label:n,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,dimension:"2d",format:p,mipLevelCount:h,size:r});const a=e.createCommandEncoder({label:`${d} copy encoder`});a.copyTextureToTexture({texture:t,mipLevel:0},{texture:x,mipLevel:0},r),e.queue.submit([a.finish()]),await e.queue.onSubmittedWorkDone()}const w=(0,i._b)(h,(e=>x.createView({label:`${d} mip view ${e}`,dimension:"2d-array",baseMipLevel:e,mipLevelCount:1}))),T=e.limits.maxComputeWorkgroupsPerDimension,S=Math.ceil(Math.log2(f)),P=Math.max(c/((1+2*u)**2*v)|0,1),A=new ArrayBuffer(4*(S+1)),O=new Uint32Array(A,0,1);new Float32Array(A,4,S).set((0,i._b)(S,(e=>{const t=f>>e;return Math.acos(1-function(e,t){const n=t>>1,r=n-Math.floor(e/4)-1,a=2/n*(r+.5)-1,i=1/n-1,o=1+a*a+i*i,s=2/t*(2*t-2*r-e-2+.5)-1,l=1/t-1,u=1+s*s+l*l,c=3/t-1,d=1+s*s+c*c,m=(s+a+l*i)/Math.sqrt(u*o),f=(s+a+c*i)/Math.sqrt(d*o);return Math.min(1-m,1-f)}(Math.min(t,u),t))/3})));const C=(0,a.Lr)(A,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,e);return await new Promise((t=>{let n,r=0,a=0,i=0,o=0,s=0;!async function l(){if(o>=i){if(r+=1,o=0,a=0,r>=h)return void t();const s=6*(f>>r)**2;i=Math.ceil(s/v),n=e.createBindGroup({layout:y,entries:[{binding:0,resource:w[r-1]},{binding:1,resource:w[r]},{binding:2,resource:{buffer:C}}]})}O[0]=o*v,e.queue.writeBuffer(C,0,O);const u=Math.min(i-o,P-s,T),c=`${d} mip ${r}, pass ${a}`,p=e.createCommandEncoder({label:c}),g=p.beginComputePass({label:c});g.setPipeline(b),g.setBindGroup(0,n),g.dispatchWorkgroups(u,1,1),g.end(),e.queue.submit([p.finish()]),o+=u,s+=u,a+=1,null!=m&&s>=P?(s=0,await e.queue.onSubmittedWorkDone(),m(l)):l()}()})),x}},4459:(e,t,n)=>{n.a(e,(async(e,r)=>{try{n.r(t),n.d(t,{default:()=>g});var a=n(541),i=n(4508),o=n(8844),s=n(1321),l=n(1447),u=n(419),c=n(5225),d=e([i]);i=(d.then?(await d)():d)[0];var m,f=function(e,t,n,r){if("a"===n&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?r:"a"===n?r.call(e):r?r.value:t.get(e)};const p=await h();async function h(){const e=await fetch("https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/model-index.json"),t=await e.text(),n=JSON.parse(t);if(!Array.isArray(n))throw new Error("could not load gtlf model index");const r=n.flatMap((e=>{if(!((0,c.Gv)(e)&&"label"in e&&"string"==typeof e.label&&"name"in e&&"string"==typeof e.name&&"variants"in e&&(0,c.Gv)(e.variants)&&"string"==typeof e.variants.glTF))return[];const{variants:{glTF:t},label:n,name:r}=e;return[[n,`https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/${r}/glTF/${t}`]]}));return Object.fromEntries(r)}class v{get depthTextureView(){return this.descriptorMap.gbuffer.depth.view}constructor(e){this.renderer=e,this.geometryPipelines={},m.set(this,(0,a.A)({skybox:(0,i.A)(this),model:{[a.t.$type]:"file",[a.t.$callback]:(e,t)=>{"value"===t&&null!=e&&("string"==typeof e||e instanceof File)&&this.setModel(e)},accept:".hdr",selection:{value:"Environment Test",initialValues:p},process:e=>e}})),this.settings=f(this,m,"f").publicSettings,this.priority=1e3,this.descriptorMap=new o.A(e.device,e.gbuffer,e.globals),this.device=e.device,this.renderer.addForwardPass(this)}async setSkybox(e){await(0,l.A)({texture:e,device:this.renderer.device,inPlace:!0,delayWork:requestAnimationFrame}),this.renderer.skybox=e}async setModel(e){const t={width:1,height:1},n=new Float32Array([1,1,1,1]),r=this.renderer.device.createTexture({size:t,format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});this.renderer.device.queue.writeTexture({texture:r},n,{},t);const a=this.renderer.device.createTexture({size:t,format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});n.set([.5,.5,1,1]),this.renderer.device.queue.writeTexture({texture:a},n,{},t);const i={addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"},o={baseColorTexture:r,baseColorFactor:[1,1,1,1],normalTexture:a,metallicRoughnessTexture:r,metallicFactor:1,roughnessFactor:1,baseColorSampler:i,normalSampler:i,metallicRoughnessSampler:i};this.geometryPipelines=await(0,u.A)(e,this.renderer.device,this.descriptorMap,o,v.goalLayout,{})}render({encoder:e,gbuffer:t,globals:n}){const r=e.beginRenderPass(t.passDescriptor);r.setBindGroup(0,n.bindgroup);for(const e of Object.values(this.geometryPipelines))e?.draw(r,this.renderer.device.queue);r.end()}}m=new WeakMap,v.title="glTF Model Viewer",v.description="",v.goalLayout=[{name:"POSITION",type:"VEC3",componentType:5126},{name:"TEXCOORD_0",type:"VEC2",componentType:5126},{name:"TANGENT",type:"VEC4",componentType:5126,depends:["NORMAL"],fill:[1,0,0,1]},{name:"NORMAL",type:"VEC3",componentType:5126,strip:!0,feature:s.Ot.VertexNormals},{name:"COLOR_0",type:"VEC4",componentType:5126,strip:!0,feature:s.Ot.VertexColors,fill:[1,1,1,1]}];const g=v;r()}catch(y){r(y)}}),1)},419:(e,t,n)=>{n.d(t,{A:()=>M});var r=n(282),a=n(287),i=n(4651),o=n(4482);class s{constructor(e){this.attributes=[];let t=0;for(const n of Object.values(e))t+=this.initAttribute(n);const n=t+3&-4;this.u8=new Uint8Array(n),this.u32=new Uint32Array(this.u8.buffer)}initAttribute(e){const t=e.data instanceof Uint8Array?e.data:new Uint8Array(e.data.buffer),n=e.bytesPerComponent*e.componentsPerElement;return this.attributes.push({u8:t,byteStride:n}),n}hash(e){let t=0;for(const{u8:n,byteStride:r}of this.attributes){for(let a=0;a<r;a+=1)this.u8[t+a]=n[e*r+a];t+=r}return this.murmurHash2()}equal(e,t){for(const{u8:n,byteStride:r}of this.attributes)for(let a=0;a<r;a+=1)if(n[e*r+a]!==n[t*r+a])return!1;return!0}hashLookup(e,t,n,r){const a=t-1;let i=this.hash(n)&a;for(let t=0;t<=a;t+=1){const o=e[i];if(o===r||this.equal(o,n))return i;i=i+t+1&a}throw new Error("Hash table full.")}murmurHash2(){const e=1540483477;let t=0;for(let n of this.u32)n=Math.imul(n,e)>>>0,n=(n^n>>24)>>>0,n=Math.imul(n,e)>>>0,t=Math.imul(t,e)>>>0,t=(t^n)>>>0;return t}}function l(e){const t=e.POSITION.count,n=new s(e),r=(a=t+t/4,2**Math.ceil(Math.log(a)/Math.LN2));var a;const i=t<65535,o=2**(i?16:32)-1,l=i?"uint16":"uint32",u=i?new Uint16Array(t):new Uint32Array(t),c=i?new Uint16Array(r):new Uint32Array(r);c.fill(o);let d=0;for(let e=0;e<t;e+=1){const t=n.hashLookup(c,r,e,o),a=c[t];a===o?(c[t]=e,u[e]=d,d+=1):u[e]=u[a]}for(const t of Object.values(e))t.remap(u,d);return{indexArray:u,indexFormat:l,vertexCount:d}}var u=n(1321),c=n(2009),d=n(71);class m{constructor(e,t,n,r,a){if(this.instanceCount=0,this.dirty=!1,this.max=n,this.features=e.features,this.name=e.name??"mesh",this.vertexCount=e.vertexCount,e.vertexArray instanceof GPUBuffer?this.vertexBuffer=e.vertexArray:this.vertexBuffer=(0,d.Lr)(e.vertexArray,GPUBufferUsage.VERTEX,t,`${this.name} vertex buffer`),e.indexArray&&e.indexFormat){const{indexArray:n,indexFormat:r}=e;this.indexData={indexFormat:r,indexCount:n.byteLength/("uint16"===r?2:4),indexBuffer:(0,d.Lr)(e.indexArray,GPUBufferUsage.INDEX,t,`${this.name} index buffer`)}}this.instanceSize=c.vV.sizeofMat4x4f,this.features&u.Ot.VertexNormals&&(this.instanceSize+=48),this.instances=new ArrayBuffer(n*this.instanceSize),this.modelMatrices=new Array(n);for(let e=0;e<n;e+=1){const t=e*this.instanceSize;this.modelMatrices[e]=new Float32Array(this.instances,t,16)}if(this.features&u.Ot.VertexNormals){this.normalMatrices=new Array(n);for(let e=0;e<n;e+=1){const t=e*this.instanceSize+c.vV.sizeofMat4x4f;this.normalMatrices[e]=new Float32Array(this.instances,t,12)}}if(this.instanceBuffer=t.createBuffer({label:`${this.name} instance buffer`,size:this.instances.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.instanceBindGroup=t.createBindGroup({label:"PrimitiveDrawData instance bind group",layout:r.forwardBindgroupLayout,entries:[{binding:0,resource:{buffer:this.instanceBuffer}}]}),a)for(const e of a)this.addInstance(e)}draw(e,t){if(this.dirty&&(t.writeBuffer(this.instanceBuffer,0,this.instances),this.dirty=!1),e.setVertexBuffer(0,this.vertexBuffer),e.setBindGroup(2,this.instanceBindGroup),null!=this.indexData){const{indexBuffer:t,indexCount:n,indexFormat:r}=this.indexData;e.setIndexBuffer(t,r),e.drawIndexed(n,this.instanceCount)}else e.draw(this.vertexCount,this.instanceCount)}addInstance(e){this.instanceCount!==this.max&&(r.pB.copy(e,this.modelMatrices[this.instanceCount]),this.calculateNormalMatrix(this.instanceCount),this.instanceCount+=1,this.dirty=!0)}calculateNormalMatrix(e){if(!(this.features&u.Ot.VertexNormals))return;const t=this.normalMatrices[e];r.w0.fromMat4(this.modelMatrices[e],t),r.w0.invert(t,t),r.w0.transpose(t,t)}}const f={0:u.Ot.PointList,1:u.Ot.LineList,4:u.Ot.TriangleList};class p{constructor(e,t){if(this.unwelded=!1,e instanceof Float32Array)this.data=e,this.componentsPerElement=t,this.count=e.length/t,this.processed=!0,this.bytesPerComponent=4,this.copyFrom=this.copyProcessed.bind(this);else{switch(this.data=e.value,this.componentsPerElement=e.components,this.count=e.count,this.bytesPerComponent=e.bytesPerComponent,this.processed=!1,this.view=new DataView(this.data.buffer),this.copyFrom=this.copyUnprocessed.bind(this),e.componentType){case 5120:this.at=(e,t)=>this.view.getInt8(e*this.componentsPerElement+t);break;case 5121:this.at=(e,t)=>this.view.getUint8(e*this.componentsPerElement+t);break;case 5122:this.at=(e,t)=>{const n=2*(e*this.componentsPerElement+t);return this.view.getInt16(n,!0)};break;case 5123:this.at=(e,t)=>{const n=2*(e*this.componentsPerElement+t);return this.view.getUint16(n,!0)};break;case 5125:this.at=(e,t)=>{const n=4*(e*this.componentsPerElement+t);return this.view.getUint32(n,!0)};break;case 5126:this.at=(e,t)=>{const n=4*(e*this.componentsPerElement+t);return this.view.getFloat32(n,!0)};break;default:throw new Error(`gltf importer -- invalid componentType ${e.componentType}`)}if(e.normalized){let t;switch(e.componentType){case 5121:t=255;break;case 5120:t=127;break;case 5123:t=65535;break;case 5122:t=32767;break;case 5125:t=4294967295;break;default:throw new Error(`gltf importer -- invalid componentType ${e.componentType}`)}this.at=(e,n)=>this.at(e,n)/t}}}get array(){return this.processed||this.process(),this.data}copyProcessed(e,t,n){for(let r=0;r<this.componentsPerElement;r+=1)n[t+r]=this.data[e*this.componentsPerElement+r]}copyUnprocessed(e,t,n){for(let r=0;r<this.componentsPerElement;r+=1)n[t+r]=this.at(e,r)}markProcessed(){this.processed=!0,this.copyFrom=this.copyProcessed.bind(this),delete this.view,delete this.at}process(){if(this.processed)return;const e=new Float32Array(this.count*this.componentsPerElement);for(let t=0;t<this.count;t+=1)this.copyFrom(t,t*this.componentsPerElement,e);this.data=e,this.markProcessed()}unweld(e){if(this.unwelded)return;this.unwelded=!0;const t=new Float32Array(e.length*this.componentsPerElement);for(let n=0;n<e.length;n+=1)this.copyFrom(e[n],n*this.componentsPerElement,t);this.count=e.length,this.data=t,this.markProcessed()}remap(e,t){const n=new Float32Array(t*this.componentsPerElement),r=new Uint8Array(t);for(let t=0;t<this.count;t+=1){const a=e[t];r[a]||(this.copyFrom(t,a*this.componentsPerElement,n),r[a]=1)}this.data=n,this.markProcessed()}}var h=n(5225);const v=n.e(451).then(n.bind(n,1451)).then((e=>e.generateTangents));function g(e){switch(e.bytesPerComponent){case 2:return{indexArray:new Uint16Array(e.value.buffer),indexFormat:"uint16"};case 4:return{indexArray:new Uint32Array(e.value.buffer),indexFormat:"uint32"};default:return{indexArray:new Uint16Array(e.value),indexFormat:"uint16"}}}async function y(e,t,n,a,i){const o=t.attributes;if(null==o.POSITION)return{};const{indices:s}=t,c=(0,h.LG)(o,(e=>new p(e)));let d,y,{mode:b}=t,x=o.POSITION.count;if(null!=s&&(({indexArray:d,indexFormat:y}=g(s)),0!==b&&1!==b&&4!==b&&({indexArray:d,indexFormat:y,mode:b}=function(e,t){switch(t){case 2:case 3:case 6:case 5:throw new Error("Topology currently unsupported");default:return{...g(e),mode:4}}}(s,b))),null!=c.NORMAL&&null==c.TANGENT)if(null!=c.TEXCOORD_0){if(null!=d){x=d.length;for(const e of Object.values(c))e.unweld(d)}const e=Date.now(),t=await v.then((e=>e(c.POSITION.array,c.NORMAL.array,c.TEXCOORD_0.array)));for(let e=3;e<t.length;e+=4)t[e]*=-1;console.log("tangents generated in "+(Date.now()-e)),c.TANGENT=new p(t,4),({indexArray:d,indexFormat:y,vertexCount:x}=l(c)),b=4}else{const e=new Float32Array(4*x);for(let t=0;t<x;t+=1)e.set([1,0,0,1],4*t);c.TANGENT=new p(e,4)}const{vertexArray:w,vertexFeatures:T}=function(e,t){let n=u.Ot.Defaults,r=5;null!=e.NORMAL&&(r+=7),null!=e.COLOR_0&&(r+=4);const a=new ArrayBuffer(r*t*4),i=new Float32Array(a);for(let n=0;n<t;n+=1)e.POSITION?.copyFrom(n,r*n,i);const o=e.TEXCOORD_0??new p(new Float32Array(2*t),2);for(let e=0;e<t;e+=1)o.copyFrom(e,e*r+3,i);if(null!=e.NORMAL&&null!=e.TANGENT){n|=u.Ot.VertexNormals;for(let n=0;n<t;n+=1)e.TANGENT.copyFrom(n,n*r+5,i);for(let n=0;n<t;n+=1)e.NORMAL.copyFrom(n,n*r+9,i)}if(null!=e.COLOR_0){n|=u.Ot.VertexColors;const a=null!=e.NORMAL?12:5;for(let n=0;n<t;n+=1)e.COLOR_0.copyFrom(n,n*r+a,i),i[n*r+a+3]=1}return{vertexArray:a,vertexFeatures:n}}(c,x);let S=function(e){let t;for(let n=0;n<e.length;n+=1){const a=r.pB.determinant(e[n]),i=Math.sign(a);if(t??=i,i!==t)return u.Ot.DoubleSided}return null==t||t>0?u.Ot.Defaults:u.Ot.ClockwiseWinding}(n)|T;null!=b&&(S|=f[b]||0);const P=new m({features:S,indexArray:d,indexFormat:y,vertexCount:x,vertexArray:w},i,n.length,a,n);return{material:t.material,drawData:P}}var b=n(1299);const x=0,w=1,T={9728:"nearest",9729:"linear",9984:"nearest",9985:"linear",9986:"nearest",9987:"linear"},S={9984:"nearest",9985:"nearest",9986:"linear",9987:"linear"},P={33071:"clamp-to-edge",33648:"mirror-repeat",10497:"repeat"};function A(e){const{magFilter:t,minFilter:n,wrapS:r,wrapT:a}=e;return{addressModeU:P[r??10497],addressModeV:P[a??10497],minFilter:T[n??9987],magFilter:T[t??9729],mipmapFilter:S[n??9987]??"linear"}}function O(e){const{source:t,sampler:n}=e;if(null==t)return{};const r=t.image.data??t.bufferView?.data;return null==r?{}:{data:r,mimeType:t.mimeType,sampler:n}}async function C(e,t,n){const a={};if(null!=e.pbrMetallicRoughness){const{baseColorFactor:t,baseColorTexture:r,metallicFactor:i,metallicRoughnessTexture:o,roughnessFactor:s}=e.pbrMetallicRoughness;if(null==o?.texture.source)null==i&&(a.metallicFactor=x),null==s&&(a.roughnessFactor=w);else{const{data:t,mimeType:r,sampler:i}=O(o.texture);null!=t&&(a.metallicRoughnessTexture=await(0,b.u)({label:`${e.id} mr texture`,data:t,mimeType:r,usage:GPUTextureUsage.TEXTURE_BINDING,device:n}),i&&(a.metallicRoughnessSampler=A(i)))}if(null!=r?.texture.source){const{data:t,mimeType:i,sampler:o}=O(r.texture);null!=t&&(a.baseColorTexture=await(0,b.u)({label:`${e.id} mr texture`,data:t,mimeType:i,usage:GPUTextureUsage.TEXTURE_BINDING,device:n,srgbToLinear:!0}),o&&(a.baseColorSampler=A(o)))}null!=t&&(a.baseColorFactor=t),null!=i&&(a.metallicFactor=i),null!=s&&(a.metallicFactor=s)}else a.metallicFactor=x,a.roughnessFactor=w;if(null!=e.normalTexture?.texture.source){const{data:t,mimeType:r,sampler:i}=O(e.normalTexture.texture);null!=t&&(a.normalTexture=await(0,b.u)({label:`${e.id} mr texture`,data:t,mimeType:r,usage:GPUTextureUsage.TEXTURE_BINDING,device:n}),i&&(a.normalSampler=A(i)))}const{emissiveFactor:i,emissiveTexture:o}=e,s=e.extensions?.KHR_materials_emissive_strength?.emissiveStrength;if(null!=o||i?.some((e=>e>0))){if(a.emissiveFactor=i??[1,1,1],a.emissiveSampler={magFilter:"linear",minFilter:"linear"},null!=o?.texture.source){const{data:t,mimeType:r,sampler:i}=O(o.texture);null!=t&&(a.emissiveTexture=await(0,b.u)({label:`${e.id} mr texture`,data:t,mimeType:r,usage:GPUTextureUsage.TEXTURE_BINDING,device:n,srgbToLinear:!0}),i&&(a.emissiveSampler=A(i)))}else a.emissiveTexture=t.baseColorTexture;null!=s&&"number"==typeof s&&r.eR.scale(a.emissiveFactor,s,a.emissiveFactor)}return e.doubleSided&&(a.doubleSided=!0),"MASK"===e.alphaMode&&(a.alphaCutoff=e.alphaCutoff??.5),{...t,...a}}class U{constructor(e,t,n,r,a){this.primitives=[],this.features=r,e.doubleSided&&(this.features|=u.Ot.DoubleSided);const i=new Float32Array(12);i.set(e.baseColorFactor),i[4]=e.metallicFactor,i[5]=e.roughnessFactor,null!=e.alphaCutoff&&(this.features|=u.Ot.AlphaCutoff,i[6]=e.alphaCutoff),null!=e.emissiveFactor&&i.set(e.emissiveFactor,8),this.propertiesBuffer=(0,d.Lr)(i,GPUBufferUsage.UNIFORM,t);const o=[{binding:0,resource:{buffer:this.propertiesBuffer}},{binding:1,resource:n.getSampler(e.baseColorSampler)},{binding:2,resource:e.baseColorTexture.createView({dimension:"2d"})},{binding:3,resource:n.getSampler(e.normalSampler)},{binding:4,resource:e.normalTexture.createView({dimension:"2d"})},{binding:5,resource:n.getSampler(e.metallicRoughnessSampler)},{binding:6,resource:e.metallicRoughnessTexture.createView({dimension:"2d"})}];null!=e.emissiveTexture&&(this.features|=u.Ot.Emissive,o.push({binding:7,resource:n.getSampler(e.emissiveSampler??{})}),o.push({binding:8,resource:e.emissiveTexture.createView({dimension:"2d"})})),this.layout=n.getMaterialBindGroup(this.features),this.matData=e,this.bindGroup=t.createBindGroup({label:(0,u.UZ)(this.features),layout:this.layout,entries:o}),null!=a&&this.addPrimitives(...a)}draw(e,t){if(0!==this.primitives.length){e.setBindGroup(1,this.bindGroup);for(const n of this.primitives)n.draw(e,t)}}addPrimitives(...e){const t=e.filter((e=>(e.features&this.features)===e.features||(console.warn(`invalid primitive added to material: \nprimitive: ${e.name}\nprimitive features: ${(0,u.UZ)(e.features).toString()}\nmaterial: ${this.matData.name}\nmaterial features: ${(0,u.UZ)(this.features).toString()}`),!1)));this.primitives.push(...t)}}class E{constructor(e,t){this.materials=[],this.features=(0,u.P7)(e);const n=t.getShaderModule(e);this.pipeline=t.device.createRenderPipeline({label:(0,u.UZ)(e),layout:t.getForwardPipelineLayout(e),primitive:t.getPrimitiveState(e),vertex:{entryPoint:"vs",buffers:[t.getVertexLayout(e)],module:n},fragment:{entryPoint:"fs",module:n,targets:t.gbuffer.targets},depthStencil:{depthWriteEnabled:!0,depthCompare:"less-equal",format:t.gbuffer.depth.format}})}addMaterials(...e){if(e.some((e=>e.features!==this.features)))throw new Error("invalid primitive added to material");this.materials.push(...e)}draw(e,t){e.setPipeline(this.pipeline);for(const n of this.materials)n.draw(e,t)}}const F=[{name:"POSITION",type:"VEC3",componentType:5126},{name:"TEXCOORD_0",type:"VEC2",componentType:5126},{name:"TANGENT",type:"VEC4",componentType:5126,depends:["NORMAL"],fill:[1,0,0,1]},{name:"NORMAL",type:"VEC3",componentType:5126,strip:!0,feature:u.Ot.VertexNormals},{name:"COLOR_0",type:"VEC4",componentType:5126,strip:!0,feature:u.Ot.VertexColors,fill:[1,1,1,1]}],G=(e,t)=>n=>{const a=n.matrix??r.pB.identity();if(null==n.matrix){if(n.scale&&r.pB.scaling(n.scale,a),n.rotation){const{axis:e,angle:t}=r.Yu.toAxisAngle(n.rotation);r.pB.rotate(a,e,t,a)}null!=n.translation&&r.pB.setTranslation(a,n.translation,a)}r.pB.mul(e,a,a),null!=n.mesh&&(t.has(n.mesh)||t.set(n.mesh,[]),t.get(n.mesh).push(a)),n.children?.forEach(G(a,t))};async function M(e,t,n,s,l=F,u={},c=console.log){c("starting import");const d=Date.now(),m=await(0,a.H)(e,i.B);c("finished loading: "+(Date.now()-d));const{scene:f}=(0,o.R)(m);if(null==f?.nodes)return u;c("finished processing: "+(Date.now()-d));const p=new Map;f.nodes.forEach(G(r.pB.identity(),p)),c("finished creating instances: "+(Date.now()-d));const h=Array.from(p.entries()).flatMap((([{primitives:e},r])=>e.map((e=>y(0,e,r,n,t))))),v=await Promise.all(h);c("finished creating primitives: "+(Date.now()-d));const g=new Map,b={};for(const{material:e,drawData:n}of v){if(null==n)continue;const r={materialId:e?.id,features:n.features};g.has(r)||g.set(r,[]),g.get(r).push(n),null!=e&&(b[e.id]=C(e,s,t))}const x=Object.entries(b).map((async([e,t])=>[e,await t])),w=Object.fromEntries(await Promise.all(x));c("finished creating material descriptors: "+(Date.now()-d));const T={...s,metallicFactor:0};for(const[{features:e,materialId:r},a]of g.entries()){const i=null!=r?w[r]:T,o=new U(i,t,n,e,a),{features:s}=o;u[s]??=new E(s,n),u[s].addMaterials(o)}return c("finished: "+(Date.now()-d)),u}},4508:(e,t,n)=>{n.a(e,(async(e,r)=>{try{n.d(t,{A:()=>c});var a=n(1299),i=n(1776),o=n(541);const s=await fetch("https://api.github.com/repos/KhronosGroup/glTF-Sample-Environments/contents?ref=low_resolution_hdrs",{headers:{"Content-Type":"application/vnd.github.object+json"}}).then((e=>e.json())),l=Object.fromEntries(s.flatMap((({name:e,download_url:t})=>"string"==typeof e&&"string"==typeof t&&t.endsWith(".hdr")?[[e,t]]:[])));async function u(e,t){let n;if(t instanceof ArrayBuffer)n=t;else if(t instanceof File)n=await t.arrayBuffer();else{const e=await fetch(t);n=await e.arrayBuffer()}const r=(0,a.y)(n);return(0,i.l3)(e,r,{format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC})}function c(e){return{[o.t.$type]:"file",[o.t.$callback]:async(t,n)=>{if("value"===n&&null!=t&&("string"==typeof t||t instanceof File)){const n=await u(e.device,t),r=e.setSkybox(n);r instanceof Promise&&await r}},accept:".hdr",selection:{value:Object.keys(l)[0],initialValues:l},process:e=>e}}r()}catch(d){r(d)}}),1)},9120:(e,t,n)=>{n.d(t,{A:()=>r});const r="\n    struct VertOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n    }\n\n    @vertex\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\n        const pos = array(\n            vec2f(-1,  3),\n            vec2f(3, -1),\n            vec2f(-1, -1),\n        );\n        var res: VertOut;\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\n        return res;\n    }\n"},7590:(e,t,n)=>{n.d(t,{V:()=>r,X:()=>a});const r="\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n",a="\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n"},71:(e,t,n)=>{n.d(t,{Lr:()=>r});n(2009);function r(e,t,n,r,a=4){const i=a-1,o=n.createBuffer({label:r,usage:t,size:e.byteLength+i&~i,mappedAtCreation:!0}),s=new Uint8Array(o.getMappedRange()),l=e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength);return s.set(l),o.unmap(),o}},1299:(e,t,n)=>{n.d(t,{u:()=>c,y:()=>d});const{baseTable:r,shiftTable:a}=(()=>{const e=new Uint32Array(256),t=new Uint32Array(256);for(let n=0;n<255;++n){const r=n-127;r<-27?(e[n]=0,t[n]=24):r<-14?(e[n]=1024>>-r-14,t[n]=-r-1):r<=15?(e[n]=r+15<<10,t[n]=13):(e[n]=31744,t[n]=24)}return e[255]=31744,t[255]=13,{baseTable:e,shiftTable:t}})(),i=new ArrayBuffer(4),o=new Float32Array(i),s=new Uint32Array(i);function l(e){o[0]=e;const t=s[0],n=t>>23&511,i=255&n;return r[i]+((8388607&t)>>a[i])+((256&n)<<7)}var u=n(1776);async function c({device:e,data:t,mimeType:n,usage:r=GPUTextureUsage.TEXTURE_BINDING,mips:a=!0,format:i="rgba8unorm",colorSpace:o="srgb",label:s="",srgbToLinear:l}){let c;if(t instanceof ImageBitmap)c=t;else{const e=t instanceof Blob||t instanceof File?t:new Blob([t],{type:n});c=await createImageBitmap(e,{colorSpaceConversion:"none"})}const d={width:c.width,height:c.height},m=e.createTexture({label:s,format:i,size:d,usage:r|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:a?1+(0|Math.log2(Math.max(c.width,c.height))):1});return e.queue.copyExternalImageToTexture({source:c},{texture:m,colorSpace:o},d),l&&(0,u.sP)(e,m),a&&(0,u.fF)(e,m),m}function d(e){const t=new TextDecoder,n=e instanceof Uint8Array?e:new Uint8Array(e);let r=0;const a=(e=1024)=>{const a=Math.min(n.length,e+r),i=n.subarray(r,a),o=i.indexOf(10)+1;return r+=o,0===o?void 0:t.decode(i.subarray(0,o))},i=e=>new Error("HDR Import Error: "+e),o=a();if(null==o)throw i("no header found");if(!/^#\?(\S+)/.test(o))throw i("bad initial token");const s=new RegExp(`^\\s*(${[/FORMAT=(?<format>\S+)/,/-Y\s+(?<Y>\d+)\s+\+X\s+(?<X>\d+)/,/EXPOSURE\s*=\s*(?<exposure>\d+(\.\d+)?)/,/GAMMA\s*=\s*(?<gamma>\d+(\.\d+)?)/].map((({source:e})=>`(${e})`)).join("|")})\\s*$`);let u,c,d,m=!0,f=1,p=1;for(let e=a();null!=e;e=null==u?a():void 0){const t=e.match(s)?.groups;null!=t&&(null!=t.format?m=!1:null!=t.X&&null!=t.Y?(u=parseInt(t.X),c=parseInt(t.Y)):null!=t.gamma?f=parseFloat(t.gamma):null!=t.exposure&&(p=parseFloat(t.exposure)))}if(m)throw i("missing format specifier");if(null==u||null==c)throw i("missing image size specifier");const h=u<8||u>32767,v=2!==n[r]||2!==n[r+1]||!!(128&n[r+2]);if(h||v)d=n.subarray(r);else{d=new Uint8Array(u*c*4);const e=4*u,t=new Uint8Array(e),a=n.byteLength;for(let o=0,s=0;o<c&&r<a;o++){if(r+4>a)throw i("file ended durning scanline");if(2!=n[r++]||2!=n[r++]||(n[r++]<<8|n[r++])!=u)throw i("bad rgbe scanline format");let o;for(let s=0;s<e&&r<a;s+=o){o=n[r++];const a=o>128;if(a&&(o-=128),0==o||s+o>e)throw i("bad scanline data");a?(t.fill(n[r],s,s+o),r+=1):(t.set(n.subarray(r,r+o),s),r+=o)}for(let n=0;n<u;n++)for(let r=0;r<e;r+=u)d[s++]=t[n+r]}}const g=new Uint16Array(d.length),y=l(1);for(let e=0;e<u*c*4;e+=4){const t=d[e+3],n=Math.pow(2,t-128)/255;for(let t=0;t<3;t+=1)g[e+t]=l(Math.min(d[e+t]*n,65504));g[e+3]=y}return{data:g,width:u,height:c,gamma:f,exposure:p}}},1776:(e,t,n)=>{n.d(t,{fF:()=>l,l3:()=>s,sP:()=>u});var r=n(9120),a=n(7590),i=n(71),o=n(5225);async function s(e,{data:t,width:n,height:s,gamma:l=1,exposure:u=1},c){const d=`\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${r.A}\n        ${a.V}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;let m,f=0;t instanceof GPUTexture?m=t:(f=1,m=e.createTexture({label:`${c.label} equirectangular`,dimension:"2d",format:"rgba16float",size:{width:n,height:s},usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING}),e.queue.writeTexture({texture:m,mipLevel:0},t,{bytesPerRow:2*n*4},{width:n,height:s,depthOrArrayLayers:1}),await e.queue.onSubmittedWorkDone());const p=m.height>>1,h=c;h.mipLevelCount??=0|Math.log2(p),h.size={width:p,height:p,depthOrArrayLayers:6},h.dimension="2d",h.usage|=GPUTextureUsage.RENDER_ATTACHMENT;const v=e.createTexture(h),g=o.OY`hdr copy${c.label}`,y=e.createBindGroupLayout({label:g,entries:[{binding:0,texture:{},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT},{binding:2,buffer:{},visibility:GPUShaderStage.FRAGMENT}]}),b=e.createShaderModule({label:g,code:d}),x=e.createSampler({label:g,minFilter:"linear",magFilter:"linear"}),w=new Uint32Array(1),T=(0,i.Lr)(w,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,e,g),S=e.createBindGroup({label:g,layout:y,entries:[{binding:0,resource:m.createView()},{binding:1,resource:x},{binding:2,resource:{buffer:T}}]}),P=e.createPipelineLayout({label:g,bindGroupLayouts:[y]}),A=e.createRenderPipeline({label:g,layout:P,vertex:{module:b},fragment:{module:b,targets:[{format:v.format}],constants:{GAMMA:l,EXPOSURE:u,FLIP_Y:f}}});for(let t=0;t<6;t+=1){w[0]=t,e.queue.writeBuffer(T,0,w,0,1);const n=v.createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:t,mipLevelCount:1}),r=e.createCommandEncoder(),a=r.beginRenderPass({label:g,colorAttachments:[{view:n,loadOp:"clear",storeOp:"store"}]});a.setPipeline(A),a.setBindGroup(0,S),a.draw(3),a.end(),e.queue.submit([r.finish()])}return v}async function l(e,t){const n=`\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${r.A}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `,a=o.OY`mip generation${t.label}`,i=e.createBindGroupLayout({label:a,entries:[{binding:0,texture:{viewDimension:"2d",sampleType:"float"},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT}]}),s={view:void 0,loadOp:"clear",storeOp:"store"},l=e.createSampler({minFilter:"linear",magFilter:"linear"}),u=e.createShaderModule({label:a,code:n}),c=e.createPipelineLayout({label:a,bindGroupLayouts:[i]}),d=e.createRenderPipeline({label:a,layout:c,vertex:{entryPoint:"vs",module:u},fragment:{entryPoint:"fs",targets:[{format:t.format}],module:u}});s.view=t.createView({mipLevelCount:1,baseMipLevel:0}),await e.queue.onSubmittedWorkDone();for(let n=1;n<t.mipLevelCount;n+=1){const r=e.createBindGroup({label:a,layout:i,entries:[{binding:0,resource:s.view},{binding:1,resource:l}]});s.view=t.createView({mipLevelCount:1,baseMipLevel:n});const o=e.createCommandEncoder(),u=o.beginRenderPass({label:a,colorAttachments:[s]});u.setPipeline(d),u.setBindGroup(0,r),u.draw(3),u.end(),e.queue.submit([o.finish()]),await e.queue.onSubmittedWorkDone()}}function u(e,t){const n=`\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${r.A}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `,a=o.OY`srgb to linear${t.label}`,i={width:t.width,height:t.height},s=e.createTexture({format:t.format,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,size:i}),l=e.createBindGroupLayout({label:a,entries:[{binding:0,texture:{},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT}]}),u=e.createSampler({minFilter:"linear",magFilter:"linear"}),c=e.createShaderModule({label:a,code:n}),d=e.createPipelineLayout({label:a,bindGroupLayouts:[l]}),m=e.createRenderPipeline({label:a,layout:d,vertex:{entryPoint:"vs",module:c},fragment:{entryPoint:"fs",targets:[{format:t.format}],module:c}}),f=e.createBindGroup({label:a,layout:l,entries:[{binding:0,resource:s.createView()},{binding:1,resource:u}]}),p=e.createCommandEncoder();p.copyTextureToTexture({texture:t},{texture:s},i);const h=p.beginRenderPass({label:a,colorAttachments:[{view:t.createView({mipLevelCount:1,baseMipLevel:0}),loadOp:"clear",storeOp:"store"}]});h.setPipeline(m),h.setBindGroup(0,f),h.draw(3),h.end(),e.queue.submit([p.finish()])}}}]);
//# sourceMappingURL=459.bundle.js.map