"use strict";(self.webpackChunkwebgpu_basic=self.webpackChunkwebgpu_basic||[]).push([[767],{767:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileHandle: () => (/* binding */ FileHandle),\n/* harmony export */   FolderHandle: () => (/* binding */ FolderHandle),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(275);\n/* global Blob, DOMException */\n\n\n\nconst { DISALLOWED } = _util_js__WEBPACK_IMPORTED_MODULE_0__.errors\n\nclass Sink {\n  /**\n   * @param {FileWriter} writer\n   * @param {FileEntry} fileEntry\n   */\n  constructor (writer, fileEntry) {\n    this.writer = writer\n    this.fileEntry = fileEntry\n  }\n\n  /**\n   * @param {BlobPart | Object} chunk\n   */\n  async write (chunk) {\n    if (typeof chunk === 'object') {\n      if (chunk.type === 'write') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          this.writer.seek(chunk.position)\n          if (this.writer.position !== chunk.position) {\n            await new Promise((resolve, reject) => {\n              this.writer.onwriteend = resolve\n              this.writer.onerror = reject\n              this.writer.truncate(chunk.position)\n            })\n            this.writer.seek(chunk.position)\n          }\n        }\n        if (!('data' in chunk)) {\n          throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. write requires a data argument', 'SyntaxError')\n        }\n        chunk = chunk.data\n      } else if (chunk.type === 'seek') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          this.writer.seek(chunk.position)\n          if (this.writer.position !== chunk.position) {\n            throw new DOMException('seeking position failed', 'InvalidStateError')\n          }\n          return\n        } else {\n          throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. seek requires a position argument', 'SyntaxError')\n        }\n      } else if (chunk.type === 'truncate') {\n        return new Promise(resolve => {\n          if (Number.isInteger(chunk.size) && chunk.size >= 0) {\n            this.writer.onwriteend = evt => resolve()\n            this.writer.truncate(chunk.size)\n          } else {\n            throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. truncate requires a size argument', 'SyntaxError')\n          }\n        })\n      }\n    }\n    await new Promise((resolve, reject) => {\n      this.writer.onwriteend = resolve\n      this.writer.onerror = reject\n      this.writer.write(new Blob([chunk]))\n    })\n  }\n\n  close () {\n    return new Promise(this.fileEntry.file.bind(this.fileEntry))\n  }\n}\n\nclass FileHandle {\n  /** @param {FileEntry} file */\n  constructor (file, writable = true) {\n    this.file = file\n    this.kind = 'file'\n    this.writable = writable\n    this.readable = true\n  }\n\n  get name () {\n    return this.file.name\n  }\n\n  /**\n   * @param {{ file: { toURL: () => string; }; }} other\n   */\n  isSameEntry (other) {\n    return this.file.toURL() === other.file.toURL()\n  }\n\n  /** @return {Promise<File>} */\n  getFile () {\n    return new Promise(this.file.file.bind(this.file))\n  }\n\n  /** @return {Promise<Sink>} */\n  createWritable (opts) {\n    if (!this.writable) throw new DOMException(...DISALLOWED)\n\n    return new Promise((resolve, reject) =>\n      this.file.createWriter(fileWriter => {\n        if (opts.keepExistingData === false) {\n          fileWriter.onwriteend = evt => resolve(new Sink(fileWriter, this.file))\n          fileWriter.truncate(0)\n        } else {\n          resolve(new Sink(fileWriter, this.file))\n        }\n      }, reject)\n    )\n  }\n}\n\nclass FolderHandle {\n  /** @param {DirectoryEntry} dir */\n  constructor (dir, writable = true) {\n    this.dir = dir\n    this.writable = writable\n    this.readable = true\n    this.kind = 'directory'\n    this.name = dir.name\n  }\n\n  /** @param {FolderHandle} other */\n  isSameEntry (other) {\n    return this.dir.fullPath === other.dir.fullPath\n  }\n\n  /** @returns {AsyncGenerator<[string, FileHandle | FolderHandle]>} */\n  async * entries () {\n    const reader = this.dir.createReader()\n    const entries = await new Promise(reader.readEntries.bind(reader))\n    for (const x of entries) {\n      yield [x.name, x.isFile ? new FileHandle(x, this.writable) : new FolderHandle(x, this.writable)]\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   * @returns {Promise<FolderHandle>}\n   */\n  getDirectoryHandle (name, opts) {\n    return new Promise((resolve, reject) => {\n      this.dir.getDirectory(name, opts, dir => {\n        resolve(new FolderHandle(dir))\n      }, reject)\n    })\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   * @returns {Promise<FileHandle>}\n   */\n  getFileHandle (name, opts) {\n    return new Promise((resolve, reject) =>\n      this.dir.getFile(name, opts, file => resolve(new FileHandle(file)), reject)\n    )\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ recursive: boolean; }} opts\n   */\n  async removeEntry (name, opts) {\n    /** @type {Error|FolderHandle|FileHandle} */\n    const entry = await this.getDirectoryHandle(name, { create: false }).catch(err =>\n      err.name === 'TypeMismatchError' ? this.getFileHandle(name, { create: false }) : err\n    )\n\n    if (entry instanceof Error) throw entry\n\n    return new Promise((resolve, reject) => {\n      if (entry instanceof FolderHandle) {\n        opts.recursive\n          ? entry.dir.removeRecursively(() => resolve(), reject)\n          : entry.dir.remove(() => resolve(), reject)\n      } else if (entry.file) {\n        entry.file.remove(() => resolve(), reject)\n      }\n    })\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((opts = {}) => new Promise((resolve, reject) =>\n  window.webkitRequestFileSystem(\n    opts._persistent, 0,\n    e => resolve(new FolderHandle(e.root)),\n    reject\n  )\n));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFFbUM7O0FBRW5DLFFBQVEsYUFBYSxFQUFFLDRDQUFNOztBQUU3QjtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBOztBQUVBLGVBQWUsZUFBZTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUCxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDLHdEQUF3RCxlQUFlO0FBQ3ZFLG9FQUFvRSxlQUFlO0FBQ25GOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGlFQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJncHUtYmFzaWMvLi9ub2RlX21vZHVsZXMvLnBucG0vbmF0aXZlLWZpbGUtc3lzdGVtLWFkYXB0ZXJAMy4wLjEvbm9kZV9tb2R1bGVzL25hdGl2ZS1maWxlLXN5c3RlbS1hZGFwdGVyL3NyYy9hZGFwdGVycy9zYW5kYm94LmpzP2JlY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIEJsb2IsIERPTUV4Y2VwdGlvbiAqL1xuXG5pbXBvcnQgeyBlcnJvcnMgfSBmcm9tICcuLi91dGlsLmpzJ1xuXG5jb25zdCB7IERJU0FMTE9XRUQgfSA9IGVycm9yc1xuXG5jbGFzcyBTaW5rIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RmlsZVdyaXRlcn0gd3JpdGVyXG4gICAqIEBwYXJhbSB7RmlsZUVudHJ5fSBmaWxlRW50cnlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh3cml0ZXIsIGZpbGVFbnRyeSkge1xuICAgIHRoaXMud3JpdGVyID0gd3JpdGVyXG4gICAgdGhpcy5maWxlRW50cnkgPSBmaWxlRW50cnlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jsb2JQYXJ0IHwgT2JqZWN0fSBjaHVua1xuICAgKi9cbiAgYXN5bmMgd3JpdGUgKGNodW5rKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChjaHVuay50eXBlID09PSAnd3JpdGUnKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGNodW5rLnBvc2l0aW9uKSAmJiBjaHVuay5wb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgdGhpcy53cml0ZXIuc2VlayhjaHVuay5wb3NpdGlvbilcbiAgICAgICAgICBpZiAodGhpcy53cml0ZXIucG9zaXRpb24gIT09IGNodW5rLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMud3JpdGVyLm9ud3JpdGVlbmQgPSByZXNvbHZlXG4gICAgICAgICAgICAgIHRoaXMud3JpdGVyLm9uZXJyb3IgPSByZWplY3RcbiAgICAgICAgICAgICAgdGhpcy53cml0ZXIudHJ1bmNhdGUoY2h1bmsucG9zaXRpb24pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy53cml0ZXIuc2VlayhjaHVuay5wb3NpdGlvbilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoJ2RhdGEnIGluIGNodW5rKSkge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ZhaWxlZCB0byBleGVjdXRlIFxcJ3dyaXRlXFwnIG9uIFxcJ1VuZGVybHlpbmdTaW5rQmFzZVxcJzogSW52YWxpZCBwYXJhbXMgcGFzc2VkLiB3cml0ZSByZXF1aXJlcyBhIGRhdGEgYXJndW1lbnQnLCAnU3ludGF4RXJyb3InKVxuICAgICAgICB9XG4gICAgICAgIGNodW5rID0gY2h1bmsuZGF0YVxuICAgICAgfSBlbHNlIGlmIChjaHVuay50eXBlID09PSAnc2VlaycpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoY2h1bmsucG9zaXRpb24pICYmIGNodW5rLnBvc2l0aW9uID49IDApIHtcbiAgICAgICAgICB0aGlzLndyaXRlci5zZWVrKGNodW5rLnBvc2l0aW9uKVxuICAgICAgICAgIGlmICh0aGlzLndyaXRlci5wb3NpdGlvbiAhPT0gY2h1bmsucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ3NlZWtpbmcgcG9zaXRpb24gZmFpbGVkJywgJ0ludmFsaWRTdGF0ZUVycm9yJylcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignRmFpbGVkIHRvIGV4ZWN1dGUgXFwnd3JpdGVcXCcgb24gXFwnVW5kZXJseWluZ1NpbmtCYXNlXFwnOiBJbnZhbGlkIHBhcmFtcyBwYXNzZWQuIHNlZWsgcmVxdWlyZXMgYSBwb3NpdGlvbiBhcmd1bWVudCcsICdTeW50YXhFcnJvcicpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsudHlwZSA9PT0gJ3RydW5jYXRlJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoY2h1bmsuc2l6ZSkgJiYgY2h1bmsuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlci5vbndyaXRlZW5kID0gZXZ0ID0+IHJlc29sdmUoKVxuICAgICAgICAgICAgdGhpcy53cml0ZXIudHJ1bmNhdGUoY2h1bmsuc2l6ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignRmFpbGVkIHRvIGV4ZWN1dGUgXFwnd3JpdGVcXCcgb24gXFwnVW5kZXJseWluZ1NpbmtCYXNlXFwnOiBJbnZhbGlkIHBhcmFtcyBwYXNzZWQuIHRydW5jYXRlIHJlcXVpcmVzIGEgc2l6ZSBhcmd1bWVudCcsICdTeW50YXhFcnJvcicpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndyaXRlci5vbndyaXRlZW5kID0gcmVzb2x2ZVxuICAgICAgdGhpcy53cml0ZXIub25lcnJvciA9IHJlamVjdFxuICAgICAgdGhpcy53cml0ZXIud3JpdGUobmV3IEJsb2IoW2NodW5rXSkpXG4gICAgfSlcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UodGhpcy5maWxlRW50cnkuZmlsZS5iaW5kKHRoaXMuZmlsZUVudHJ5KSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmlsZUhhbmRsZSB7XG4gIC8qKiBAcGFyYW0ge0ZpbGVFbnRyeX0gZmlsZSAqL1xuICBjb25zdHJ1Y3RvciAoZmlsZSwgd3JpdGFibGUgPSB0cnVlKSB7XG4gICAgdGhpcy5maWxlID0gZmlsZVxuICAgIHRoaXMua2luZCA9ICdmaWxlJ1xuICAgIHRoaXMud3JpdGFibGUgPSB3cml0YWJsZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZS5uYW1lXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHt7IGZpbGU6IHsgdG9VUkw6ICgpID0+IHN0cmluZzsgfTsgfX0gb3RoZXJcbiAgICovXG4gIGlzU2FtZUVudHJ5IChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmZpbGUudG9VUkwoKSA9PT0gb3RoZXIuZmlsZS50b1VSTCgpXG4gIH1cblxuICAvKiogQHJldHVybiB7UHJvbWlzZTxGaWxlPn0gKi9cbiAgZ2V0RmlsZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHRoaXMuZmlsZS5maWxlLmJpbmQodGhpcy5maWxlKSlcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtQcm9taXNlPFNpbms+fSAqL1xuICBjcmVhdGVXcml0YWJsZSAob3B0cykge1xuICAgIGlmICghdGhpcy53cml0YWJsZSkgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbiguLi5ESVNBTExPV0VEKVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICB0aGlzLmZpbGUuY3JlYXRlV3JpdGVyKGZpbGVXcml0ZXIgPT4ge1xuICAgICAgICBpZiAob3B0cy5rZWVwRXhpc3RpbmdEYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgIGZpbGVXcml0ZXIub253cml0ZWVuZCA9IGV2dCA9PiByZXNvbHZlKG5ldyBTaW5rKGZpbGVXcml0ZXIsIHRoaXMuZmlsZSkpXG4gICAgICAgICAgZmlsZVdyaXRlci50cnVuY2F0ZSgwKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUobmV3IFNpbmsoZmlsZVdyaXRlciwgdGhpcy5maWxlKSlcbiAgICAgICAgfVxuICAgICAgfSwgcmVqZWN0KVxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRm9sZGVySGFuZGxlIHtcbiAgLyoqIEBwYXJhbSB7RGlyZWN0b3J5RW50cnl9IGRpciAqL1xuICBjb25zdHJ1Y3RvciAoZGlyLCB3cml0YWJsZSA9IHRydWUpIHtcbiAgICB0aGlzLmRpciA9IGRpclxuICAgIHRoaXMud3JpdGFibGUgPSB3cml0YWJsZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gICAgdGhpcy5raW5kID0gJ2RpcmVjdG9yeSdcbiAgICB0aGlzLm5hbWUgPSBkaXIubmFtZVxuICB9XG5cbiAgLyoqIEBwYXJhbSB7Rm9sZGVySGFuZGxlfSBvdGhlciAqL1xuICBpc1NhbWVFbnRyeSAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kaXIuZnVsbFBhdGggPT09IG90aGVyLmRpci5mdWxsUGF0aFxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtBc3luY0dlbmVyYXRvcjxbc3RyaW5nLCBGaWxlSGFuZGxlIHwgRm9sZGVySGFuZGxlXT59ICovXG4gIGFzeW5jICogZW50cmllcyAoKSB7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5kaXIuY3JlYXRlUmVhZGVyKClcbiAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgbmV3IFByb21pc2UocmVhZGVyLnJlYWRFbnRyaWVzLmJpbmQocmVhZGVyKSlcbiAgICBmb3IgKGNvbnN0IHggb2YgZW50cmllcykge1xuICAgICAgeWllbGQgW3gubmFtZSwgeC5pc0ZpbGUgPyBuZXcgRmlsZUhhbmRsZSh4LCB0aGlzLndyaXRhYmxlKSA6IG5ldyBGb2xkZXJIYW5kbGUoeCwgdGhpcy53cml0YWJsZSldXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7eyBjcmVhdGU6IGJvb2xlYW47IH19IG9wdHNcbiAgICogQHJldHVybnMge1Byb21pc2U8Rm9sZGVySGFuZGxlPn1cbiAgICovXG4gIGdldERpcmVjdG9yeUhhbmRsZSAobmFtZSwgb3B0cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmRpci5nZXREaXJlY3RvcnkobmFtZSwgb3B0cywgZGlyID0+IHtcbiAgICAgICAgcmVzb2x2ZShuZXcgRm9sZGVySGFuZGxlKGRpcikpXG4gICAgICB9LCByZWplY3QpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3sgY3JlYXRlOiBib29sZWFuOyB9fSBvcHRzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbGVIYW5kbGU+fVxuICAgKi9cbiAgZ2V0RmlsZUhhbmRsZSAobmFtZSwgb3B0cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgdGhpcy5kaXIuZ2V0RmlsZShuYW1lLCBvcHRzLCBmaWxlID0+IHJlc29sdmUobmV3IEZpbGVIYW5kbGUoZmlsZSkpLCByZWplY3QpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7eyByZWN1cnNpdmU6IGJvb2xlYW47IH19IG9wdHNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUVudHJ5IChuYW1lLCBvcHRzKSB7XG4gICAgLyoqIEB0eXBlIHtFcnJvcnxGb2xkZXJIYW5kbGV8RmlsZUhhbmRsZX0gKi9cbiAgICBjb25zdCBlbnRyeSA9IGF3YWl0IHRoaXMuZ2V0RGlyZWN0b3J5SGFuZGxlKG5hbWUsIHsgY3JlYXRlOiBmYWxzZSB9KS5jYXRjaChlcnIgPT5cbiAgICAgIGVyci5uYW1lID09PSAnVHlwZU1pc21hdGNoRXJyb3InID8gdGhpcy5nZXRGaWxlSGFuZGxlKG5hbWUsIHsgY3JlYXRlOiBmYWxzZSB9KSA6IGVyclxuICAgIClcblxuICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBlbnRyeVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIEZvbGRlckhhbmRsZSkge1xuICAgICAgICBvcHRzLnJlY3Vyc2l2ZVxuICAgICAgICAgID8gZW50cnkuZGlyLnJlbW92ZVJlY3Vyc2l2ZWx5KCgpID0+IHJlc29sdmUoKSwgcmVqZWN0KVxuICAgICAgICAgIDogZW50cnkuZGlyLnJlbW92ZSgoKSA9PiByZXNvbHZlKCksIHJlamVjdClcbiAgICAgIH0gZWxzZSBpZiAoZW50cnkuZmlsZSkge1xuICAgICAgICBlbnRyeS5maWxlLnJlbW92ZSgoKSA9PiByZXNvbHZlKCksIHJlamVjdClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IChvcHRzID0ge30pID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gIHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbShcbiAgICBvcHRzLl9wZXJzaXN0ZW50LCAwLFxuICAgIGUgPT4gcmVzb2x2ZShuZXcgRm9sZGVySGFuZGxlKGUucm9vdCkpLFxuICAgIHJlamVjdFxuICApXG4pXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///767\n")}}]);