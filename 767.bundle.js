"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[767],{2767:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileHandle: () => (/* binding */ FileHandle),\n/* harmony export */   FolderHandle: () => (/* binding */ FolderHandle),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5275);\n/* global Blob, DOMException */\n\n\n\nconst { DISALLOWED } = _util_js__WEBPACK_IMPORTED_MODULE_0__.errors\n\nclass Sink {\n  /**\n   * @param {FileWriter} writer\n   * @param {FileEntry} fileEntry\n   */\n  constructor (writer, fileEntry) {\n    this.writer = writer\n    this.fileEntry = fileEntry\n  }\n\n  /**\n   * @param {BlobPart | Object} chunk\n   */\n  async write (chunk) {\n    if (typeof chunk === 'object') {\n      if (chunk.type === 'write') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          this.writer.seek(chunk.position)\n          if (this.writer.position !== chunk.position) {\n            await new Promise((resolve, reject) => {\n              this.writer.onwriteend = resolve\n              this.writer.onerror = reject\n              this.writer.truncate(chunk.position)\n            })\n            this.writer.seek(chunk.position)\n          }\n        }\n        if (!('data' in chunk)) {\n          throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. write requires a data argument', 'SyntaxError')\n        }\n        chunk = chunk.data\n      } else if (chunk.type === 'seek') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          this.writer.seek(chunk.position)\n          if (this.writer.position !== chunk.position) {\n            throw new DOMException('seeking position failed', 'InvalidStateError')\n          }\n          return\n        } else {\n          throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. seek requires a position argument', 'SyntaxError')\n        }\n      } else if (chunk.type === 'truncate') {\n        return new Promise(resolve => {\n          if (Number.isInteger(chunk.size) && chunk.size >= 0) {\n            this.writer.onwriteend = evt => resolve()\n            this.writer.truncate(chunk.size)\n          } else {\n            throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. truncate requires a size argument', 'SyntaxError')\n          }\n        })\n      }\n    }\n    await new Promise((resolve, reject) => {\n      this.writer.onwriteend = resolve\n      this.writer.onerror = reject\n      this.writer.write(new Blob([chunk]))\n    })\n  }\n\n  close () {\n    return new Promise(this.fileEntry.file.bind(this.fileEntry))\n  }\n}\n\nclass FileHandle {\n  /** @param {FileEntry} file */\n  constructor (file, writable = true) {\n    this.file = file\n    this.kind = 'file'\n    this.writable = writable\n    this.readable = true\n  }\n\n  get name () {\n    return this.file.name\n  }\n\n  /**\n   * @param {{ file: { toURL: () => string; }; }} other\n   */\n  isSameEntry (other) {\n    return this.file.toURL() === other.file.toURL()\n  }\n\n  /** @return {Promise<File>} */\n  getFile () {\n    return new Promise(this.file.file.bind(this.file))\n  }\n\n  /** @return {Promise<Sink>} */\n  createWritable (opts) {\n    if (!this.writable) throw new DOMException(...DISALLOWED)\n\n    return new Promise((resolve, reject) =>\n      this.file.createWriter(fileWriter => {\n        if (opts.keepExistingData === false) {\n          fileWriter.onwriteend = evt => resolve(new Sink(fileWriter, this.file))\n          fileWriter.truncate(0)\n        } else {\n          resolve(new Sink(fileWriter, this.file))\n        }\n      }, reject)\n    )\n  }\n}\n\nclass FolderHandle {\n  /** @param {DirectoryEntry} dir */\n  constructor (dir, writable = true) {\n    this.dir = dir\n    this.writable = writable\n    this.readable = true\n    this.kind = 'directory'\n    this.name = dir.name\n  }\n\n  /** @param {FolderHandle} other */\n  isSameEntry (other) {\n    return this.dir.fullPath === other.dir.fullPath\n  }\n\n  /** @returns {AsyncGenerator<[string, FileHandle | FolderHandle]>} */\n  async * entries () {\n    const reader = this.dir.createReader()\n    const entries = await new Promise(reader.readEntries.bind(reader))\n    for (const x of entries) {\n      yield [x.name, x.isFile ? new FileHandle(x, this.writable) : new FolderHandle(x, this.writable)]\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   * @returns {Promise<FolderHandle>}\n   */\n  getDirectoryHandle (name, opts) {\n    return new Promise((resolve, reject) => {\n      this.dir.getDirectory(name, opts, dir => {\n        resolve(new FolderHandle(dir))\n      }, reject)\n    })\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   * @returns {Promise<FileHandle>}\n   */\n  getFileHandle (name, opts) {\n    return new Promise((resolve, reject) =>\n      this.dir.getFile(name, opts, file => resolve(new FileHandle(file)), reject)\n    )\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ recursive: boolean; }} opts\n   */\n  async removeEntry (name, opts) {\n    /** @type {Error|FolderHandle|FileHandle} */\n    const entry = await this.getDirectoryHandle(name, { create: false }).catch(err =>\n      err.name === 'TypeMismatchError' ? this.getFileHandle(name, { create: false }) : err\n    )\n\n    if (entry instanceof Error) throw entry\n\n    return new Promise((resolve, reject) => {\n      if (entry instanceof FolderHandle) {\n        opts.recursive\n          ? entry.dir.removeRecursively(() => resolve(), reject)\n          : entry.dir.remove(() => resolve(), reject)\n      } else if (entry.file) {\n        entry.file.remove(() => resolve(), reject)\n      }\n    })\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((opts = {}) => new Promise((resolve, reject) =>\n  window.webkitRequestFileSystem(\n    opts._persistent, 0,\n    e => resolve(new FolderHandle(e.root)),\n    reject\n  )\n));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc2Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRW1DOztBQUVuQyxRQUFRLGFBQWEsRUFBRSw0Q0FBTTs7QUFFN0I7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUSwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1AsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5Qyx3REFBd0QsZUFBZTtBQUN2RSxvRUFBb0UsZUFBZTtBQUNuRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxpRUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25hdGl2ZS1maWxlLXN5c3RlbS1hZGFwdGVyQDMuMC4xL25vZGVfbW9kdWxlcy9uYXRpdmUtZmlsZS1zeXN0ZW0tYWRhcHRlci9zcmMvYWRhcHRlcnMvc2FuZGJveC5qcz9iZWNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBCbG9iLCBET01FeGNlcHRpb24gKi9cblxuaW1wb3J0IHsgZXJyb3JzIH0gZnJvbSAnLi4vdXRpbC5qcydcblxuY29uc3QgeyBESVNBTExPV0VEIH0gPSBlcnJvcnNcblxuY2xhc3MgU2luayB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0ZpbGVXcml0ZXJ9IHdyaXRlclxuICAgKiBAcGFyYW0ge0ZpbGVFbnRyeX0gZmlsZUVudHJ5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAod3JpdGVyLCBmaWxlRW50cnkpIHtcbiAgICB0aGlzLndyaXRlciA9IHdyaXRlclxuICAgIHRoaXMuZmlsZUVudHJ5ID0gZmlsZUVudHJ5XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCbG9iUGFydCB8IE9iamVjdH0gY2h1bmtcbiAgICovXG4gIGFzeW5jIHdyaXRlIChjaHVuaykge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoY2h1bmsudHlwZSA9PT0gJ3dyaXRlJykge1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihjaHVuay5wb3NpdGlvbikgJiYgY2h1bmsucG9zaXRpb24gPj0gMCkge1xuICAgICAgICAgIHRoaXMud3JpdGVyLnNlZWsoY2h1bmsucG9zaXRpb24pXG4gICAgICAgICAgaWYgKHRoaXMud3JpdGVyLnBvc2l0aW9uICE9PSBjaHVuay5wb3NpdGlvbikge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLndyaXRlci5vbndyaXRlZW5kID0gcmVzb2x2ZVxuICAgICAgICAgICAgICB0aGlzLndyaXRlci5vbmVycm9yID0gcmVqZWN0XG4gICAgICAgICAgICAgIHRoaXMud3JpdGVyLnRydW5jYXRlKGNodW5rLnBvc2l0aW9uKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnNlZWsoY2h1bmsucG9zaXRpb24pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKCdkYXRhJyBpbiBjaHVuaykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdGYWlsZWQgdG8gZXhlY3V0ZSBcXCd3cml0ZVxcJyBvbiBcXCdVbmRlcmx5aW5nU2lua0Jhc2VcXCc6IEludmFsaWQgcGFyYW1zIHBhc3NlZC4gd3JpdGUgcmVxdWlyZXMgYSBkYXRhIGFyZ3VtZW50JywgJ1N5bnRheEVycm9yJylcbiAgICAgICAgfVxuICAgICAgICBjaHVuayA9IGNodW5rLmRhdGFcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsudHlwZSA9PT0gJ3NlZWsnKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGNodW5rLnBvc2l0aW9uKSAmJiBjaHVuay5wb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgdGhpcy53cml0ZXIuc2VlayhjaHVuay5wb3NpdGlvbilcbiAgICAgICAgICBpZiAodGhpcy53cml0ZXIucG9zaXRpb24gIT09IGNodW5rLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdzZWVraW5nIHBvc2l0aW9uIGZhaWxlZCcsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ZhaWxlZCB0byBleGVjdXRlIFxcJ3dyaXRlXFwnIG9uIFxcJ1VuZGVybHlpbmdTaW5rQmFzZVxcJzogSW52YWxpZCBwYXJhbXMgcGFzc2VkLiBzZWVrIHJlcXVpcmVzIGEgcG9zaXRpb24gYXJndW1lbnQnLCAnU3ludGF4RXJyb3InKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNodW5rLnR5cGUgPT09ICd0cnVuY2F0ZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGNodW5rLnNpemUpICYmIGNodW5rLnNpemUgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZXIub253cml0ZWVuZCA9IGV2dCA9PiByZXNvbHZlKClcbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnRydW5jYXRlKGNodW5rLnNpemUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ZhaWxlZCB0byBleGVjdXRlIFxcJ3dyaXRlXFwnIG9uIFxcJ1VuZGVybHlpbmdTaW5rQmFzZVxcJzogSW52YWxpZCBwYXJhbXMgcGFzc2VkLiB0cnVuY2F0ZSByZXF1aXJlcyBhIHNpemUgYXJndW1lbnQnLCAnU3ludGF4RXJyb3InKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy53cml0ZXIub253cml0ZWVuZCA9IHJlc29sdmVcbiAgICAgIHRoaXMud3JpdGVyLm9uZXJyb3IgPSByZWplY3RcbiAgICAgIHRoaXMud3JpdGVyLndyaXRlKG5ldyBCbG9iKFtjaHVua10pKVxuICAgIH0pXG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHRoaXMuZmlsZUVudHJ5LmZpbGUuYmluZCh0aGlzLmZpbGVFbnRyeSkpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVIYW5kbGUge1xuICAvKiogQHBhcmFtIHtGaWxlRW50cnl9IGZpbGUgKi9cbiAgY29uc3RydWN0b3IgKGZpbGUsIHdyaXRhYmxlID0gdHJ1ZSkge1xuICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgICB0aGlzLmtpbmQgPSAnZmlsZSdcbiAgICB0aGlzLndyaXRhYmxlID0gd3JpdGFibGVcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZVxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGUubmFtZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7eyBmaWxlOiB7IHRvVVJMOiAoKSA9PiBzdHJpbmc7IH07IH19IG90aGVyXG4gICAqL1xuICBpc1NhbWVFbnRyeSAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlLnRvVVJMKCkgPT09IG90aGVyLmZpbGUudG9VUkwoKVxuICB9XG5cbiAgLyoqIEByZXR1cm4ge1Byb21pc2U8RmlsZT59ICovXG4gIGdldEZpbGUgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSh0aGlzLmZpbGUuZmlsZS5iaW5kKHRoaXMuZmlsZSkpXG4gIH1cblxuICAvKiogQHJldHVybiB7UHJvbWlzZTxTaW5rPn0gKi9cbiAgY3JlYXRlV3JpdGFibGUgKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHRocm93IG5ldyBET01FeGNlcHRpb24oLi4uRElTQUxMT1dFRClcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgdGhpcy5maWxlLmNyZWF0ZVdyaXRlcihmaWxlV3JpdGVyID0+IHtcbiAgICAgICAgaWYgKG9wdHMua2VlcEV4aXN0aW5nRGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBmaWxlV3JpdGVyLm9ud3JpdGVlbmQgPSBldnQgPT4gcmVzb2x2ZShuZXcgU2luayhmaWxlV3JpdGVyLCB0aGlzLmZpbGUpKVxuICAgICAgICAgIGZpbGVXcml0ZXIudHJ1bmNhdGUoMClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG5ldyBTaW5rKGZpbGVXcml0ZXIsIHRoaXMuZmlsZSkpXG4gICAgICAgIH1cbiAgICAgIH0sIHJlamVjdClcbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZvbGRlckhhbmRsZSB7XG4gIC8qKiBAcGFyYW0ge0RpcmVjdG9yeUVudHJ5fSBkaXIgKi9cbiAgY29uc3RydWN0b3IgKGRpciwgd3JpdGFibGUgPSB0cnVlKSB7XG4gICAgdGhpcy5kaXIgPSBkaXJcbiAgICB0aGlzLndyaXRhYmxlID0gd3JpdGFibGVcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZVxuICAgIHRoaXMua2luZCA9ICdkaXJlY3RvcnknXG4gICAgdGhpcy5uYW1lID0gZGlyLm5hbWVcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge0ZvbGRlckhhbmRsZX0gb3RoZXIgKi9cbiAgaXNTYW1lRW50cnkgKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlyLmZ1bGxQYXRoID09PSBvdGhlci5kaXIuZnVsbFBhdGhcbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7QXN5bmNHZW5lcmF0b3I8W3N0cmluZywgRmlsZUhhbmRsZSB8IEZvbGRlckhhbmRsZV0+fSAqL1xuICBhc3luYyAqIGVudHJpZXMgKCkge1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuZGlyLmNyZWF0ZVJlYWRlcigpXG4gICAgY29uc3QgZW50cmllcyA9IGF3YWl0IG5ldyBQcm9taXNlKHJlYWRlci5yZWFkRW50cmllcy5iaW5kKHJlYWRlcikpXG4gICAgZm9yIChjb25zdCB4IG9mIGVudHJpZXMpIHtcbiAgICAgIHlpZWxkIFt4Lm5hbWUsIHguaXNGaWxlID8gbmV3IEZpbGVIYW5kbGUoeCwgdGhpcy53cml0YWJsZSkgOiBuZXcgRm9sZGVySGFuZGxlKHgsIHRoaXMud3JpdGFibGUpXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3sgY3JlYXRlOiBib29sZWFuOyB9fSBvcHRzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEZvbGRlckhhbmRsZT59XG4gICAqL1xuICBnZXREaXJlY3RvcnlIYW5kbGUgKG5hbWUsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5kaXIuZ2V0RGlyZWN0b3J5KG5hbWUsIG9wdHMsIGRpciA9PiB7XG4gICAgICAgIHJlc29sdmUobmV3IEZvbGRlckhhbmRsZShkaXIpKVxuICAgICAgfSwgcmVqZWN0KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHt7IGNyZWF0ZTogYm9vbGVhbjsgfX0gb3B0c1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlSGFuZGxlPn1cbiAgICovXG4gIGdldEZpbGVIYW5kbGUgKG5hbWUsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgIHRoaXMuZGlyLmdldEZpbGUobmFtZSwgb3B0cywgZmlsZSA9PiByZXNvbHZlKG5ldyBGaWxlSGFuZGxlKGZpbGUpKSwgcmVqZWN0KVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3sgcmVjdXJzaXZlOiBib29sZWFuOyB9fSBvcHRzXG4gICAqL1xuICBhc3luYyByZW1vdmVFbnRyeSAobmFtZSwgb3B0cykge1xuICAgIC8qKiBAdHlwZSB7RXJyb3J8Rm9sZGVySGFuZGxlfEZpbGVIYW5kbGV9ICovXG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCB0aGlzLmdldERpcmVjdG9yeUhhbmRsZShuYW1lLCB7IGNyZWF0ZTogZmFsc2UgfSkuY2F0Y2goZXJyID0+XG4gICAgICBlcnIubmFtZSA9PT0gJ1R5cGVNaXNtYXRjaEVycm9yJyA/IHRoaXMuZ2V0RmlsZUhhbmRsZShuYW1lLCB7IGNyZWF0ZTogZmFsc2UgfSkgOiBlcnJcbiAgICApXG5cbiAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgZW50cnlcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBGb2xkZXJIYW5kbGUpIHtcbiAgICAgICAgb3B0cy5yZWN1cnNpdmVcbiAgICAgICAgICA/IGVudHJ5LmRpci5yZW1vdmVSZWN1cnNpdmVseSgoKSA9PiByZXNvbHZlKCksIHJlamVjdClcbiAgICAgICAgICA6IGVudHJ5LmRpci5yZW1vdmUoKCkgPT4gcmVzb2x2ZSgpLCByZWplY3QpXG4gICAgICB9IGVsc2UgaWYgKGVudHJ5LmZpbGUpIHtcbiAgICAgICAgZW50cnkuZmlsZS5yZW1vdmUoKCkgPT4gcmVzb2x2ZSgpLCByZWplY3QpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCAob3B0cyA9IHt9KSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICB3aW5kb3cud2Via2l0UmVxdWVzdEZpbGVTeXN0ZW0oXG4gICAgb3B0cy5fcGVyc2lzdGVudCwgMCxcbiAgICBlID0+IHJlc29sdmUobmV3IEZvbGRlckhhbmRsZShlLnJvb3QpKSxcbiAgICByZWplY3RcbiAgKVxuKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2767\n")}}]);