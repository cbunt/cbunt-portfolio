{"version":3,"file":"158.bundle.js","mappings":"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","sources":["webpack://cbunt-portfolio/./src/samples/cubemap-blur/cubemap-blur-sample.ts","webpack://cbunt-portfolio/./src/samples/cubemap-blur/cubemap-guassian-pyramid.ts","webpack://cbunt-portfolio/./src/samples/settings/skybox-options.ts","webpack://cbunt-portfolio/./src/shaders/blit-vert.shader.ts","webpack://cbunt-portfolio/./src/shaders/cubemap-sampling.shader.ts","webpack://cbunt-portfolio/./src/utils/data-copy.ts","webpack://cbunt-portfolio/./src/utils/data-conversion.ts","webpack://cbunt-portfolio/./src/utils/texture-importing.ts","webpack://cbunt-portfolio/./src/utils/texture-processing.ts"],"sourcesContent":["import { showSaveFilePicker } from 'native-file-system-adapter';\n\nimport getSkyboxOptions from '../settings/skybox-options';\nimport { FullRenderModel } from '../settings/sample-spec';\nimport propertyListener, { ListenerSyms } from '../settings/property-listener';\n\nimport { textureToKTX } from '../../utils/data-copy';\nimport Renderer, { ForwardPassParams } from '../../rendering/renderer';\n\nimport cubemapGuassianPyramid from './cubemap-guassian-pyramid';\n\nenum BlurState { IDLE, BLUR, WAIT }\n\nexport default class CubemapBlurModel implements FullRenderModel {\n    static title = '';\n    static description = '';\n\n    skybox?: GPUTexture;\n    state: BlurState = BlurState.IDLE;\n\n    readonly #settings = propertyListener({\n        nearestSample: {\n            [ListenerSyms.$type]: 'checkbox' as const,\n            [ListenerSyms.$callback]: (val: unknown) => {\n                if (typeof val === 'boolean') this.renderer.skyboxPass.useNearestSample = val;\n            },\n            value: false,\n            description: 'Disables linear sampling in the viewer.',\n        },\n        mipLevel: {\n            [ListenerSyms.$type]: 'slider' as const,\n            [ListenerSyms.$callback]: (value: unknown) => {\n                if (typeof value === 'number') this.renderer.skyboxPass.mipLevel = value;\n            },\n            value: 0,\n            min: 0,\n            max: 1,\n            step: 0.1,\n            description: 'The mip level to display in the viewer. 0 is the original image, max is completely blurred with 1 pixel faces.',\n        },\n        filterDistance: {\n            [ListenerSyms.$type]: 'slider' as const,\n            [ListenerSyms.$callback]: this.reblur.bind(this) as () => void,\n            value: 2,\n            max: 64,\n            min: 0,\n            step: 0.1,\n            description: 'The number of pixels to blur from.',\n        },\n        skybox: getSkyboxOptions(this),\n        'Download Result': {\n            [ListenerSyms.$type]: 'button' as const,\n            onClick: () => { void this.saveFile(); },\n        },\n    });\n\n    readonly settings = this.#settings.publicSettings;\n    readonly priority = 0;\n    device: GPUDevice;\n\n    constructor(public renderer: Renderer) {\n        renderer.addForwardPass(this);\n        this.device = renderer.device;\n    }\n\n    setSkybox(skybox: GPUTexture) {\n        this.skybox = skybox;\n        this.#settings.privateSettings.mipLevel.max = this.skybox.mipLevelCount - 1;\n        this.#settings.privateSettings.mipLevel.value = 1;\n        this.renderer.skyboxPass.mipLevel = 1;\n\n        this.refresh();\n        void this.reblur();\n    }\n\n    resolve() {\n        this.refresh();\n        const lastState = this.state;\n        this.state = BlurState.IDLE;\n        if (lastState === BlurState.WAIT) void this.reblur();\n    }\n\n    async reblur() {\n        if (this.skybox == null || this.state === BlurState.WAIT) return;\n\n        if (this.state === BlurState.BLUR) {\n            this.state = BlurState.WAIT;\n            return;\n        }\n\n        this.state = BlurState.BLUR;\n\n        await cubemapGuassianPyramid({\n            device: this.renderer.device,\n            texture: this.skybox,\n            steps: this.settings.filterDistance.value,\n            inPlace: true,\n            delayWork: requestAnimationFrame,\n        });\n\n        this.resolve();\n    }\n\n    refresh() {\n        if (this.skybox == null) return;\n        this.renderer.skyboxPass.skyTexture = this.skybox.createView({ dimension: 'cube' });\n    }\n\n    async saveFile() {\n        if (this.skybox == null) return;\n        try {\n            const proms = Promise.all([\n                textureToKTX(this.renderer.device, this.skybox, true)\n                    .then((ktx2) => new Blob([ktx2], { type: 'image/ktx2' })),\n                showSaveFilePicker({\n                    types: [{ accept: { 'image/ktx2': ['.ktx2'] } }],\n                    suggestedName: 'blurred-skybox.ktx2',\n                }).then((handle) => handle.createWritable({ keepExistingData: false })),\n            ]);\n\n            const [blob, stream] = await proms;\n            await blob.stream().pipeTo(stream);\n        } catch (e) {\n            console.warn(e);\n        }\n    }\n\n    render({ encoder, gbuffer }: ForwardPassParams) {\n        encoder.beginRenderPass({\n            colorAttachments: [],\n            depthStencilAttachment: {\n                depthClearValue: 1,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n                view: gbuffer.depth.view,\n            },\n        }).end();\n    }\n}\n","/* eslint @stylistic/max-len: \"error\" */\r\n\r\nimport {\r\n    toWorldDir,\r\n    cubemapSampleConversions,\r\n} from '../../shaders/cubemap-sampling.shader';\r\n\r\nimport { createAndCopyBuffer } from '../../utils/data-copy';\r\nimport { mapRange } from '../../utils/general';\r\n\r\nconst createMipBlurCode = (\r\n    groups: number,\r\n    format: GPUTextureFormat,\r\n) => /* wgsl */`\r\n    ${cubemapSampleConversions}\r\n    ${toWorldDir}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    struct Params {\r\n        offset: u32,\r\n        sigmas: array<f32>,\r\n    }\r\n\r\n    @group(0) @binding(0) var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    // sigma[0] reserved for work offset\r\n    @group(0) @binding(2) var<storage> params: Params;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + params.offset;\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = toWorldDir(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&params.sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = params.sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = toWorldDir(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\r\n\r\n/**\r\n *  the minimum angular distance between any pixel on a cubemap\r\n *  of the given face width and any pixel lying on a perimeter\r\n *  the given number of steps away\r\n */\r\nfunction minStepDistance(steps: number, width: number) {\r\n    // the angular distance\r\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\r\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\r\n\r\n    // It's likely possible to programmatically determine whether the\r\n    // destination pixel should be v = 0 or v = 1, but checking both works fine\r\n\r\n    const nextMipWidth = width >> 1;\r\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\r\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\r\n    const baseUN = (1 / nextMipWidth) - 1;\r\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\r\n\r\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\r\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\r\n    const samp0VN = (1 / width) - 1;\r\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\r\n    const samp1VN = (3 / width) - 1;\r\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\r\n\r\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN)\r\n        / Math.sqrt(samp0Mag2 * baseMag2);\r\n\r\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN)\r\n        / Math.sqrt(samp1Mag2 * baseMag2);\r\n\r\n    return Math.min(1 - dot0, 1 - dot1);\r\n}\r\n\r\nexport type GaussianPyramidDescriptor = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n\r\n    /**\r\n     *  If the pyramid should overwrite the existing mips\r\n     *  of the given texture\r\n     *\r\n     *  @defaultValue `false`\r\n     */\r\n    inPlace?: boolean,\r\n\r\n    /**\r\n     *  The maximum width of the smallest mip level.\r\n     *\r\n     *  @defaultValue `8`\r\n     */\r\n    minWidth?: number,\r\n\r\n    /**\r\n     *  The kernel extent distance, in pixels.\r\n     *\r\n     *  @defaultValue `4`\r\n     */\r\n    steps?: number,\r\n\r\n    /**\r\n     *  A function to delay the processing of additional pixels,\r\n     *  e.g. `requestAnimationFrame`. Spaces work to allow additional\r\n     *  rendering and interactivity during heavy blurring workloads.\r\n     *\r\n     *  If undefined, all pixels are processed at once.\r\n     */\r\n    delayWork?: (fn: () => Promise<void> | void) => void,\r\n\r\n    /**\r\n     *  The maximum number of pixels to process within a batch.\r\n     *  Unused if `delayWork` is undefined.\r\n     *\r\n     *  @defaultValue 6 * ((17 * 256) ** 2)\r\n     *\r\n     *  Allowing cubemap 256 pixels in width with `steps = 8` to run\r\n     *  in a single pass. This is a conservatively low default for\r\n     *  compatibility with lower-end hardware.\r\n     */\r\n    maxOpsPerPass?: number,\r\n\r\n    /**\r\n     *  A prefix string for error message thrown from the function\r\n     *\r\n     *  @defaultValue `cubemapGuassianPyramid --`\r\n     */\r\n    label?: string,\r\n\r\n    /**\r\n     *  The label to pass the output GPUTexture.\r\n     *\r\n     *  Unused if `inPlace == true`\r\n     */\r\n    outputTextureLabel?: string,\r\n};\r\n\r\nexport default async function cubemapGuassianPyramid({\r\n    device,\r\n    texture,\r\n    outputTextureLabel,\r\n    inPlace = false,\r\n    minWidth = 8,\r\n    steps = 4,\r\n    maxOpsPerPass = 6 * ((17 * 256) ** 2),\r\n    label = cubemapGuassianPyramid.name,\r\n    delayWork,\r\n}: GaussianPyramidDescriptor) {\r\n    const { width, format } = texture;\r\n    const mipLevelCount = inPlace\r\n        ? texture.mipLevelCount\r\n        : (Math.log2(width) - Math.log2(minWidth) + 1);\r\n\r\n    if (mipLevelCount <= 1) return texture;\r\n\r\n    const groups = Math.min(\r\n        device.limits.maxComputeWorkgroupSizeX,\r\n        device.limits.maxComputeInvocationsPerWorkgroup,\r\n    );\r\n    const shader = device.createShaderModule({\r\n        label,\r\n        code: createMipBlurCode(groups, format),\r\n    });\r\n\r\n    const bindgroupLayout = device.createBindGroupLayout({\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                texture: { viewDimension: '2d-array' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 1,\r\n                storageTexture: {\r\n                    access: 'write-only',\r\n                    viewDimension: '2d-array',\r\n                    format,\r\n                },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 2,\r\n                buffer: { type: 'read-only-storage' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n        ],\r\n    });\r\n\r\n    const pipeline = device.createComputePipeline({\r\n        label,\r\n        layout: device.createPipelineLayout({\r\n            label,\r\n            bindGroupLayouts: [bindgroupLayout],\r\n        }),\r\n        compute: {\r\n            module: shader,\r\n            entryPoint: 'main',\r\n            constants: { STEPS: Math.ceil(steps) },\r\n        },\r\n    });\r\n\r\n    let gaussianPyramid = texture;\r\n    if (!inPlace) {\r\n        const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n        gaussianPyramid = device.createTexture({\r\n            label: outputTextureLabel,\r\n            usage: GPUTextureUsage.STORAGE_BINDING\r\n                | GPUTextureUsage.TEXTURE_BINDING\r\n                | GPUTextureUsage.COPY_SRC\r\n                | GPUTextureUsage.COPY_DST,\r\n            dimension: '2d',\r\n            format,\r\n            mipLevelCount,\r\n            size,\r\n        });\r\n\r\n        const copyEncoder = device.createCommandEncoder({\r\n            label: `${label} copy encoder`,\r\n        });\r\n\r\n        copyEncoder.copyTextureToTexture(\r\n            { texture, mipLevel: 0 },\r\n            { texture: gaussianPyramid, mipLevel: 0 },\r\n            size,\r\n        );\r\n\r\n        device.queue.submit([copyEncoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n\r\n    const mipViews = mapRange(mipLevelCount, (i) => gaussianPyramid.createView({\r\n        label: `${label} mip view ${i}`,\r\n        dimension: '2d-array',\r\n        baseMipLevel: i,\r\n        mipLevelCount: 1,\r\n    }));\r\n\r\n    const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\r\n    const maxLayers = Math.ceil(Math.log2(width));\r\n    const maxDispatches = Math.max(\r\n        (maxOpsPerPass / (((1 + (steps * 2)) ** 2) * groups)) | 0,\r\n        1,\r\n    );\r\n\r\n    const propertyArray = new ArrayBuffer((maxLayers + 1) * 4);\r\n    const offset = new Uint32Array(propertyArray, 0, 1);\r\n    const simgas = new Float32Array(propertyArray, 4, maxLayers);\r\n\r\n    simgas.set(mapRange(maxLayers, (i) => {\r\n        const w = width >> i;\r\n        return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\r\n    }));\r\n\r\n    const propertyBuffer = createAndCopyBuffer(\r\n        propertyArray,\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        device,\r\n    );\r\n\r\n    await new Promise<void>((resolve) => {\r\n        let mipLevel = 0;\r\n        let mipPasses = 0;\r\n        let requiredMipDispatches = 0;\r\n        let currentMipDispatches = 0;\r\n        let batchDispatches = 0;\r\n        let bindgroup: GPUBindGroup;\r\n\r\n        async function runPass() {\r\n            if (currentMipDispatches >= requiredMipDispatches) {\r\n                mipLevel += 1;\r\n                currentMipDispatches = 0;\r\n                mipPasses = 0;\r\n\r\n                if (mipLevel >= mipLevelCount) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n\r\n                const mipPixels = 6 * ((width >> mipLevel) ** 2);\r\n                requiredMipDispatches = Math.ceil(mipPixels / groups);\r\n\r\n                bindgroup = device.createBindGroup({\r\n                    layout: bindgroupLayout,\r\n                    entries: [\r\n                        {\r\n                            binding: 0,\r\n                            resource: mipViews[mipLevel - 1],\r\n                        },\r\n                        {\r\n                            binding: 1,\r\n                            resource: mipViews[mipLevel],\r\n                        },\r\n                        {\r\n                            binding: 2,\r\n                            resource: { buffer: propertyBuffer },\r\n                        },\r\n                    ],\r\n                });\r\n            }\r\n\r\n            offset[0] = currentMipDispatches * groups;\r\n            device.queue.writeBuffer(propertyBuffer, 0, offset);\r\n\r\n            const passDispatches = Math.min(\r\n                requiredMipDispatches - currentMipDispatches,\r\n                maxDispatches - batchDispatches,\r\n                maxWorkgroups,\r\n            );\r\n\r\n            const passLabel = `${label} mip ${mipLevel}, pass ${mipPasses}`;\r\n            const encoder = device.createCommandEncoder({ label: passLabel });\r\n            const pass = encoder.beginComputePass({ label: passLabel });\r\n\r\n            pass.setPipeline(pipeline);\r\n            pass.setBindGroup(0, bindgroup);\r\n            pass.dispatchWorkgroups(passDispatches, 1, 1);\r\n            pass.end();\r\n\r\n            device.queue.submit([encoder.finish()]);\r\n\r\n            currentMipDispatches += passDispatches;\r\n            batchDispatches += passDispatches;\r\n            mipPasses += 1;\r\n\r\n            if (delayWork != null && batchDispatches >= maxDispatches) {\r\n                batchDispatches = 0;\r\n                await device.queue.onSubmittedWorkDone();\r\n                delayWork(runPass);\r\n            } else {\r\n                void runPass();\r\n            }\r\n        }\r\n\r\n        void runPass();\r\n    });\r\n\r\n    return gaussianPyramid;\r\n}\r\n","import { parseHDR } from '../../utils/texture-importing';\nimport { equirectangularToCubemap } from '../../utils/texture-processing';\nimport { ListenerSyms } from './property-listener';\n\nconst hdrPromises = await fetch(HDR_BASE_URL__, { headers: { 'Content-Type': 'application/vnd.github.object+json' } })\n    .then((res) => res.json()) as Record<string, unknown>[];\n\nexport const hdrs = Object.fromEntries(hdrPromises.flatMap(({ name, download_url }) => typeof name === 'string' && typeof download_url === 'string' && download_url.endsWith('.hdr') ? [[name, download_url]] : []));\n\nasync function processSkybox(device: GPUDevice, file: string | URL | File | ArrayBuffer) {\n    let buffer: ArrayBuffer;\n    if (file instanceof ArrayBuffer) {\n        buffer = file;\n    } else if (file instanceof File) {\n        buffer = await file.arrayBuffer();\n    } else {\n        const res = await fetch(file);\n        buffer = await res.arrayBuffer();\n    }\n\n    const hdr = parseHDR(buffer);\n\n    return equirectangularToCubemap(\n        device,\n        hdr,\n        {\n            format: 'rgba16float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        },\n    );\n}\n\nexport type SkyboxTarget = { device: GPUDevice, setSkybox: (resource: GPUTexture) => unknown };\n\nexport default function getSkyboxOptions(target: SkyboxTarget) {\n    return {\n        [ListenerSyms.$type]: 'file' as const,\n        [ListenerSyms.$callback]: async (val: unknown, key: PropertyKey) => {\n            if (key !== 'value' || val == null) return;\n            if (typeof val === 'string' || val instanceof File) {\n                const texture = await processSkybox(target.device, val);\n                const res = target.setSkybox(texture);\n                if (res instanceof Promise) await res;\n            }\n        },\n        accept: '.hdr',\n        selection: {\n            value: Object.keys(hdrs)[0],\n            initialValues: hdrs,\n        },\n        process: (file: File) => file,\n    };\n}\n","export default /* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`;\r\n","export const toWorldDir: string = /* wgsl */`\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nexport const cubemapSampleConversions: string = /* wgsl */`\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n","import * as ktxparse from 'ktx-parse';\r\n\r\nimport { VkFormatToWebGPU, TextureFormatToSize, TextureFormatToChannelSize, WebGPUToVkFormat } from '../rendering/constants';\r\nimport { padTemplate } from './general';\r\n\r\nexport function createAndCopyBuffer(\r\n    arr: ArrayBuffer | TypedArrayLike,\r\n    usage: GPUFlagsConstant,\r\n    device: GPUDevice,\r\n    label?: string,\r\n    alignment = 4,\r\n): GPUBuffer {\r\n    const pad = alignment - 1;\r\n    const buffer = device.createBuffer({\r\n        label,\r\n        usage,\r\n        size: (arr.byteLength + pad) & ~pad,\r\n        mappedAtCreation: true,\r\n    } as GPUBufferDescriptor);\r\n\r\n    const writeArray = new Uint8Array(buffer.getMappedRange());\r\n    const readArray = arr instanceof ArrayBuffer\r\n        ? new Uint8Array(arr)\r\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n\r\n    writeArray.set(readArray);\r\n    buffer.unmap();\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function createAndCopyCubemap(\r\n    device: GPUDevice,\r\n    data: ArrayBuffer,\r\n    format: GPUTextureFormat,\r\n    usage: number,\r\n    label?: string,\r\n) {\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\r\n    }\r\n\r\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\r\n    const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n    const texture = device.createTexture({\r\n        usage: usage | GPUTextureUsage.COPY_DST,\r\n        label,\r\n        format,\r\n        size,\r\n    });\r\n\r\n    device.queue.writeTexture(\r\n        { texture },\r\n        data,\r\n        { bytesPerRow: width * pixelSize, rowsPerImage: width },\r\n        size,\r\n    );\r\n\r\n    return texture;\r\n}\r\n\r\nexport type KTXImportOptions = {\r\n    label?: string,\r\n    mipLevelCount?: number | 'max' | 'default',\r\n    textureUsage?: number,\r\n    validate?: boolean,\r\n};\r\n\r\nexport function ktx2ToTexture(\r\n    buffer: ArrayBuffer,\r\n    device: GPUDevice,\r\n    options?: KTXImportOptions,\r\n) {\r\n    const arr = new Uint8Array(buffer);\r\n    const ktx = ktxparse.read(arr);\r\n    const format = VkFormatToWebGPU[ktx.vkFormat];\r\n\r\n    if (format == null) {\r\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not covert to webgpu`);\r\n    }\r\n\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not get pixel byte size`);\r\n    }\r\n\r\n    const size = {\r\n        width: ktx.pixelWidth,\r\n        height: ktx.pixelHeight,\r\n        depthOrArrayLayers: ktx.faceCount,\r\n    };\r\n\r\n    const maxMipCount = Math.ceil(Math.log2(Math.max(size.width, size.height))) + 1;\r\n    let mipLevelCount = ktx.levels.length;\r\n    if (options?.mipLevelCount === 'max') {\r\n        mipLevelCount = maxMipCount;\r\n    } else if (typeof options?.mipLevelCount === 'number') {\r\n        mipLevelCount = Math.min(maxMipCount, options.mipLevelCount);\r\n    }\r\n\r\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\r\n    if (options?.textureUsage) usage |= options.textureUsage;\r\n\r\n    const texture = device.createTexture({\r\n        label: options?.label,\r\n        size,\r\n        mipLevelCount,\r\n        format,\r\n        usage,\r\n    });\r\n\r\n    const mipCopies = Math.min(ktx.levels.length, mipLevelCount) - 1;\r\n\r\n    for (let mipLevel = mipCopies; mipLevel >= 0; mipLevel -= 1) {\r\n        const width = size.width >> mipLevel;\r\n        const height = size.height >> mipLevel;\r\n        const { levelData } = ktx.levels[mipLevel];\r\n\r\n        const rawBytesPerRow = width * pixelSize;\r\n        const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n        const rowsPerImage = height;\r\n        const bytesPerImage = rowsPerImage * bytesPerRow;\r\n\r\n        let imageData = levelData;\r\n        if (bytesPerRow > rawBytesPerRow) {\r\n            imageData = new Uint8Array(bytesPerImage * texture.depthOrArrayLayers);\r\n\r\n            for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n                for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                    imageData[w + h * bytesPerRow] = levelData[w + h * rawBytesPerRow];\r\n                }\r\n            }\r\n        }\r\n\r\n        const layerBatch = Math.min(\r\n            Math.floor(device.limits.maxBufferSize / bytesPerImage),\r\n            ktx.faceCount,\r\n        );\r\n        const layerCount = Math.ceil(ktx.faceCount / layerBatch);\r\n\r\n        for (let l = 0; l < layerCount; l += 1) {\r\n            const offset = l * layerBatch;\r\n            const count = Math.min(layerBatch, ktx.faceCount - offset);\r\n\r\n            const data = layerCount > 1\r\n                ? imageData.subarray(offset * bytesPerImage, (offset + count) * bytesPerImage)\r\n                : imageData;\r\n\r\n            device.queue.writeTexture(\r\n                { mipLevel, texture, origin: [0, 0, offset] },\r\n                data,\r\n                { bytesPerRow, rowsPerImage },\r\n                [width, height, count],\r\n            );\r\n        }\r\n    }\r\n\r\n    return texture;\r\n}\r\n\r\nexport type TextureToArrayBufferOptions = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    mipLevel?: number,\r\n    resultBuffer?: Uint8Array,\r\n    storageBuffer?: GPUBuffer,\r\n    returnBuffer?: boolean,\r\n    description?: string,\r\n};\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer?: false },\r\n): Promise<{ imageData: Uint8Array }>;\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer: true },\r\n): Promise<{ imageData: Uint8Array, storageBuffer: GPUBuffer }>;\r\n\r\nexport async function textureToArrayBuffer({\r\n    device,\r\n    texture,\r\n    mipLevel = 0,\r\n    returnBuffer,\r\n    storageBuffer,\r\n    resultBuffer,\r\n    description,\r\n}: TextureToArrayBufferOptions) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const fullDescription = padTemplate`[textureToKTX${description ?? ''}${texture.label}] --`;\r\n\r\n    if (pixelSize == null) {\r\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\r\n    }\r\n\r\n    const width = texture.width >> mipLevel;\r\n    const height = texture.height >> mipLevel;\r\n    const rawBytesPerRow = width * pixelSize;\r\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n    const rowsPerImage = height;\r\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\r\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\r\n\r\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\r\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\r\n    }\r\n\r\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\r\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\r\n    }\r\n\r\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\r\n\r\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\r\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\r\n    }\r\n\r\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\r\n    const storage = storageBuffer ?? device.createBuffer({\r\n        label: `${fullDescription} storage buffer`,\r\n        size: byteSize,\r\n        usage: requiredUsage,\r\n    });\r\n\r\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\r\n    encoder.copyTextureToBuffer(\r\n        { texture, mipLevel },\r\n        { buffer: storage, rowsPerImage, bytesPerRow },\r\n        { width, height, depthOrArrayLayers: texture.depthOrArrayLayers },\r\n    );\r\n    device.queue.submit([encoder.finish()]);\r\n\r\n    await Promise.all([\r\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\r\n        device.queue.onSubmittedWorkDone(),\r\n    ]);\r\n\r\n    const mapped = storage.getMappedRange(0, byteSize);\r\n    imageData.set(new Uint8Array(mapped));\r\n    storage.unmap();\r\n\r\n    if (bytesPerRow > rawBytesPerRow) {\r\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\r\n            }\r\n        }\r\n        imageData = imageData.slice(0, resultSize);\r\n    }\r\n\r\n    return {\r\n        imageData,\r\n        storageBuffer: returnBuffer ? storage : undefined,\r\n    };\r\n}\r\n\r\nexport async function textureToKTX(device: GPUDevice, texture: GPUTexture, cube = false) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const typeSize = TextureFormatToChannelSize[texture.format];\r\n\r\n    if (pixelSize == null || typeSize == null) {\r\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\r\n    }\r\n\r\n    const container = new ktxparse.KTX2Container();\r\n    container.pixelWidth = texture.width;\r\n    container.pixelHeight = texture.height;\r\n    container.vkFormat = WebGPUToVkFormat[texture.format];\r\n    container.typeSize = typeSize;\r\n    delete container.keyValue.KTXswizzle;\r\n\r\n    const dataFormat = container.dataFormatDescriptor[0];\r\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\r\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\r\n    dataFormat.bytesPlane[0] = pixelSize;\r\n\r\n    dataFormat.samples = [0, 1, 2, 3].map((i) => ({\r\n        channelType: [192, 193, 194, 207][i],\r\n        samplePosition: [0, 0, 0, 0],\r\n        bitLength: container.typeSize * 8 - 1,\r\n        bitOffset: container.typeSize * 8 * i,\r\n        sampleLower: -1082130432,\r\n        sampleUpper: 1065353216,\r\n    }));\r\n\r\n    if (texture.dimension === '3d') {\r\n        container.faceCount = 1;\r\n        container.pixelDepth = texture.depthOrArrayLayers;\r\n    } else if (cube) {\r\n        const cubeLayers = texture.depthOrArrayLayers / 6;\r\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\r\n        container.faceCount = 6;\r\n    } else {\r\n        container.layerCount = texture.depthOrArrayLayers;\r\n        container.faceCount = 1;\r\n    }\r\n\r\n    let storageBuffer: GPUBuffer | undefined;\r\n    let imageData: Uint8Array;\r\n\r\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\r\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\r\n            mipLevel: i,\r\n            returnBuffer: true,\r\n            device,\r\n            texture,\r\n            storageBuffer,\r\n        }));\r\n\r\n        container.levels.push({\r\n            levelData: imageData,\r\n            uncompressedByteLength: imageData.byteLength,\r\n        });\r\n    }\r\n\r\n    return ktxparse.write(container);\r\n}\r\n","const { baseTable, shiftTable } = (() => {\n    const baseTable = new Uint32Array(256);\n    const shiftTable = new Uint32Array(256);\n\n    for (let i = 0; i < 255; ++i) {\n        const e = i - 127;\n        if (e < -27) { // very small number (0, -0)\n            baseTable[i] = 0x0000;\n            shiftTable[i] = 24;\n        } else if (e < -14) { // small number (denorm)\n            baseTable[i] = 0x0400 >> (-e - 14);\n            shiftTable[i] = -e - 1;\n        } else if (e <= 15) { // normal number\n            baseTable[i] = (e + 15) << 10;\n            shiftTable[i] = 13;\n        } else { // e < 128, large number (Infinity, -Infinity)\n            baseTable[i] = 0x7c00;\n            shiftTable[i] = 24;\n        }\n    }\n\n    // e == 128, stay (NaN, Infinity, -Infinity)\n    baseTable[255] = 0x7c00;\n    shiftTable[255] = 13;\n\n    return { baseTable, shiftTable };\n})();\n\nconst conversionBuffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(conversionBuffer);\nconst uintView = new Uint32Array(conversionBuffer);\n\nexport function toFloat16Bytes(val: number) {\n    floatView[0] = val;\n    const f = uintView[0];\n    const e = (f >> 23) & 0x1ff;\n    const idx = e & 0xff;\n    return baseTable[idx] + ((f & 0x007fffff) >> shiftTable[idx]) + ((e & 0x100) << 7);\n}\n","import { toFloat16Bytes } from './data-conversion';\nimport { srgbTextureToLinear, generateMips } from './texture-processing';\n\nexport type imageToTextureDescriptor = {\n    device: GPUDevice,\n    data: Uint8Array | Blob | File | ImageBitmap,\n    mimeType?: string,\n    label?: string,\n    usage?: number,\n    format?: GPUTextureFormat,\n    mips?: boolean,\n    srgbToLinear?: boolean,\n    colorSpace?: PredefinedColorSpace,\n};\n\nexport async function imageToTexture({\n    device,\n    data,\n    mimeType,\n    usage = GPUTextureUsage.TEXTURE_BINDING,\n    mips = true,\n    format = 'rgba8unorm',\n    colorSpace = 'srgb',\n    label = '',\n    srgbToLinear,\n}: imageToTextureDescriptor) {\n    let bitmap: ImageBitmap;\n\n    if (data instanceof ImageBitmap) {\n        bitmap = data;\n    } else {\n        const blob = (data instanceof Blob || data instanceof File)\n            ? data\n            : new Blob([data], { type: mimeType });\n        bitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n    }\n\n    const size = { width: bitmap.width, height: bitmap.height };\n\n    const texture = device.createTexture({\n        label,\n        format,\n        size: size,\n        usage: usage | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: mips ? 1 + (Math.log2(Math.max(bitmap.width, bitmap.height)) | 0) : 1,\n    });\n\n    device.queue.copyExternalImageToTexture(\n        { source: bitmap },\n        { texture, colorSpace },\n        size,\n    );\n\n    if (srgbToLinear) srgbTextureToLinear(device, texture);\n    if (mips) void generateMips(device, texture);\n\n    return texture;\n}\n\nexport function parseHDR(inData: Uint8Array | ArrayBuffer) {\n    const decoder = new TextDecoder();\n    const buffer = inData instanceof Uint8Array ? inData : new Uint8Array(inData);\n    let pos = 0;\n\n    const getLine = (lineLimit = 1024) => {\n        const limit = Math.min(buffer.length, lineLimit + pos);\n        const sub = buffer.subarray(pos, limit);\n        const end = sub.indexOf(0x0A) + 1;\n        pos += end;\n        return end === 0 ? undefined : decoder.decode(sub.subarray(0, end));\n    };\n\n    const importError = (msg: string) => new Error('HDR Import Error: ' + msg);\n\n    // #region Read Header\n    const magicTokenRegex = /^#\\?(\\S+)/;\n    const magicTokenLine = getLine();\n\n    if (magicTokenLine == null) throw importError('no header found');\n    if (!magicTokenRegex.test(magicTokenLine)) throw importError('bad initial token');\n\n    const headerRegs = [\n        /FORMAT=(?<format>\\S+)/, // format\n        /-Y\\s+(?<Y>\\d+)\\s+\\+X\\s+(?<X>\\d+)/, // size\n        /EXPOSURE\\s*=\\s*(?<exposure>\\d+(\\.\\d+)?)/, // exposure\n        /GAMMA\\s*=\\s*(?<gamma>\\d+(\\.\\d+)?)/, // gamma\n    ];\n\n    const headerReg = new RegExp(`^\\\\s*(${\n        headerRegs.map(({ source }) => `(${source})`).join('|')\n    })\\\\s*$`);\n\n    let noFormat = true;\n    let gamma = 1; /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n    let exposure = 1; /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n    let width: number | undefined = undefined;\n    let height: number | undefined = undefined;\n\n    for (let line = getLine(); line != null; line = width == null ? getLine() : undefined) {\n        const groups = line.match(headerReg)?.groups as Partial<Record<string, string>> | undefined;\n        if (groups == null) continue;\n\n        if (groups.format != null) {\n            noFormat = false;\n        } else if (groups.X != null && groups.Y != null) {\n            width = parseInt(groups.X);\n            height = parseInt(groups.Y);\n        } else if (groups.gamma != null) {\n            gamma = parseFloat(groups.gamma);\n        } else if (groups.exposure != null) {\n            exposure = parseFloat(groups.exposure);\n        }\n    }\n\n    if (noFormat) throw importError('missing format specifier');\n    if (width == null || height == null) throw importError('missing image size specifier');\n    // #endregion\n\n    // #region Read Scanline Data\n    let rawData: Uint8Array;\n    const unencodable = width < 8 || width > 0x7fff;\n    const flatData = buffer[pos] !== 2 || buffer[pos + 1] !== 2 || (buffer[pos + 2] & 0x80) !== 0;\n\n    if (unencodable || flatData) {\n        rawData = buffer.subarray(pos);\n    } else {\n        rawData = new Uint8Array(width * height * 4);\n        const end = 4 * width;\n        const scanline_buffer = new Uint8Array(end);\n        const len = buffer.byteLength;\n\n        for (let k = 0, offset = 0; k < height && pos < len; k++) {\n            if (pos + 4 > len)\n                throw importError('file ended durning scanline');\n\n            if ((2 != buffer[pos++]) || (2 != buffer[pos++]) || (((buffer[pos++] << 8) | buffer[pos++]) != width))\n                throw importError('bad rgbe scanline format');\n\n            let count;\n            for (let ptr = 0; ptr < end && pos < len; ptr += count) {\n                count = buffer[pos++];\n                const isEncodedRun = count > 128;\n                if (isEncodedRun) count -= 128;\n\n                if (count == 0 || ptr + count > end)\n                    throw importError('bad scanline data');\n\n                if (isEncodedRun) {\n                    scanline_buffer.fill(buffer[pos], ptr, ptr + count);\n                    pos += 1;\n                } else {\n                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                    pos += count;\n                }\n            }\n\n            for (let i = 0; i < width; i++)\n                for (let j = 0; j < end; j += width)\n                    rawData[offset++] = scanline_buffer[i + j];\n        }\n    }\n    // #endregion\n\n    // #region Convert to Float16\n    const data = new Uint16Array(rawData.length);\n    const float16One = toFloat16Bytes(1);\n\n    for (let i = 0; i < width * height * 4; i += 4) {\n        const raw_e = rawData[i + 3];\n        const scale = Math.pow(2.0, raw_e - 128.0) / 255.0;\n\n        for (let j = 0; j < 3; j += 1) {\n            data[i + j] = toFloat16Bytes(Math.min(rawData[i + j] * scale, 65504));\n        }\n        data[i + 3] = float16One;\n    }\n    // #endregion\n\n    return { data, width, height, gamma, exposure };\n}\n","import blit from '../shaders/blit-vert.shader';\nimport { toWorldDir } from '../shaders/cubemap-sampling.shader';\nimport { createAndCopyBuffer } from './data-copy';\nimport { padTemplate } from './general';\n\ntype EquirectangularDescriptor = {\n    data: SharedArrayBuffer | BufferSource | GPUTexture,\n    width: number,\n    height: number,\n    gamma?: number,\n    exposure?: number,\n};\n\nexport async function equirectangularToCubemap(\n    device: GPUDevice,\n    { data, width, height, gamma = 1, exposure = 1 }: EquirectangularDescriptor,\n    outputDescriptor: Omit<GPUTextureDescriptor, 'dimension' | 'size'>,\n) {\n    const code = /* wgsl */ `\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${blit}\n        ${toWorldDir}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;\n\n    let FLIP_Y = 0;\n    let equirectangular: GPUTexture;\n    if (data instanceof GPUTexture) {\n        equirectangular = data;\n    } else {\n        FLIP_Y = 1;\n        equirectangular = device.createTexture({\n            label: `${outputDescriptor.label} equirectangular`,\n            dimension: '2d',\n            format: 'rgba16float',\n            size: { width, height },\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        device.queue.writeTexture(\n            { texture: equirectangular, mipLevel: 0 },\n            data,\n            { bytesPerRow: width * 2 * 4 },\n            { width, height, depthOrArrayLayers: 1 },\n        );\n        await device.queue.onSubmittedWorkDone();\n    }\n\n    const faceSize = equirectangular.height >> 1;\n    const cubemapDescriptor = outputDescriptor as GPUTextureDescriptor;\n    cubemapDescriptor.mipLevelCount ??= Math.log2(faceSize) | 0;\n    cubemapDescriptor.size = { width: faceSize, height: faceSize, depthOrArrayLayers: 6 };\n    cubemapDescriptor.dimension = '2d';\n    cubemapDescriptor.usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    const cubemap = device.createTexture(cubemapDescriptor);\n\n    const label = padTemplate`hdr copy${outputDescriptor.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 2,\n                buffer: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const module = device.createShaderModule({ label, code });\n    const sampler = device.createSampler({ label, minFilter: 'linear', magFilter: 'linear' });\n    const params = new Uint32Array(1);\n    const paramBuffer = createAndCopyBuffer(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device, label);\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            { binding: 0, resource: equirectangular.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: paramBuffer } },\n        ],\n    });\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: { module },\n        fragment: {\n            module,\n            targets: [{ format: cubemap.format }],\n            constants: {\n                GAMMA: gamma,\n                EXPOSURE: exposure,\n                FLIP_Y,\n            },\n        },\n    });\n\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n\n        const view = cubemap.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n            mipLevelCount: 1,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [{\n                view,\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n\n    return cubemap;\n}\nexport async function generateMips(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${blit}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `;\n\n    const label = padTemplate`mip generation${texture.label}`;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d', sampleType: 'float' },\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const colorAttachment = {\n        view: undefined as GPUTextureView | undefined,\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: 0 });\n    await device.queue.onSubmittedWorkDone();\n\n    for (let i = 1; i < texture.mipLevelCount; i += 1) {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: colorAttachment.view,\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n\n        colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: i });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [colorAttachment as GPURenderPassColorAttachment],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n\n        device.queue.submit([encoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport function srgbTextureToLinear(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${blit}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `;\n\n    const label = padTemplate`srgb to linear${texture.label}`;\n\n    const size = { width: texture.width, height: texture.height };\n\n    const tempTexture = device.createTexture({\n        format: texture.format,\n        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        size,\n    });\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n\n    const module = device.createShaderModule({ label, code: code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: tempTexture.createView(),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n        ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n        { texture },\n        { texture: tempTexture },\n        size,\n    );\n\n    const pass = encoder.beginRenderPass({\n        label,\n        colorAttachments: [{\n            view: texture.createView({ mipLevelCount: 1, baseMipLevel: 0 }),\n            loadOp: 'clear',\n            storeOp: 'store',\n        }],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindgroup);\n    pass.draw(3);\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n}\n"],"names":["BlurState","CubemapBlurModel","constructor","renderer","state","IDLE","nearestSample","$type","$callback","val","this","skyboxPass","useNearestSample","value","description","mipLevel","min","max","step","filterDistance","reblur","bind","skybox","onClick","saveFile","settings","publicSettings","priority","addForwardPass","device","setSkybox","privateSettings","mipLevelCount","refresh","resolve","lastState","WAIT","BLUR","texture","steps","inPlace","delayWork","requestAnimationFrame","skyTexture","createView","dimension","proms","Promise","all","then","ktx2","Blob","type","types","accept","suggestedName","handle","createWritable","keepExistingData","blob","stream","pipeTo","e","console","warn","render","encoder","gbuffer","beginRenderPass","colorAttachments","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","view","depth","end","title","createMipBlurCode","groups","format","async","cubemapGuassianPyramid","outputTextureLabel","minWidth","maxOpsPerPass","label","name","width","Math","log2","limits","maxComputeWorkgroupSizeX","maxComputeInvocationsPerWorkgroup","shader","createShaderModule","code","bindgroupLayout","createBindGroupLayout","entries","binding","viewDimension","visibility","GPUShaderStage","COMPUTE","storageTexture","access","buffer","pipeline","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","entryPoint","constants","STEPS","ceil","gaussianPyramid","size","height","depthOrArrayLayers","createTexture","usage","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","COPY_SRC","COPY_DST","copyEncoder","createCommandEncoder","copyTextureToTexture","queue","submit","finish","onSubmittedWorkDone","mipViews","i","baseMipLevel","maxWorkgroups","maxComputeWorkgroupsPerDimension","maxLayers","maxDispatches","propertyArray","ArrayBuffer","offset","Uint32Array","Float32Array","set","w","acos","nextMipWidth","baseV","floor","baseVN","baseUN","baseMag2","sampUN","samp0VN","samp0Mag2","samp1VN","samp1Mag2","dot0","sqrt","dot1","minStepDistance","propertyBuffer","GPUBufferUsage","STORAGE","bindgroup","mipPasses","requiredMipDispatches","currentMipDispatches","batchDispatches","runPass","mipPixels","createBindGroup","resource","writeBuffer","passDispatches","passLabel","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","hdrPromises","fetch","headers","res","json","hdrs","Object","fromEntries","flatMap","download_url","endsWith","processSkybox","file","File","arrayBuffer","hdr","getSkyboxOptions","target","key","selection","keys","initialValues","process","toWorldDir","cubemapSampleConversions","createAndCopyBuffer","arr","alignment","pad","createBuffer","byteLength","mappedAtCreation","writeArray","Uint8Array","getMappedRange","readArray","byteOffset","unmap","textureToArrayBuffer","returnBuffer","storageBuffer","resultBuffer","pixelSize","fullDescription","Error","rawBytesPerRow","bytesPerRow","rowsPerImage","byteSize","resultSize","requiredUsage","MAP_READ","imageData","storage","copyTextureToBuffer","mapAsync","GPUMapMode","READ","mapped","h","slice","undefined","textureToKTX","cube","typeSize","container","pixelWidth","pixelHeight","vkFormat","keyValue","KTXswizzle","dataFormat","dataFormatDescriptor","colorModel","transferFunction","bytesPlane","samples","map","channelType","samplePosition","bitLength","bitOffset","sampleLower","sampleUpper","faceCount","pixelDepth","cubeLayers","layerCount","levels","push","levelData","uncompressedByteLength","baseTable","shiftTable","conversionBuffer","floatView","uintView","toFloat16Bytes","f","idx","parseHDR","inData","decoder","TextDecoder","pos","getLine","lineLimit","limit","length","sub","subarray","indexOf","decode","importError","msg","magicTokenLine","test","headerReg","RegExp","source","join","rawData","noFormat","gamma","exposure","line","match","X","Y","parseInt","parseFloat","unencodable","flatData","scanline_buffer","len","k","count","ptr","isEncodedRun","fill","j","data","Uint16Array","float16One","raw_e","scale","pow","equirectangularToCubemap","outputDescriptor","equirectangular","FLIP_Y","GPUTexture","writeTexture","faceSize","cubemapDescriptor","RENDER_ATTACHMENT","cubemap","FRAGMENT","sampler","createSampler","minFilter","magFilter","params","paramBuffer","UNIFORM","pipelineLayout","createRenderPipeline","vertex","fragment","targets","GAMMA","EXPOSURE","arrayLayerCount","baseArrayLayer","loadOp","storeOp","draw"],"sourceRoot":""}