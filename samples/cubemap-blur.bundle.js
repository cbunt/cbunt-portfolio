/*! For license information see: https://cbunt.ing/oss-licenses.json */
(()=>{"use strict";var e,r,n,t,i,a,s,o={2349:(e,r,n)=>{function t(e,r){const n=Object.entries(e).map((([e,n])=>[e,r(n)]));return Object.fromEntries(n)}function i(e,r,n){return Math.max(r,Math.min(n,e))}function a(e,...r){const n=[e[0]];return r.forEach(((r,t)=>{return n.push(null==(i=r)||""===i?"":` ${i}`,e[t+1]);var i})),n.join("")}function s(e,r){return function(e){return[...Array(e).keys()]}(e).map(r)}function o(e,r){let n;return function(...t){const i=self;null!=n&&clearTimeout(n),n=setTimeout((()=>{e.apply(i,t)}),r)}}function p(e,r,n,t=0,i=e.length-1){if(i-t<=1)n(r,e[t]??r)<0?e.splice(t,0,r):n(r,e[i]??r)>0?e.splice(i+1,0,r):e.splice(i,0,r);else{const a=Math.floor((i-t)/2)+t;n(r,e[a])<0?p(e,r,n,t,a):p(e,r,n,a,i)}}n.d(r,{LG:()=>t,OY:()=>a,_b:()=>s,nn:()=>p,qE:()=>i,sg:()=>o})},8174:(e,r,n)=>{var t=n(7577),i=n(5105),a=n(5855);const s=()=>Promise.all([n.e(253),n.e(777),n.e(962)]).then(n.bind(n,7962)).then((e=>e.default));function o(e){const r={a:"a",code:"code",em:"em",li:"li",p:"p",ul:"ul",...e.components};return(0,i.jsxs)(a.A,{modelName:"Cubemap Blur",loadModelConstructor:s,source:"/* eslint @stylistic/max-len: \"error\" */\r\n\r\nimport {\r\n    toWorldDir,\r\n    cubemapSampleConversions,\r\n} from '../../shaders/cubemap-sampling.shader';\r\n\r\nimport { createAndCopyBuffer } from '../../utils/data-copy';\r\nimport { mapRange } from '../../../utils/general';\r\n\r\nconst DEFAULT_MAX_OPS = 6 * ((17 * 256) ** 2);\r\n\r\nconst createMipBlurCode = (\r\n    groups: number,\r\n    format: GPUTextureFormat,\r\n) => /* wgsl */`\r\n    ${cubemapSampleConversions}\r\n    ${toWorldDir}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    struct Params {\r\n        offset: u32,\r\n        sigmas: array<f32>,\r\n    }\r\n\r\n    @group(0) @binding(0) \r\n    var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    @group(0) @binding(2) \r\n    var<storage> params: Params;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + params.offset;\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = toWorldDir(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&params.sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = params.sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = toWorldDir(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\r\n\r\n/**\r\n *  the minimum angular distance between any pixel on a cubemap\r\n *  of the given face width and any pixel lying on a perimeter\r\n *  the given number of steps away\r\n */\r\nfunction minStepDistance(steps: number, width: number) {\r\n    // the angular distance\r\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\r\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\r\n\r\n    // It's likely possible to programmatically determine whether the\r\n    // destination pixel should be v = 0 or v = 1, but checking both works fine\r\n\r\n    const nextMipWidth = width >> 1;\r\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\r\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\r\n    const baseUN = (1 / nextMipWidth) - 1;\r\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\r\n\r\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\r\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\r\n    const samp0VN = (1 / width) - 1;\r\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\r\n    const samp1VN = (3 / width) - 1;\r\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\r\n\r\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN)\r\n        / Math.sqrt(samp0Mag2 * baseMag2);\r\n\r\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN)\r\n        / Math.sqrt(samp1Mag2 * baseMag2);\r\n\r\n    return Math.min(1 - dot0, 1 - dot1);\r\n}\r\n\r\nexport type GaussianPyramidDescriptor = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    /**\r\n     * If the pyramid should overwrite the existing mips\r\n     * of the given texture\r\n     *\r\n     * @defaultValue `false`\r\n     */\r\n    inPlace?: boolean,\r\n    /**\r\n     * The maximum width of the smallest mip level.\r\n     *\r\n     * @defaultValue `8`\r\n     */\r\n    minWidth?: number,\r\n    /**\r\n     * The kernel extent distance, in pixels.\r\n     *\r\n     * @defaultValue `4`\r\n     */\r\n    steps?: number,\r\n    /**\r\n     * A function to delay the processing of additional pixels,\r\n     * e.g. `requestAnimationFrame`. Spaces work to allow additional\r\n     * rendering and interactivity during heavy blurring workloads.\r\n     *\r\n     * If undefined, all pixels are processed at once.\r\n     */\r\n    delayWork?: (fn: () => Promise<void> | void) => void,\r\n    /**\r\n     * The maximum number of pixels to process within a batch.\r\n     * Unused if `delayWork` is undefined.\r\n     *\r\n     * @defaultValue 6 * ((17 * 256) ** 2)\r\n     *\r\n     * @remarks\r\n     * Allowing cubemap 256 pixels in width with `steps = 8` to run\r\n     * in a single pass. This is a conservatively low default for\r\n     * compatibility with lower-end hardware.\r\n     */\r\n    maxOpsPerPass?: number,\r\n    /**\r\n     * A prefix string for error message thrown from the function\r\n     *\r\n     * @defaultValue `cubemapGuassianPyramid --`\r\n     */\r\n    label?: string,\r\n    /**\r\n     * The label to pass the output GPUTexture.\r\n     *\r\n     * @remarks\r\n     * Unused if `inPlace == true`\r\n     */\r\n    outputTextureLabel?: string,\r\n};\r\n\r\nexport default async function cubemapGuassianPyramid({\r\n    device,\r\n    texture,\r\n    outputTextureLabel,\r\n    inPlace = false,\r\n    minWidth = 8,\r\n    steps = 4,\r\n    maxOpsPerPass = DEFAULT_MAX_OPS,\r\n    label = cubemapGuassianPyramid.name,\r\n    delayWork,\r\n}: GaussianPyramidDescriptor) {\r\n    const { width, format } = texture;\r\n    const mipLevelCount = inPlace\r\n        ? texture.mipLevelCount\r\n        : (Math.log2(width) - Math.log2(minWidth) + 1);\r\n\r\n    if (mipLevelCount <= 1) return texture;\r\n\r\n    const groups = Math.min(\r\n        device.limits.maxComputeWorkgroupSizeX,\r\n        device.limits.maxComputeInvocationsPerWorkgroup,\r\n    );\r\n\r\n    const shader = device.createShaderModule({\r\n        label,\r\n        code: createMipBlurCode(groups, format),\r\n    });\r\n\r\n    const bindgroupLayout = device.createBindGroupLayout({\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                texture: { viewDimension: '2d-array' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 1,\r\n                storageTexture: {\r\n                    access: 'write-only',\r\n                    viewDimension: '2d-array',\r\n                    format,\r\n                },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 2,\r\n                buffer: { type: 'read-only-storage' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n        ],\r\n    });\r\n\r\n    const pipeline = device.createComputePipeline({\r\n        label,\r\n        layout: device.createPipelineLayout({\r\n            label,\r\n            bindGroupLayouts: [bindgroupLayout],\r\n        }),\r\n        compute: {\r\n            module: shader,\r\n            entryPoint: 'main',\r\n            constants: { STEPS: Math.ceil(steps) },\r\n        },\r\n    });\r\n\r\n    let gaussianPyramid = texture;\r\n    if (!inPlace) {\r\n        const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n        gaussianPyramid = device.createTexture({\r\n            label: outputTextureLabel,\r\n            usage: GPUTextureUsage.STORAGE_BINDING\r\n                | GPUTextureUsage.TEXTURE_BINDING\r\n                | GPUTextureUsage.COPY_SRC\r\n                | GPUTextureUsage.COPY_DST,\r\n            dimension: '2d',\r\n            format,\r\n            mipLevelCount,\r\n            size,\r\n        });\r\n\r\n        const copyEncoder = device.createCommandEncoder({\r\n            label: `${label} copy encoder`,\r\n        });\r\n\r\n        copyEncoder.copyTextureToTexture(\r\n            { texture, mipLevel: 0 },\r\n            { texture: gaussianPyramid, mipLevel: 0 },\r\n            size,\r\n        );\r\n\r\n        device.queue.submit([copyEncoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n\r\n    const mipViews = mapRange(mipLevelCount, (i) => gaussianPyramid.createView({\r\n        label: `${label} mip view ${i}`,\r\n        dimension: '2d-array',\r\n        baseMipLevel: i,\r\n        mipLevelCount: 1,\r\n    }));\r\n\r\n    const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\r\n    const maxLayers = Math.ceil(Math.log2(width));\r\n    const maxDispatches = Math.max(\r\n        (maxOpsPerPass / (((1 + (steps * 2)) ** 2) * groups)) | 0,\r\n        1,\r\n    );\r\n\r\n    const propertyArray = new ArrayBuffer((maxLayers + 1) * 4);\r\n    const offset = new Uint32Array(propertyArray, 0, 1);\r\n    const simgas = new Float32Array(propertyArray, 4, maxLayers);\r\n\r\n    simgas.set(mapRange(maxLayers, (i) => {\r\n        const w = width >> i;\r\n        return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\r\n    }));\r\n\r\n    const propertyBuffer = createAndCopyBuffer(\r\n        propertyArray,\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        device,\r\n    );\r\n\r\n    let mipLevel = 0;\r\n    let mipPasses = 0;\r\n    let requiredMipDispatches = 0;\r\n    let currentMipDispatches = 0;\r\n    let batchDispatches = 0;\r\n    let bindgroup: GPUBindGroup;\r\n\r\n    async function runPass() {\r\n        if (currentMipDispatches >= requiredMipDispatches) {\r\n            mipLevel += 1;\r\n            currentMipDispatches = 0;\r\n            mipPasses = 0;\r\n\r\n            if (mipLevel >= mipLevelCount) {\r\n                return;\r\n            }\r\n\r\n            const mipPixels = 6 * ((width >> mipLevel) ** 2);\r\n            requiredMipDispatches = Math.ceil(mipPixels / groups);\r\n\r\n            bindgroup = device.createBindGroup({\r\n                layout: bindgroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: mipViews[mipLevel - 1],\r\n                    },\r\n                    {\r\n                        binding: 1,\r\n                        resource: mipViews[mipLevel],\r\n                    },\r\n                    {\r\n                        binding: 2,\r\n                        resource: { buffer: propertyBuffer },\r\n                    },\r\n                ],\r\n            });\r\n        }\r\n\r\n        offset[0] = currentMipDispatches * groups;\r\n        device.queue.writeBuffer(propertyBuffer, 0, offset);\r\n\r\n        const passDispatches = Math.min(\r\n            requiredMipDispatches - currentMipDispatches,\r\n            maxDispatches - batchDispatches,\r\n            maxWorkgroups,\r\n        );\r\n\r\n        const passLabel = `${label} mip ${mipLevel}, pass ${mipPasses}`;\r\n        const encoder = device.createCommandEncoder({ label: passLabel });\r\n        const pass = encoder.beginComputePass({ label: passLabel });\r\n\r\n        pass.setPipeline(pipeline);\r\n        pass.setBindGroup(0, bindgroup);\r\n        pass.dispatchWorkgroups(passDispatches, 1, 1);\r\n        pass.end();\r\n\r\n        device.queue.submit([encoder.finish()]);\r\n\r\n        currentMipDispatches += passDispatches;\r\n        batchDispatches += passDispatches;\r\n        mipPasses += 1;\r\n\r\n        if (delayWork != null && batchDispatches >= maxDispatches) {\r\n            batchDispatches = 0;\r\n            await device.queue.onSubmittedWorkDone();\r\n            delayWork(runPass);\r\n        } else {\r\n            await runPass();\r\n        }\r\n    }\r\n\r\n    await runPass();\r\n\r\n    return gaussianPyramid;\r\n}\r\n",children:[(0,i.jsx)(r.p,{children:"Computes an approximate, perceptually-even Gaussian pyramid of a cubemap\ntexture. Given an image and a desired maximum distance in pixels, for each\nblurred mip level the process:"}),(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Calculates the minimum angular distance between any pixel and a perimeter of\nthe given pixel distance"}),"\n",(0,i.jsx)(r.li,{children:"Uses that minimum angle over 3 as the Guassian sigma for blurring"}),"\n",(0,i.jsx)(r.li,{children:"For each pixel, samples all pixels of the previous mip within the given pixel distance\nand weights their contributions by the Guassian of their angular distances from the origin pixel"}),"\n",(0,i.jsx)(r.li,{children:"Normalizes the result with the sum of the weights"}),"\n"]}),(0,i.jsxs)(r.p,{children:["For heavy loads that could impair smooth rendering or interactivity—such\nas large images, high filter distances, or both at once—\n",(0,i.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame",children:(0,i.jsx)(r.code,{children:"requestAnimationFrame"})}),"\nis used to break up work over multiple frames."]}),(0,i.jsxs)(r.p,{children:["This demo accepts .hdr cubemap textures to be uploaded and\nprocessed. Results are exported as an rgba32 .ktx2 file, including blurred mip levels.\n",(0,i.jsx)(r.em,{children:"NOTE:"})," exported .ktx2 files are currently malformed and unreadable to some\nprograms. This is likely due to a bug in the exporting library. Opening them with\n",(0,i.jsx)(r.a,{href:"'https://developer.nvidia.com/texture-tools-exporter'",children:"NVIDIA Texture Tools Exporter"})," and\nre-exporting fixes these issues."]})]})}(0,t.A)((function(e={}){const{wrapper:r}=e.components||{};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}))}},p={};function u(e){var r=p[e];if(void 0!==r)return r.exports;var n=p[e]={id:e,exports:{}};return o[e](n,n.exports,u),n.exports}u.m=o,e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",r="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",n="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",t=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},u.a=(i,a,s)=>{var o;s&&((o=[]).d=-1);var p,u,l,c=new Set,d=i.exports,m=new Promise(((e,r)=>{l=r,u=e}));m[r]=d,m[e]=e=>(o&&e(o),c.forEach(e),m.catch((e=>{}))),i.exports=m,a((i=>{var a;p=(i=>i.map((i=>{if(null!==i&&"object"==typeof i){if(i[e])return i;if(i.then){var a=[];a.d=0,i.then((e=>{s[r]=e,t(a)}),(e=>{s[n]=e,t(a)}));var s={};return s[e]=e=>e(a),s}}var o={};return o[e]=e=>{},o[r]=i,o})))(i);var s=()=>p.map((e=>{if(e[n])throw e[n];return e[r]})),u=new Promise((r=>{(a=()=>r(s)).r=0;var n=e=>e!==o&&!c.has(e)&&(c.add(e),e&&!e.d&&(a.r++,e.push(a)));p.map((r=>r[e](n)))}));return a.r?u:s()}),(e=>(e?l(m[n]=e):u(d),t(o)))),o&&o.d<0&&(o.d=0)},i=[],u.O=(e,r,n,t)=>{if(!r){var a=1/0;for(l=0;l<i.length;l++){for(var[r,n,t]=i[l],s=!0,o=0;o<r.length;o++)(!1&t||a>=t)&&Object.keys(u.O).every((e=>u.O[e](r[o])))?r.splice(o--,1):(s=!1,t<a&&(a=t));if(s){i.splice(l--,1);var p=n();void 0!==p&&(e=p)}}return e}t=t||0;for(var l=i.length;l>0&&i[l-1][2]>t;l--)i[l]=i[l-1];i[l]=[r,n,t]},u.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return u.d(r,{a:r}),r},u.d=(e,r)=>{for(var n in r)u.o(r,n)&&!u.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},u.f={},u.e=e=>Promise.all(Object.keys(u.f).reduce(((r,n)=>(u.f[n](e,r),r)),[])),u.u=e=>e+".bundle.js",u.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),a={},s="cbunt-portfolio:",u.l=(e,r,n,t)=>{if(a[e])a[e].push(r);else{var i,o;if(void 0!==n)for(var p=document.getElementsByTagName("script"),l=0;l<p.length;l++){var c=p[l];if(c.getAttribute("src")==e||c.getAttribute("data-webpack")==s+n){i=c;break}}i||(o=!0,(i=document.createElement("script")).charset="utf-8",i.timeout=120,u.nc&&i.setAttribute("nonce",u.nc),i.setAttribute("data-webpack",s+n),i.src=e),a[e]=[r];var d=(r,n)=>{i.onerror=i.onload=null,clearTimeout(m);var t=a[e];if(delete a[e],i.parentNode&&i.parentNode.removeChild(i),t&&t.forEach((e=>e(n))),r)return r(n)},m=setTimeout(d.bind(null,void 0,{type:"timeout",target:i}),12e4);i.onerror=d.bind(null,i.onerror),i.onload=d.bind(null,i.onload),o&&document.head.appendChild(i)}},u.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},u.j=344,u.p="/",(()=>{var e={344:0};u.f.j=(r,n)=>{var t=u.o(e,r)?e[r]:void 0;if(0!==t)if(t)n.push(t[2]);else{var i=new Promise(((n,i)=>t=e[r]=[n,i]));n.push(t[2]=i);var a=u.p+u.u(r),s=new Error;u.l(a,(n=>{if(u.o(e,r)&&(0!==(t=e[r])&&(e[r]=void 0),t)){var i=n&&("load"===n.type?"missing":n.type),a=n&&n.target&&n.target.src;s.message="Loading chunk "+r+" failed.\n("+i+": "+a+")",s.name="ChunkLoadError",s.type=i,s.request=a,t[1](s)}}),"chunk-"+r,r)}},u.O.j=r=>0===e[r];var r=(r,n)=>{var t,i,[a,s,o]=n,p=0;if(a.some((r=>0!==e[r]))){for(t in s)u.o(s,t)&&(u.m[t]=s[t]);if(o)var l=o(u)}for(r&&r(n);p<a.length;p++)i=a[p],u.o(e,i)&&e[i]&&e[i][0](),e[i]=0;return u.O(l)},n=self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[];n.forEach(r.bind(null,0)),n.push=r.bind(null,n.push.bind(n))})(),u.nc=void 0;var l=u.O(void 0,[788,637,282,577,855],(()=>u(8174)));l=u.O(l)})();
//# sourceMappingURL=cubemap-blur.bundle.js.map