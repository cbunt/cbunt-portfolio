/*! For license information see: https://cbunt.ing/oss-licenses.json */
(()=>{"use strict";var e,r,n,t,i,a,o,s={2456:(e,r,n)=>{n.a(e,(async(e,t)=>{try{n.d(r,{A:()=>c});var i=n(5105),a=n(1387),o=n(3492);null!=navigator.gpu?.requestAdapter&&await Promise.all([n.e(253),n.e(777),n.e(490),n.e(218)]).then(n.bind(n,7962)).then((e=>e.default));async function s(e){const r={a:"a",code:"code",em:"em",li:"li",p:"p",ul:"ul",...e.components};return(0,i.jsxs)(a.A,{modelName:"Cubemap Blur",ModelConstructor:null!=navigator.gpu?.requestAdapter?await Promise.all([n.e(253),n.e(777),n.e(490),n.e(218)]).then(n.bind(n,7962)).then((e=>e.default)):void 0,source:o,children:[(0,i.jsx)(r.p,{children:"Computes an approximate, perceptually-even Gaussian pyramid of a cubemap\ntexture. Given an image and a desired maximum distance in pixels, for each\nblurred mip level the process:"}),(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Calculates the minimum angular distance between any pixel and a perimeter of\nthe given pixel distance"}),"\n",(0,i.jsx)(r.li,{children:"Uses that minimum angle over 3 as the Guassian sigma for blurring"}),"\n",(0,i.jsx)(r.li,{children:"For each pixel, samples all pixels of the previous mip within the given pixel distance\nand weights their contributions by the Guassian of their angular distances from the origin pixel"}),"\n",(0,i.jsx)(r.li,{children:"Normalizes the result with the sum of the weights"}),"\n"]}),(0,i.jsxs)(r.p,{children:["For heavy loads that could impair smooth rendering or interactivityâ€”such\nas large images, high filter distances, or both at onceâ€”\n",(0,i.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame",children:(0,i.jsx)(r.code,{children:"requestAnimationFrame"})}),"\nis used to break up work over multiple frames."]}),(0,i.jsxs)(r.p,{children:["This demo accepts .hdr cubemap textures to be uploaded and\nprocessed. Results are exported as an rgba32 .ktx2 file, including blurred mip levels.\n",(0,i.jsx)(r.em,{children:"NOTE:"})," exported .ktx2 files are currently malformed and unreadable to some\nprograms. This is likely due to a bug in the exporting library. Opening them with\n",(0,i.jsx)(r.a,{href:"'https://developer.nvidia.com/texture-tools-exporter'",children:"NVIDIA Texture Tools Exporter"})," and\nre-exporting fixes these issues."]})]})}function c(e={}){const{wrapper:r}=e.components||{};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(s,{...e})}):s(e)}t()}catch(l){t(l)}}),1)},5954:(e,r,n)=>{n.d(r,{A:()=>s});var t=n(1973),i=n.n(t),a=n(6163),o=n.n(a)()(i());o.push([e.id,'html{--hover-scale: 1.075;--active-scale: 0.95;--scale-bezier: cubic-bezier(0.81, 0, 0.37, 3.69);--scale-transition-duration: 0.2s}@media(prefers-reduced-motion)or (hover: none){html{--hover-scale: 1 !important;--active-scale: 1 !important}}.XdTtGVf_v7P0udse5eJI{position:relative;border:5px solid rgba(0,0,0,0);padding:.5em;border-radius:6px}.XdTtGVf_v7P0udse5eJI:before{content:"";position:absolute;z-index:1;pointer-events:none;width:calc(100% + 5px);height:calc(100% + 5px);top:calc(-0.5*5px);left:calc(-0.5*5px);filter:var(--distortion-filter);border:solid;background-color:rgba(0,0,0,0);border-radius:inherit;border-width:5px;border-color:var(--secondary-color)}',"",{version:3,sources:["webpack://./src/components/mixins.module.scss","webpack://./src/components/sample-wrapper/sample-wrapper.module.scss"],names:[],mappings:"AAAA,KACI,oBAAA,CACA,oBAAA,CACA,iDAAA,CACA,iCAAA,CAEA,+CANJ,KAOQ,2BAAA,CACA,4BAAA,CAAA,CCNR,sBD4BI,iBAAA,CACA,8BAAA,CC1BA,YAAA,CACA,iBAAA,CD2BA,6BACI,UAAA,CACA,iBAAA,CACA,SAAA,CACA,mBAAA,CAEA,sBAAA,CACA,uBAAA,CACA,kBAAA,CACA,mBAAA,CACA,+BAAA,CAEA,YAAA,CACA,8BAAA,CACA,qBAAA,CACA,gBAAA,CACA,mCAAA",sourcesContent:["html {\n    --hover-scale: 1.075;\n    --active-scale: 0.95;\n    --scale-bezier: cubic-bezier(0.81, 0, 0.37, 3.69);\n    --scale-transition-duration: 0.2s; \n\n    @media (prefers-reduced-motion) OR (hover: none) { \n        --hover-scale: 1 !important;\n        --active-scale: 1 !important;\n    }\n}\n\n@mixin clickable {\n    --scale-transition: scale var(--scale-transition-duration) var(--scale-bezier);\n    transition: var(--scale-transition);\n\n    &:not(:disabled) {\n        cursor: pointer;\n    }\n    \n    &:hover:not(:disabled) {\n        scale: var(--hover-scale);\n    }\n    \n    &:active:not(:disabled) {\n        scale: var(--active-scale);\n    }\n}\n\n@mixin distortion-border($width, $color: currentColor) {\n    position: relative;\n    border: #{$width} solid transparent;\n\n    &:before {\n        content: '';\n        position: absolute;\n        z-index: 1;\n        pointer-events: none;\n    \n        width: calc(100% + #{$width});\n        height: calc(100% + #{$width});\n        top: calc(-0.5 * #{$width});\n        left: calc(-0.5 * #{$width});\n        filter: var(--distortion-filter);\n    \n        border: solid;\n        background-color: #0000;\n        border-radius: inherit;\n        border-width: #{$width};\n        border-color: #{$color};\n    }\n}\n\n@mixin distortion-background($color:var(--background-color)) {\n    position: relative;\n\n    &:before {\n        content: '';\n        position: absolute;\n        z-index: -1;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        filter: var(--distortion-filter);\n\n        border-radius: inherit;\n        background-color: #{$color};\n    }\n}\n",'@use "../mixins.module.scss" as mixins;\n\n.code-container {\n    @include mixins.distortion-border(5px, var(--secondary-color));\n\n    padding: 0.5em;\n    border-radius: 6px;\n}'],sourceRoot:""}]),o.locals={"code-container":"XdTtGVf_v7P0udse5eJI"};const s=o},53:(e,r,n)=>{n.d(r,{A:()=>s});var t=n(1973),i=n.n(t),a=n(6163),o=n.n(a)()(i());o.push([e.id,'html{--hover-scale: 1.075;--active-scale: 0.95;--scale-bezier: cubic-bezier(0.81, 0, 0.37, 3.69);--scale-transition-duration: 0.2s}@media(prefers-reduced-motion)or (hover: none){html{--hover-scale: 1 !important;--active-scale: 1 !important}}.dMhnFcvQoUr6kFJaiK7t{position:relative;border:10px solid rgba(0,0,0,0);border:none;aspect-ratio:1.66/1;width:100%;background-color:var(--secondary-color);display:flex;justify-content:center;align-content:center}.dMhnFcvQoUr6kFJaiK7t:before{content:"";position:absolute;z-index:1;pointer-events:none;width:calc(100% + 10px);height:calc(100% + 10px);top:calc(-0.5*10px);left:calc(-0.5*10px);filter:var(--distortion-filter);border:solid;background-color:rgba(0,0,0,0);border-radius:inherit;border-width:10px;border-color:var(--background-color)}.dMhnFcvQoUr6kFJaiK7t canvas{width:100%;cursor:grab}.dMhnFcvQoUr6kFJaiK7t>p{font-weight:500;line-height:1.5;margin:1rem;height:fit-content}',"",{version:3,sources:["webpack://./src/components/mixins.module.scss","webpack://./src/components/viewport/support-check/support-check.module.scss"],names:[],mappings:"AAAA,KACI,oBAAA,CACA,oBAAA,CACA,iDAAA,CACA,iCAAA,CAEA,+CANJ,KAOQ,2BAAA,CACA,4BAAA,CAAA,CCNR,sBD4BI,iBAAA,CACA,+BAAA,CC1BA,WAAA,CACA,mBAAA,CACA,UAAA,CACA,uCAAA,CAEA,YAAA,CACA,sBAAA,CACA,oBAAA,CDqBA,6BACI,UAAA,CACA,iBAAA,CACA,SAAA,CACA,mBAAA,CAEA,uBAAA,CACA,wBAAA,CACA,mBAAA,CACA,oBAAA,CACA,+BAAA,CAEA,YAAA,CACA,8BAAA,CACA,qBAAA,CACA,iBAAA,CACA,oCAAA,CCnCJ,6BACI,UAAA,CACA,WAAA,CAGJ,wBACI,eAAA,CACA,eAAA,CACA,WAAA,CACA,kBAAA",sourcesContent:["html {\n    --hover-scale: 1.075;\n    --active-scale: 0.95;\n    --scale-bezier: cubic-bezier(0.81, 0, 0.37, 3.69);\n    --scale-transition-duration: 0.2s; \n\n    @media (prefers-reduced-motion) OR (hover: none) { \n        --hover-scale: 1 !important;\n        --active-scale: 1 !important;\n    }\n}\n\n@mixin clickable {\n    --scale-transition: scale var(--scale-transition-duration) var(--scale-bezier);\n    transition: var(--scale-transition);\n\n    &:not(:disabled) {\n        cursor: pointer;\n    }\n    \n    &:hover:not(:disabled) {\n        scale: var(--hover-scale);\n    }\n    \n    &:active:not(:disabled) {\n        scale: var(--active-scale);\n    }\n}\n\n@mixin distortion-border($width, $color: currentColor) {\n    position: relative;\n    border: #{$width} solid transparent;\n\n    &:before {\n        content: '';\n        position: absolute;\n        z-index: 1;\n        pointer-events: none;\n    \n        width: calc(100% + #{$width});\n        height: calc(100% + #{$width});\n        top: calc(-0.5 * #{$width});\n        left: calc(-0.5 * #{$width});\n        filter: var(--distortion-filter);\n    \n        border: solid;\n        background-color: #0000;\n        border-radius: inherit;\n        border-width: #{$width};\n        border-color: #{$color};\n    }\n}\n\n@mixin distortion-background($color:var(--background-color)) {\n    position: relative;\n\n    &:before {\n        content: '';\n        position: absolute;\n        z-index: -1;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        filter: var(--distortion-filter);\n\n        border-radius: inherit;\n        background-color: #{$color};\n    }\n}\n",'@use "../../mixins.module.scss" as mixins;\n\n.viewport {\n    @include mixins.distortion-border(10px, var(--background-color));\n\n    border: none;\n    aspect-ratio: 1.66 / 1;\n    width: 100%;\n    background-color: var(--secondary-color);\n\n    display: flex;\n    justify-content: center;\n    align-content: center;\n\n    canvas {\n        width: 100%;\n        cursor: grab;\n    }\n\n    > p {\n        font-weight: 500;\n        line-height: 1.5;\n        margin: 1rem;\n        height: fit-content;\n    }\n}'],sourceRoot:""}]),o.locals={viewport:"dMhnFcvQoUr6kFJaiK7t"};const s=o},3142:(e,r,n)=>{n.d(r,{A:()=>v});var t=n(6741),i=n.n(t),a=n(386),o=n.n(a),s=n(2658),c=n.n(s),l=n(3533),d=n.n(l),p=n(9369),u=n.n(p),m=n(5750),A=n.n(m),h=n(5954),b={};b.styleTagTransform=A(),b.setAttributes=d(),b.insert=c().bind(null,"head"),b.domAPI=o(),b.insertStyleElement=u();i()(h.A,b);const v=h.A&&h.A.locals?h.A.locals:void 0},5793:(e,r,n)=>{n.d(r,{A:()=>v});var t=n(6741),i=n.n(t),a=n(386),o=n.n(a),s=n(2658),c=n.n(s),l=n(3533),d=n.n(l),p=n(9369),u=n.n(p),m=n(5750),A=n.n(m),h=n(53),b={};b.styleTagTransform=A(),b.setAttributes=d(),b.insert=c().bind(null,"head"),b.domAPI=o(),b.insertStyleElement=u();i()(h.A,b);const v=h.A&&h.A.locals?h.A.locals:void 0},2120:(e,r,n)=>{n.d(r,{aj:()=>t,gh:()=>i,yn:()=>a});const t={defaultFilter:{scale:5,baseFrequency:.02,numOctaves:1},hoverFilter:{alternate:{scale:4,baseFrequency:.01},animationJitter:200,animationInterval:650,steps:5,scale:8,baseFrequency:.02},activeFilter:{scale:5,baseFrequency:.01}},i={...t,defaultFilter:{...t.defaultFilter,disable:!0}},a={defaultFilter:{...t.defaultFilter,disable:!0},hoverFilter:{...t.hoverFilter,disable:!0},activeFilter:{...t.activeFilter,disable:!0}}},1387:(e,r,n)=>{n.d(r,{A:()=>u});var t=n(5105),i=n(751),a=n(5707),o=n(2061),s=n(895),c=n(7707),l=n(2968),d=n(3142);const p=(0,o.a)({theme:"dark",settings:{background:"var(--background-color)",foreground:"var(--hi-vis-color)",caret:"red",selection:"#8884",selectionMatch:"#8880",lineHighlight:"#0000",gutterBackground:"var(--background-color)",gutterForeground:"var(--accent-3)",fontFamily:"Space Mono",fontSize:"min(2vw, 1rem)"},styles:[{tag:s._A.propertyName,"font-style":"italic"},{tag:s._A.literal,color:"var(--accent-3)"},{tag:[s._A.className,s._A.typeName],color:"var(--accent-2)"},{tag:[s._A.string,s._A.special(s._A.brace)],color:"light-dark(#037b55, #c1fba0)"},{tag:s._A.comment,color:"color-mix(in oklab, var(--background-color) 40%, var(--hi-vis-gray))"},{tag:[s._A.keyword,s._A.operator],color:"var(--accent-2)","font-weight":"bold"},{tag:[s._A.brace,s._A.bracket,s._A.paren,s._A.angleBracket],color:"var(--accent-3)","font-weight":"bold"},{tag:[s._A.function(s._A.propertyName),s._A.function(s._A.variableName)],color:"var(--accent-1)","font-weight":"bold"}]});function u({ModelConstructor:e,modelName:r,source:n,children:o}){return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("h1",{children:r}),(0,t.jsx)(l.A,{ModelConstructor:e}),o,null==n?void 0:(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("h2",{children:"Source Code"}),(0,t.jsx)(c.A,{className:d.A["code-container"],defaultFilter:{disable:!0},as:i.Ay,theme:p,editable:!1,maxHeight:"80vh",value:n,extensions:[(0,a.Q2)({typescript:!0})]})]})]})}},2968:(e,r,n)=>{n.d(r,{A:()=>p});var t=n(5105),i=n(7707),a=n(8101),o=n(5793),s=n(1125);const c=null!=navigator.gpu?.requestAdapter,l="\nThis browser does not support webgpu.  \n\\\nFor an up to date list of supported browsers,  \nsee [caniuse.com/webgpu](https://caniuse.com/webgpu).\n",d=(0,a.lazy)((()=>Promise.all([n.e(282),n.e(253),n.e(341),n.e(840)]).then(n.bind(n,7840))));function p({ModelConstructor:e}){const r=(0,a.useRef)(null);return(0,t.jsx)(i.A,{className:o.A.viewport,forwardedRef:r,defaultFilter:{disable:!0,scale:5},children:e&&c?(0,t.jsx)(d,{viewportRef:r,ModelConstructor:e}):(0,t.jsx)(s.o,{children:l})})}},8864:(e,r,n)=>{n.a(e,(async(e,r)=>{try{var t=n(7577),i=n(2456),a=e([i]);i=(a.then?(await a)():a)[0],(0,t.A)(i.A),r()}catch(e){r(e)}}))},3492:e=>{e.exports="/* eslint @stylistic/max-len: \"error\" */\r\n\r\nimport {\r\n    toWorldDir,\r\n    cubemapSampleConversions,\r\n} from '../../shaders/cubemap-sampling.shader';\r\n\r\nimport { createAndCopyBuffer } from '../../utils/data-copy';\r\nimport { mapRange } from '../../../utils/general';\r\n\r\nconst DEFAULT_MAX_OPS = 6 * ((17 * 256) ** 2);\r\n\r\nconst createMipBlurCode = (\r\n    groups: number,\r\n    format: GPUTextureFormat,\r\n) => /* wgsl */`\r\n    ${cubemapSampleConversions}\r\n    ${toWorldDir}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    struct Params {\r\n        offset: u32,\r\n        sigmas: array<f32>,\r\n    }\r\n\r\n    @group(0) @binding(0) \r\n    var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    @group(0) @binding(2) \r\n    var<storage> params: Params;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + params.offset;\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = toWorldDir(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&params.sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = params.sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = toWorldDir(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\r\n\r\n/**\r\n *  the minimum angular distance between any pixel on a cubemap\r\n *  of the given face width and any pixel lying on a perimeter\r\n *  the given number of steps away\r\n */\r\nfunction minStepDistance(steps: number, width: number) {\r\n    // the angular distance\r\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\r\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\r\n\r\n    // It's likely possible to programmatically determine whether the\r\n    // destination pixel should be v = 0 or v = 1, but checking both works fine\r\n\r\n    const nextMipWidth = width >> 1;\r\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\r\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\r\n    const baseUN = (1 / nextMipWidth) - 1;\r\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\r\n\r\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\r\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\r\n    const samp0VN = (1 / width) - 1;\r\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\r\n    const samp1VN = (3 / width) - 1;\r\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\r\n\r\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN)\r\n        / Math.sqrt(samp0Mag2 * baseMag2);\r\n\r\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN)\r\n        / Math.sqrt(samp1Mag2 * baseMag2);\r\n\r\n    return Math.min(1 - dot0, 1 - dot1);\r\n}\r\n\r\nexport type GaussianPyramidDescriptor = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    /**\r\n     * If the pyramid should overwrite the existing mips\r\n     * of the given texture\r\n     *\r\n     * @defaultValue `false`\r\n     */\r\n    inPlace?: boolean,\r\n    /**\r\n     * The maximum width of the smallest mip level.\r\n     *\r\n     * @defaultValue `8`\r\n     */\r\n    minWidth?: number,\r\n    /**\r\n     * The kernel extent distance, in pixels.\r\n     *\r\n     * @defaultValue `4`\r\n     */\r\n    steps?: number,\r\n    /**\r\n     * A function to delay the processing of additional pixels,\r\n     * e.g. `requestAnimationFrame`. Spaces work to allow additional\r\n     * rendering and interactivity during heavy blurring workloads.\r\n     *\r\n     * If undefined, all pixels are processed at once.\r\n     */\r\n    delayWork?: (fn: () => Promise<void> | void) => void,\r\n    /**\r\n     * The maximum number of pixels to process within a batch.\r\n     * Unused if `delayWork` is undefined.\r\n     *\r\n     * @defaultValue 6 * ((17 * 256) ** 2)\r\n     *\r\n     * @remarks\r\n     * Allowing cubemap 256 pixels in width with `steps = 8` to run\r\n     * in a single pass. This is a conservatively low default for\r\n     * compatibility with lower-end hardware.\r\n     */\r\n    maxOpsPerPass?: number,\r\n    /**\r\n     * A prefix string for error message thrown from the function\r\n     *\r\n     * @defaultValue `cubemapGuassianPyramid --`\r\n     */\r\n    label?: string,\r\n    /**\r\n     * The label to pass the output GPUTexture.\r\n     *\r\n     * @remarks\r\n     * Unused if `inPlace == true`\r\n     */\r\n    outputTextureLabel?: string,\r\n};\r\n\r\nexport default async function cubemapGuassianPyramid({\r\n    device,\r\n    texture,\r\n    outputTextureLabel,\r\n    inPlace = false,\r\n    minWidth = 8,\r\n    steps = 4,\r\n    maxOpsPerPass = DEFAULT_MAX_OPS,\r\n    label = cubemapGuassianPyramid.name,\r\n    delayWork,\r\n}: GaussianPyramidDescriptor) {\r\n    const { width, format } = texture;\r\n    const mipLevelCount = inPlace\r\n        ? texture.mipLevelCount\r\n        : (Math.log2(width) - Math.log2(minWidth) + 1);\r\n\r\n    if (mipLevelCount <= 1) return texture;\r\n\r\n    const groups = Math.min(\r\n        device.limits.maxComputeWorkgroupSizeX,\r\n        device.limits.maxComputeInvocationsPerWorkgroup,\r\n    );\r\n\r\n    const shader = device.createShaderModule({\r\n        label,\r\n        code: createMipBlurCode(groups, format),\r\n    });\r\n\r\n    const bindgroupLayout = device.createBindGroupLayout({\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                texture: { viewDimension: '2d-array' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 1,\r\n                storageTexture: {\r\n                    access: 'write-only',\r\n                    viewDimension: '2d-array',\r\n                    format,\r\n                },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 2,\r\n                buffer: { type: 'read-only-storage' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n        ],\r\n    });\r\n\r\n    const pipeline = device.createComputePipeline({\r\n        label,\r\n        layout: device.createPipelineLayout({\r\n            label,\r\n            bindGroupLayouts: [bindgroupLayout],\r\n        }),\r\n        compute: {\r\n            module: shader,\r\n            entryPoint: 'main',\r\n            constants: { STEPS: Math.ceil(steps) },\r\n        },\r\n    });\r\n\r\n    let gaussianPyramid = texture;\r\n    if (!inPlace) {\r\n        const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n        gaussianPyramid = device.createTexture({\r\n            label: outputTextureLabel,\r\n            usage: GPUTextureUsage.STORAGE_BINDING\r\n                | GPUTextureUsage.TEXTURE_BINDING\r\n                | GPUTextureUsage.COPY_SRC\r\n                | GPUTextureUsage.COPY_DST,\r\n            dimension: '2d',\r\n            format,\r\n            mipLevelCount,\r\n            size,\r\n        });\r\n\r\n        const copyEncoder = device.createCommandEncoder({\r\n            label: `${label} copy encoder`,\r\n        });\r\n\r\n        copyEncoder.copyTextureToTexture(\r\n            { texture, mipLevel: 0 },\r\n            { texture: gaussianPyramid, mipLevel: 0 },\r\n            size,\r\n        );\r\n\r\n        device.queue.submit([copyEncoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n\r\n    const mipViews = mapRange(mipLevelCount, (i) => gaussianPyramid.createView({\r\n        label: `${label} mip view ${i}`,\r\n        dimension: '2d-array',\r\n        baseMipLevel: i,\r\n        mipLevelCount: 1,\r\n    }));\r\n\r\n    const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\r\n    const maxLayers = Math.ceil(Math.log2(width));\r\n    const maxDispatches = Math.max(\r\n        (maxOpsPerPass / (((1 + (steps * 2)) ** 2) * groups)) | 0,\r\n        1,\r\n    );\r\n\r\n    const propertyArray = new ArrayBuffer((maxLayers + 1) * 4);\r\n    const offset = new Uint32Array(propertyArray, 0, 1);\r\n    const simgas = new Float32Array(propertyArray, 4, maxLayers);\r\n\r\n    simgas.set(mapRange(maxLayers, (i) => {\r\n        const w = width >> i;\r\n        return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\r\n    }));\r\n\r\n    const propertyBuffer = createAndCopyBuffer(\r\n        propertyArray,\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        device,\r\n    );\r\n\r\n    let mipLevel = 0;\r\n    let mipPasses = 0;\r\n    let requiredMipDispatches = 0;\r\n    let currentMipDispatches = 0;\r\n    let batchDispatches = 0;\r\n    let bindgroup: GPUBindGroup;\r\n\r\n    async function runPass() {\r\n        if (currentMipDispatches >= requiredMipDispatches) {\r\n            mipLevel += 1;\r\n            currentMipDispatches = 0;\r\n            mipPasses = 0;\r\n\r\n            if (mipLevel >= mipLevelCount) {\r\n                return;\r\n            }\r\n\r\n            const mipPixels = 6 * ((width >> mipLevel) ** 2);\r\n            requiredMipDispatches = Math.ceil(mipPixels / groups);\r\n\r\n            bindgroup = device.createBindGroup({\r\n                layout: bindgroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: mipViews[mipLevel - 1],\r\n                    },\r\n                    {\r\n                        binding: 1,\r\n                        resource: mipViews[mipLevel],\r\n                    },\r\n                    {\r\n                        binding: 2,\r\n                        resource: { buffer: propertyBuffer },\r\n                    },\r\n                ],\r\n            });\r\n        }\r\n\r\n        offset[0] = currentMipDispatches * groups;\r\n        device.queue.writeBuffer(propertyBuffer, 0, offset);\r\n\r\n        const passDispatches = Math.min(\r\n            requiredMipDispatches - currentMipDispatches,\r\n            maxDispatches - batchDispatches,\r\n            maxWorkgroups,\r\n        );\r\n\r\n        const passLabel = `${label} mip ${mipLevel}, pass ${mipPasses}`;\r\n        const encoder = device.createCommandEncoder({ label: passLabel });\r\n        const pass = encoder.beginComputePass({ label: passLabel });\r\n\r\n        pass.setPipeline(pipeline);\r\n        pass.setBindGroup(0, bindgroup);\r\n        pass.dispatchWorkgroups(passDispatches, 1, 1);\r\n        pass.end();\r\n\r\n        device.queue.submit([encoder.finish()]);\r\n\r\n        currentMipDispatches += passDispatches;\r\n        batchDispatches += passDispatches;\r\n        mipPasses += 1;\r\n\r\n        if (delayWork != null && batchDispatches >= maxDispatches) {\r\n            batchDispatches = 0;\r\n            await device.queue.onSubmittedWorkDone();\r\n            delayWork(runPass);\r\n        } else {\r\n            await runPass();\r\n        }\r\n    }\r\n\r\n    await runPass();\r\n\r\n    return gaussianPyramid;\r\n}\r\n"}},c={};function l(e){var r=c[e];if(void 0!==r)return r.exports;var n=c[e]={id:e,exports:{}};return s[e].call(n.exports,n,n.exports,l),n.exports}l.m=s,e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",r="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",n="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",t=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},l.a=(i,a,o)=>{var s;o&&((s=[]).d=-1);var c,l,d,p=new Set,u=i.exports,m=new Promise(((e,r)=>{d=r,l=e}));m[r]=u,m[e]=e=>(s&&e(s),p.forEach(e),m.catch((e=>{}))),i.exports=m,a((i=>{var a;c=(i=>i.map((i=>{if(null!==i&&"object"==typeof i){if(i[e])return i;if(i.then){var a=[];a.d=0,i.then((e=>{o[r]=e,t(a)}),(e=>{o[n]=e,t(a)}));var o={};return o[e]=e=>e(a),o}}var s={};return s[e]=e=>{},s[r]=i,s})))(i);var o=()=>c.map((e=>{if(e[n])throw e[n];return e[r]})),l=new Promise((r=>{(a=()=>r(o)).r=0;var n=e=>e!==s&&!p.has(e)&&(p.add(e),e&&!e.d&&(a.r++,e.push(a)));c.map((r=>r[e](n)))}));return a.r?l:o()}),(e=>(e?d(m[n]=e):l(u),t(s)))),s&&s.d<0&&(s.d=0)},i=[],l.O=(e,r,n,t)=>{if(!r){var a=1/0;for(d=0;d<i.length;d++){for(var[r,n,t]=i[d],o=!0,s=0;s<r.length;s++)(!1&t||a>=t)&&Object.keys(l.O).every((e=>l.O[e](r[s])))?r.splice(s--,1):(o=!1,t<a&&(a=t));if(o){i.splice(d--,1);var c=n();void 0!==c&&(e=c)}}return e}t=t||0;for(var d=i.length;d>0&&i[d-1][2]>t;d--)i[d]=i[d-1];i[d]=[r,n,t]},l.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return l.d(r,{a:r}),r},l.d=(e,r)=>{for(var n in r)l.o(r,n)&&!l.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},l.f={},l.e=e=>Promise.all(Object.keys(l.f).reduce(((r,n)=>(l.f[n](e,r),r)),[])),l.u=e=>e+".bundle.js",l.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),a={},o="cbunt-portfolio:",l.l=(e,r,n,t)=>{if(a[e])a[e].push(r);else{var i,s;if(void 0!==n)for(var c=document.getElementsByTagName("script"),d=0;d<c.length;d++){var p=c[d];if(p.getAttribute("src")==e||p.getAttribute("data-webpack")==o+n){i=p;break}}i||(s=!0,(i=document.createElement("script")).charset="utf-8",i.timeout=120,l.nc&&i.setAttribute("nonce",l.nc),i.setAttribute("data-webpack",o+n),i.src=e),a[e]=[r];var u=(r,n)=>{i.onerror=i.onload=null,clearTimeout(m);var t=a[e];if(delete a[e],i.parentNode&&i.parentNode.removeChild(i),t&&t.forEach((e=>e(n))),r)return r(n)},m=setTimeout(u.bind(null,void 0,{type:"timeout",target:i}),12e4);i.onerror=u.bind(null,i.onerror),i.onload=u.bind(null,i.onload),s&&document.head.appendChild(i)}},l.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},l.j=344,l.p="/",(()=>{var e={344:0};l.f.j=(r,n)=>{var t=l.o(e,r)?e[r]:void 0;if(0!==t)if(t)n.push(t[2]);else{var i=new Promise(((n,i)=>t=e[r]=[n,i]));n.push(t[2]=i);var a=l.p+l.u(r),o=new Error;l.l(a,(n=>{if(l.o(e,r)&&(0!==(t=e[r])&&(e[r]=void 0),t)){var i=n&&("load"===n.type?"missing":n.type),a=n&&n.target&&n.target.src;o.message="Loading chunk "+r+" failed.\n("+i+": "+a+")",o.name="ChunkLoadError",o.type=i,o.request=a,t[1](o)}}),"chunk-"+r,r)}},l.O.j=r=>0===e[r];var r=(r,n)=>{var t,i,[a,o,s]=n,c=0;if(a.some((r=>0!==e[r]))){for(t in o)l.o(o,t)&&(l.m[t]=o[t]);if(s)var d=s(l)}for(r&&r(n);c<a.length;c++)i=a[c],l.o(e,i)&&e[i]&&e[i][0](),e[i]=0;return l.O(d)},n=self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[];n.forEach(r.bind(null,0)),n.push=r.bind(null,n.push.bind(n))})(),l.nc=void 0;var d=l.O(void 0,[788,83,537,577],(()=>l(8864)));d=l.O(d)})();
//# sourceMappingURL=cubemap-blur.bundle.js.map