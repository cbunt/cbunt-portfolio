{"version":3,"file":"908.bundle.js","mappings":"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","sources":["webpack://cbunt-portfolio/./src/rendering/samples/settings/skybox-options.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-conversion.ts","webpack://cbunt-portfolio/./src/rendering/shaders/cubemap-sampling.shader.ts","webpack://cbunt-portfolio/./src/rendering/samples/cubemap-blur/cubemap-guassian-pyramid.ts","webpack://cbunt-portfolio/./src/rendering/samples/settings/property-listener.ts","webpack://cbunt-portfolio/./src/rendering/shaders/blit-vert.shader.ts"],"sourcesContent":["import { parseHDR } from '../../utils/texture-importing';\nimport { equirectangularToCubemap } from '../../utils/texture-processing';\nimport { ListenerSyms } from './property-listener';\n\nconst hdrPromises = await fetch(HDR_BASE_URL__, { headers: { 'Content-Type': 'application/vnd.github.object+json' } })\n    .then((res) => res.json()) as Record<string, unknown>[];\n\nexport const hdrs = Object.fromEntries(hdrPromises.flatMap(({ name, download_url }) => typeof name === 'string' && typeof download_url === 'string' && download_url.endsWith('.hdr') ? [[name, download_url]] : []));\n\nasync function processSkybox(device: GPUDevice, file: string | URL | File | ArrayBuffer) {\n    let buffer: ArrayBuffer;\n    if (file instanceof ArrayBuffer) {\n        buffer = file;\n    } else if (file instanceof File) {\n        buffer = await file.arrayBuffer();\n    } else {\n        const res = await fetch(file);\n        buffer = await res.arrayBuffer();\n    }\n\n    const hdr = parseHDR(buffer);\n\n    return equirectangularToCubemap(\n        device,\n        hdr,\n        {\n            format: 'rgba16float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        },\n    );\n}\n\nexport type SkyboxTarget = { device: GPUDevice, setSkybox: (resource: GPUTexture) => unknown };\n\nexport default function getSkyboxOptions(target: SkyboxTarget) {\n    return {\n        [ListenerSyms.$type]: 'file' as const,\n        [ListenerSyms.$callback]: async (val: unknown, key: PropertyKey) => {\n            if (key !== 'value' || val == null) return;\n            if (typeof val === 'string' || val instanceof File) {\n                const texture = await processSkybox(target.device, val);\n                const res = target.setSkybox(texture);\n                if (res instanceof Promise) await res;\n            }\n        },\n        accept: '.hdr',\n        value: Object.keys(hdrs)[0],\n        initialValues: hdrs,\n        process: (file: File) => file,\n    };\n}\n","const { baseTable, shiftTable } = (() => {\n    const baseTable = new Uint32Array(256);\n    const shiftTable = new Uint32Array(256);\n\n    for (let i = 0; i < 255; ++i) {\n        const e = i - 127;\n        if (e < -27) { // very small number (0, -0)\n            baseTable[i] = 0x0000;\n            shiftTable[i] = 24;\n        } else if (e < -14) { // small number (denorm)\n            baseTable[i] = 0x0400 >> (-e - 14);\n            shiftTable[i] = -e - 1;\n        } else if (e <= 15) { // normal number\n            baseTable[i] = (e + 15) << 10;\n            shiftTable[i] = 13;\n        } else { // e < 128, large number (Infinity, -Infinity)\n            baseTable[i] = 0x7c00;\n            shiftTable[i] = 24;\n        }\n    }\n\n    // e == 128, stay (NaN, Infinity, -Infinity)\n    baseTable[255] = 0x7c00;\n    shiftTable[255] = 13;\n\n    return { baseTable, shiftTable };\n})();\n\nconst conversionBuffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(conversionBuffer);\nconst uintView = new Uint32Array(conversionBuffer);\n\nexport function toFloat16Bytes(val: number) {\n    floatView[0] = val;\n    const bits = uintView[0];\n    const mantissa = (bits >> 23) & 0x1ff;\n    const idx = mantissa & 0xff;\n\n    const shifted = (bits & 0x007fffff) >> shiftTable[idx];\n    const sign = (mantissa & 0x100) << 7;\n\n    return sign + baseTable[idx] + shifted;\n}\n","export const toWorldDir: string = /* wgsl */`\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nexport const cubemapSampleConversions: string = /* wgsl */`\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n","/* eslint @stylistic/max-len: \"error\" */\r\n\r\nimport {\r\n    toWorldDir,\r\n    cubemapSampleConversions,\r\n} from '../../shaders/cubemap-sampling.shader';\r\n\r\nimport { createAndCopyBuffer } from '../../utils/data-copy';\r\nimport { mapRange } from '../../../utils/general';\r\n\r\nconst DEFAULT_MAX_OPS = 6 * ((17 * 256) ** 2);\r\n\r\nconst createMipBlurCode = (\r\n    groups: number,\r\n    format: GPUTextureFormat,\r\n) => /* wgsl */`\r\n    ${cubemapSampleConversions}\r\n    ${toWorldDir}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    struct Params {\r\n        offset: u32,\r\n        sigmas: array<f32>,\r\n    }\r\n\r\n    @group(0) @binding(0) \r\n    var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    @group(0) @binding(2) \r\n    var<storage> params: Params;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + params.offset;\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = toWorldDir(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&params.sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = params.sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = toWorldDir(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\r\n\r\n/**\r\n *  the minimum angular distance between any pixel on a cubemap\r\n *  of the given face width and any pixel lying on a perimeter\r\n *  the given number of steps away\r\n */\r\nfunction minStepDistance(steps: number, width: number) {\r\n    // the angular distance\r\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\r\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\r\n\r\n    // It's likely possible to programmatically determine whether the\r\n    // destination pixel should be v = 0 or v = 1, but checking both works fine\r\n\r\n    const nextMipWidth = width >> 1;\r\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\r\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\r\n    const baseUN = (1 / nextMipWidth) - 1;\r\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\r\n\r\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\r\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\r\n\r\n    const samp0VN = (1 / width) - 1;\r\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\r\n    const samp1VN = (3 / width) - 1;\r\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\r\n\r\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN);\r\n    const mag0 = dot0 / Math.sqrt(samp0Mag2 * baseMag2);\r\n\r\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN);\r\n    const mag1 = dot1 / Math.sqrt(samp1Mag2 * baseMag2);\r\n\r\n    return Math.min(1 - mag0, 1 - mag1);\r\n}\r\n\r\nexport type GaussianPyramidDescriptor = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    /**\r\n     * If the pyramid should overwrite the existing mips\r\n     * of the given texture\r\n     *\r\n     * @defaultValue `false`\r\n     */\r\n    inPlace?: boolean,\r\n    /**\r\n     * The maximum width of the smallest mip level.\r\n     *\r\n     * @defaultValue `8`\r\n     */\r\n    minWidth?: number,\r\n    /**\r\n     * The kernel extent distance, in pixels.\r\n     *\r\n     * @defaultValue `4`\r\n     */\r\n    steps?: number,\r\n    /**\r\n     * A function to delay the processing of additional pixels,\r\n     * e.g. `requestAnimationFrame`. Spaces work to allow additional\r\n     * rendering and interactivity during heavy blurring workloads.\r\n     *\r\n     * If undefined, all pixels are processed at once.\r\n     */\r\n    delayWork?: (fn: () => Promise<void> | void) => void,\r\n    /**\r\n     * The maximum number of pixels to process within a batch.\r\n     * Unused if `delayWork` is undefined.\r\n     *\r\n     * @defaultValue 6 * ((17 * 256) ** 2)\r\n     *\r\n     * @remarks\r\n     * Allowing cubemap 256 pixels in width with `steps = 8` to run\r\n     * in a single pass. This is a conservatively low default for\r\n     * compatibility with lower-end hardware.\r\n     */\r\n    maxOpsPerPass?: number,\r\n    /**\r\n     * A prefix string for error message thrown from the function\r\n     *\r\n     * @defaultValue `cubemapGuassianPyramid --`\r\n     */\r\n    label?: string,\r\n    /**\r\n     * The label to pass the output GPUTexture.\r\n     *\r\n     * @remarks\r\n     * Unused if `inPlace == true`\r\n     */\r\n    outputTextureLabel?: string,\r\n};\r\n\r\nexport default async function cubemapGuassianPyramid({\r\n    device,\r\n    texture,\r\n    outputTextureLabel,\r\n    inPlace = false,\r\n    minWidth = 8,\r\n    steps = 4,\r\n    maxOpsPerPass = DEFAULT_MAX_OPS,\r\n    label = cubemapGuassianPyramid.name,\r\n    delayWork,\r\n}: GaussianPyramidDescriptor) {\r\n    const { width, format } = texture;\r\n    const mipLevelCount = inPlace\r\n        ? texture.mipLevelCount\r\n        : (Math.log2(width) - Math.log2(minWidth) + 1);\r\n\r\n    if (mipLevelCount <= 1) return texture;\r\n\r\n    const groups = Math.min(\r\n        device.limits.maxComputeWorkgroupSizeX,\r\n        device.limits.maxComputeInvocationsPerWorkgroup,\r\n    );\r\n\r\n    const shader = device.createShaderModule({\r\n        label,\r\n        code: createMipBlurCode(groups, format),\r\n    });\r\n\r\n    const bindgroupLayout = device.createBindGroupLayout({\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                texture: { viewDimension: '2d-array' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 1,\r\n                storageTexture: {\r\n                    access: 'write-only',\r\n                    viewDimension: '2d-array',\r\n                    format,\r\n                },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 2,\r\n                buffer: { type: 'read-only-storage' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n        ],\r\n    });\r\n\r\n    const pipeline = device.createComputePipeline({\r\n        label,\r\n        layout: device.createPipelineLayout({\r\n            label,\r\n            bindGroupLayouts: [bindgroupLayout],\r\n        }),\r\n        compute: {\r\n            module: shader,\r\n            entryPoint: 'main',\r\n            constants: { STEPS: Math.ceil(steps) },\r\n        },\r\n    });\r\n\r\n    let gaussianPyramid = texture;\r\n    if (!inPlace) {\r\n        const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n        gaussianPyramid = device.createTexture({\r\n            label: outputTextureLabel,\r\n            usage: GPUTextureUsage.STORAGE_BINDING\r\n                | GPUTextureUsage.TEXTURE_BINDING\r\n                | GPUTextureUsage.COPY_SRC\r\n                | GPUTextureUsage.COPY_DST,\r\n            dimension: '2d',\r\n            format,\r\n            mipLevelCount,\r\n            size,\r\n        });\r\n\r\n        const copyEncoder = device.createCommandEncoder({\r\n            label: `${label} copy encoder`,\r\n        });\r\n\r\n        copyEncoder.copyTextureToTexture(\r\n            { texture, mipLevel: 0 },\r\n            { texture: gaussianPyramid, mipLevel: 0 },\r\n            size,\r\n        );\r\n\r\n        device.queue.submit([copyEncoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n\r\n    const mipViews = mapRange(mipLevelCount, (i) => gaussianPyramid.createView({\r\n        label: `${label} mip view ${i}`,\r\n        dimension: '2d-array',\r\n        baseMipLevel: i,\r\n        mipLevelCount: 1,\r\n    }));\r\n\r\n    const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\r\n    const maxLayers = Math.ceil(Math.log2(width));\r\n    const maxDispatches = Math.max(\r\n        (maxOpsPerPass / (((1 + (steps * 2)) ** 2) * groups)) | 0,\r\n        1,\r\n    );\r\n\r\n    const propertyArray = new ArrayBuffer((maxLayers + 1) * 4);\r\n    const offset = new Uint32Array(propertyArray, 0, 1);\r\n    const simgas = new Float32Array(propertyArray, 4, maxLayers);\r\n\r\n    simgas.set(mapRange(maxLayers, (i) => {\r\n        const w = width >> i;\r\n        return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\r\n    }));\r\n\r\n    const propertyBuffer = createAndCopyBuffer(\r\n        propertyArray,\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        device,\r\n    );\r\n\r\n    let mipLevel = 0;\r\n    let mipPasses = 0;\r\n    let requiredMipDispatches = 0;\r\n    let currentMipDispatches = 0;\r\n    let batchDispatches = 0;\r\n    let bindgroup: GPUBindGroup;\r\n\r\n    async function runPass() {\r\n        if (currentMipDispatches >= requiredMipDispatches) {\r\n            mipLevel += 1;\r\n            currentMipDispatches = 0;\r\n            mipPasses = 0;\r\n\r\n            if (mipLevel >= mipLevelCount) {\r\n                return;\r\n            }\r\n\r\n            const mipPixels = 6 * ((width >> mipLevel) ** 2);\r\n            requiredMipDispatches = Math.ceil(mipPixels / groups);\r\n\r\n            bindgroup = device.createBindGroup({\r\n                layout: bindgroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: mipViews[mipLevel - 1],\r\n                    },\r\n                    {\r\n                        binding: 1,\r\n                        resource: mipViews[mipLevel],\r\n                    },\r\n                    {\r\n                        binding: 2,\r\n                        resource: { buffer: propertyBuffer },\r\n                    },\r\n                ],\r\n            });\r\n        }\r\n\r\n        offset[0] = currentMipDispatches * groups;\r\n        device.queue.writeBuffer(propertyBuffer, 0, offset);\r\n\r\n        const passDispatches = Math.min(\r\n            requiredMipDispatches - currentMipDispatches,\r\n            maxDispatches - batchDispatches,\r\n            maxWorkgroups,\r\n        );\r\n\r\n        const passLabel = `${label} mip ${mipLevel}, pass ${mipPasses}`;\r\n        const encoder = device.createCommandEncoder({ label: passLabel });\r\n        const pass = encoder.beginComputePass({ label: passLabel });\r\n\r\n        pass.setPipeline(pipeline);\r\n        pass.setBindGroup(0, bindgroup);\r\n        pass.dispatchWorkgroups(passDispatches, 1, 1);\r\n        pass.end();\r\n\r\n        device.queue.submit([encoder.finish()]);\r\n\r\n        currentMipDispatches += passDispatches;\r\n        batchDispatches += passDispatches;\r\n        mipPasses += 1;\r\n\r\n        if (delayWork != null && batchDispatches >= maxDispatches) {\r\n            batchDispatches = 0;\r\n            await device.queue.onSubmittedWorkDone();\r\n            delayWork(runPass);\r\n        } else {\r\n            await runPass();\r\n        }\r\n    }\r\n\r\n    await runPass();\r\n\r\n    return gaussianPyramid;\r\n}\r\n","import { UnknownObject, mapValues } from '../../../utils/general';\n\n// Unique symbols to avoid naming collisions with underlying types\nconst $type = Symbol('PropertyListener -- Type');\nconst $callback = Symbol('PropertyListener -- Callback');\nconst $listeners = Symbol('PropertyListener -- Listeners');\nexport const ListenerSyms = Object.freeze({ $type, $callback, $listeners });\n\ntype Syms = typeof $type | typeof $callback | typeof $listeners;\nexport type ValueKeyCallback<T extends object> = <K extends keyof T, V extends T[K]>(value: V, key: K) => void;\n\nexport type GuiSetting<T extends object = object, Tag extends string = string> = {\n    [$type]: Tag,\n    [$callback]?: ValueKeyCallback<T>,\n    [$listeners]: Set<ValueKeyCallback<T>>,\n} & T;\n\nexport type ListenerSpec<T extends object = object, Tag extends string = string> =\n    Omit<GuiSetting<T, Tag>, typeof $listeners>;\n\ntype MapSpec<T extends Record<PropertyKey, ListenerSpec>> = {\n    [K in keyof T]: T[K] extends ListenerSpec<object, infer Tag> & infer Rest\n        ? Rest extends object\n            ? GuiSetting<Omit<Rest, Syms>, Tag> : never : never\n};\n\nfunction fastProxy(spec: GuiSetting<UnknownObject>, callback?: (value: unknown, key: string) => void) {\n    return Object.keys(spec)\n        .reduce((prev, key) => Object.defineProperty(prev, key, {\n            enumerable: true,\n            get() { return spec[key]; },\n            set(value: unknown) {\n                if (spec[key] !== value) {\n                    spec[key] = value;\n                    callback?.(value, key);\n                }\n            },\n        }), { [$type]: spec[$type], [$listeners]: spec[$listeners] });\n}\n\nexport default function propertyListener<T extends Record<PropertyKey, ListenerSpec<UnknownObject>>>(specs: T) {\n    for (const spec of Object.values(specs) as GuiSetting[]) {\n        spec[$listeners] = new Set();\n    }\n\n    return {\n        publicSettings: mapValues(specs, (spec) => {\n            const cast = spec as GuiSetting<UnknownObject>;\n            return fastProxy(cast, cast[$callback]);\n        }) as MapSpec<T>,\n        privateSettings: mapValues(specs, (spec) => {\n            const cast = spec as GuiSetting<UnknownObject>;\n            return fastProxy(cast, (value, key) => {\n                cast[$listeners].forEach((fn) => { fn(value, key); });\n            });\n        }) as MapSpec<T>,\n    };\n}\n","export default /* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`;\r\n"],"names":["hdrPromises","fetch","headers","then","res","json","hdrs","Object","fromEntries","flatMap","name","download_url","endsWith","async","processSkybox","device","file","buffer","ArrayBuffer","File","arrayBuffer","hdr","format","usage","GPUTextureUsage","TEXTURE_BINDING","STORAGE_BINDING","COPY_SRC","getSkyboxOptions","target","$type","$callback","val","key","texture","setSkybox","Promise","accept","value","keys","initialValues","process","baseTable","shiftTable","Uint32Array","i","e","conversionBuffer","floatView","Float32Array","uintView","toFloat16Bytes","bits","mantissa","idx","shifted","toWorldDir","cubemapSampleConversions","DEFAULT_MAX_OPS","createMipBlurCode","groups","cubemapGuassianPyramid","outputTextureLabel","inPlace","minWidth","steps","maxOpsPerPass","label","delayWork","width","mipLevelCount","Math","log2","min","limits","maxComputeWorkgroupSizeX","maxComputeInvocationsPerWorkgroup","shader","createShaderModule","code","bindgroupLayout","createBindGroupLayout","entries","binding","viewDimension","visibility","GPUShaderStage","COMPUTE","storageTexture","access","type","pipeline","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","entryPoint","constants","STEPS","ceil","gaussianPyramid","size","height","depthOrArrayLayers","createTexture","COPY_DST","dimension","copyEncoder","createCommandEncoder","copyTextureToTexture","mipLevel","queue","submit","finish","onSubmittedWorkDone","mipViews","createView","baseMipLevel","maxWorkgroups","maxComputeWorkgroupsPerDimension","maxLayers","maxDispatches","max","propertyArray","offset","set","w","acos","nextMipWidth","baseV","floor","baseVN","baseUN","baseMag2","sampUN","samp0VN","samp0Mag2","samp1VN","samp1Mag2","mag0","sqrt","mag1","minStepDistance","propertyBuffer","GPUBufferUsage","STORAGE","bindgroup","mipPasses","requiredMipDispatches","currentMipDispatches","batchDispatches","runPass","mipPixels","createBindGroup","resource","writeBuffer","passDispatches","passLabel","encoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","Symbol","$listeners","ListenerSyms","freeze","fastProxy","spec","callback","reduce","prev","defineProperty","enumerable","get","propertyListener","specs","values","Set","publicSettings","privateSettings","cast","forEach","fn"],"sourceRoot":""}