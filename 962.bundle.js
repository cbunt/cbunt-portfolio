/*! For license information see: https://cbunt.ing/oss-licenses.json */
"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[962],{2323:(e,r,n)=>{n.d(r,{GE:()=>s,KO:()=>u,T2:()=>o,vV:()=>a});var t=n(9253);const a={mat4x4Count:16,sizeofMat4x4f:16*Float32Array.BYTES_PER_ELEMENT},i={[t.VIE]:"r8unorm",[t.B7n]:"r8snorm",[t.W_U]:"r8uint",[t.YeG]:"r8sint",[t.HYY]:"r16uint",[t.brc]:"r16sint",[t.eLQ]:"r16float",[t.sk6]:"rg8unorm",[t.aiL]:"rg8snorm",[t.xWH]:"rg8uint",[t.$Kq]:"rg8sint",[t.nR0]:"r32uint",[t.rwM]:"r32sint",[t.e4n]:"r32float",[t.P1c]:"rg16uint",[t.bc6]:"rg16sint",[t.cps]:"rg16float",[t.tsP]:"rgba8unorm",[t.Wm_]:"rgba8unorm-srgb",[t.zqn]:"rgba8snorm",[t.MZV]:"rgba8uint",[t._Je]:"rgba8sint",[t.J6Z]:"bgra8unorm",[t.mIY]:"bgra8unorm-srgb",[t.KIZ]:"rgb9e5ufloat",[t.eAA]:"rgb10a2uint",[t.fJh]:"rgb10a2unorm",[t.kot]:"rg11b10ufloat",[t.nlo]:"rg32uint",[t.x9e]:"rg32sint",[t.yAK]:"rg32float",[t.CSc]:"rgba16uint",[t.GF$]:"rgba16sint",[t.l2T]:"rgba16float",[t.KMX]:"rgba32uint",[t.KBq]:"rgba32sint",[t.Ze1]:"rgba32float",[t.QFs]:"bc1-rgba-unorm",[t.bOE]:"bc1-rgba-unorm-srgb",[t.wt4]:"bc2-rgba-unorm",[t.ZBp]:"bc2-rgba-unorm-srgb",[t.D_t]:"bc3-rgba-unorm",[t.elk]:"bc3-rgba-unorm-srgb",[t.ydS]:"bc4-r-unorm",[t.iIv]:"bc4-r-snorm",[t.LHP]:"bc5-rg-unorm",[t.xXb]:"bc5-rg-snorm",[t.mQu]:"bc6h-rgb-ufloat",[t.CpY]:"bc6h-rgb-float",[t.FD_]:"bc7-rgba-unorm",[t.GJu]:"bc7-rgba-unorm-srgb"},o={r8unorm:1,r8snorm:1,r8uint:1,r8sint:1,r16uint:2,r16sint:2,r16float:2,rg8unorm:2,rg8snorm:2,rg8uint:2,rg8sint:2,r32uint:4,r32sint:4,r32float:4,rg16uint:4,rg16sint:4,rg16float:4,rgba8unorm:4,"rgba8unorm-srgb":4,rgba8snorm:4,rgba8uint:4,rgba8sint:4,bgra8unorm:4,"bgra8unorm-srgb":4,rgb9e5ufloat:4,rgb10a2uint:4,rgb10a2unorm:4,rg11b10ufloat:4,rg32uint:8,rg32sint:8,rg32float:8,rgba16uint:8,rgba16sint:8,rgba16float:8,rgba32uint:16,rgba32sint:16,rgba32float:16},s={r8unorm:1,r8snorm:1,r8uint:1,r8sint:1,r16uint:2,r16sint:2,r16float:2,rg8unorm:1,rg8snorm:1,rg8uint:1,rg8sint:1,r32uint:4,r32sint:4,r32float:4,rg16uint:2,rg16sint:2,rg16float:2,rgba8unorm:1,"rgba8unorm-srgb":1,rgba8snorm:1,rgba8uint:1,rgba8sint:1,bgra8unorm:1,"bgra8unorm-srgb":1,rgb9e5ufloat:4,rgb10a2uint:4,rgb10a2unorm:4,rg11b10ufloat:4,rg32uint:4,rg32sint:4,rg32float:4,rgba16uint:2,rgba16sint:2,rgba16float:2,rgba32uint:4,rgba32sint:4,rgba32float:4},u=Object.fromEntries(Object.entries(i).map((([e,r])=>[r,parseInt(e,10)])))},7962:(e,r,n)=>{n.a(e,(async(e,t)=>{try{n.r(r),n.d(r,{default:()=>v});var a=n(8777),i=n(3803),o=n(2112),s=n(3936),u=n(9196),c=e([i]);i=(c.then?(await c)():c)[0];var l,d,f=function(e,r,n,t){if("a"===n&&!t)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof r?e!==r||!t:!r.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?t:"a"===n?t.call(e):t?t.value:r.get(e)};!function(e){e[e.IDLE=0]="IDLE",e[e.BLUR=1]="BLUR",e[e.WAIT=2]="WAIT"}(d||(d={}));class g{constructor(e){this.renderer=e,this.state=d.IDLE,l.set(this,(0,o.A)({nearestSample:{[o.t.$type]:"checkbox",[o.t.$callback]:e=>{"boolean"==typeof e&&(this.renderer.skyboxPass.useNearestSample=e)},value:!1,description:"Disables linear sampling in the viewer."},mipLevel:{[o.t.$type]:"slider",[o.t.$callback]:e=>{"number"==typeof e&&(this.renderer.skyboxPass.mipLevel=e)},value:0,min:0,max:1,step:.1,description:"The mip level to display in the viewer. 0 is the original image, max is completely blurred with 1 pixel faces."},filterDistance:{[o.t.$type]:"slider",[o.t.$callback]:this.reblur.bind(this),value:8,max:64,min:0,step:.1,description:"The number of pixels to blur from."},skybox:(0,i.A)(this),"Download Result":{[o.t.$type]:"button",onClick:()=>{this.saveFile()}}})),this.settings=f(this,l,"f").publicSettings,this.priority=0,e.addForwardPass(this),this.device=e.device}setSkybox(e){this.skybox=e,f(this,l,"f").privateSettings.mipLevel.max=this.skybox.mipLevelCount-1,f(this,l,"f").privateSettings.mipLevel.value=1,this.renderer.skyboxPass.mipLevel=1,this.refresh(),this.reblur()}resolve(){this.refresh();const e=this.state;this.state=d.IDLE,e===d.WAIT&&this.reblur()}async reblur(){null!=this.skybox&&this.state!==d.WAIT&&(this.state!==d.BLUR?(this.state=d.BLUR,await(0,u.A)({device:this.renderer.device,texture:this.skybox,steps:this.settings.filterDistance.value,inPlace:!0,delayWork:requestAnimationFrame}),this.resolve()):this.state=d.WAIT)}refresh(){null!=this.skybox&&(this.renderer.skyboxPass.skyTexture=this.skybox.createView({dimension:"cube"}))}async saveFile(){if(null!=this.skybox)try{const e=Promise.all([(0,s.gU)(this.renderer.device,this.skybox,!0).then((e=>new Blob([e],{type:"image/ktx2"}))),(0,a.H1)({types:[{accept:{"image/ktx2":[".ktx2"]}}],suggestedName:"blurred-skybox.ktx2"}).then((e=>e.createWritable({keepExistingData:!1})))]),[r,n]=await e;await r.stream().pipeTo(n)}catch(e){console.warn(e)}}render({encoder:e,gbuffer:r}){e.beginRenderPass({colorAttachments:[],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",view:r.depth.view}}).end()}}l=new WeakMap,g.title="",g.description="";const v=g;t()}catch(e){t(e)}}))},9196:(e,r,n)=>{n.d(r,{A:()=>u});var t=n(5753),a=n(3936),i=n(2349);const o=113639424,s=(e,r)=>`\n    ${t.X}\n    ${t.V}\n\n    override STEPS: i32 = 4;\n\n    struct Params {\n        offset: u32,\n        sigmas: array<f32>,\n    }\n\n    @group(0) @binding(0) \n    var previousMip: texture_2d_array<f32>;\n\n    @group(0) @binding(1) \n    var outputTexture: texture_storage_2d_array<${r}, write>;\n\n    @group(0) @binding(2) \n    var<storage> params: Params;\n    \n    @compute @workgroup_size(${e}, 1, 1)\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\n        let mipSize = textureDimensions(outputTexture).x;\n\n        let idx = gid.x + params.offset;\n        let faceSize = mipSize * mipSize;\n        let faceIdx = idx % faceSize;\n\n        let coord = vec3u(\n            faceIdx % mipSize, \n            faceIdx / mipSize, \n            idx / faceSize,\n        ); \n\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \n            return; \n        }\n\n        let previousSize = textureDimensions(previousMip).x;\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\n        let pos = toWorldDir(vec3u(coord), mipSize);\n\n        let size = arrayLength(&params.sigmas);\n        let level = size - u32(ceil(log2(f32(previousSize))));\n        let sigma = params.sigmas[level];\n        let guassian_factor = -0.5 / (sigma * sigma);\n\n        var weight = 0.0;\n        var res = vec3(0.0);\n\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\n                if (sample.z == INVALID_FACE) { continue; }\n\n                let samplePos = toWorldDir(sample, previousSize);\n                let x = max(0.0, acos(dot(samplePos, pos)));\n                let w = exp(x * x * guassian_factor);\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\n\n                res += color.rgb * w;\n                weight += w;\n            }\n        }\n\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\n    }\n`;async function u({device:e,texture:r,outputTextureLabel:n,inPlace:t=!1,minWidth:c=8,steps:l=4,maxOpsPerPass:d=o,label:f=u.name,delayWork:g}){const{width:v,format:m}=r,p=t?r.mipLevelCount:Math.log2(v)-Math.log2(c)+1;if(p<=1)return r;const b=Math.min(e.limits.maxComputeWorkgroupSizeX,e.limits.maxComputeInvocationsPerWorkgroup),h=e.createShaderModule({label:f,code:s(b,m)}),y=e.createBindGroupLayout({label:f,entries:[{binding:0,texture:{viewDimension:"2d-array"},visibility:GPUShaderStage.COMPUTE},{binding:1,storageTexture:{access:"write-only",viewDimension:"2d-array",format:m},visibility:GPUShaderStage.COMPUTE},{binding:2,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.COMPUTE}]}),w=e.createComputePipeline({label:f,layout:e.createPipelineLayout({label:f,bindGroupLayouts:[y]}),compute:{module:h,entryPoint:"main",constants:{STEPS:Math.ceil(l)}}});let x=r;if(!t){const t={width:v,height:v,depthOrArrayLayers:6};x=e.createTexture({label:n,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,dimension:"2d",format:m,mipLevelCount:p,size:t});const a=e.createCommandEncoder({label:`${f} copy encoder`});a.copyTextureToTexture({texture:r,mipLevel:0},{texture:x,mipLevel:0},t),e.queue.submit([a.finish()]),await e.queue.onSubmittedWorkDone()}const A=(0,i._b)(p,(e=>x.createView({label:`${f} mip view ${e}`,dimension:"2d-array",baseMipLevel:e,mipLevelCount:1}))),S=e.limits.maxComputeWorkgroupsPerDimension,T=Math.ceil(Math.log2(v)),P=Math.max(d/((1+2*l)**2*b)|0,1),L=new ArrayBuffer(4*(T+1)),E=new Uint32Array(L,0,1);new Float32Array(L,4,T).set((0,i._b)(T,(e=>{const r=v>>e;return Math.acos(1-function(e,r){const n=r>>1,t=n-Math.floor(e/4)-1,a=2/n*(t+.5)-1,i=1/n-1,o=1+a*a+i*i,s=2/r*(2*r-2*t-e-2+.5)-1,u=1/r-1,c=1+s*s+u*u,l=3/r-1,d=1+s*s+l*l,f=(s+a+u*i)/Math.sqrt(c*o),g=(s+a+l*i)/Math.sqrt(d*o);return Math.min(1-f,1-g)}(Math.min(r,l),r))/3})));const U=(0,a.Lr)(L,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,e);let I,C=0,M=0,D=0,G=0,_=0;return await async function r(){if(G>=D){if(C+=1,G=0,M=0,C>=p)return;const r=6*(v>>C)**2;D=Math.ceil(r/b),I=e.createBindGroup({layout:y,entries:[{binding:0,resource:A[C-1]},{binding:1,resource:A[C]},{binding:2,resource:{buffer:U}}]})}E[0]=G*b,e.queue.writeBuffer(U,0,E);const n=Math.min(D-G,P-_,S),t=`${f} mip ${C}, pass ${M}`,a=e.createCommandEncoder({label:t}),i=a.beginComputePass({label:t});i.setPipeline(w),i.setBindGroup(0,I),i.dispatchWorkgroups(n,1,1),i.end(),e.queue.submit([a.finish()]),G+=n,_+=n,M+=1,null!=g&&_>=P?(_=0,await e.queue.onSubmittedWorkDone(),g(r)):await r()}(),x}},3803:(e,r,n)=>{n.a(e,(async(e,t)=>{try{n.d(r,{A:()=>l});var a=n(4802),i=n(2965),o=n(2112);const s=await fetch("https://api.github.com/repos/KhronosGroup/glTF-Sample-Environments/contents?ref=low_resolution_hdrs",{headers:{"Content-Type":"application/vnd.github.object+json"}}).then((e=>e.json())),u=Object.fromEntries(s.flatMap((({name:e,download_url:r})=>"string"==typeof e&&"string"==typeof r&&r.endsWith(".hdr")?[[e,r]]:[])));async function c(e,r){let n;if(r instanceof ArrayBuffer)n=r;else if(r instanceof File)n=await r.arrayBuffer();else{const e=await fetch(r);n=await e.arrayBuffer()}const t=(0,a.y)(n);return(0,i.l3)(e,t,{format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC})}function l(e){return{[o.t.$type]:"file",[o.t.$callback]:async(r,n)=>{if("value"===n&&null!=r&&("string"==typeof r||r instanceof File)){const n=await c(e.device,r),t=e.setSkybox(n);t instanceof Promise&&await t}},accept:".hdr",selection:{value:Object.keys(u)[0],initialValues:u},process:e=>e}}t()}catch(d){t(d)}}),1)},4581:(e,r,n)=>{n.d(r,{A:()=>t});const t="\n    struct VertOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n    }\n\n    @vertex\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\n        const pos = array(\n            vec2f(-1,  3),\n            vec2f(3, -1),\n            vec2f(-1, -1),\n        );\n        var res: VertOut;\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\n        return res;\n    }\n"},5753:(e,r,n)=>{n.d(r,{V:()=>t,X:()=>a});const t="\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n",a="\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n"},3936:(e,r,n)=>{n.d(r,{Lr:()=>o,gU:()=>u});var t=n(9253),a=n(2323),i=n(2349);function o(e,r,n,t,a=4){const i=a-1,o=n.createBuffer({label:t,usage:r,size:e.byteLength+i&~i,mappedAtCreation:!0}),s=new Uint8Array(o.getMappedRange()),u=e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength);return s.set(u),o.unmap(),o}async function s({device:e,texture:r,mipLevel:n=0,returnBuffer:t,storageBuffer:o,resultBuffer:s,description:u}){const c=a.T2[r.format],l=i.OY`[textureToKTX${u??""}${r.label}] --`;if(null==c)throw new Error(`${l} format ${r.format} unsupported`);const d=r.width>>n,f=r.height>>n,g=d*c,v=Math.max(g,256),m=f,p=m*v*r.depthOrArrayLayers,b=g*f*r.depthOrArrayLayers;if(null!=s&&s.byteLength<p)throw new Error(`${l} given result array not large enough.\n${s.byteLength} < ${p}`);if(null!=o&&o.size<p)throw new Error(`${l} given storage buffer not large enough.\n${o.size} < ${p}`);const h=GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ;if(null!=o&&(o.usage&h)!==h)throw new Error(`${l} given storage does not have correct usage flags.\nGiven: ${o.usage}\nRequired: ${h}`);let y=s??new Uint8Array(p);const w=o??e.createBuffer({label:`${l} storage buffer`,size:p,usage:h}),x=e.createCommandEncoder({label:`${l} encoder`});x.copyTextureToBuffer({texture:r,mipLevel:n},{buffer:w,rowsPerImage:m,bytesPerRow:v},{width:d,height:f,depthOrArrayLayers:r.depthOrArrayLayers}),e.queue.submit([x.finish()]),await Promise.all([w.mapAsync(GPUMapMode.READ,0,p),e.queue.onSubmittedWorkDone()]);const A=w.getMappedRange(0,p);if(y.set(new Uint8Array(A)),w.unmap(),v>g){for(let e=0;e<f*r.depthOrArrayLayers;e+=1)for(let r=0;r<g;r+=1)y[r+e*g]=y[r+e*v];y=y.slice(0,b)}return{imageData:y,storageBuffer:t?w:void 0}}async function u(e,r,n=!1){const o=a.T2[r.format],u=a.GE[r.format];if(null==o||null==u)throw new Error(`textureToKTX -- format ${r.format} of ${r.label} unsupported`);const c=new t.nYd;c.pixelWidth=r.width,c.pixelHeight=r.height,c.vkFormat=a.KO[r.format],c.typeSize=u,delete c.keyValue.KTXswizzle;const l=c.dataFormatDescriptor[0];if(l.colorModel=t.Tre,l.transferFunction=t.T5j,l.bytesPlane[0]=o,l.samples=(0,i._b)(4,(e=>({channelType:[192,193,194,207][e],samplePosition:[0,0,0,0],bitLength:8*c.typeSize-1,bitOffset:8*c.typeSize*e,sampleLower:-1082130432,sampleUpper:1065353216}))),"3d"===r.dimension)c.faceCount=1,c.pixelDepth=r.depthOrArrayLayers;else if(n){const e=r.depthOrArrayLayers/6;c.layerCount=1===e?0:e,c.faceCount=6}else c.layerCount=r.depthOrArrayLayers,c.faceCount=1;let d,f;for(let n=0;n<r.mipLevelCount;n+=1)({imageData:f,storageBuffer:d}=await s({mipLevel:n,returnBuffer:!0,device:e,texture:r,storageBuffer:d})),c.levels.push({levelData:f,uncompressedByteLength:f.byteLength});return t.M98(c)}},4802:(e,r,n)=>{n.d(r,{y:()=>c});const{baseTable:t,shiftTable:a}=(()=>{const e=new Uint32Array(256),r=new Uint32Array(256);for(let n=0;n<255;++n){const t=n-127;t<-27?(e[n]=0,r[n]=24):t<-14?(e[n]=1024>>-t-14,r[n]=-t-1):t<=15?(e[n]=t+15<<10,r[n]=13):(e[n]=31744,r[n]=24)}return e[255]=31744,r[255]=13,{baseTable:e,shiftTable:r}})(),i=new ArrayBuffer(4),o=new Float32Array(i),s=new Uint32Array(i);function u(e){o[0]=e;const r=s[0],n=r>>23&511,i=255&n,u=(8388607&r)>>a[i];return((256&n)<<7)+t[i]+u}n(2965);function c(e){const r=new TextDecoder,n=e instanceof Uint8Array?e:new Uint8Array(e);let t=0;const a=(e=1024)=>{const a=Math.min(n.length,e+t),i=n.subarray(t,a),o=i.indexOf(10)+1;return t+=o,0===o?void 0:r.decode(i.subarray(0,o))},i=e=>new Error("HDR Import Error: "+e),o=a();if(null==o)throw i("no header found");if(!/^#\?(\S+)/.test(o))throw i("bad initial token");const s=new RegExp(`^\\s*(${[/FORMAT=(?<format>\S+)/,/-Y\s+(?<Y>\d+)\s+\+X\s+(?<X>\d+)/,/EXPOSURE\s*=\s*(?<exposure>\d+(\.\d+)?)/,/GAMMA\s*=\s*(?<gamma>\d+(\.\d+)?)/].map((({source:e})=>`(${e})`)).join("|")})\\s*$`);let c,l,d,f=!0,g=1,v=1;for(let e=a();null!=e;e=null==c?a():void 0){const r=e.match(s)?.groups;null!=r&&(null!=r.format?f=!1:null!=r.X&&null!=r.Y?(c=parseInt(r.X),l=parseInt(r.Y)):null!=r.gamma?g=parseFloat(r.gamma):null!=r.exposure&&(v=parseFloat(r.exposure)))}if(f)throw i("missing format specifier");if(null==c||null==l)throw i("missing image size specifier");const m=c<8||c>32767,p=2!==n[t]||2!==n[t+1]||!!(128&n[t+2]);if(m||p)d=n.subarray(t);else{d=new Uint8Array(c*l*4);const e=4*c,r=new Uint8Array(e),a=n.byteLength;for(let o=0,s=0;o<l&&t<a;o++){if(t+4>a)throw i("file ended durning scanline");if(2!=n[t++]||2!=n[t++]||(n[t++]<<8|n[t++])!=c)throw i("bad rgbe scanline format");let o;for(let s=0;s<e&&t<a;s+=o){o=n[t++];const a=o>128;if(a&&(o-=128),0==o||s+o>e)throw i("bad scanline data");a?(r.fill(n[t],s,s+o),t+=1):(r.set(n.subarray(t,t+o),s),t+=o)}for(let n=0;n<c;n++)for(let t=0;t<e;t+=c)d[s++]=r[n+t]}}const b=new Uint16Array(d.length),h=u(1);for(let e=0;e<c*l*4;e+=4){const r=d[e+3],n=Math.pow(2,r-128)/255;for(let r=0;r<3;r+=1)b[e+r]=u(Math.min(d[e+r]*n,65504));b[e+3]=h}return{data:b,width:c,height:l,gamma:g,exposure:v}}},2965:(e,r,n)=>{n.d(r,{l3:()=>s});var t=n(4581),a=n(5753),i=n(3936),o=n(2349);async function s(e,{data:r,width:n,height:s,gamma:u=1,exposure:c=1},l){const d=`\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${t.A}\n        ${a.V}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;let f,g=0;r instanceof GPUTexture?f=r:(g=1,f=e.createTexture({label:`${l.label} equirectangular`,dimension:"2d",format:"rgba16float",size:{width:n,height:s},usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING}),e.queue.writeTexture({texture:f,mipLevel:0},r,{bytesPerRow:2*n*4},{width:n,height:s,depthOrArrayLayers:1}),await e.queue.onSubmittedWorkDone());const v=f.height>>1,m=l;m.mipLevelCount??=0|Math.log2(v),m.size={width:v,height:v,depthOrArrayLayers:6},m.dimension="2d",m.usage|=GPUTextureUsage.RENDER_ATTACHMENT;const p=e.createTexture(m),b=o.OY`hdr copy${l.label}`,h=e.createBindGroupLayout({label:b,entries:[{binding:0,texture:{},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT},{binding:2,buffer:{},visibility:GPUShaderStage.FRAGMENT}]}),y=e.createShaderModule({label:b,code:d}),w=e.createSampler({label:b,minFilter:"linear",magFilter:"linear"}),x=new Uint32Array(1),A=(0,i.Lr)(x,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,e,b),S=e.createBindGroup({label:b,layout:h,entries:[{binding:0,resource:f.createView()},{binding:1,resource:w},{binding:2,resource:{buffer:A}}]}),T=e.createPipelineLayout({label:b,bindGroupLayouts:[h]}),P=e.createRenderPipeline({label:b,layout:T,vertex:{module:y},fragment:{module:y,targets:[{format:p.format}],constants:{GAMMA:u,EXPOSURE:c,FLIP_Y:g}}});for(let r=0;r<6;r+=1){x[0]=r,e.queue.writeBuffer(A,0,x,0,1);const n=p.createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:r,mipLevelCount:1}),t=e.createCommandEncoder(),a=t.beginRenderPass({label:b,colorAttachments:[{view:n,loadOp:"clear",storeOp:"store"}]});a.setPipeline(P),a.setBindGroup(0,S),a.draw(3),a.end(),e.queue.submit([t.finish()])}return p}}}]);
//# sourceMappingURL=962.bundle.js.map