"use strict";(self.webpackChunkwebgpu_basic=self.webpackChunkwebgpu_basic||[]).push([[770],{838:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GE: () => (/* binding */ TextureFormatToChannelSize),\n/* harmony export */   KO: () => (/* binding */ WebGPUToVkFormat),\n/* harmony export */   Oi: () => (/* binding */ VkFormatToWebGPU),\n/* harmony export */   T2: () => (/* binding */ TextureFormatToSize),\n/* harmony export */   vV: () => (/* binding */ TypeSizes)\n/* harmony export */ });\n/* unused harmony export textureTypeToDimension */\n/* harmony import */ var ktx_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(380);\n\nconst TypeSizes = {\n    mat4x4Count: 16,\n    sizeofMat4x4f: 16 * Float32Array.BYTES_PER_ELEMENT,\n};\nconst VkFormatToWebGPU = {\n    // 8-bit formats\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8_UNORM */ .VIE]: 'r8unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8_SNORM */ .B7n]: 'r8snorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8_UINT */ .W_U]: 'r8uint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8_SINT */ .YeG]: 'r8sint',\n    // 16-bit formats\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R16_UINT */ .HYY]: 'r16uint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R16_SINT */ .brc]: 'r16sint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R16_SFLOAT */ .eLQ]: 'r16float',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8G8_UNORM */ .sk6]: 'rg8unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8G8_SNORM */ .aiL]: 'rg8snorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8G8_UINT */ .xWH]: 'rg8uint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8G8_SINT */ .$Kq]: 'rg8sint',\n    // 32-bit formats\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R32_UINT */ .nR0]: 'r32uint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R32_SINT */ .rwM]: 'r32sint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R32_SFLOAT */ .e4n]: 'r32float',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R16G16_UINT */ .P1c]: 'rg16uint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R16G16_SINT */ .bc6]: 'rg16sint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R16G16_SFLOAT */ .cps]: 'rg16float',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8G8B8A8_UNORM */ .tsP]: 'rgba8unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8G8B8A8_SRGB */ .Wm_]: 'rgba8unorm-srgb',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8G8B8A8_SNORM */ .zqn]: 'rgba8snorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8G8B8A8_UINT */ .MZV]: 'rgba8uint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R8G8B8A8_SINT */ ._Je]: 'rgba8sint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_B8G8R8A8_UNORM */ .J6Z]: 'bgra8unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_B8G8R8A8_SRGB */ .mIY]: 'bgra8unorm-srgb',\n    // Packed 32-bit formats\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 */ .KIZ]: 'rgb9e5ufloat',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_A2R10G10B10_UINT_PACK32 */ .eAA]: 'rgb10a2uint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_A2R10G10B10_UNORM_PACK32 */ .fJh]: 'rgb10a2unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_B10G11R11_UFLOAT_PACK32 */ .kot]: 'rg11b10ufloat',\n    // 64-bit formats\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R32G32_UINT */ .nlo]: 'rg32uint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R32G32_SINT */ .x9e]: 'rg32sint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R32G32_SFLOAT */ .yAK]: 'rg32float',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R16G16B16A16_UINT */ .CSc]: 'rgba16uint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R16G16B16A16_SINT */ .GF$]: 'rgba16sint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R16G16B16A16_SFLOAT */ .l2T]: 'rgba16float',\n    // 128-bit formats\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R32G32B32A32_UINT */ .KMX]: 'rgba32uint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R32G32B32A32_SINT */ .KBq]: 'rgba32sint',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_R32G32B32A32_SFLOAT */ .Ze1]: 'rgba32float',\n    // BC compressed formats usable if \"texture-compression-bc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC1_RGBA_UNORM_BLOCK */ .QFs]: 'bc1-rgba-unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC1_RGBA_SRGB_BLOCK */ .bOE]: 'bc1-rgba-unorm-srgb',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC2_UNORM_BLOCK */ .wt4]: 'bc2-rgba-unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC2_SRGB_BLOCK */ .ZBp]: 'bc2-rgba-unorm-srgb',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC3_UNORM_BLOCK */ .D_t]: 'bc3-rgba-unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC3_SRGB_BLOCK */ .elk]: 'bc3-rgba-unorm-srgb',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC4_UNORM_BLOCK */ .ydS]: 'bc4-r-unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC4_SNORM_BLOCK */ .iIv]: 'bc4-r-snorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC5_UNORM_BLOCK */ .LHP]: 'bc5-rg-unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC5_SNORM_BLOCK */ .xXb]: 'bc5-rg-snorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC6H_UFLOAT_BLOCK */ .mQu]: 'bc6h-rgb-ufloat',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC6H_SFLOAT_BLOCK */ .CpY]: 'bc6h-rgb-float',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC7_UNORM_BLOCK */ .FD_]: 'bc7-rgba-unorm',\n    [ktx_parse__WEBPACK_IMPORTED_MODULE_0__/* .VK_FORMAT_BC7_SRGB_BLOCK */ .GJu]: 'bc7-rgba-unorm-srgb',\n    // Currently unsupported extension formats:\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    // \"etc2-rgb8unorm\",\n    // \"etc2-rgb8unorm-srgb\",\n    // \"etc2-rgb8a1unorm\",\n    // \"etc2-rgb8a1unorm-srgb\",\n    // \"etc2-rgba8unorm\",\n    // \"etc2-rgba8unorm-srgb\",\n    // \"eac-r11unorm\",\n    // \"eac-r11snorm\",\n    // \"eac-rg11unorm\",\n    // \"eac-rg11snorm\",\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    // \"astc-4x4-unorm\",\n    // \"astc-4x4-unorm-srgb\",\n    // \"astc-5x4-unorm\",\n    // \"astc-5x4-unorm-srgb\",\n    // \"astc-5x5-unorm\",\n    // \"astc-5x5-unorm-srgb\",\n    // \"astc-6x5-unorm\",\n    // \"astc-6x5-unorm-srgb\",\n    // \"astc-6x6-unorm\",\n    // \"astc-6x6-unorm-srgb\",\n    // \"astc-8x5-unorm\",\n    // \"astc-8x5-unorm-srgb\",\n    // \"astc-8x6-unorm\",\n    // \"astc-8x6-unorm-srgb\",\n    // \"astc-8x8-unorm\",\n    // \"astc-8x8-unorm-srgb\",\n    // \"astc-10x5-unorm\",\n    // \"astc-10x5-unorm-srgb\",\n    // \"astc-10x6-unorm\",\n    // \"astc-10x6-unorm-srgb\",\n    // \"astc-10x8-unorm\",\n    // \"astc-10x8-unorm-srgb\",\n    // \"astc-10x10-unorm\",\n    // \"astc-10x10-unorm-srgb\",\n    // \"astc-12x10-unorm\",\n    // \"astc-12x10-unorm-srgb\",\n    // \"astc-12x12-unorm\",\n};\nconst TextureFormatToSize = {\n    // 8-bit formats\n    r8unorm: 1,\n    r8snorm: 1,\n    r8uint: 1,\n    r8sint: 1,\n    // 16-bit formats\n    r16uint: 2,\n    r16sint: 2,\n    r16float: 2,\n    rg8unorm: 2,\n    rg8snorm: 2,\n    rg8uint: 2,\n    rg8sint: 2,\n    // 32-bit formats\n    r32uint: 4,\n    r32sint: 4,\n    r32float: 4,\n    rg16uint: 4,\n    rg16sint: 4,\n    rg16float: 4,\n    rgba8unorm: 4,\n    'rgba8unorm-srgb': 4,\n    rgba8snorm: 4,\n    rgba8uint: 4,\n    rgba8sint: 4,\n    bgra8unorm: 4,\n    'bgra8unorm-srgb': 4,\n    // Packed 32-bit formats\n    rgb9e5ufloat: 4,\n    rgb10a2uint: 4,\n    rgb10a2unorm: 4,\n    rg11b10ufloat: 4,\n    // 64-bit formats\n    rg32uint: 8,\n    rg32sint: 8,\n    rg32float: 8,\n    rgba16uint: 8,\n    rgba16sint: 8,\n    rgba16float: 8,\n    // 128-bit formats\n    rgba32uint: 16,\n    rgba32sint: 16,\n    rgba32float: 16,\n};\nconst TextureFormatToChannelSize = {\n    // 8-bit formats\n    r8unorm: 1,\n    r8snorm: 1,\n    r8uint: 1,\n    r8sint: 1,\n    // 16-bit formats\n    r16uint: 2,\n    r16sint: 2,\n    r16float: 2,\n    rg8unorm: 1,\n    rg8snorm: 1,\n    rg8uint: 1,\n    rg8sint: 1,\n    // 32-bit formats\n    r32uint: 4,\n    r32sint: 4,\n    r32float: 4,\n    rg16uint: 2,\n    rg16sint: 2,\n    rg16float: 2,\n    rgba8unorm: 1,\n    'rgba8unorm-srgb': 1,\n    rgba8snorm: 1,\n    rgba8uint: 1,\n    rgba8sint: 1,\n    bgra8unorm: 1,\n    'bgra8unorm-srgb': 1,\n    // Packed 32-bit formats\n    rgb9e5ufloat: 4,\n    rgb10a2uint: 4,\n    rgb10a2unorm: 4,\n    rg11b10ufloat: 4,\n    // 64-bit formats\n    rg32uint: 4,\n    rg32sint: 4,\n    rg32float: 4,\n    rgba16uint: 2,\n    rgba16sint: 2,\n    rgba16float: 2,\n    // 128-bit formats\n    rgba32uint: 4,\n    rgba32sint: 4,\n    rgba32float: 4,\n};\nconst WebGPUToVkFormat = Object.fromEntries(Object.entries(VkFormatToWebGPU).map(([vk, wgpu]) => [wgpu, parseInt(vk, 10)]));\nconst textureTypeToDimension = {\n    texture_cube: 'cube',\n    texture_3d: '3d',\n    texture_2d: '2d',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUUsTUFBTTtJQUNwQixVQUFVLEVBQUUsSUFBSTtJQUNoQixVQUFVLEVBQUUsSUFBSTtDQUNuQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViZ3B1LWJhc2ljLy4vc3JjL3JlbmRlcmluZy9jb25zdGFudHMudHM/MmU4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBrdHhwIGZyb20gJ2t0eC1wYXJzZSc7XHJcblxyXG5leHBvcnQgY29uc3QgVHlwZVNpemVzID0ge1xyXG4gICAgbWF0NHg0Q291bnQ6IDE2LFxyXG4gICAgc2l6ZW9mTWF0NHg0ZjogMTYgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgVmtGb3JtYXRUb1dlYkdQVTogUmVjb3JkPG51bWJlciwgR1BVVGV4dHVyZUZvcm1hdCB8IHVuZGVmaW5lZD4gPSB7XHJcbiAgICAvLyA4LWJpdCBmb3JtYXRzXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjhfVU5PUk1dOiAncjh1bm9ybScsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjhfU05PUk1dOiAncjhzbm9ybScsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjhfVUlOVF06ICdyOHVpbnQnLFxyXG4gICAgW2t0eHAuVktfRk9STUFUX1I4X1NJTlRdOiAncjhzaW50JyxcclxuICAgIC8vIDE2LWJpdCBmb3JtYXRzXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjE2X1VJTlRdOiAncjE2dWludCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjE2X1NJTlRdOiAncjE2c2ludCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjE2X1NGTE9BVF06ICdyMTZmbG9hdCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjhHOF9VTk9STV06ICdyZzh1bm9ybScsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjhHOF9TTk9STV06ICdyZzhzbm9ybScsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjhHOF9VSU5UXTogJ3JnOHVpbnQnLFxyXG4gICAgW2t0eHAuVktfRk9STUFUX1I4RzhfU0lOVF06ICdyZzhzaW50JyxcclxuICAgIC8vIDMyLWJpdCBmb3JtYXRzXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjMyX1VJTlRdOiAncjMydWludCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjMyX1NJTlRdOiAncjMyc2ludCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjMyX1NGTE9BVF06ICdyMzJmbG9hdCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjE2RzE2X1VJTlRdOiAncmcxNnVpbnQnLFxyXG4gICAgW2t0eHAuVktfRk9STUFUX1IxNkcxNl9TSU5UXTogJ3JnMTZzaW50JyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9SMTZHMTZfU0ZMT0FUXTogJ3JnMTZmbG9hdCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjhHOEI4QThfVU5PUk1dOiAncmdiYTh1bm9ybScsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjhHOEI4QThfU1JHQl06ICdyZ2JhOHVub3JtLXNyZ2InLFxyXG4gICAgW2t0eHAuVktfRk9STUFUX1I4RzhCOEE4X1NOT1JNXTogJ3JnYmE4c25vcm0nLFxyXG4gICAgW2t0eHAuVktfRk9STUFUX1I4RzhCOEE4X1VJTlRdOiAncmdiYTh1aW50JyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9SOEc4QjhBOF9TSU5UXTogJ3JnYmE4c2ludCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfQjhHOFI4QThfVU5PUk1dOiAnYmdyYTh1bm9ybScsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfQjhHOFI4QThfU1JHQl06ICdiZ3JhOHVub3JtLXNyZ2InLFxyXG4gICAgLy8gUGFja2VkIDMyLWJpdCBmb3JtYXRzXHJcbiAgICBba3R4cC5WS19GT1JNQVRfRTVCOUc5UjlfVUZMT0FUX1BBQ0szMl06ICdyZ2I5ZTV1ZmxvYXQnLFxyXG4gICAgW2t0eHAuVktfRk9STUFUX0EyUjEwRzEwQjEwX1VJTlRfUEFDSzMyXTogJ3JnYjEwYTJ1aW50JyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9BMlIxMEcxMEIxMF9VTk9STV9QQUNLMzJdOiAncmdiMTBhMnVub3JtJyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9CMTBHMTFSMTFfVUZMT0FUX1BBQ0szMl06ICdyZzExYjEwdWZsb2F0JyxcclxuICAgIC8vIDY0LWJpdCBmb3JtYXRzXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjMyRzMyX1VJTlRdOiAncmczMnVpbnQnLFxyXG4gICAgW2t0eHAuVktfRk9STUFUX1IzMkczMl9TSU5UXTogJ3JnMzJzaW50JyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9SMzJHMzJfU0ZMT0FUXTogJ3JnMzJmbG9hdCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjE2RzE2QjE2QTE2X1VJTlRdOiAncmdiYTE2dWludCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjE2RzE2QjE2QTE2X1NJTlRdOiAncmdiYTE2c2ludCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfUjE2RzE2QjE2QTE2X1NGTE9BVF06ICdyZ2JhMTZmbG9hdCcsXHJcbiAgICAvLyAxMjgtYml0IGZvcm1hdHNcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9SMzJHMzJCMzJBMzJfVUlOVF06ICdyZ2JhMzJ1aW50JyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9SMzJHMzJCMzJBMzJfU0lOVF06ICdyZ2JhMzJzaW50JyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9SMzJHMzJCMzJBMzJfU0ZMT0FUXTogJ3JnYmEzMmZsb2F0JyxcclxuICAgIC8vIEJDIGNvbXByZXNzZWQgZm9ybWF0cyB1c2FibGUgaWYgXCJ0ZXh0dXJlLWNvbXByZXNzaW9uLWJjXCIgaXMgYm90aFxyXG4gICAgLy8gc3VwcG9ydGVkIGJ5IHRoZSBkZXZpY2UvdXNlciBhZ2VudCBhbmQgZW5hYmxlZCBpbiByZXF1ZXN0RGV2aWNlLlxyXG4gICAgW2t0eHAuVktfRk9STUFUX0JDMV9SR0JBX1VOT1JNX0JMT0NLXTogJ2JjMS1yZ2JhLXVub3JtJyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9CQzFfUkdCQV9TUkdCX0JMT0NLXTogJ2JjMS1yZ2JhLXVub3JtLXNyZ2InLFxyXG4gICAgW2t0eHAuVktfRk9STUFUX0JDMl9VTk9STV9CTE9DS106ICdiYzItcmdiYS11bm9ybScsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfQkMyX1NSR0JfQkxPQ0tdOiAnYmMyLXJnYmEtdW5vcm0tc3JnYicsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfQkMzX1VOT1JNX0JMT0NLXTogJ2JjMy1yZ2JhLXVub3JtJyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9CQzNfU1JHQl9CTE9DS106ICdiYzMtcmdiYS11bm9ybS1zcmdiJyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9CQzRfVU5PUk1fQkxPQ0tdOiAnYmM0LXItdW5vcm0nLFxyXG4gICAgW2t0eHAuVktfRk9STUFUX0JDNF9TTk9STV9CTE9DS106ICdiYzQtci1zbm9ybScsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfQkM1X1VOT1JNX0JMT0NLXTogJ2JjNS1yZy11bm9ybScsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfQkM1X1NOT1JNX0JMT0NLXTogJ2JjNS1yZy1zbm9ybScsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfQkM2SF9VRkxPQVRfQkxPQ0tdOiAnYmM2aC1yZ2ItdWZsb2F0JyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9CQzZIX1NGTE9BVF9CTE9DS106ICdiYzZoLXJnYi1mbG9hdCcsXHJcbiAgICBba3R4cC5WS19GT1JNQVRfQkM3X1VOT1JNX0JMT0NLXTogJ2JjNy1yZ2JhLXVub3JtJyxcclxuICAgIFtrdHhwLlZLX0ZPUk1BVF9CQzdfU1JHQl9CTE9DS106ICdiYzctcmdiYS11bm9ybS1zcmdiJyxcclxuICAgIC8vIEN1cnJlbnRseSB1bnN1cHBvcnRlZCBleHRlbnNpb24gZm9ybWF0czpcclxuICAgIC8vIEVUQzIgY29tcHJlc3NlZCBmb3JtYXRzIHVzYWJsZSBpZiBcInRleHR1cmUtY29tcHJlc3Npb24tZXRjMlwiIGlzIGJvdGhcclxuICAgIC8vIHN1cHBvcnRlZCBieSB0aGUgZGV2aWNlL3VzZXIgYWdlbnQgYW5kIGVuYWJsZWQgaW4gcmVxdWVzdERldmljZS5cclxuICAgIC8vIFwiZXRjMi1yZ2I4dW5vcm1cIixcclxuICAgIC8vIFwiZXRjMi1yZ2I4dW5vcm0tc3JnYlwiLFxyXG4gICAgLy8gXCJldGMyLXJnYjhhMXVub3JtXCIsXHJcbiAgICAvLyBcImV0YzItcmdiOGExdW5vcm0tc3JnYlwiLFxyXG4gICAgLy8gXCJldGMyLXJnYmE4dW5vcm1cIixcclxuICAgIC8vIFwiZXRjMi1yZ2JhOHVub3JtLXNyZ2JcIixcclxuICAgIC8vIFwiZWFjLXIxMXVub3JtXCIsXHJcbiAgICAvLyBcImVhYy1yMTFzbm9ybVwiLFxyXG4gICAgLy8gXCJlYWMtcmcxMXVub3JtXCIsXHJcbiAgICAvLyBcImVhYy1yZzExc25vcm1cIixcclxuICAgIC8vIEFTVEMgY29tcHJlc3NlZCBmb3JtYXRzIHVzYWJsZSBpZiBcInRleHR1cmUtY29tcHJlc3Npb24tYXN0Y1wiIGlzIGJvdGhcclxuICAgIC8vIHN1cHBvcnRlZCBieSB0aGUgZGV2aWNlL3VzZXIgYWdlbnQgYW5kIGVuYWJsZWQgaW4gcmVxdWVzdERldmljZS5cclxuICAgIC8vIFwiYXN0Yy00eDQtdW5vcm1cIixcclxuICAgIC8vIFwiYXN0Yy00eDQtdW5vcm0tc3JnYlwiLFxyXG4gICAgLy8gXCJhc3RjLTV4NC11bm9ybVwiLFxyXG4gICAgLy8gXCJhc3RjLTV4NC11bm9ybS1zcmdiXCIsXHJcbiAgICAvLyBcImFzdGMtNXg1LXVub3JtXCIsXHJcbiAgICAvLyBcImFzdGMtNXg1LXVub3JtLXNyZ2JcIixcclxuICAgIC8vIFwiYXN0Yy02eDUtdW5vcm1cIixcclxuICAgIC8vIFwiYXN0Yy02eDUtdW5vcm0tc3JnYlwiLFxyXG4gICAgLy8gXCJhc3RjLTZ4Ni11bm9ybVwiLFxyXG4gICAgLy8gXCJhc3RjLTZ4Ni11bm9ybS1zcmdiXCIsXHJcbiAgICAvLyBcImFzdGMtOHg1LXVub3JtXCIsXHJcbiAgICAvLyBcImFzdGMtOHg1LXVub3JtLXNyZ2JcIixcclxuICAgIC8vIFwiYXN0Yy04eDYtdW5vcm1cIixcclxuICAgIC8vIFwiYXN0Yy04eDYtdW5vcm0tc3JnYlwiLFxyXG4gICAgLy8gXCJhc3RjLTh4OC11bm9ybVwiLFxyXG4gICAgLy8gXCJhc3RjLTh4OC11bm9ybS1zcmdiXCIsXHJcbiAgICAvLyBcImFzdGMtMTB4NS11bm9ybVwiLFxyXG4gICAgLy8gXCJhc3RjLTEweDUtdW5vcm0tc3JnYlwiLFxyXG4gICAgLy8gXCJhc3RjLTEweDYtdW5vcm1cIixcclxuICAgIC8vIFwiYXN0Yy0xMHg2LXVub3JtLXNyZ2JcIixcclxuICAgIC8vIFwiYXN0Yy0xMHg4LXVub3JtXCIsXHJcbiAgICAvLyBcImFzdGMtMTB4OC11bm9ybS1zcmdiXCIsXHJcbiAgICAvLyBcImFzdGMtMTB4MTAtdW5vcm1cIixcclxuICAgIC8vIFwiYXN0Yy0xMHgxMC11bm9ybS1zcmdiXCIsXHJcbiAgICAvLyBcImFzdGMtMTJ4MTAtdW5vcm1cIixcclxuICAgIC8vIFwiYXN0Yy0xMngxMC11bm9ybS1zcmdiXCIsXHJcbiAgICAvLyBcImFzdGMtMTJ4MTItdW5vcm1cIixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBUZXh0dXJlRm9ybWF0VG9TaXplOiBQYXJ0aWFsPFJlY29yZDxHUFVUZXh0dXJlRm9ybWF0LCBudW1iZXI+PiA9IHtcclxuICAgIC8vIDgtYml0IGZvcm1hdHNcclxuICAgIHI4dW5vcm06IDEsXHJcbiAgICByOHNub3JtOiAxLFxyXG4gICAgcjh1aW50OiAxLFxyXG4gICAgcjhzaW50OiAxLFxyXG4gICAgLy8gMTYtYml0IGZvcm1hdHNcclxuICAgIHIxNnVpbnQ6IDIsXHJcbiAgICByMTZzaW50OiAyLFxyXG4gICAgcjE2ZmxvYXQ6IDIsXHJcbiAgICByZzh1bm9ybTogMixcclxuICAgIHJnOHNub3JtOiAyLFxyXG4gICAgcmc4dWludDogMixcclxuICAgIHJnOHNpbnQ6IDIsXHJcbiAgICAvLyAzMi1iaXQgZm9ybWF0c1xyXG4gICAgcjMydWludDogNCxcclxuICAgIHIzMnNpbnQ6IDQsXHJcbiAgICByMzJmbG9hdDogNCxcclxuICAgIHJnMTZ1aW50OiA0LFxyXG4gICAgcmcxNnNpbnQ6IDQsXHJcbiAgICByZzE2ZmxvYXQ6IDQsXHJcbiAgICByZ2JhOHVub3JtOiA0LFxyXG4gICAgJ3JnYmE4dW5vcm0tc3JnYic6IDQsXHJcbiAgICByZ2JhOHNub3JtOiA0LFxyXG4gICAgcmdiYTh1aW50OiA0LFxyXG4gICAgcmdiYThzaW50OiA0LFxyXG4gICAgYmdyYTh1bm9ybTogNCxcclxuICAgICdiZ3JhOHVub3JtLXNyZ2InOiA0LFxyXG4gICAgLy8gUGFja2VkIDMyLWJpdCBmb3JtYXRzXHJcbiAgICByZ2I5ZTV1ZmxvYXQ6IDQsXHJcbiAgICByZ2IxMGEydWludDogNCxcclxuICAgIHJnYjEwYTJ1bm9ybTogNCxcclxuICAgIHJnMTFiMTB1ZmxvYXQ6IDQsXHJcbiAgICAvLyA2NC1iaXQgZm9ybWF0c1xyXG4gICAgcmczMnVpbnQ6IDgsXHJcbiAgICByZzMyc2ludDogOCxcclxuICAgIHJnMzJmbG9hdDogOCxcclxuICAgIHJnYmExNnVpbnQ6IDgsXHJcbiAgICByZ2JhMTZzaW50OiA4LFxyXG4gICAgcmdiYTE2ZmxvYXQ6IDgsXHJcbiAgICAvLyAxMjgtYml0IGZvcm1hdHNcclxuICAgIHJnYmEzMnVpbnQ6IDE2LFxyXG4gICAgcmdiYTMyc2ludDogMTYsXHJcbiAgICByZ2JhMzJmbG9hdDogMTYsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgVGV4dHVyZUZvcm1hdFRvQ2hhbm5lbFNpemU6IFBhcnRpYWw8UmVjb3JkPEdQVVRleHR1cmVGb3JtYXQsIG51bWJlcj4+ID0ge1xyXG4gICAgLy8gOC1iaXQgZm9ybWF0c1xyXG4gICAgcjh1bm9ybTogMSxcclxuICAgIHI4c25vcm06IDEsXHJcbiAgICByOHVpbnQ6IDEsXHJcbiAgICByOHNpbnQ6IDEsXHJcbiAgICAvLyAxNi1iaXQgZm9ybWF0c1xyXG4gICAgcjE2dWludDogMixcclxuICAgIHIxNnNpbnQ6IDIsXHJcbiAgICByMTZmbG9hdDogMixcclxuICAgIHJnOHVub3JtOiAxLFxyXG4gICAgcmc4c25vcm06IDEsXHJcbiAgICByZzh1aW50OiAxLFxyXG4gICAgcmc4c2ludDogMSxcclxuICAgIC8vIDMyLWJpdCBmb3JtYXRzXHJcbiAgICByMzJ1aW50OiA0LFxyXG4gICAgcjMyc2ludDogNCxcclxuICAgIHIzMmZsb2F0OiA0LFxyXG4gICAgcmcxNnVpbnQ6IDIsXHJcbiAgICByZzE2c2ludDogMixcclxuICAgIHJnMTZmbG9hdDogMixcclxuICAgIHJnYmE4dW5vcm06IDEsXHJcbiAgICAncmdiYTh1bm9ybS1zcmdiJzogMSxcclxuICAgIHJnYmE4c25vcm06IDEsXHJcbiAgICByZ2JhOHVpbnQ6IDEsXHJcbiAgICByZ2JhOHNpbnQ6IDEsXHJcbiAgICBiZ3JhOHVub3JtOiAxLFxyXG4gICAgJ2JncmE4dW5vcm0tc3JnYic6IDEsXHJcbiAgICAvLyBQYWNrZWQgMzItYml0IGZvcm1hdHNcclxuICAgIHJnYjllNXVmbG9hdDogNCxcclxuICAgIHJnYjEwYTJ1aW50OiA0LFxyXG4gICAgcmdiMTBhMnVub3JtOiA0LFxyXG4gICAgcmcxMWIxMHVmbG9hdDogNCxcclxuICAgIC8vIDY0LWJpdCBmb3JtYXRzXHJcbiAgICByZzMydWludDogNCxcclxuICAgIHJnMzJzaW50OiA0LFxyXG4gICAgcmczMmZsb2F0OiA0LFxyXG4gICAgcmdiYTE2dWludDogMixcclxuICAgIHJnYmExNnNpbnQ6IDIsXHJcbiAgICByZ2JhMTZmbG9hdDogMixcclxuICAgIC8vIDEyOC1iaXQgZm9ybWF0c1xyXG4gICAgcmdiYTMydWludDogNCxcclxuICAgIHJnYmEzMnNpbnQ6IDQsXHJcbiAgICByZ2JhMzJmbG9hdDogNCxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBXZWJHUFVUb1ZrRm9ybWF0ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxyXG4gICAgT2JqZWN0LmVudHJpZXMoVmtGb3JtYXRUb1dlYkdQVSkubWFwKChbdmssIHdncHVdKSA9PiBbd2dwdSwgcGFyc2VJbnQodmssIDEwKV0pLFxyXG4pIGFzIFJlY29yZDxHUFVUZXh0dXJlRm9ybWF0LCBrdHhwLlZLRm9ybWF0PjtcclxuXHJcbmV4cG9ydCBjb25zdCB0ZXh0dXJlVHlwZVRvRGltZW5zaW9uOiBSZWNvcmQ8c3RyaW5nLCBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbj4gPSB7XHJcbiAgICB0ZXh0dXJlX2N1YmU6ICdjdWJlJyxcclxuICAgIHRleHR1cmVfM2Q6ICczZCcsXHJcbiAgICB0ZXh0dXJlXzJkOiAnMmQnLFxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///838\n")},427:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ cubemap_blur_sample)\n});\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/es6.js + 4 modules\nvar es6 = __webpack_require__(777);\n;// CONCATENATED MODULE: ./public/environment-maps/shoreline.ktx2\nconst shoreline_namespaceObject = __webpack_require__.p + \"cbc03dc5dc89564ca7ef.ktx2\";\n;// CONCATENATED MODULE: ./public/environment-maps/papermill.ktx2\nconst papermill_namespaceObject = __webpack_require__.p + \"9415fdbc706f67f268b7.ktx2\";\n;// CONCATENATED MODULE: ./public/environment-maps/leland-market.ktx2\nconst leland_market_namespaceObject = __webpack_require__.p + \"e17791c0693ab4a8220f.ktx2\";\n// EXTERNAL MODULE: ./src/samples/property-listener.ts\nvar property_listener = __webpack_require__(564);\n// EXTERNAL MODULE: ./node_modules/.pnpm/ktx-parse@0.7.0/node_modules/ktx-parse/dist/ktx-parse.modern.js\nvar ktx_parse_modern = __webpack_require__(380);\n// EXTERNAL MODULE: ./src/rendering/constants.ts\nvar constants = __webpack_require__(838);\n// EXTERNAL MODULE: ./src/utils/general.ts\nvar general = __webpack_require__(986);\n;// CONCATENATED MODULE: ./src/utils/data-copy.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nfunction createAndCopyBuffer(arr, usage, device, label, alignment = 4) {\n    const pad = alignment - 1;\n    const buffer = device.createBuffer({\n        label,\n        usage,\n        size: (arr.byteLength + pad) & ~pad,\n        mappedAtCreation: true,\n    });\n    const writeArray = new Uint8Array(buffer.getMappedRange());\n    const readArray = arr instanceof ArrayBuffer\n        ? new Uint8Array(arr)\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n    writeArray.set(readArray);\n    buffer.unmap();\n    return buffer;\n}\nfunction createAndCopyCubemap(device, data, format, usage, label) {\n    const pixelSize = TextureFormatToSize[format];\n    if (pixelSize == null) {\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\n    }\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\n    const size = { width, height: width, depthOrArrayLayers: 6 };\n    const texture = device.createTexture({\n        usage: usage | GPUTextureUsage.COPY_DST,\n        label,\n        format,\n        size,\n    });\n    device.queue.writeTexture({ texture }, data, { bytesPerRow: width * pixelSize, rowsPerImage: width }, size);\n    return texture;\n}\nfunction copyKTX(resource, device, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let buf;\n        if (resource instanceof ArrayBuffer) {\n            buf = resource;\n        }\n        else if (resource instanceof File) {\n            buf = yield resource.arrayBuffer();\n        }\n        else {\n            const response = yield fetch(resource);\n            buf = yield response.arrayBuffer();\n        }\n        const ktx = ktx_parse_modern/* read */.LF4(new Uint8Array(buf));\n        const format = constants/* VkFormatToWebGPU */.Oi[ktx.vkFormat];\n        if (format == null) {\n            throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not covert to webgpu`);\n        }\n        const pixelSize = constants/* TextureFormatToSize */.T2[format];\n        if (pixelSize == null) {\n            throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not get pixel byte size`);\n        }\n        const size = {\n            width: ktx.pixelWidth,\n            height: ktx.pixelHeight,\n            depthOrArrayLayers: ktx.faceCount,\n        };\n        const maxMipCount = Math.ceil(Math.log2(Math.max(size.width, size.height))) + 1;\n        let mipLevelCount = ktx.levels.length;\n        if ((options === null || options === void 0 ? void 0 : options.mipLevelCount) === 'max') {\n            mipLevelCount = maxMipCount;\n        }\n        else if (typeof (options === null || options === void 0 ? void 0 : options.mipLevelCount) === 'number') {\n            mipLevelCount = Math.min(maxMipCount, options.mipLevelCount);\n        }\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n        if (options === null || options === void 0 ? void 0 : options.textureUsage)\n            usage |= options.textureUsage;\n        const texture = device.createTexture({\n            label: options === null || options === void 0 ? void 0 : options.label,\n            size,\n            mipLevelCount,\n            format,\n            usage,\n        });\n        const mipCopies = Math.min(ktx.levels.length, mipLevelCount) - 1;\n        for (let mipLevel = mipCopies; mipLevel >= 0; mipLevel -= 1) {\n            const width = size.width >> mipLevel;\n            const height = size.height >> mipLevel;\n            const { levelData } = ktx.levels[mipLevel];\n            const rawBytesPerRow = width * pixelSize;\n            const bytesPerRow = Math.max(rawBytesPerRow, 256);\n            const rowsPerImage = height;\n            const bytesPerImage = rowsPerImage * bytesPerRow;\n            let imageData = levelData;\n            if (bytesPerRow > rawBytesPerRow) {\n                imageData = new Uint8Array(bytesPerImage * texture.depthOrArrayLayers);\n                for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\n                    for (let w = 0; w < rawBytesPerRow; w += 1) {\n                        imageData[w + h * bytesPerRow] = levelData[w + h * rawBytesPerRow];\n                    }\n                }\n            }\n            const layerBatch = Math.min(Math.floor(device.limits.maxBufferSize / bytesPerImage), ktx.faceCount);\n            const layerCount = Math.ceil(ktx.faceCount / layerBatch);\n            for (let l = 0; l < layerCount; l += 1) {\n                const offset = l * layerBatch;\n                const count = Math.min(layerBatch, ktx.faceCount - offset);\n                const data = layerCount > 1\n                    ? imageData.subarray(offset * bytesPerImage, (offset + count) * bytesPerImage)\n                    : imageData;\n                device.queue.writeTexture({ mipLevel, texture, origin: [0, 0, offset] }, data, { bytesPerRow, rowsPerImage }, [width, height, count]);\n            }\n        }\n        return texture;\n    });\n}\nfunction textureToArrayBuffer(_a) {\n    return __awaiter(this, arguments, void 0, function* ({ device, texture, mipLevel = 0, returnBuffer, storageBuffer, resultBuffer, description, }) {\n        const pixelSize = constants/* TextureFormatToSize */.T2[texture.format];\n        const fullDescription = (0,general/* padTemplate */.OY) `[textureToKTX${description !== null && description !== void 0 ? description : ''}${texture.label}] --`;\n        if (pixelSize == null) {\n            throw new Error(`${fullDescription} format ${texture.format} unsupported`);\n        }\n        const width = texture.width >> mipLevel;\n        const height = texture.height >> mipLevel;\n        const rawBytesPerRow = width * pixelSize;\n        const bytesPerRow = Math.max(rawBytesPerRow, 256);\n        const rowsPerImage = height;\n        const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\n        const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\n        if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\n            throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\n        }\n        if (storageBuffer != null && storageBuffer.size < byteSize) {\n            throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\n        }\n        const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n        if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\n            throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\n        }\n        let imageData = resultBuffer !== null && resultBuffer !== void 0 ? resultBuffer : new Uint8Array(byteSize);\n        const storage = storageBuffer !== null && storageBuffer !== void 0 ? storageBuffer : device.createBuffer({\n            label: `${fullDescription} storage buffer`,\n            size: byteSize,\n            usage: requiredUsage,\n        });\n        const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\n        encoder.copyTextureToBuffer({ texture, mipLevel }, { buffer: storage, rowsPerImage, bytesPerRow }, { width, height, depthOrArrayLayers: texture.depthOrArrayLayers });\n        device.queue.submit([encoder.finish()]);\n        yield device.queue.onSubmittedWorkDone();\n        yield storage.mapAsync(GPUMapMode.READ, 0, byteSize);\n        const mapped = storage.getMappedRange(0, byteSize);\n        imageData.set(new Uint8Array(mapped));\n        storage.unmap();\n        if (bytesPerRow > rawBytesPerRow) {\n            for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\n                for (let w = 0; w < rawBytesPerRow; w += 1) {\n                    imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\n                }\n            }\n            imageData = imageData.slice(0, resultSize);\n        }\n        return {\n            imageData,\n            storageBuffer: returnBuffer ? storage : undefined,\n        };\n    });\n}\nfunction textureToKTX(device_1, texture_1) {\n    return __awaiter(this, arguments, void 0, function* (device, texture, cube = false) {\n        const pixelSize = constants/* TextureFormatToSize */.T2[texture.format];\n        const typeSize = constants/* TextureFormatToChannelSize */.GE[texture.format];\n        if (pixelSize == null || typeSize == null) {\n            throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\n        }\n        const container = new ktx_parse_modern/* KTX2Container */.nYd();\n        container.pixelWidth = texture.width;\n        container.pixelHeight = texture.height;\n        container.vkFormat = constants/* WebGPUToVkFormat */.KO[texture.format];\n        container.typeSize = typeSize;\n        delete container.keyValue.KTXswizzle;\n        const dataFormat = container.dataFormatDescriptor[0];\n        dataFormat.colorModel = ktx_parse_modern/* KHR_DF_MODEL_RGBSDA */.Tre;\n        dataFormat.transferFunction = ktx_parse_modern/* KHR_DF_TRANSFER_LINEAR */.T5j;\n        dataFormat.bytesPlane[0] = pixelSize;\n        dataFormat.samples = [0, 1, 2, 3].map((i) => ({\n            channelType: [192, 193, 194, 207][i],\n            samplePosition: [0, 0, 0, 0],\n            bitLength: container.typeSize * 8 - 1,\n            bitOffset: container.typeSize * 8 * i,\n            sampleLower: -1082130432,\n            sampleUpper: 1065353216,\n        }));\n        if (texture.dimension === '3d') {\n            container.faceCount = 1;\n            container.pixelDepth = texture.depthOrArrayLayers;\n        }\n        else if (cube) {\n            const cubeLayers = texture.depthOrArrayLayers / 6;\n            container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\n            container.faceCount = 6;\n        }\n        else {\n            container.layerCount = texture.depthOrArrayLayers;\n            container.faceCount = 1;\n        }\n        let storageBuffer;\n        let imageData;\n        for (let i = 0; i < texture.mipLevelCount; i += 1) {\n            // eslint-disable-next-line no-await-in-loop\n            ({ imageData, storageBuffer } = yield textureToArrayBuffer({\n                mipLevel: i,\n                returnBuffer: true,\n                device,\n                texture,\n                storageBuffer,\n            }));\n            container.levels.push({\n                levelData: imageData,\n                uncompressedByteLength: imageData.byteLength,\n            });\n        }\n        return ktx_parse_modern/* write */.M98(container);\n    });\n}\n\n;// CONCATENATED MODULE: ./src/samples/cubemap-blur/cubemap-guassian-pyramid.ts\n/* eslint @stylistic/max-len: \"error\" */\nvar cubemap_guassian_pyramid_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nconst cubemapSampling = /* wgsl */ `\r\n    const INVALID_FACE = 6;\r\n    const INVALID_IDX = 4294967295u; // max u32\r\n\r\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\r\n        // a flattened matrix of destination faces based on\r\n        // starting face and direction\r\n        const dfaces = array(\r\n            //                               I  Up Down Left Right Invalid\r\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \r\n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \r\n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \r\n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \r\n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \r\n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \r\n        );\r\n\r\n        // a flattend matrix in the same form as dfaces\r\n        // giving the index of the damts array containing \r\n        // the transformation from the starting face to \r\n        // the destination face\r\n        const dindices = array(\r\n            0, 1,  2,  3,  4,  0,\r\n            0, 5,  6,  3,  4,  0,\r\n            0, 7,  8,  9,  10, 0,\r\n            0, 11, 12, 13, 14, 0,\r\n            0, 11, 8,  3,  4,  0,\r\n            0, 7,  12, 3,  4,  0,\r\n        );\r\n\r\n        // 2x4 martices transforming a coordinate vector <u, v, w, 1>\r\n        // from one face to another\r\n        const dmats = array(\r\n            array(// 0\r\n                vec4(1, 0, 0, 0),   // u = u\r\n                vec4(0, 1, 0, 0),   // v = v\r\n            ),\r\n            array(// 1\r\n                vec4(0, 1, 1, 0),   // u = v + w\r\n                vec4(-1, 0, 1, -1), // v = w - u - 1\r\n            ),\r\n            array(// 2\r\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\r\n                vec4(1, 0, 0, 0),   // v = u\r\n            ),\r\n            array(// 3\r\n                vec4(1, 0, 1, 0),   // u = u + w\r\n                vec4(0, 1, 0, 0),   // v = v\r\n            ),\r\n            array(// 4\r\n                vec4(1, 0, -1, 0),  // u = u - w\r\n                vec4(0, 1, 0, 0),   // v = v\r\n            ),\r\n            array(// 5\r\n                vec4(0, -1, 0, -1), // u = -v - 1\r\n                vec4(1, 0, 0, 0),   // v = u\r\n            ),\r\n            array(// 6\r\n                vec4(0, 1, -1, 0),  // u = v - w\r\n                vec4(-1, 0, 1, -1), // v = w - u - 1\r\n            ),\r\n            array(// 7\r\n                vec4(-1, 0, 1, -1), // u = w - u - 1\r\n                vec4(0, -1, 0, -1), // v = -v - 1\r\n            ),\r\n            array(// 8\r\n                vec4(1, 0, 0, 0),   // u = u\r\n                vec4(0, 1, -1, 0),  // v = v - w\r\n            ),\r\n            array(// 9\r\n                vec4(0, 1, 0, 0),   // u = v\r\n                vec4(-1, 0, 0, -1), // v = -u - 1\r\n            ),\r\n            array(// 10\r\n                vec4(0, -1, 1, -1), // u = w - v - 1\r\n                vec4(1, 0, -1, 0),  // v = u - w\r\n            ),\r\n            array(// 11\r\n                vec4(1, 0, 0, 0),   // u = u\r\n                vec4(0, 1, 1, 0),   // v = v + w\r\n            ),\r\n            array(// 12\r\n                vec4(-1, 0, 1, -1), // u = w - u - 1\r\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\r\n            ),\r\n            array(// 13\r\n                vec4(0, -1, 1, -1), // u = w - v - 1\r\n                vec4(1, 0, 1, 0),   // v = u + w\r\n            ),\r\n            array(// 14\r\n                vec4(0, 1, 0, 0),   // u = v\r\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\r\n            ),\r\n        );\r\n\r\n        let iw = i32(w);\r\n\r\n        var dir = 0;\r\n        if (\r\n            coord.y >= iw * 2 - 1 \r\n            || coord.y <= -iw \r\n            || coord.x >= iw * 2 - 1 \r\n            || coord.x <= -iw\r\n        ) {\r\n            dir = 5;\r\n        } else {\r\n            if (coord.y < 0) {\r\n                dir = 1;\r\n            } else if (coord.y >= iw) {\r\n                dir = 2;\r\n            }\r\n            if (coord.x < 0) {\r\n                dir = select(5, 3, dir == 0);\r\n            } else if (coord.x >= iw) {\r\n                dir = select(5, 4, dir == 0);\r\n            }\r\n        }\r\n\r\n        let idx = coord.z * 6 + dir;\r\n        let samp = vec4(coord.xy, iw, 1);\r\n        let dmat = dmats[dindices[idx]];\r\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\r\n    }\r\n\r\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\r\n        return coord.x + coord.y * w + coord.z * w * w;\r\n    }\r\n\r\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\r\n        let w2 = w * w;\r\n        let fidx = idx % w2;\r\n        return vec3u(fidx % w, fidx / w, idx / w2);\r\n    }\r\n\r\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\r\n        let coord = cubeSampleCoord(uvf, w);\r\n        return select(\r\n            cubeCoordToIdx(coord, w), \r\n            INVALID_IDX, \r\n            coord.z == INVALID_FACE,\r\n        );\r\n    }\r\n`;\nconst createMipBlurCode = (groups, format) => /* wgsl */ `\r\n    ${cubemapSampling}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    fn to_world_coords(coord: vec3u, size: u32) -> vec3f {\r\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\r\n\r\n        var pos: vec3f;\r\n        switch (coord.z) {\r\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\r\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\r\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\r\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\r\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\r\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\r\n        }\r\n\r\n        return normalize(pos);\r\n    }\r\n\r\n    @group(0) @binding(0) var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    // simga[0] resevered for work offset\r\n    @group(0) @binding(2) var<storage> sigmas : array<f32>;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + u32(sigmas[0]);\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = to_world_coords(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = to_world_coords(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\n// the minimum angular distance between any pixel on a cubemap\n// of the given face width and any pixel lying on a perimeter\n// the given number of steps away\nfunction minStepDistance(steps, width) {\n    // the angular distance\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\n    // It's likely possible to programitically determine whether the destition\n    // pixel should be v = 0 or v = 1, but checking both works fine\n    const nextMipWidth = width >> 1;\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\n    const baseUN = (1 / nextMipWidth) - 1;\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\n    const samp0VN = (1 / width) - 1;\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\n    const samp1VN = (3 / width) - 1;\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN)\n        / Math.sqrt(samp0Mag2 * baseMag2);\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN)\n        / Math.sqrt(samp1Mag2 * baseMag2);\n    return Math.min(1 - dot0, 1 - dot1);\n}\nfunction cubemapGuassianPyramid(_a) {\n    return cubemap_guassian_pyramid_awaiter(this, arguments, void 0, function* ({ device, texture, outputTextureLabel, inPlace = false, minWidth = 8, steps = 4, maxOpsPerPass = 6 * (Math.pow((32 * 256), 2)), delayWork = (fn) => { void fn(); }, labelTag = `${cubemapGuassianPyramid.name} --`, }) {\n        const { width, format } = texture;\n        const mipLevelCount = inPlace\n            ? texture.mipLevelCount\n            : (Math.log2(width) - Math.log2(minWidth) + 1);\n        if (mipLevelCount <= 1)\n            return texture;\n        const groups = Math.min(device.limits.maxComputeWorkgroupSizeX, device.limits.maxComputeInvocationsPerWorkgroup);\n        const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\n        const shader = device.createShaderModule({\n            label: `${labelTag} shader`,\n            code: createMipBlurCode(groups, format),\n        });\n        const bindgroupLayout = device.createBindGroupLayout({\n            label: `${labelTag} bindgroup layout`,\n            entries: [\n                {\n                    binding: 0,\n                    texture: { viewDimension: '2d-array' },\n                    visibility: GPUShaderStage.COMPUTE,\n                },\n                {\n                    binding: 1,\n                    storageTexture: {\n                        access: 'write-only',\n                        viewDimension: '2d-array',\n                        format,\n                    },\n                    visibility: GPUShaderStage.COMPUTE,\n                },\n                {\n                    binding: 2,\n                    buffer: { type: 'read-only-storage' },\n                    visibility: GPUShaderStage.COMPUTE,\n                },\n            ],\n        });\n        const pipeline = device.createComputePipeline({\n            label: `${labelTag} pipeline`,\n            layout: device.createPipelineLayout({\n                label: `${labelTag} -- pipeline layout`,\n                bindGroupLayouts: [bindgroupLayout],\n            }),\n            compute: {\n                module: shader,\n                entryPoint: 'main',\n                constants: { STEPS: Math.ceil(steps) },\n            },\n        });\n        let gaussianPyramid = texture;\n        if (!inPlace) {\n            const size = { width, height: width, depthOrArrayLayers: 6 };\n            gaussianPyramid = device.createTexture({\n                label: outputTextureLabel,\n                usage: GPUTextureUsage.STORAGE_BINDING\n                    | GPUTextureUsage.TEXTURE_BINDING\n                    | GPUTextureUsage.COPY_SRC\n                    | GPUTextureUsage.COPY_DST,\n                dimension: '2d',\n                format,\n                mipLevelCount,\n                size,\n            });\n            const copyEncoder = device.createCommandEncoder({\n                label: `${labelTag} copy encoder`,\n            });\n            copyEncoder.copyTextureToTexture({ texture, mipLevel: 0 }, { texture: gaussianPyramid, mipLevel: 0 }, size);\n            device.queue.submit([copyEncoder.finish()]);\n            yield device.queue.onSubmittedWorkDone();\n        }\n        const mipViews = (0,general/* mapRange */._b)(mipLevelCount, (i) => gaussianPyramid.createView({\n            label: `${labelTag} mip view ${i}`,\n            dimension: '2d-array',\n            baseMipLevel: i,\n            mipLevelCount: 1,\n        }));\n        const maxDispatches = Math.max((maxOpsPerPass / ((Math.pow((1 + (steps * 2)), 2)) * groups)) | 0, 1);\n        const maxLayers = Math.ceil(Math.log2(width));\n        const propertyArray = new Float32Array([0, ...(0,general/* mapRange */._b)(maxLayers, (i) => {\n                const w = width >> i;\n                return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\n            })]);\n        const propertyBuffer = createAndCopyBuffer(propertyArray, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, device);\n        yield new Promise((resolve) => {\n            let mipLevel = 0;\n            let mipPasses = 0;\n            let requiredMipDispatches = 0;\n            let currentMipDispatches = 0;\n            let batchDispatches = 0;\n            let bindgroup;\n            function runPass() {\n                return cubemap_guassian_pyramid_awaiter(this, void 0, void 0, function* () {\n                    if (currentMipDispatches >= requiredMipDispatches) {\n                        mipLevel += 1;\n                        currentMipDispatches = 0;\n                        mipPasses = 0;\n                        if (mipLevel >= mipLevelCount) {\n                            resolve();\n                            return;\n                        }\n                        const mipPixels = 6 * (Math.pow((width >> mipLevel), 2));\n                        requiredMipDispatches = Math.ceil(mipPixels / groups);\n                        bindgroup = device.createBindGroup({\n                            layout: bindgroupLayout,\n                            entries: [\n                                {\n                                    binding: 0,\n                                    resource: mipViews[mipLevel - 1],\n                                },\n                                {\n                                    binding: 1,\n                                    resource: mipViews[mipLevel],\n                                },\n                                {\n                                    binding: 2,\n                                    resource: { buffer: propertyBuffer },\n                                },\n                            ],\n                        });\n                    }\n                    propertyArray[0] = currentMipDispatches * groups;\n                    device.queue.writeBuffer(propertyBuffer, 0, propertyArray, 0, 1);\n                    const passDispatches = Math.min(requiredMipDispatches - currentMipDispatches, maxDispatches - batchDispatches, maxWorkgroups);\n                    const passEncoder = device.createCommandEncoder({\n                        label: `${labelTag} mip ${mipLevel}, pass ${mipPasses} encoder`,\n                    });\n                    const pass = passEncoder.beginComputePass({\n                        label: `${labelTag} mip ${mipLevel}, pass ${mipPasses}`,\n                    });\n                    pass.setPipeline(pipeline);\n                    pass.setBindGroup(0, bindgroup);\n                    pass.dispatchWorkgroups(passDispatches, 1, 1);\n                    pass.end();\n                    device.queue.submit([passEncoder.finish()]);\n                    currentMipDispatches += passDispatches;\n                    batchDispatches += passDispatches;\n                    mipPasses += 1;\n                    if (batchDispatches >= maxDispatches) {\n                        batchDispatches = 0;\n                        yield device.queue.onSubmittedWorkDone();\n                        delayWork(runPass);\n                    }\n                    else {\n                        void runPass();\n                    }\n                });\n            }\n            void runPass();\n        });\n        return gaussianPyramid;\n    });\n}\n\n;// CONCATENATED MODULE: ./src/samples/cubemap-blur/cubemap-blur-sample.ts\nvar cubemap_blur_sample_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CubemapBlurModel_settings;\n\n\n\n\n\n\n\n\nvar BlurState;\n(function (BlurState) {\n    BlurState[BlurState[\"IDLE\"] = 0] = \"IDLE\";\n    BlurState[BlurState[\"BLUR\"] = 1] = \"BLUR\";\n    BlurState[BlurState[\"WAIT\"] = 2] = \"WAIT\";\n})(BlurState || (BlurState = {}));\nclass CubemapBlurModel {\n    constructor(device, skyboxTarget, target) {\n        this.device = device;\n        this.skyboxTarget = skyboxTarget;\n        this.colorAttachment = {\n            clearValue: { r: 0, g: 0, b: 0, a: 1 },\n            loadOp: 'clear',\n            storeOp: 'store',\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            view: undefined,\n        };\n        this.passDescriptor = { colorAttachments: [this.colorAttachment] };\n        this.state = BlurState.IDLE;\n        _CubemapBlurModel_settings.set(this, (0,property_listener/* default */.A)({\n            nearestSample: {\n                [property_listener/* ListenerSyms */.t.$type]: 'checkbox',\n                [property_listener/* ListenerSyms */.t.$callback]: (val) => {\n                    if (typeof val === 'boolean')\n                        this.skyboxTarget.useNearestSample = val;\n                },\n                value: this.skyboxTarget.useNearestSample,\n                description: 'Disables linear sampling in the viewer.',\n            },\n            mipLevel: {\n                [property_listener/* ListenerSyms */.t.$type]: 'slider',\n                [property_listener/* ListenerSyms */.t.$callback]: (value) => {\n                    if (typeof value === 'number')\n                        this.skyboxTarget.mipLevel = value;\n                },\n                value: 0,\n                min: 0,\n                max: 1,\n                step: 0.1,\n                description: 'The mip level to display in the viewer. 0 is the orignal image, max is completely blurred with 1 pixel faces.',\n            },\n            filterDistance: {\n                [property_listener/* ListenerSyms */.t.$type]: 'slider',\n                [property_listener/* ListenerSyms */.t.$callback]: this.reblur.bind(this),\n                value: 2,\n                max: 64,\n                min: 0,\n                step: 0.1,\n                description: 'The number of pixels to blur from.',\n            },\n            skybox: {\n                [property_listener/* ListenerSyms */.t.$type]: 'file',\n                [property_listener/* ListenerSyms */.t.$callback]: (val, key) => {\n                    if (key === 'value' && val != null)\n                        void val.then(this.setSkybox.bind(this));\n                },\n                accept: '.ktx2',\n                selection: {\n                    value: 'papermill',\n                    initialValues: (0,general/* mapValues */.LG)({ papermill: papermill_namespaceObject, shoreline: shoreline_namespaceObject, market: leland_market_namespaceObject }, this.processSkybox.bind(this)),\n                },\n                process: this.processSkybox.bind(this),\n            },\n            'Download Result': {\n                [property_listener/* ListenerSyms */.t.$type]: 'button',\n                onClick: () => { void this.saveFile(); },\n            },\n        }));\n        this.settings = __classPrivateFieldGet(this, _CubemapBlurModel_settings, \"f\").publicSettings;\n        this.depthTexture = device.createTexture({\n            dimension: '2d',\n            format: 'depth32float',\n            size: { width: 1, height: 1 },\n            usage: GPUTextureUsage.RENDER_ATTACHMENT\n                | GPUTextureUsage.TEXTURE_BINDING,\n        });\n        this.depthTextureView = this.depthTexture.createView();\n        this.colorAttachment.view = target.view;\n        const encoder = device.createCommandEncoder({ label: 'cubemap blur dummy depth encoder' });\n        const pass = encoder.beginRenderPass({\n            colorAttachments: [],\n            depthStencilAttachment: {\n                depthClearValue: 1,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n                view: this.depthTextureView,\n            },\n        });\n        pass.end();\n        this.device.queue.submit([encoder.finish()]);\n    }\n    render(encoder) {\n        return encoder.beginRenderPass(this.passDescriptor);\n    }\n    setTarget(view) {\n        this.colorAttachment.view = view.view;\n    }\n    processSkybox(file) {\n        return copyKTX(file, this.device, {\n            mipLevelCount: 'max',\n            textureUsage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n            validate: true,\n        });\n    }\n    setSkybox(resource) {\n        return cubemap_blur_sample_awaiter(this, void 0, void 0, function* () {\n            this.skybox = resource instanceof GPUTexture\n                ? resource\n                : yield this.processSkybox(resource);\n            __classPrivateFieldGet(this, _CubemapBlurModel_settings, \"f\").privateSettings.mipLevel.max = this.skybox.mipLevelCount - 1;\n            __classPrivateFieldGet(this, _CubemapBlurModel_settings, \"f\").privateSettings.mipLevel.value = 1;\n            this.skyboxTarget.mipLevel = 1;\n            void this.reblur();\n        });\n    }\n    resolve() {\n        this.refresh();\n        const lastState = this.state;\n        this.state = BlurState.IDLE;\n        if (lastState === BlurState.WAIT)\n            void this.reblur();\n    }\n    reblur() {\n        return cubemap_blur_sample_awaiter(this, void 0, void 0, function* () {\n            if (this.skybox == null || this.state === BlurState.WAIT)\n                return;\n            if (this.state === BlurState.BLUR) {\n                this.state = BlurState.WAIT;\n                return;\n            }\n            this.state = BlurState.BLUR;\n            yield cubemapGuassianPyramid({\n                device: this.device,\n                texture: this.skybox,\n                inPlace: true,\n                steps: this.settings.filterDistance.value,\n                delayWork: requestAnimationFrame,\n            });\n            this.resolve();\n        });\n    }\n    refresh() {\n        if (this.skybox == null)\n            return;\n        this.skyboxTarget.skyTexture = this.skybox.createView({ dimension: 'cube' });\n    }\n    saveFile() {\n        return cubemap_blur_sample_awaiter(this, void 0, void 0, function* () {\n            if (this.skybox == null)\n                return;\n            try {\n                const proms = Promise.all([\n                    textureToKTX(this.device, this.skybox, true),\n                    (0,es6/* showSaveFilePicker */.H1)({\n                        types: [{ accept: { 'image/ktx2': ['.ktx2'] } }],\n                        suggestedName: 'blured-skybox.ktx2',\n                    }).then((handle) => handle.createWritable({ keepExistingData: false })),\n                ]);\n                const [ktx2, stream] = yield proms;\n                yield new Blob([ktx2], { type: 'image/ktx2' }).stream().pipeTo(stream);\n            }\n            catch (e) {\n                console.warn(e);\n            }\n        });\n    }\n}\n_CubemapBlurModel_settings = new WeakMap();\nCubemapBlurModel.title = '';\nCubemapBlurModel.description = '';\n/* harmony default export */ const cubemap_blur_sample = (CubemapBlurModel);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFjLENBQUMsRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO2lCQUMxRSxDQUFDLENBQUM7Z0JBRUgsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsR0FBRyxNQUFNLEtBQUssQ0FBQztnQkFDbkMsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzNFLENBQUM7WUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO2dCQUNULE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEIsQ0FBQztRQUNMLENBQUM7S0FBQTs7O0FBbExNLHNCQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ1gsNEJBQVcsR0FBRyxFQUFFLENBQUM7MERBRlAsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViZ3B1LWJhc2ljLy4vc3JjL3V0aWxzL2RhdGEtY29weS50cz9iYTVmIiwid2VicGFjazovL3dlYmdwdS1iYXNpYy8uL3NyYy9zYW1wbGVzL2N1YmVtYXAtYmx1ci9jdWJlbWFwLWd1YXNzaWFuLXB5cmFtaWQudHM/ZDc4ZSIsIndlYnBhY2s6Ly93ZWJncHUtYmFzaWMvLi9zcmMvc2FtcGxlcy9jdWJlbWFwLWJsdXIvY3ViZW1hcC1ibHVyLXNhbXBsZS50cz80ZTI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGt0eHBhcnNlIGZyb20gJ2t0eC1wYXJzZSc7XHJcblxyXG5pbXBvcnQgeyBWa0Zvcm1hdFRvV2ViR1BVLCBUZXh0dXJlRm9ybWF0VG9TaXplLCBUZXh0dXJlRm9ybWF0VG9DaGFubmVsU2l6ZSwgV2ViR1BVVG9Wa0Zvcm1hdCB9IGZyb20gJy4uL3JlbmRlcmluZy9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBwYWRUZW1wbGF0ZSB9IGZyb20gJy4vZ2VuZXJhbCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQW5kQ29weUJ1ZmZlcihcclxuICAgIGFycjogQXJyYXlCdWZmZXIgfCBUeXBlZEFycmF5TGlrZSxcclxuICAgIHVzYWdlOiBHUFVGbGFnc0NvbnN0YW50LFxyXG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXHJcbiAgICBsYWJlbD86IHN0cmluZyxcclxuICAgIGFsaWdubWVudCA9IDQsXHJcbik6IEdQVUJ1ZmZlciB7XHJcbiAgICBjb25zdCBwYWQgPSBhbGlnbm1lbnQgLSAxO1xyXG4gICAgY29uc3QgYnVmZmVyID0gZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgdXNhZ2UsXHJcbiAgICAgICAgc2l6ZTogKGFyci5ieXRlTGVuZ3RoICsgcGFkKSAmIH5wYWQsXHJcbiAgICAgICAgbWFwcGVkQXRDcmVhdGlvbjogdHJ1ZSxcclxuICAgIH0gYXMgR1BVQnVmZmVyRGVzY3JpcHRvcik7XHJcblxyXG4gICAgY29uc3Qgd3JpdGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpKTtcclxuICAgIGNvbnN0IHJlYWRBcnJheSA9IGFyciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXHJcbiAgICAgICAgPyBuZXcgVWludDhBcnJheShhcnIpXHJcbiAgICAgICAgOiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xyXG5cclxuICAgIHdyaXRlQXJyYXkuc2V0KHJlYWRBcnJheSk7XHJcbiAgICBidWZmZXIudW5tYXAoKTtcclxuXHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBUZXh0dXJlU2l6ZUluZm9Qcm9wcyA9IHtcclxuICAgIHdpZHRoOiBudW1iZXIsXHJcbiAgICBoZWlnaHQ6IG51bWJlcixcclxuICAgIGZvcm1hdD86IEdQVVRleHR1cmVGb3JtYXQsXHJcbiAgICBwaXhlbFNpemU/OiBudW1iZXIsXHJcbiAgICBtaXBMZXZlbD86IG51bWJlcixcclxuICAgIGRlcHRoT3JBcnJheUxheWVycz86IG51bWJlcixcclxuICAgIGN1YmU/OiBib29sZWFuLFxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFuZENvcHlDdWJlbWFwKFxyXG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXHJcbiAgICBkYXRhOiBBcnJheUJ1ZmZlcixcclxuICAgIGZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCxcclxuICAgIHVzYWdlOiBudW1iZXIsXHJcbiAgICBsYWJlbD86IHN0cmluZyxcclxuKSB7XHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW2Zvcm1hdF07XHJcbiAgICBpZiAocGl4ZWxTaXplID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvcHkgY3ViZW1hcCAtLSB1bnN1cHBvcnRlZCBmb3JtYXQ6ICR7Zm9ybWF0fWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5zcXJ0KGRhdGEuYnl0ZUxlbmd0aCAvICg2ICogcGl4ZWxTaXplKSk7XHJcbiAgICBjb25zdCBzaXplID0geyB3aWR0aCwgaGVpZ2h0OiB3aWR0aCwgZGVwdGhPckFycmF5TGF5ZXJzOiA2IH07XHJcblxyXG4gICAgY29uc3QgdGV4dHVyZSA9IGRldmljZS5jcmVhdGVUZXh0dXJlKHtcclxuICAgICAgICB1c2FnZTogdXNhZ2UgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1QsXHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgZm9ybWF0LFxyXG4gICAgICAgIHNpemUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXZpY2UucXVldWUud3JpdGVUZXh0dXJlKFxyXG4gICAgICAgIHsgdGV4dHVyZSB9LFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgeyBieXRlc1BlclJvdzogd2lkdGggKiBwaXhlbFNpemUsIHJvd3NQZXJJbWFnZTogd2lkdGggfSxcclxuICAgICAgICBzaXplLFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgS1RYQ29weU9wdGlvbnMgPSB7XHJcbiAgICBsYWJlbD86IHN0cmluZyxcclxuICAgIG1pcExldmVsQ291bnQ/OiBudW1iZXIgfCAnbWF4JyB8ICdkZWZhdWx0JyxcclxuICAgIHRleHR1cmVVc2FnZT86IG51bWJlcixcclxuICAgIHZhbGlkYXRlPzogYm9vbGVhbixcclxufTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb3B5S1RYKFxyXG4gICAgcmVzb3VyY2U6IHN0cmluZyB8IFVSTCB8IEFycmF5QnVmZmVyIHwgRmlsZSxcclxuICAgIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgb3B0aW9ucz86IEtUWENvcHlPcHRpb25zLFxyXG4pOiBQcm9taXNlPEdQVVRleHR1cmU+IHtcclxuICAgIGxldCBidWY6IEFycmF5QnVmZmVyO1xyXG4gICAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICBidWYgPSByZXNvdXJjZTtcclxuICAgIH0gZWxzZSBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XHJcbiAgICAgICAgYnVmID0gYXdhaXQgcmVzb3VyY2UuYXJyYXlCdWZmZXIoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXNvdXJjZSk7XHJcbiAgICAgICAgYnVmID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBrdHggPSBrdHhwYXJzZS5yZWFkKG5ldyBVaW50OEFycmF5KGJ1ZikpO1xyXG4gICAgY29uc3QgZm9ybWF0ID0gVmtGb3JtYXRUb1dlYkdQVVtrdHgudmtGb3JtYXRdO1xyXG5cclxuICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihga3R4IHRleHR1cmUgaW1wb3J0IC0tIHVuc3VwcG9ydGVkIGZvcm1hdDogJHtrdHgudmtGb3JtYXR9XFxuXFx0Q291bGQgbm90IGNvdmVydCB0byB3ZWJncHVgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW2Zvcm1hdF07XHJcbiAgICBpZiAocGl4ZWxTaXplID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGt0eCB0ZXh0dXJlIGltcG9ydCAtLSB1bnN1cHBvcnRlZCBmb3JtYXQ6ICR7a3R4LnZrRm9ybWF0fVxcblxcdENvdWxkIG5vdCBnZXQgcGl4ZWwgYnl0ZSBzaXplYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2l6ZSA9IHtcclxuICAgICAgICB3aWR0aDoga3R4LnBpeGVsV2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBrdHgucGl4ZWxIZWlnaHQsXHJcbiAgICAgICAgZGVwdGhPckFycmF5TGF5ZXJzOiBrdHguZmFjZUNvdW50LFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBtYXhNaXBDb3VudCA9IE1hdGguY2VpbChNYXRoLmxvZzIoTWF0aC5tYXgoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpKSkgKyAxO1xyXG4gICAgbGV0IG1pcExldmVsQ291bnQgPSBrdHgubGV2ZWxzLmxlbmd0aDtcclxuICAgIGlmIChvcHRpb25zPy5taXBMZXZlbENvdW50ID09PSAnbWF4Jykge1xyXG4gICAgICAgIG1pcExldmVsQ291bnQgPSBtYXhNaXBDb3VudDtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnM/Lm1pcExldmVsQ291bnQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgbWlwTGV2ZWxDb3VudCA9IE1hdGgubWluKG1heE1pcENvdW50LCBvcHRpb25zLm1pcExldmVsQ291bnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB1c2FnZSA9IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1Q7XHJcbiAgICBpZiAob3B0aW9ucz8udGV4dHVyZVVzYWdlKSB1c2FnZSB8PSBvcHRpb25zLnRleHR1cmVVc2FnZTtcclxuXHJcbiAgICBjb25zdCB0ZXh0dXJlID0gZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xyXG4gICAgICAgIGxhYmVsOiBvcHRpb25zPy5sYWJlbCxcclxuICAgICAgICBzaXplLFxyXG4gICAgICAgIG1pcExldmVsQ291bnQsXHJcbiAgICAgICAgZm9ybWF0LFxyXG4gICAgICAgIHVzYWdlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbWlwQ29waWVzID0gTWF0aC5taW4oa3R4LmxldmVscy5sZW5ndGgsIG1pcExldmVsQ291bnQpIC0gMTtcclxuXHJcbiAgICBmb3IgKGxldCBtaXBMZXZlbCA9IG1pcENvcGllczsgbWlwTGV2ZWwgPj0gMDsgbWlwTGV2ZWwgLT0gMSkge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gc2l6ZS53aWR0aCA+PiBtaXBMZXZlbDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBzaXplLmhlaWdodCA+PiBtaXBMZXZlbDtcclxuICAgICAgICBjb25zdCB7IGxldmVsRGF0YSB9ID0ga3R4LmxldmVsc1ttaXBMZXZlbF07XHJcblxyXG4gICAgICAgIGNvbnN0IHJhd0J5dGVzUGVyUm93ID0gd2lkdGggKiBwaXhlbFNpemU7XHJcbiAgICAgICAgY29uc3QgYnl0ZXNQZXJSb3cgPSBNYXRoLm1heChyYXdCeXRlc1BlclJvdywgMjU2KTtcclxuICAgICAgICBjb25zdCByb3dzUGVySW1hZ2UgPSBoZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgYnl0ZXNQZXJJbWFnZSA9IHJvd3NQZXJJbWFnZSAqIGJ5dGVzUGVyUm93O1xyXG5cclxuICAgICAgICBsZXQgaW1hZ2VEYXRhID0gbGV2ZWxEYXRhO1xyXG4gICAgICAgIGlmIChieXRlc1BlclJvdyA+IHJhd0J5dGVzUGVyUm93KSB7XHJcbiAgICAgICAgICAgIGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzUGVySW1hZ2UgKiB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBoID0gMDsgaCA8IGhlaWdodCAqIHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzOyBoICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgcmF3Qnl0ZXNQZXJSb3c7IHcgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YVt3ICsgaCAqIGJ5dGVzUGVyUm93XSA9IGxldmVsRGF0YVt3ICsgaCAqIHJhd0J5dGVzUGVyUm93XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbGF5ZXJCYXRjaCA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICBNYXRoLmZsb29yKGRldmljZS5saW1pdHMubWF4QnVmZmVyU2l6ZSAvIGJ5dGVzUGVySW1hZ2UpLFxyXG4gICAgICAgICAgICBrdHguZmFjZUNvdW50LFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgbGF5ZXJDb3VudCA9IE1hdGguY2VpbChrdHguZmFjZUNvdW50IC8gbGF5ZXJCYXRjaCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgbGF5ZXJDb3VudDsgbCArPSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGwgKiBsYXllckJhdGNoO1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKGxheWVyQmF0Y2gsIGt0eC5mYWNlQ291bnQgLSBvZmZzZXQpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGxheWVyQ291bnQgPiAxXHJcbiAgICAgICAgICAgICAgICA/IGltYWdlRGF0YS5zdWJhcnJheShvZmZzZXQgKiBieXRlc1BlckltYWdlLCAob2Zmc2V0ICsgY291bnQpICogYnl0ZXNQZXJJbWFnZSlcclxuICAgICAgICAgICAgICAgIDogaW1hZ2VEYXRhO1xyXG5cclxuICAgICAgICAgICAgZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZShcclxuICAgICAgICAgICAgICAgIHsgbWlwTGV2ZWwsIHRleHR1cmUsIG9yaWdpbjogWzAsIDAsIG9mZnNldF0gfSxcclxuICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICB7IGJ5dGVzUGVyUm93LCByb3dzUGVySW1hZ2UgfSxcclxuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0LCBjb3VudF0sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBUZXh0dXJlVG9BcnJheUJ1ZmZlck9wdGlvbnMgPSB7XHJcbiAgICBkZXZpY2U6IEdQVURldmljZSxcclxuICAgIHRleHR1cmU6IEdQVVRleHR1cmUsXHJcbiAgICBtaXBMZXZlbD86IG51bWJlcixcclxuICAgIHJlc3VsdEJ1ZmZlcj86IFVpbnQ4QXJyYXksXHJcbiAgICBzdG9yYWdlQnVmZmVyPzogR1BVQnVmZmVyLFxyXG4gICAgcmV0dXJuQnVmZmVyPzogYm9vbGVhbixcclxuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxyXG59O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRleHR1cmVUb0FycmF5QnVmZmVyKFxyXG4gICAgb3B0aW9uczogT21pdDxUZXh0dXJlVG9BcnJheUJ1ZmZlck9wdGlvbnMsICdyZXR1cm5CdWZmZXInPiAmIHsgcmV0dXJuQnVmZmVyPzogZmFsc2UgfSxcclxuKTogUHJvbWlzZTx7IGltYWdlRGF0YTogVWludDhBcnJheSB9PjtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0ZXh0dXJlVG9BcnJheUJ1ZmZlcihcclxuICAgIG9wdGlvbnM6IE9taXQ8VGV4dHVyZVRvQXJyYXlCdWZmZXJPcHRpb25zLCAncmV0dXJuQnVmZmVyJz4gJiB7IHJldHVybkJ1ZmZlcjogdHJ1ZSB9LFxyXG4pOiBQcm9taXNlPHsgaW1hZ2VEYXRhOiBVaW50OEFycmF5LCBzdG9yYWdlQnVmZmVyOiBHUFVCdWZmZXIgfT47XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGV4dHVyZVRvQXJyYXlCdWZmZXIoe1xyXG4gICAgZGV2aWNlLFxyXG4gICAgdGV4dHVyZSxcclxuICAgIG1pcExldmVsID0gMCxcclxuICAgIHJldHVybkJ1ZmZlcixcclxuICAgIHN0b3JhZ2VCdWZmZXIsXHJcbiAgICByZXN1bHRCdWZmZXIsXHJcbiAgICBkZXNjcmlwdGlvbixcclxufTogVGV4dHVyZVRvQXJyYXlCdWZmZXJPcHRpb25zKSB7XHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW3RleHR1cmUuZm9ybWF0XTtcclxuICAgIGNvbnN0IGZ1bGxEZXNjcmlwdGlvbiA9IHBhZFRlbXBsYXRlYFt0ZXh0dXJlVG9LVFgke2Rlc2NyaXB0aW9uID8/ICcnfSR7dGV4dHVyZS5sYWJlbH1dIC0tYDtcclxuXHJcbiAgICBpZiAocGl4ZWxTaXplID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVsbERlc2NyaXB0aW9ufSBmb3JtYXQgJHt0ZXh0dXJlLmZvcm1hdH0gdW5zdXBwb3J0ZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB3aWR0aCA9IHRleHR1cmUud2lkdGggPj4gbWlwTGV2ZWw7XHJcbiAgICBjb25zdCBoZWlnaHQgPSB0ZXh0dXJlLmhlaWdodCA+PiBtaXBMZXZlbDtcclxuICAgIGNvbnN0IHJhd0J5dGVzUGVyUm93ID0gd2lkdGggKiBwaXhlbFNpemU7XHJcbiAgICBjb25zdCBieXRlc1BlclJvdyA9IE1hdGgubWF4KHJhd0J5dGVzUGVyUm93LCAyNTYpO1xyXG4gICAgY29uc3Qgcm93c1BlckltYWdlID0gaGVpZ2h0O1xyXG4gICAgY29uc3QgYnl0ZVNpemUgPSByb3dzUGVySW1hZ2UgKiBieXRlc1BlclJvdyAqIHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzO1xyXG4gICAgY29uc3QgcmVzdWx0U2l6ZSA9IHJhd0J5dGVzUGVyUm93ICogaGVpZ2h0ICogdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnM7XHJcblxyXG4gICAgaWYgKHJlc3VsdEJ1ZmZlciAhPSBudWxsICYmIHJlc3VsdEJ1ZmZlci5ieXRlTGVuZ3RoIDwgYnl0ZVNpemUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVsbERlc2NyaXB0aW9ufSBnaXZlbiByZXN1bHQgYXJyYXkgbm90IGxhcmdlIGVub3VnaC5cclxuJHtyZXN1bHRCdWZmZXIuYnl0ZUxlbmd0aH0gPCAke2J5dGVTaXplfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdG9yYWdlQnVmZmVyICE9IG51bGwgJiYgc3RvcmFnZUJ1ZmZlci5zaXplIDwgYnl0ZVNpemUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVsbERlc2NyaXB0aW9ufSBnaXZlbiBzdG9yYWdlIGJ1ZmZlciBub3QgbGFyZ2UgZW5vdWdoLlxyXG4ke3N0b3JhZ2VCdWZmZXIuc2l6ZX0gPCAke2J5dGVTaXplfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlcXVpcmVkVXNhZ2UgPSBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEO1xyXG5cclxuICAgIGlmIChzdG9yYWdlQnVmZmVyICE9IG51bGwgJiYgKHN0b3JhZ2VCdWZmZXIudXNhZ2UgJiByZXF1aXJlZFVzYWdlKSAhPT0gcmVxdWlyZWRVc2FnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdWxsRGVzY3JpcHRpb259IGdpdmVuIHN0b3JhZ2UgZG9lcyBub3QgaGF2ZSBjb3JyZWN0IHVzYWdlIGZsYWdzLlxyXG5HaXZlbjogJHtzdG9yYWdlQnVmZmVyLnVzYWdlfVxyXG5SZXF1aXJlZDogJHtyZXF1aXJlZFVzYWdlfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpbWFnZURhdGEgPSByZXN1bHRCdWZmZXIgPz8gbmV3IFVpbnQ4QXJyYXkoYnl0ZVNpemUpO1xyXG4gICAgY29uc3Qgc3RvcmFnZSA9IHN0b3JhZ2VCdWZmZXIgPz8gZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XHJcbiAgICAgICAgbGFiZWw6IGAke2Z1bGxEZXNjcmlwdGlvbn0gc3RvcmFnZSBidWZmZXJgLFxyXG4gICAgICAgIHNpemU6IGJ5dGVTaXplLFxyXG4gICAgICAgIHVzYWdlOiByZXF1aXJlZFVzYWdlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgZW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2Rlcih7IGxhYmVsOiBgJHtmdWxsRGVzY3JpcHRpb259IGVuY29kZXJgIH0pO1xyXG4gICAgZW5jb2Rlci5jb3B5VGV4dHVyZVRvQnVmZmVyKFxyXG4gICAgICAgIHsgdGV4dHVyZSwgbWlwTGV2ZWwgfSxcclxuICAgICAgICB7IGJ1ZmZlcjogc3RvcmFnZSwgcm93c1BlckltYWdlLCBieXRlc1BlclJvdyB9LFxyXG4gICAgICAgIHsgd2lkdGgsIGhlaWdodCwgZGVwdGhPckFycmF5TGF5ZXJzOiB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycyB9LFxyXG4gICAgKTtcclxuICAgIGRldmljZS5xdWV1ZS5zdWJtaXQoW2VuY29kZXIuZmluaXNoKCldKTtcclxuXHJcbiAgICBhd2FpdCBkZXZpY2UucXVldWUub25TdWJtaXR0ZWRXb3JrRG9uZSgpO1xyXG4gICAgYXdhaXQgc3RvcmFnZS5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQsIDAsIGJ5dGVTaXplKTtcclxuXHJcbiAgICBjb25zdCBtYXBwZWQgPSBzdG9yYWdlLmdldE1hcHBlZFJhbmdlKDAsIGJ5dGVTaXplKTtcclxuICAgIGltYWdlRGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkobWFwcGVkKSk7XHJcbiAgICBzdG9yYWdlLnVubWFwKCk7XHJcblxyXG4gICAgaWYgKGJ5dGVzUGVyUm93ID4gcmF3Qnl0ZXNQZXJSb3cpIHtcclxuICAgICAgICBmb3IgKGxldCBoID0gMDsgaCA8IGhlaWdodCAqIHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzOyBoICs9IDEpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCByYXdCeXRlc1BlclJvdzsgdyArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZURhdGFbdyArIGggKiByYXdCeXRlc1BlclJvd10gPSBpbWFnZURhdGFbdyArIGggKiBieXRlc1BlclJvd107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaW1hZ2VEYXRhID0gaW1hZ2VEYXRhLnNsaWNlKDAsIHJlc3VsdFNpemUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaW1hZ2VEYXRhLFxyXG4gICAgICAgIHN0b3JhZ2VCdWZmZXI6IHJldHVybkJ1ZmZlciA/IHN0b3JhZ2UgOiB1bmRlZmluZWQsXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGV4dHVyZVRvS1RYKGRldmljZTogR1BVRGV2aWNlLCB0ZXh0dXJlOiBHUFVUZXh0dXJlLCBjdWJlID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHBpeGVsU2l6ZSA9IFRleHR1cmVGb3JtYXRUb1NpemVbdGV4dHVyZS5mb3JtYXRdO1xyXG4gICAgY29uc3QgdHlwZVNpemUgPSBUZXh0dXJlRm9ybWF0VG9DaGFubmVsU2l6ZVt0ZXh0dXJlLmZvcm1hdF07XHJcblxyXG4gICAgaWYgKHBpeGVsU2l6ZSA9PSBudWxsIHx8IHR5cGVTaXplID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRleHR1cmVUb0tUWCAtLSBmb3JtYXQgJHt0ZXh0dXJlLmZvcm1hdH0gb2YgJHt0ZXh0dXJlLmxhYmVsfSB1bnN1cHBvcnRlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBrdHhwYXJzZS5LVFgyQ29udGFpbmVyKCk7XHJcbiAgICBjb250YWluZXIucGl4ZWxXaWR0aCA9IHRleHR1cmUud2lkdGg7XHJcbiAgICBjb250YWluZXIucGl4ZWxIZWlnaHQgPSB0ZXh0dXJlLmhlaWdodDtcclxuICAgIGNvbnRhaW5lci52a0Zvcm1hdCA9IFdlYkdQVVRvVmtGb3JtYXRbdGV4dHVyZS5mb3JtYXRdO1xyXG4gICAgY29udGFpbmVyLnR5cGVTaXplID0gdHlwZVNpemU7XHJcbiAgICBkZWxldGUgY29udGFpbmVyLmtleVZhbHVlLktUWHN3aXp6bGU7XHJcblxyXG4gICAgY29uc3QgZGF0YUZvcm1hdCA9IGNvbnRhaW5lci5kYXRhRm9ybWF0RGVzY3JpcHRvclswXTtcclxuICAgIGRhdGFGb3JtYXQuY29sb3JNb2RlbCA9IGt0eHBhcnNlLktIUl9ERl9NT0RFTF9SR0JTREE7XHJcbiAgICBkYXRhRm9ybWF0LnRyYW5zZmVyRnVuY3Rpb24gPSBrdHhwYXJzZS5LSFJfREZfVFJBTlNGRVJfTElORUFSO1xyXG4gICAgZGF0YUZvcm1hdC5ieXRlc1BsYW5lWzBdID0gcGl4ZWxTaXplO1xyXG5cclxuICAgIGRhdGFGb3JtYXQuc2FtcGxlcyA9IFswLCAxLCAyLCAzXS5tYXAoKGkpID0+ICh7XHJcbiAgICAgICAgY2hhbm5lbFR5cGU6IFsxOTIsIDE5MywgMTk0LCAyMDddW2ldLFxyXG4gICAgICAgIHNhbXBsZVBvc2l0aW9uOiBbMCwgMCwgMCwgMF0sXHJcbiAgICAgICAgYml0TGVuZ3RoOiBjb250YWluZXIudHlwZVNpemUgKiA4IC0gMSxcclxuICAgICAgICBiaXRPZmZzZXQ6IGNvbnRhaW5lci50eXBlU2l6ZSAqIDggKiBpLFxyXG4gICAgICAgIHNhbXBsZUxvd2VyOiAtMTA4MjEzMDQzMixcclxuICAgICAgICBzYW1wbGVVcHBlcjogMTA2NTM1MzIxNixcclxuICAgIH0pKTtcclxuXHJcbiAgICBpZiAodGV4dHVyZS5kaW1lbnNpb24gPT09ICczZCcpIHtcclxuICAgICAgICBjb250YWluZXIuZmFjZUNvdW50ID0gMTtcclxuICAgICAgICBjb250YWluZXIucGl4ZWxEZXB0aCA9IHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzO1xyXG4gICAgfSBlbHNlIGlmIChjdWJlKSB7XHJcbiAgICAgICAgY29uc3QgY3ViZUxheWVycyA9IHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzIC8gNjtcclxuICAgICAgICBjb250YWluZXIubGF5ZXJDb3VudCA9IGN1YmVMYXllcnMgPT09IDEgPyAwIDogY3ViZUxheWVycztcclxuICAgICAgICBjb250YWluZXIuZmFjZUNvdW50ID0gNjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29udGFpbmVyLmxheWVyQ291bnQgPSB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycztcclxuICAgICAgICBjb250YWluZXIuZmFjZUNvdW50ID0gMTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgc3RvcmFnZUJ1ZmZlcjogR1BVQnVmZmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgbGV0IGltYWdlRGF0YTogVWludDhBcnJheTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHR1cmUubWlwTGV2ZWxDb3VudDsgaSArPSAxKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcclxuICAgICAgICAoeyBpbWFnZURhdGEsIHN0b3JhZ2VCdWZmZXIgfSA9IGF3YWl0IHRleHR1cmVUb0FycmF5QnVmZmVyKHtcclxuICAgICAgICAgICAgbWlwTGV2ZWw6IGksXHJcbiAgICAgICAgICAgIHJldHVybkJ1ZmZlcjogdHJ1ZSxcclxuICAgICAgICAgICAgZGV2aWNlLFxyXG4gICAgICAgICAgICB0ZXh0dXJlLFxyXG4gICAgICAgICAgICBzdG9yYWdlQnVmZmVyLFxyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgY29udGFpbmVyLmxldmVscy5wdXNoKHtcclxuICAgICAgICAgICAgbGV2ZWxEYXRhOiBpbWFnZURhdGEsXHJcbiAgICAgICAgICAgIHVuY29tcHJlc3NlZEJ5dGVMZW5ndGg6IGltYWdlRGF0YS5ieXRlTGVuZ3RoLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBrdHhwYXJzZS53cml0ZShjb250YWluZXIpO1xyXG59XHJcbiIsIi8qIGVzbGludCBAc3R5bGlzdGljL21heC1sZW46IFwiZXJyb3JcIiAqL1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlQW5kQ29weUJ1ZmZlciB9IGZyb20gJy4uLy4uL3V0aWxzL2RhdGEtY29weSc7XHJcbmltcG9ydCB7IG1hcFJhbmdlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZ2VuZXJhbCc7XHJcblxyXG4vKipcclxuICogIFdHU0wgZnVuY3Rpb25zIGZvciBzYW1wbGluZyBhY3Jvc3MgYWRqYWNlbnQgZmFjZXMgb2YgYSBjdWJlbWFwXHJcbiAqL1xyXG5jb25zdCBjdWJlbWFwU2FtcGxpbmc6IHN0cmluZyA9IC8qIHdnc2wgKi9gXHJcbiAgICBjb25zdCBJTlZBTElEX0ZBQ0UgPSA2O1xyXG4gICAgY29uc3QgSU5WQUxJRF9JRFggPSA0Mjk0OTY3Mjk1dTsgLy8gbWF4IHUzMlxyXG5cclxuICAgIGZuIGN1YmVTYW1wbGVDb29yZChjb29yZDogdmVjM2ksIHc6IHUzMikgLT4gdmVjM3Uge1xyXG4gICAgICAgIC8vIGEgZmxhdHRlbmVkIG1hdHJpeCBvZiBkZXN0aW5hdGlvbiBmYWNlcyBiYXNlZCBvblxyXG4gICAgICAgIC8vIHN0YXJ0aW5nIGZhY2UgYW5kIGRpcmVjdGlvblxyXG4gICAgICAgIGNvbnN0IGRmYWNlcyA9IGFycmF5KFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJICBVcCBEb3duIExlZnQgUmlnaHQgSW52YWxpZFxyXG4gICAgICAgICAgICAwLCAyLCAzLCA0LCA1LCBJTlZBTElEX0ZBQ0UsIC8vICtYICArWSAgIC1ZICAgK1ogICAtWiAgIFxyXG4gICAgICAgICAgICAxLCAyLCAzLCA1LCA0LCBJTlZBTElEX0ZBQ0UsIC8vIC1YICArWSAgIC1ZICAgLVogICArWiBcclxuICAgICAgICAgICAgMiwgNSwgNCwgMSwgMCwgSU5WQUxJRF9GQUNFLCAvLyArWSAgLVogICArWiAgIC1YICAgK1ggXHJcbiAgICAgICAgICAgIDMsIDQsIDUsIDEsIDAsIElOVkFMSURfRkFDRSwgLy8gLVkgICtaICAgLVogICAtWCAgICtYIFxyXG4gICAgICAgICAgICA0LCAyLCAzLCAxLCAwLCBJTlZBTElEX0ZBQ0UsIC8vICtaICArWSAgIC1ZICAgLVggICArWCBcclxuICAgICAgICAgICAgNSwgMiwgMywgMCwgMSwgSU5WQUxJRF9GQUNFLCAvLyAtWiAgK1kgICAtWSAgICtYICAgLVggXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gYSBmbGF0dGVuZCBtYXRyaXggaW4gdGhlIHNhbWUgZm9ybSBhcyBkZmFjZXNcclxuICAgICAgICAvLyBnaXZpbmcgdGhlIGluZGV4IG9mIHRoZSBkYW10cyBhcnJheSBjb250YWluaW5nIFxyXG4gICAgICAgIC8vIHRoZSB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSBzdGFydGluZyBmYWNlIHRvIFxyXG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBmYWNlXHJcbiAgICAgICAgY29uc3QgZGluZGljZXMgPSBhcnJheShcclxuICAgICAgICAgICAgMCwgMSwgIDIsICAzLCAgNCwgIDAsXHJcbiAgICAgICAgICAgIDAsIDUsICA2LCAgMywgIDQsICAwLFxyXG4gICAgICAgICAgICAwLCA3LCAgOCwgIDksICAxMCwgMCxcclxuICAgICAgICAgICAgMCwgMTEsIDEyLCAxMywgMTQsIDAsXHJcbiAgICAgICAgICAgIDAsIDExLCA4LCAgMywgIDQsICAwLFxyXG4gICAgICAgICAgICAwLCA3LCAgMTIsIDMsICA0LCAgMCxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyAyeDQgbWFydGljZXMgdHJhbnNmb3JtaW5nIGEgY29vcmRpbmF0ZSB2ZWN0b3IgPHUsIHYsIHcsIDE+XHJcbiAgICAgICAgLy8gZnJvbSBvbmUgZmFjZSB0byBhbm90aGVyXHJcbiAgICAgICAgY29uc3QgZG1hdHMgPSBhcnJheShcclxuICAgICAgICAgICAgYXJyYXkoLy8gMFxyXG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAwLCAwKSwgICAvLyB1ID0gdVxyXG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAwLCAwKSwgICAvLyB2ID0gdlxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBhcnJheSgvLyAxXHJcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDEsIDApLCAgIC8vIHUgPSB2ICsgd1xyXG4gICAgICAgICAgICAgICAgdmVjNCgtMSwgMCwgMSwgLTEpLCAvLyB2ID0gdyAtIHUgLSAxXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIGFycmF5KC8vIDJcclxuICAgICAgICAgICAgICAgIHZlYzQoMCwgLTEsIDIsIC0xKSwgLy8gdSA9IDJ3IC0gdiAtIDFcclxuICAgICAgICAgICAgICAgIHZlYzQoMSwgMCwgMCwgMCksICAgLy8gdiA9IHVcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgYXJyYXkoLy8gM1xyXG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAxLCAwKSwgICAvLyB1ID0gdSArIHdcclxuICAgICAgICAgICAgICAgIHZlYzQoMCwgMSwgMCwgMCksICAgLy8gdiA9IHZcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgYXJyYXkoLy8gNFxyXG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAtMSwgMCksICAvLyB1ID0gdSAtIHdcclxuICAgICAgICAgICAgICAgIHZlYzQoMCwgMSwgMCwgMCksICAgLy8gdiA9IHZcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgYXJyYXkoLy8gNVxyXG4gICAgICAgICAgICAgICAgdmVjNCgwLCAtMSwgMCwgLTEpLCAvLyB1ID0gLXYgLSAxXHJcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDAsIDApLCAgIC8vIHYgPSB1XHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIGFycmF5KC8vIDZcclxuICAgICAgICAgICAgICAgIHZlYzQoMCwgMSwgLTEsIDApLCAgLy8gdSA9IHYgLSB3XHJcbiAgICAgICAgICAgICAgICB2ZWM0KC0xLCAwLCAxLCAtMSksIC8vIHYgPSB3IC0gdSAtIDFcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgYXJyYXkoLy8gN1xyXG4gICAgICAgICAgICAgICAgdmVjNCgtMSwgMCwgMSwgLTEpLCAvLyB1ID0gdyAtIHUgLSAxXHJcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAwLCAtMSksIC8vIHYgPSAtdiAtIDFcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgYXJyYXkoLy8gOFxyXG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAwLCAwKSwgICAvLyB1ID0gdVxyXG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAtMSwgMCksICAvLyB2ID0gdiAtIHdcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgYXJyYXkoLy8gOVxyXG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAwLCAwKSwgICAvLyB1ID0gdlxyXG4gICAgICAgICAgICAgICAgdmVjNCgtMSwgMCwgMCwgLTEpLCAvLyB2ID0gLXUgLSAxXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIGFycmF5KC8vIDEwXHJcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAxLCAtMSksIC8vIHUgPSB3IC0gdiAtIDFcclxuICAgICAgICAgICAgICAgIHZlYzQoMSwgMCwgLTEsIDApLCAgLy8gdiA9IHUgLSB3XHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIGFycmF5KC8vIDExXHJcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDAsIDApLCAgIC8vIHUgPSB1XHJcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDEsIDApLCAgIC8vIHYgPSB2ICsgd1xyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBhcnJheSgvLyAxMlxyXG4gICAgICAgICAgICAgICAgdmVjNCgtMSwgMCwgMSwgLTEpLCAvLyB1ID0gdyAtIHUgLSAxXHJcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAyLCAtMSksIC8vIHYgPSAydyAtIHYgLSAxXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIGFycmF5KC8vIDEzXHJcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAxLCAtMSksIC8vIHUgPSB3IC0gdiAtIDFcclxuICAgICAgICAgICAgICAgIHZlYzQoMSwgMCwgMSwgMCksICAgLy8gdiA9IHUgKyB3XHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIGFycmF5KC8vIDE0XHJcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDAsIDApLCAgIC8vIHUgPSB2XHJcbiAgICAgICAgICAgICAgICB2ZWM0KC0xLCAwLCAyLCAtMSksIC8vIHYgPSAydyAtIHUgLSAxXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgbGV0IGl3ID0gaTMyKHcpO1xyXG5cclxuICAgICAgICB2YXIgZGlyID0gMDtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGNvb3JkLnkgPj0gaXcgKiAyIC0gMSBcclxuICAgICAgICAgICAgfHwgY29vcmQueSA8PSAtaXcgXHJcbiAgICAgICAgICAgIHx8IGNvb3JkLnggPj0gaXcgKiAyIC0gMSBcclxuICAgICAgICAgICAgfHwgY29vcmQueCA8PSAtaXdcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgZGlyID0gNTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY29vcmQueSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGRpciA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29vcmQueSA+PSBpdykge1xyXG4gICAgICAgICAgICAgICAgZGlyID0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29vcmQueCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGRpciA9IHNlbGVjdCg1LCAzLCBkaXIgPT0gMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29vcmQueCA+PSBpdykge1xyXG4gICAgICAgICAgICAgICAgZGlyID0gc2VsZWN0KDUsIDQsIGRpciA9PSAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGlkeCA9IGNvb3JkLnogKiA2ICsgZGlyO1xyXG4gICAgICAgIGxldCBzYW1wID0gdmVjNChjb29yZC54eSwgaXcsIDEpO1xyXG4gICAgICAgIGxldCBkbWF0ID0gZG1hdHNbZGluZGljZXNbaWR4XV07XHJcbiAgICAgICAgcmV0dXJuIHZlYzN1KHZlYzMoZG90KGRtYXRbMF0sIHNhbXApLCBkb3QoZG1hdFsxXSwgc2FtcCksIGRmYWNlc1tpZHhdKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm4gY3ViZUNvb3JkVG9JZHgoY29vcmQ6IHZlYzN1LCB3OiB1MzIpIC0+IHUzMiB7XHJcbiAgICAgICAgcmV0dXJuIGNvb3JkLnggKyBjb29yZC55ICogdyArIGNvb3JkLnogKiB3ICogdztcclxuICAgIH1cclxuXHJcbiAgICBmbiBjdWJlSWR4VG9Db29yZChpZHg6IHUzMiwgdzogdTMyKSAtPiB2ZWMzdSB7XHJcbiAgICAgICAgbGV0IHcyID0gdyAqIHc7XHJcbiAgICAgICAgbGV0IGZpZHggPSBpZHggJSB3MjtcclxuICAgICAgICByZXR1cm4gdmVjM3UoZmlkeCAlIHcsIGZpZHggLyB3LCBpZHggLyB3Mik7XHJcbiAgICB9XHJcblxyXG4gICAgZm4gY3ViZVNhbXBsZUlkeCh1dmY6IHZlYzNpLCB3OiB1MzIpIC0+IHUzMiB7XHJcbiAgICAgICAgbGV0IGNvb3JkID0gY3ViZVNhbXBsZUNvb3JkKHV2Ziwgdyk7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdChcclxuICAgICAgICAgICAgY3ViZUNvb3JkVG9JZHgoY29vcmQsIHcpLCBcclxuICAgICAgICAgICAgSU5WQUxJRF9JRFgsIFxyXG4gICAgICAgICAgICBjb29yZC56ID09IElOVkFMSURfRkFDRSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5gO1xyXG5cclxuY29uc3QgY3JlYXRlTWlwQmx1ckNvZGUgPSAoXHJcbiAgICBncm91cHM6IG51bWJlcixcclxuICAgIGZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCxcclxuKSA9PiAvKiB3Z3NsICovYFxyXG4gICAgJHtjdWJlbWFwU2FtcGxpbmd9XHJcblxyXG4gICAgb3ZlcnJpZGUgU1RFUFM6IGkzMiA9IDQ7XHJcblxyXG4gICAgZm4gdG9fd29ybGRfY29vcmRzKGNvb3JkOiB2ZWMzdSwgc2l6ZTogdTMyKSAtPiB2ZWMzZiB7XHJcbiAgICAgICAgbGV0IHV2ID0gKDIuMCAvIGYzMihzaXplKSkgKiAodmVjMmYoY29vcmQueHkpICsgMC41KSAtIDEuMDtcclxuXHJcbiAgICAgICAgdmFyIHBvczogdmVjM2Y7XHJcbiAgICAgICAgc3dpdGNoIChjb29yZC56KSB7XHJcbiAgICAgICAgICAgIGNhc2UgMCAgeyBwb3MgPSB2ZWMzKCAgMS4wLCAtdXYueSwgLXV2LngpOyB9XHJcbiAgICAgICAgICAgIGNhc2UgMSAgeyBwb3MgPSB2ZWMzKCAtMS4wLCAtdXYueSwgIHV2LngpOyB9XHJcbiAgICAgICAgICAgIGNhc2UgMiAgeyBwb3MgPSB2ZWMzKCB1di54LCAgIDEuMCwgIHV2LnkpOyB9XHJcbiAgICAgICAgICAgIGNhc2UgMyAgeyBwb3MgPSB2ZWMzKCB1di54LCAgLTEuMCwgLXV2LnkpOyB9XHJcbiAgICAgICAgICAgIGNhc2UgNCAgeyBwb3MgPSB2ZWMzKCB1di54LCAtdXYueSwgICAxLjApOyB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQgeyBwb3MgPSB2ZWMzKC11di54LCAtdXYueSwgIC0xLjApOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplKHBvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhciBwcmV2aW91c01pcDogdGV4dHVyZV8yZF9hcnJheTxmMzI+O1xyXG5cclxuICAgIEBncm91cCgwKSBAYmluZGluZygxKSBcclxuICAgIHZhciBvdXRwdXRUZXh0dXJlOiB0ZXh0dXJlX3N0b3JhZ2VfMmRfYXJyYXk8JHtmb3JtYXR9LCB3cml0ZT47XHJcblxyXG4gICAgLy8gc2ltZ2FbMF0gcmVzZXZlcmVkIGZvciB3b3JrIG9mZnNldFxyXG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlPiBzaWdtYXMgOiBhcnJheTxmMzI+O1xyXG4gICAgXHJcbiAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHtncm91cHN9LCAxLCAxKVxyXG4gICAgZm4gbWFpbihAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2lkOiB2ZWMzdSkge1xyXG4gICAgICAgIGxldCBtaXBTaXplID0gdGV4dHVyZURpbWVuc2lvbnMob3V0cHV0VGV4dHVyZSkueDtcclxuXHJcbiAgICAgICAgbGV0IGlkeCA9IGdpZC54ICsgdTMyKHNpZ21hc1swXSk7XHJcbiAgICAgICAgbGV0IGZhY2VTaXplID0gbWlwU2l6ZSAqIG1pcFNpemU7XHJcbiAgICAgICAgbGV0IGZhY2VJZHggPSBpZHggJSBmYWNlU2l6ZTtcclxuICAgICAgICBsZXQgY29vcmQgPSB2ZWMzdShcclxuICAgICAgICAgICAgZmFjZUlkeCAlIG1pcFNpemUsIFxyXG4gICAgICAgICAgICBmYWNlSWR4IC8gbWlwU2l6ZSwgXHJcbiAgICAgICAgICAgIGlkeCAvIGZhY2VTaXplLFxyXG4gICAgICAgICk7IFxyXG5cclxuICAgICAgICBpZiAoY29vcmQueCA+PSBtaXBTaXplIHx8IGNvb3JkLnkgPj0gbWlwU2l6ZSB8fCBjb29yZC56ID49IDYpIHsgXHJcbiAgICAgICAgICAgIHJldHVybjsgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcHJldmlvdXNTaXplID0gdGV4dHVyZURpbWVuc2lvbnMocHJldmlvdXNNaXApLng7XHJcbiAgICAgICAgbGV0IGJhc2VDb29yZCA9IHZlYzNpKHZlYzN1KGNvb3JkLnggKiAyLCBjb29yZC55ICogMiwgY29vcmQueikpO1xyXG4gICAgICAgIGxldCBwb3MgPSB0b193b3JsZF9jb29yZHModmVjM3UoY29vcmQpLCBtaXBTaXplKTtcclxuXHJcbiAgICAgICAgbGV0IHNpemUgPSBhcnJheUxlbmd0aCgmc2lnbWFzKTtcclxuICAgICAgICBsZXQgbGV2ZWwgPSBzaXplIC0gdTMyKGNlaWwobG9nMihmMzIocHJldmlvdXNTaXplKSkpKTtcclxuICAgICAgICBsZXQgc2lnbWEgPSBzaWdtYXNbbGV2ZWxdO1xyXG4gICAgICAgIGxldCBndWFzc2lhbl9mYWN0b3IgPSAtMC41IC8gKHNpZ21hICogc2lnbWEpO1xyXG5cclxuICAgICAgICB2YXIgd2VpZ2h0ID0gMC4wO1xyXG4gICAgICAgIHZhciByZXMgPSB2ZWMzKDAuMCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHUgPSAtU1RFUFM7IHUgPD0gU1RFUFMgKyAxOyB1ICs9IDEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgdiA9IC1TVEVQUzsgdiA8PSBTVEVQUyArIDE7IHYgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldENvb3JkID0gYmFzZUNvb3JkICsgdmVjM2kodSwgdiwgMCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2FtcGxlID0gY3ViZVNhbXBsZUNvb3JkKG9mZnNldENvb3JkLCBwcmV2aW91c1NpemUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZS56ID09IElOVkFMSURfRkFDRSkgeyBjb250aW51ZTsgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzYW1wbGVQb3MgPSB0b193b3JsZF9jb29yZHMoc2FtcGxlLCBwcmV2aW91c1NpemUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHggPSBtYXgoMC4wLCBhY29zKGRvdChzYW1wbGVQb3MsIHBvcykpKTtcclxuICAgICAgICAgICAgICAgIGxldCB3ID0gZXhwKHggKiB4ICogZ3Vhc3NpYW5fZmFjdG9yKTtcclxuICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IHRleHR1cmVMb2FkKHByZXZpb3VzTWlwLCBzYW1wbGUueHksIHNhbXBsZS56LCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXMgKz0gY29sb3IucmdiICogdztcclxuICAgICAgICAgICAgICAgIHdlaWdodCArPSB3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0ZXh0dXJlU3RvcmUob3V0cHV0VGV4dHVyZSwgY29vcmQueHksIGNvb3JkLnosIHZlYzQocmVzIC8gd2VpZ2h0LCAxKSk7XHJcbiAgICB9XHJcbmA7XHJcblxyXG4vLyB0aGUgbWluaW11bSBhbmd1bGFyIGRpc3RhbmNlIGJldHdlZW4gYW55IHBpeGVsIG9uIGEgY3ViZW1hcFxyXG4vLyBvZiB0aGUgZ2l2ZW4gZmFjZSB3aWR0aCBhbmQgYW55IHBpeGVsIGx5aW5nIG9uIGEgcGVyaW1ldGVyXHJcbi8vIHRoZSBnaXZlbiBudW1iZXIgb2Ygc3RlcHMgYXdheVxyXG5mdW5jdGlvbiBtaW5TdGVwRGlzdGFuY2Uoc3RlcHM6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xyXG4gICAgLy8gdGhlIGFuZ3VsYXIgZGlzdGFuY2VcclxuICAgIC8vIGZyb20gdGhlIHV2ZjogZmFjZSA9IDAsIHUgPSAwLCBhbmQgdiA9IHdpZHRoIC0gTWF0aC5mbG9vcihzdGVwcyAvIDIpIC0gMVxyXG4gICAgLy8gdG8gdGhlIHV2ZjogZmFjZSA9IDMsIHUgPSAyICogd2lkdGggLSBiYXNlViAtIHN0ZXBzIC0gMiwgYW5kIHYgPSAwIG9yIDFcclxuXHJcbiAgICAvLyBJdCdzIGxpa2VseSBwb3NzaWJsZSB0byBwcm9ncmFtaXRpY2FsbHkgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGRlc3RpdGlvblxyXG4gICAgLy8gcGl4ZWwgc2hvdWxkIGJlIHYgPSAwIG9yIHYgPSAxLCBidXQgY2hlY2tpbmcgYm90aCB3b3JrcyBmaW5lXHJcblxyXG4gICAgY29uc3QgbmV4dE1pcFdpZHRoID0gd2lkdGggPj4gMTtcclxuICAgIGNvbnN0IGJhc2VWID0gbmV4dE1pcFdpZHRoIC0gTWF0aC5mbG9vcihzdGVwcyAvIDQpIC0gMTtcclxuICAgIGNvbnN0IGJhc2VWTiA9ICgyIC8gbmV4dE1pcFdpZHRoKSAqIChiYXNlViArIDAuNSkgLSAxO1xyXG4gICAgY29uc3QgYmFzZVVOID0gKDEgLyBuZXh0TWlwV2lkdGgpIC0gMTtcclxuICAgIGNvbnN0IGJhc2VNYWcyID0gMSArIGJhc2VWTiAqIGJhc2VWTiArIGJhc2VVTiAqIGJhc2VVTjtcclxuXHJcbiAgICBjb25zdCBzYW1wVSA9IDIgKiB3aWR0aCAtIChiYXNlViAqIDIpIC0gc3RlcHMgLSAyO1xyXG4gICAgY29uc3Qgc2FtcFVOID0gKDIgLyB3aWR0aCkgKiAoc2FtcFUgKyAwLjUpIC0gMTtcclxuICAgIGNvbnN0IHNhbXAwVk4gPSAoMSAvIHdpZHRoKSAtIDE7XHJcbiAgICBjb25zdCBzYW1wME1hZzIgPSAxICsgc2FtcFVOICogc2FtcFVOICsgc2FtcDBWTiAqIHNhbXAwVk47XHJcbiAgICBjb25zdCBzYW1wMVZOID0gKDMgLyB3aWR0aCkgLSAxO1xyXG4gICAgY29uc3Qgc2FtcDFNYWcyID0gMSArIHNhbXBVTiAqIHNhbXBVTiArIHNhbXAxVk4gKiBzYW1wMVZOO1xyXG5cclxuICAgIGNvbnN0IGRvdDAgPSAoc2FtcFVOICsgYmFzZVZOICsgc2FtcDBWTiAqIGJhc2VVTilcclxuICAgICAgICAvIE1hdGguc3FydChzYW1wME1hZzIgKiBiYXNlTWFnMik7XHJcblxyXG4gICAgY29uc3QgZG90MSA9IChzYW1wVU4gKyBiYXNlVk4gKyBzYW1wMVZOICogYmFzZVVOKVxyXG4gICAgICAgIC8gTWF0aC5zcXJ0KHNhbXAxTWFnMiAqIGJhc2VNYWcyKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5taW4oMSAtIGRvdDAsIDEgLSBkb3QxKTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgR2F1c3NpYW5QeXJhbWlkRGVzY3JpcHRvciA9IHtcclxuICAgIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgdGV4dHVyZTogR1BVVGV4dHVyZSxcclxuICAgIGluUGxhY2U/OiBib29sZWFuLFxyXG4gICAgbWluV2lkdGg/OiBudW1iZXIsXHJcbiAgICBzdGVwcz86IG51bWJlcixcclxuICAgIG1heE9wc1BlclBhc3M/OiBudW1iZXIsXHJcbiAgICBkZWxheVdvcms/OiAoZm46ICgpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkKSA9PiB2b2lkLFxyXG4gICAgb3V0cHV0VGV4dHVyZUxhYmVsPzogc3RyaW5nLFxyXG4gICAgbGFiZWxUYWc/OiBzdHJpbmcsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBjdWJlbWFwR3Vhc3NpYW5QeXJhbWlkKHtcclxuICAgIGRldmljZSxcclxuICAgIHRleHR1cmUsXHJcbiAgICBvdXRwdXRUZXh0dXJlTGFiZWwsXHJcbiAgICBpblBsYWNlID0gZmFsc2UsXHJcbiAgICBtaW5XaWR0aCA9IDgsXHJcbiAgICBzdGVwcyA9IDQsXHJcbiAgICBtYXhPcHNQZXJQYXNzID0gNiAqICgoMzIgKiAyNTYpICoqIDIpLFxyXG4gICAgZGVsYXlXb3JrID0gKGZuKSA9PiB7IHZvaWQgZm4oKTsgfSxcclxuICAgIGxhYmVsVGFnID0gYCR7Y3ViZW1hcEd1YXNzaWFuUHlyYW1pZC5uYW1lfSAtLWAsXHJcbn06IEdhdXNzaWFuUHlyYW1pZERlc2NyaXB0b3IpIHtcclxuICAgIGNvbnN0IHsgd2lkdGgsIGZvcm1hdCB9ID0gdGV4dHVyZTtcclxuICAgIGNvbnN0IG1pcExldmVsQ291bnQgPSBpblBsYWNlXHJcbiAgICAgICAgPyB0ZXh0dXJlLm1pcExldmVsQ291bnRcclxuICAgICAgICA6IChNYXRoLmxvZzIod2lkdGgpIC0gTWF0aC5sb2cyKG1pbldpZHRoKSArIDEpO1xyXG5cclxuICAgIGlmIChtaXBMZXZlbENvdW50IDw9IDEpIHJldHVybiB0ZXh0dXJlO1xyXG5cclxuICAgIGNvbnN0IGdyb3VwcyA9IE1hdGgubWluKFxyXG4gICAgICAgIGRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLFxyXG4gICAgICAgIGRldmljZS5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IG1heFdvcmtncm91cHMgPSBkZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO1xyXG4gICAgY29uc3Qgc2hhZGVyID0gZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7XHJcbiAgICAgICAgbGFiZWw6IGAke2xhYmVsVGFnfSBzaGFkZXJgLFxyXG4gICAgICAgIGNvZGU6IGNyZWF0ZU1pcEJsdXJDb2RlKGdyb3VwcywgZm9ybWF0KSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGJpbmRncm91cExheW91dCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoe1xyXG4gICAgICAgIGxhYmVsOiBgJHtsYWJlbFRhZ30gYmluZGdyb3VwIGxheW91dGAsXHJcbiAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZTogeyB2aWV3RGltZW5zaW9uOiAnMmQtYXJyYXknIH0sXHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxyXG4gICAgICAgICAgICAgICAgc3RvcmFnZVRleHR1cmU6IHtcclxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3M6ICd3cml0ZS1vbmx5JyxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RGltZW5zaW9uOiAnMmQtYXJyYXknLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAyLFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyOiB7IHR5cGU6ICdyZWFkLW9ubHktc3RvcmFnZScgfSxcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7XHJcbiAgICAgICAgbGFiZWw6IGAke2xhYmVsVGFnfSBwaXBlbGluZWAsXHJcbiAgICAgICAgbGF5b3V0OiBkZXZpY2UuY3JlYXRlUGlwZWxpbmVMYXlvdXQoe1xyXG4gICAgICAgICAgICBsYWJlbDogYCR7bGFiZWxUYWd9IC0tIHBpcGVsaW5lIGxheW91dGAsXHJcbiAgICAgICAgICAgIGJpbmRHcm91cExheW91dHM6IFtiaW5kZ3JvdXBMYXlvdXRdLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGNvbXB1dGU6IHtcclxuICAgICAgICAgICAgbW9kdWxlOiBzaGFkZXIsXHJcbiAgICAgICAgICAgIGVudHJ5UG9pbnQ6ICdtYWluJyxcclxuICAgICAgICAgICAgY29uc3RhbnRzOiB7IFNURVBTOiBNYXRoLmNlaWwoc3RlcHMpIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBnYXVzc2lhblB5cmFtaWQgPSB0ZXh0dXJlO1xyXG4gICAgaWYgKCFpblBsYWNlKSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHsgd2lkdGgsIGhlaWdodDogd2lkdGgsIGRlcHRoT3JBcnJheUxheWVyczogNiB9O1xyXG5cclxuICAgICAgICBnYXVzc2lhblB5cmFtaWQgPSBkZXZpY2UuY3JlYXRlVGV4dHVyZSh7XHJcbiAgICAgICAgICAgIGxhYmVsOiBvdXRwdXRUZXh0dXJlTGFiZWwsXHJcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HXHJcbiAgICAgICAgICAgIHwgR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElOR1xyXG4gICAgICAgICAgICB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQ1xyXG4gICAgICAgICAgICB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCxcclxuICAgICAgICAgICAgZGltZW5zaW9uOiAnMmQnLFxyXG4gICAgICAgICAgICBmb3JtYXQsXHJcbiAgICAgICAgICAgIG1pcExldmVsQ291bnQsXHJcbiAgICAgICAgICAgIHNpemUsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvcHlFbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKHtcclxuICAgICAgICAgICAgbGFiZWw6IGAke2xhYmVsVGFnfSBjb3B5IGVuY29kZXJgLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb3B5RW5jb2Rlci5jb3B5VGV4dHVyZVRvVGV4dHVyZShcclxuICAgICAgICAgICAgeyB0ZXh0dXJlLCBtaXBMZXZlbDogMCB9LFxyXG4gICAgICAgICAgICB7IHRleHR1cmU6IGdhdXNzaWFuUHlyYW1pZCwgbWlwTGV2ZWw6IDAgfSxcclxuICAgICAgICAgICAgc2l6ZSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBkZXZpY2UucXVldWUuc3VibWl0KFtjb3B5RW5jb2Rlci5maW5pc2goKV0pO1xyXG4gICAgICAgIGF3YWl0IGRldmljZS5xdWV1ZS5vblN1Ym1pdHRlZFdvcmtEb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWlwVmlld3MgPSBtYXBSYW5nZShtaXBMZXZlbENvdW50LCAoaSkgPT4gZ2F1c3NpYW5QeXJhbWlkLmNyZWF0ZVZpZXcoe1xyXG4gICAgICAgIGxhYmVsOiBgJHtsYWJlbFRhZ30gbWlwIHZpZXcgJHtpfWAsXHJcbiAgICAgICAgZGltZW5zaW9uOiAnMmQtYXJyYXknLFxyXG4gICAgICAgIGJhc2VNaXBMZXZlbDogaSxcclxuICAgICAgICBtaXBMZXZlbENvdW50OiAxLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIGNvbnN0IG1heERpc3BhdGNoZXMgPSBNYXRoLm1heChcclxuICAgICAgICAobWF4T3BzUGVyUGFzcyAvICgoKDEgKyAoc3RlcHMgKiAyKSkgKiogMikgKiBncm91cHMpKSB8IDAsXHJcbiAgICAgICAgMSxcclxuICAgICk7XHJcbiAgICBjb25zdCBtYXhMYXllcnMgPSBNYXRoLmNlaWwoTWF0aC5sb2cyKHdpZHRoKSk7XHJcblxyXG4gICAgY29uc3QgcHJvcGVydHlBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIC4uLm1hcFJhbmdlKG1heExheWVycywgKGkpID0+IHtcclxuICAgICAgICBjb25zdCB3ID0gd2lkdGggPj4gaTtcclxuICAgICAgICByZXR1cm4gTWF0aC5hY29zKDEgLSBtaW5TdGVwRGlzdGFuY2UoTWF0aC5taW4odywgc3RlcHMpLCB3KSkgLyAzO1xyXG4gICAgfSldKTtcclxuXHJcbiAgICBjb25zdCBwcm9wZXJ0eUJ1ZmZlciA9IGNyZWF0ZUFuZENvcHlCdWZmZXIoXHJcbiAgICAgICAgcHJvcGVydHlBcnJheSxcclxuICAgICAgICBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXHJcbiAgICAgICAgZGV2aWNlLFxyXG4gICAgKTtcclxuXHJcbiAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgIGxldCBtaXBMZXZlbCA9IDA7XHJcbiAgICAgICAgbGV0IG1pcFBhc3NlcyA9IDA7XHJcbiAgICAgICAgbGV0IHJlcXVpcmVkTWlwRGlzcGF0Y2hlcyA9IDA7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRNaXBEaXNwYXRjaGVzID0gMDtcclxuICAgICAgICBsZXQgYmF0Y2hEaXNwYXRjaGVzID0gMDtcclxuICAgICAgICBsZXQgYmluZGdyb3VwOiBHUFVCaW5kR3JvdXA7XHJcblxyXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJ1blBhc3MoKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50TWlwRGlzcGF0Y2hlcyA+PSByZXF1aXJlZE1pcERpc3BhdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIG1pcExldmVsICs9IDE7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TWlwRGlzcGF0Y2hlcyA9IDA7XHJcbiAgICAgICAgICAgICAgICBtaXBQYXNzZXMgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtaXBMZXZlbCA+PSBtaXBMZXZlbENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtaXBQaXhlbHMgPSA2ICogKCh3aWR0aCA+PiBtaXBMZXZlbCkgKiogMik7XHJcbiAgICAgICAgICAgICAgICByZXF1aXJlZE1pcERpc3BhdGNoZXMgPSBNYXRoLmNlaWwobWlwUGl4ZWxzIC8gZ3JvdXBzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBiaW5kZ3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IGJpbmRncm91cExheW91dCxcclxuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogbWlwVmlld3NbbWlwTGV2ZWwgLSAxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiBtaXBWaWV3c1ttaXBMZXZlbF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogeyBidWZmZXI6IHByb3BlcnR5QnVmZmVyIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcm9wZXJ0eUFycmF5WzBdID0gY3VycmVudE1pcERpc3BhdGNoZXMgKiBncm91cHM7XHJcbiAgICAgICAgICAgIGRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihwcm9wZXJ0eUJ1ZmZlciwgMCwgcHJvcGVydHlBcnJheSwgMCwgMSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwYXNzRGlzcGF0Y2hlcyA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWRNaXBEaXNwYXRjaGVzIC0gY3VycmVudE1pcERpc3BhdGNoZXMsXHJcbiAgICAgICAgICAgICAgICBtYXhEaXNwYXRjaGVzIC0gYmF0Y2hEaXNwYXRjaGVzLFxyXG4gICAgICAgICAgICAgICAgbWF4V29ya2dyb3VwcyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhc3NFbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBgJHtsYWJlbFRhZ30gbWlwICR7bWlwTGV2ZWx9LCBwYXNzICR7bWlwUGFzc2VzfSBlbmNvZGVyYCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwYXNzID0gcGFzc0VuY29kZXIuYmVnaW5Db21wdXRlUGFzcyh7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogYCR7bGFiZWxUYWd9IG1pcCAke21pcExldmVsfSwgcGFzcyAke21pcFBhc3Nlc31gLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHBhc3Muc2V0UGlwZWxpbmUocGlwZWxpbmUpO1xyXG4gICAgICAgICAgICBwYXNzLnNldEJpbmRHcm91cCgwLCBiaW5kZ3JvdXApO1xyXG4gICAgICAgICAgICBwYXNzLmRpc3BhdGNoV29ya2dyb3VwcyhwYXNzRGlzcGF0Y2hlcywgMSwgMSk7XHJcbiAgICAgICAgICAgIHBhc3MuZW5kKCk7XHJcblxyXG4gICAgICAgICAgICBkZXZpY2UucXVldWUuc3VibWl0KFtwYXNzRW5jb2Rlci5maW5pc2goKV0pO1xyXG5cclxuICAgICAgICAgICAgY3VycmVudE1pcERpc3BhdGNoZXMgKz0gcGFzc0Rpc3BhdGNoZXM7XHJcbiAgICAgICAgICAgIGJhdGNoRGlzcGF0Y2hlcyArPSBwYXNzRGlzcGF0Y2hlcztcclxuICAgICAgICAgICAgbWlwUGFzc2VzICs9IDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmF0Y2hEaXNwYXRjaGVzID49IG1heERpc3BhdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGJhdGNoRGlzcGF0Y2hlcyA9IDA7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkZXZpY2UucXVldWUub25TdWJtaXR0ZWRXb3JrRG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgZGVsYXlXb3JrKHJ1blBhc3MpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm9pZCBydW5QYXNzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgcnVuUGFzcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGdhdXNzaWFuUHlyYW1pZDtcclxufVxyXG4iLCJpbXBvcnQgeyBzaG93U2F2ZUZpbGVQaWNrZXIgfSBmcm9tICduYXRpdmUtZmlsZS1zeXN0ZW0tYWRhcHRlcic7XHJcblxyXG5pbXBvcnQgc2hvcmVsaW5lIGZyb20gJ3B1YmxpYy9lbnZpcm9ubWVudC1tYXBzL3Nob3JlbGluZS5rdHgyJztcclxuaW1wb3J0IHBhcGVybWlsbCBmcm9tICdwdWJsaWMvZW52aXJvbm1lbnQtbWFwcy9wYXBlcm1pbGwua3R4Mic7XHJcbmltcG9ydCBtYXJrZXQgZnJvbSAncHVibGljL2Vudmlyb25tZW50LW1hcHMvbGVsYW5kLW1hcmtldC5rdHgyJztcclxuXHJcbmltcG9ydCB7IEZ1bGxSZW5kZXJNb2RlbCB9IGZyb20gJy4uL3NhbXBsZS1zcGVjJztcclxuaW1wb3J0IHByb3BlcnR5TGlzdGVuZXIsIHsgTGlzdGVuZXJTeW1zIH0gZnJvbSAnLi4vcHJvcGVydHktbGlzdGVuZXInO1xyXG5pbXBvcnQgdHlwZSB7IFZpZXdJbmZvLCBTa3lib3hUYXJnZXQgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyLW1vZGVsJztcclxuaW1wb3J0IHsgY29weUtUWCwgdGV4dHVyZVRvS1RYIH0gZnJvbSAnLi4vLi4vdXRpbHMvZGF0YS1jb3B5JztcclxuaW1wb3J0IGN1YmVtYXBHdWFzc2lhblB5cmFtaWQgZnJvbSAnLi9jdWJlbWFwLWd1YXNzaWFuLXB5cmFtaWQnO1xyXG5pbXBvcnQgeyBtYXBWYWx1ZXMgfSBmcm9tICcuLi8uLi91dGlscy9nZW5lcmFsJztcclxuXHJcbmVudW0gQmx1clN0YXRlIHsgSURMRSwgQkxVUiwgV0FJVCB9XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdWJlbWFwQmx1ck1vZGVsIGltcGxlbWVudHMgRnVsbFJlbmRlck1vZGVsIHtcclxuICAgIHN0YXRpYyB0aXRsZSA9ICcnO1xyXG4gICAgc3RhdGljIGRlc2NyaXB0aW9uID0gJyc7XHJcblxyXG4gICAgY29sb3JBdHRhY2htZW50OiBHUFVSZW5kZXJQYXNzQ29sb3JBdHRhY2htZW50ID0ge1xyXG4gICAgICAgIGNsZWFyVmFsdWU6IHsgcjogMCwgZzogMCwgYjogMCwgYTogMSB9LFxyXG4gICAgICAgIGxvYWRPcDogJ2NsZWFyJyxcclxuICAgICAgICBzdG9yZU9wOiAnc3RvcmUnLFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXHJcbiAgICAgICAgdmlldzogdW5kZWZpbmVkISxcclxuICAgIH07XHJcblxyXG4gICAgcGFzc0Rlc2NyaXB0b3I6IEdQVVJlbmRlclBhc3NEZXNjcmlwdG9yID0geyBjb2xvckF0dGFjaG1lbnRzOiBbdGhpcy5jb2xvckF0dGFjaG1lbnRdIH07XHJcblxyXG4gICAgZGVwdGhUZXh0dXJlOiBHUFVUZXh0dXJlO1xyXG4gICAgZGVwdGhUZXh0dXJlVmlldzogR1BVVGV4dHVyZVZpZXc7XHJcblxyXG4gICAgc2t5Ym94PzogR1BVVGV4dHVyZTtcclxuICAgIHN0YXRlOiBCbHVyU3RhdGUgPSBCbHVyU3RhdGUuSURMRTtcclxuXHJcbiAgICByZWFkb25seSAjc2V0dGluZ3MgPSBwcm9wZXJ0eUxpc3RlbmVyKHtcclxuICAgICAgICBuZWFyZXN0U2FtcGxlOiB7XHJcbiAgICAgICAgICAgIFtMaXN0ZW5lclN5bXMuJHR5cGVdOiAnY2hlY2tib3gnIGFzIGNvbnN0LFxyXG4gICAgICAgICAgICBbTGlzdGVuZXJTeW1zLiRjYWxsYmFja106ICh2YWw6IHVua25vd24pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHRoaXMuc2t5Ym94VGFyZ2V0LnVzZU5lYXJlc3RTYW1wbGUgPSB2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNreWJveFRhcmdldC51c2VOZWFyZXN0U2FtcGxlLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Rpc2FibGVzIGxpbmVhciBzYW1wbGluZyBpbiB0aGUgdmlld2VyLicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXBMZXZlbDoge1xyXG4gICAgICAgICAgICBbTGlzdGVuZXJTeW1zLiR0eXBlXTogJ3NsaWRlcicgYXMgY29uc3QsXHJcbiAgICAgICAgICAgIFtMaXN0ZW5lclN5bXMuJGNhbGxiYWNrXTogKHZhbHVlOiB1bmtub3duKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgdGhpcy5za3lib3hUYXJnZXQubWlwTGV2ZWwgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgIG1pbjogMCxcclxuICAgICAgICAgICAgbWF4OiAxLFxyXG4gICAgICAgICAgICBzdGVwOiAwLjEsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIG1pcCBsZXZlbCB0byBkaXNwbGF5IGluIHRoZSB2aWV3ZXIuIDAgaXMgdGhlIG9yaWduYWwgaW1hZ2UsIG1heCBpcyBjb21wbGV0ZWx5IGJsdXJyZWQgd2l0aCAxIHBpeGVsIGZhY2VzLicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaWx0ZXJEaXN0YW5jZToge1xyXG4gICAgICAgICAgICBbTGlzdGVuZXJTeW1zLiR0eXBlXTogJ3NsaWRlcicgYXMgY29uc3QsXHJcbiAgICAgICAgICAgIFtMaXN0ZW5lclN5bXMuJGNhbGxiYWNrXTogdGhpcy5yZWJsdXIuYmluZCh0aGlzKSBhcyAoKSA9PiB2b2lkLFxyXG4gICAgICAgICAgICB2YWx1ZTogMixcclxuICAgICAgICAgICAgbWF4OiA2NCxcclxuICAgICAgICAgICAgbWluOiAwLFxyXG4gICAgICAgICAgICBzdGVwOiAwLjEsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIG51bWJlciBvZiBwaXhlbHMgdG8gYmx1ciBmcm9tLicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBza3lib3g6IHtcclxuICAgICAgICAgICAgW0xpc3RlbmVyU3ltcy4kdHlwZV06ICdmaWxlJyBhcyBjb25zdCxcclxuICAgICAgICAgICAgW0xpc3RlbmVyU3ltcy4kY2FsbGJhY2tdOiAodmFsOiB1bmtub3duLCBrZXk6IFByb3BlcnR5S2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIHZhbCAhPSBudWxsKSB2b2lkICh2YWwgYXMgUHJvbWlzZTxHUFVUZXh0dXJlPikudGhlbih0aGlzLnNldFNreWJveC5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWNjZXB0OiAnLmt0eDInLFxyXG4gICAgICAgICAgICBzZWxlY3Rpb246IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAncGFwZXJtaWxsJyxcclxuICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZXM6IG1hcFZhbHVlcyhcclxuICAgICAgICAgICAgICAgICAgICB7IHBhcGVybWlsbCwgc2hvcmVsaW5lLCBtYXJrZXQgfSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NTa3lib3guYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByb2Nlc3M6IHRoaXMucHJvY2Vzc1NreWJveC5iaW5kKHRoaXMpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ0Rvd25sb2FkIFJlc3VsdCc6IHtcclxuICAgICAgICAgICAgW0xpc3RlbmVyU3ltcy4kdHlwZV06ICdidXR0b24nIGFzIGNvbnN0LFxyXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7IHZvaWQgdGhpcy5zYXZlRmlsZSgpOyB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICByZWFkb25seSBzZXR0aW5ncyA9IHRoaXMuI3NldHRpbmdzLnB1YmxpY1NldHRpbmdzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgZGV2aWNlOiBHUFVEZXZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBza3lib3hUYXJnZXQ6IFNreWJveFRhcmdldCxcclxuICAgICAgICB0YXJnZXQ6IFZpZXdJbmZvLFxyXG4gICAgKSB7XHJcbiAgICAgICAgdGhpcy5kZXB0aFRleHR1cmUgPSBkZXZpY2UuY3JlYXRlVGV4dHVyZSh7XHJcbiAgICAgICAgICAgIGRpbWVuc2lvbjogJzJkJyxcclxuICAgICAgICAgICAgZm9ybWF0OiAnZGVwdGgzMmZsb2F0JyxcclxuICAgICAgICAgICAgc2l6ZTogeyB3aWR0aDogMSwgaGVpZ2h0OiAxIH0sXHJcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlRcclxuICAgICAgICAgICAgfCBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmRlcHRoVGV4dHVyZVZpZXcgPSB0aGlzLmRlcHRoVGV4dHVyZS5jcmVhdGVWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jb2xvckF0dGFjaG1lbnQudmlldyA9IHRhcmdldC52aWV3O1xyXG5cclxuICAgICAgICBjb25zdCBlbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKHsgbGFiZWw6ICdjdWJlbWFwIGJsdXIgZHVtbXkgZGVwdGggZW5jb2RlcicgfSk7XHJcbiAgICAgICAgY29uc3QgcGFzcyA9IGVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKHtcclxuICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW10sXHJcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQ6IHtcclxuICAgICAgICAgICAgICAgIGRlcHRoQ2xlYXJWYWx1ZTogMSxcclxuICAgICAgICAgICAgICAgIGRlcHRoTG9hZE9wOiAnY2xlYXInLFxyXG4gICAgICAgICAgICAgICAgZGVwdGhTdG9yZU9wOiAnc3RvcmUnLFxyXG4gICAgICAgICAgICAgICAgdmlldzogdGhpcy5kZXB0aFRleHR1cmVWaWV3LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBhc3MuZW5kKCk7XHJcbiAgICAgICAgdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFtlbmNvZGVyLmZpbmlzaCgpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKGVuY29kZXI6IEdQVUNvbW1hbmRFbmNvZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKHRoaXMucGFzc0Rlc2NyaXB0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFRhcmdldCh2aWV3OiBWaWV3SW5mbykge1xyXG4gICAgICAgIHRoaXMuY29sb3JBdHRhY2htZW50LnZpZXcgPSB2aWV3LnZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2Vzc1NreWJveChmaWxlOiBzdHJpbmcgfCBVUkwgfCBGaWxlIHwgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICByZXR1cm4gY29weUtUWChmaWxlLCB0aGlzLmRldmljZSwge1xyXG4gICAgICAgICAgICBtaXBMZXZlbENvdW50OiAnbWF4JyxcclxuICAgICAgICAgICAgdGV4dHVyZVVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDLFxyXG4gICAgICAgICAgICB2YWxpZGF0ZTogdHJ1ZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzZXRTa3lib3gocmVzb3VyY2U6IEdQVVRleHR1cmUgfCBzdHJpbmcgfCBVUkwgfCBGaWxlIHwgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLnNreWJveCA9IHJlc291cmNlIGluc3RhbmNlb2YgR1BVVGV4dHVyZVxyXG4gICAgICAgICAgICA/IHJlc291cmNlXHJcbiAgICAgICAgICAgIDogYXdhaXQgdGhpcy5wcm9jZXNzU2t5Ym94KHJlc291cmNlKTtcclxuXHJcbiAgICAgICAgdGhpcy4jc2V0dGluZ3MucHJpdmF0ZVNldHRpbmdzLm1pcExldmVsLm1heCA9IHRoaXMuc2t5Ym94Lm1pcExldmVsQ291bnQgLSAxO1xyXG4gICAgICAgIHRoaXMuI3NldHRpbmdzLnByaXZhdGVTZXR0aW5ncy5taXBMZXZlbC52YWx1ZSA9IDE7XHJcbiAgICAgICAgdGhpcy5za3lib3hUYXJnZXQubWlwTGV2ZWwgPSAxO1xyXG5cclxuICAgICAgICB2b2lkIHRoaXMucmVibHVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzb2x2ZSgpIHtcclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICBjb25zdCBsYXN0U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBCbHVyU3RhdGUuSURMRTtcclxuICAgICAgICBpZiAobGFzdFN0YXRlID09PSBCbHVyU3RhdGUuV0FJVCkgdm9pZCB0aGlzLnJlYmx1cigpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHJlYmx1cigpIHtcclxuICAgICAgICBpZiAodGhpcy5za3lib3ggPT0gbnVsbCB8fCB0aGlzLnN0YXRlID09PSBCbHVyU3RhdGUuV0FJVCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQmx1clN0YXRlLkJMVVIpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEJsdXJTdGF0ZS5XQUlUO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gQmx1clN0YXRlLkJMVVI7XHJcblxyXG4gICAgICAgIGF3YWl0IGN1YmVtYXBHdWFzc2lhblB5cmFtaWQoe1xyXG4gICAgICAgICAgICBkZXZpY2U6IHRoaXMuZGV2aWNlLFxyXG4gICAgICAgICAgICB0ZXh0dXJlOiB0aGlzLnNreWJveCxcclxuICAgICAgICAgICAgaW5QbGFjZTogdHJ1ZSxcclxuICAgICAgICAgICAgc3RlcHM6IHRoaXMuc2V0dGluZ3MuZmlsdGVyRGlzdGFuY2UudmFsdWUsXHJcbiAgICAgICAgICAgIGRlbGF5V29yazogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlc29sdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICByZWZyZXNoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNreWJveCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy5za3lib3hUYXJnZXQuc2t5VGV4dHVyZSA9IHRoaXMuc2t5Ym94LmNyZWF0ZVZpZXcoeyBkaW1lbnNpb246ICdjdWJlJyB9KTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzYXZlRmlsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5za3lib3ggPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21zID0gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZVRvS1RYKHRoaXMuZGV2aWNlLCB0aGlzLnNreWJveCwgdHJ1ZSksXHJcbiAgICAgICAgICAgICAgICBzaG93U2F2ZUZpbGVQaWNrZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbeyBhY2NlcHQ6IHsgJ2ltYWdlL2t0eDInOiBbJy5rdHgyJ10gfSB9XSxcclxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWROYW1lOiAnYmx1cmVkLXNreWJveC5rdHgyJyxcclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKGhhbmRsZSkgPT4gaGFuZGxlLmNyZWF0ZVdyaXRhYmxlKHsga2VlcEV4aXN0aW5nRGF0YTogZmFsc2UgfSkpLFxyXG4gICAgICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IFtrdHgyLCBzdHJlYW1dID0gYXdhaXQgcHJvbXM7XHJcbiAgICAgICAgICAgIGF3YWl0IG5ldyBCbG9iKFtrdHgyXSwgeyB0eXBlOiAnaW1hZ2Uva3R4MicgfSkuc3RyZWFtKCkucGlwZVRvKHN0cmVhbSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///427\n")}}]);