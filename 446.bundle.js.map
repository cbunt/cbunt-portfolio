{"version":3,"file":"446.bundle.js","mappings":"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","sources":["webpack://cbunt-portfolio/./src/rendering/core/camera/camera.ts","webpack://cbunt-portfolio/./src/rendering/core/constants.ts","webpack://cbunt-portfolio/./src/rendering/utils/shader.ts","webpack://cbunt-portfolio/./src/rendering/shaders/forward.shader.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/descriptor-map.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/pipeline-feature-flags.ts","webpack://cbunt-portfolio/./src/rendering/core/global-uniforms.ts","webpack://cbunt-portfolio/./src/rendering/samples/cubemap-blur/cubemap-guassian-pyramid.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/gltf-viewer-sample.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/weld.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/primitive-draw-data.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/type-conversions.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/attribute-wrapper.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/primitive-loader.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/interleave-vertices.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/material-loader.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/material-draw-data.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/geometry-pipeline.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/gltf-loader.ts","webpack://cbunt-portfolio/./src/rendering/samples/settings/skybox-options.ts","webpack://cbunt-portfolio/./src/rendering/shaders/blit-vert.shader.ts","webpack://cbunt-portfolio/./src/rendering/shaders/cubemap-sampling.shader.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-copy.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-conversion.ts","webpack://cbunt-portfolio/./src/rendering/utils/texture-importing.ts","webpack://cbunt-portfolio/./src/rendering/utils/texture-processing.ts"],"sourcesContent":["import { Vec3, Mat4, mat4, Quat } from 'wgpu-matrix';\r\nimport { TypeSizes } from '../constants';\r\n\r\nexport type CameraParams = {\r\n    nearPlane: number,\r\n    farPlane: number,\r\n    fov: number,\r\n    width: number,\r\n    height: number,\r\n    projection: 'perspective' | 'ortho',\r\n};\r\n\r\nexport default class Camera {\r\n    static readonly worldToViewOffset = 0;\r\n    static readonly viewToClipOffset = this.worldToViewOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly worldToClipOffset = this.viewToClipOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly viewToWorldOffset = this.worldToClipOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly clipToViewOffset = this.viewToWorldOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly clipToWorldOffset = this.clipToViewOffset + TypeSizes.sizeofMat4x4f;\r\n\r\n    static readonly bufferLength = this.clipToWorldOffset + TypeSizes.sizeofMat4x4f;\r\n\r\n    /**\r\n   *  An ArrayBuffer containing the camera's worldToView, viewToClip, worldToClip,\r\n   *  viewToWorld, clipToView, and clipToWorld matrices as Float32Arrays for\r\n   *  easier transfer. Ordered as listed above.\r\n   */\r\n    readonly buffer: ArrayBuffer = new ArrayBuffer(Camera.bufferLength);\r\n\r\n    readonly worldToView: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.worldToViewOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly viewToClip: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.viewToClipOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly worldToClip: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.worldToClipOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly viewToWorld: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.viewToWorldOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly clipToView: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.clipToViewOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly clipToWorld: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.clipToWorldOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly location: Vec3 = new Float32Array([0, 0, 0]);\r\n    readonly rotation: Quat = new Float32Array([0, 0, 0, 1]);\r\n\r\n    params: CameraParams = {\r\n        nearPlane: 0.01,\r\n        farPlane: 500.0,\r\n        fov: 40,\r\n        width: 1920,\r\n        height: 1080,\r\n        projection: 'perspective',\r\n    };\r\n\r\n    constructor(viewParams: Partial<CameraParams> = {}) {\r\n        this.updateParams(viewParams);\r\n    }\r\n\r\n    updateParams(val: Partial<CameraParams>) {\r\n        this.params = { ...this.params, ...val };\r\n        this.#cacheProjection();\r\n    }\r\n\r\n    cacheView(): void {\r\n        mat4.fromQuat(this.rotation, this.viewToWorld);\r\n        mat4.setTranslation(this.viewToWorld, this.location, this.viewToWorld);\r\n        mat4.invert(this.viewToWorld, this.worldToView);\r\n        mat4.mul(this.viewToClip, this.worldToView, this.worldToClip);\r\n        mat4.mul(this.viewToWorld, this.clipToView, this.clipToWorld);\r\n    }\r\n\r\n    #cacheProjection(): void {\r\n        if (this.params.projection === 'perspective') {\r\n            mat4.perspective(\r\n                this.params.fov * (Math.PI / 180),\r\n                this.params.width / this.params.height,\r\n                this.params.nearPlane,\r\n                this.params.farPlane,\r\n                this.viewToClip,\r\n            );\r\n        } else {\r\n            const x = this.params.width / 2;\r\n            const y = this.params.height / 2;\r\n\r\n            mat4.ortho(\r\n                -x,\r\n                x,\r\n                -y,\r\n                y,\r\n                this.params.nearPlane,\r\n                this.params.farPlane,\r\n                this.viewToClip,\r\n            );\r\n        }\r\n\r\n        mat4.invert(this.viewToClip, this.clipToView);\r\n    }\r\n}\r\n","import * as ktxp from 'ktx-parse';\r\n\r\nexport const TypeSizes = {\r\n    mat4x4Count: 16,\r\n    sizeofMat4x4f: 16 * Float32Array.BYTES_PER_ELEMENT,\r\n};\r\n\r\nexport const VkFormatToWebGPU: Record<number, GPUTextureFormat | undefined> = {\r\n    // 8-bit formats\r\n    [ktxp.VK_FORMAT_R8_UNORM]: 'r8unorm',\r\n    [ktxp.VK_FORMAT_R8_SNORM]: 'r8snorm',\r\n    [ktxp.VK_FORMAT_R8_UINT]: 'r8uint',\r\n    [ktxp.VK_FORMAT_R8_SINT]: 'r8sint',\r\n    // 16-bit formats\r\n    [ktxp.VK_FORMAT_R16_UINT]: 'r16uint',\r\n    [ktxp.VK_FORMAT_R16_SINT]: 'r16sint',\r\n    [ktxp.VK_FORMAT_R16_SFLOAT]: 'r16float',\r\n    [ktxp.VK_FORMAT_R8G8_UNORM]: 'rg8unorm',\r\n    [ktxp.VK_FORMAT_R8G8_SNORM]: 'rg8snorm',\r\n    [ktxp.VK_FORMAT_R8G8_UINT]: 'rg8uint',\r\n    [ktxp.VK_FORMAT_R8G8_SINT]: 'rg8sint',\r\n    // 32-bit formats\r\n    [ktxp.VK_FORMAT_R32_UINT]: 'r32uint',\r\n    [ktxp.VK_FORMAT_R32_SINT]: 'r32sint',\r\n    [ktxp.VK_FORMAT_R32_SFLOAT]: 'r32float',\r\n    [ktxp.VK_FORMAT_R16G16_UINT]: 'rg16uint',\r\n    [ktxp.VK_FORMAT_R16G16_SINT]: 'rg16sint',\r\n    [ktxp.VK_FORMAT_R16G16_SFLOAT]: 'rg16float',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UNORM]: 'rgba8unorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SRGB]: 'rgba8unorm-srgb',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SNORM]: 'rgba8snorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UINT]: 'rgba8uint',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SINT]: 'rgba8sint',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_UNORM]: 'bgra8unorm',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_SRGB]: 'bgra8unorm-srgb',\r\n    // Packed 32-bit formats\r\n    [ktxp.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32]: 'rgb9e5ufloat',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UINT_PACK32]: 'rgb10a2uint',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UNORM_PACK32]: 'rgb10a2unorm',\r\n    [ktxp.VK_FORMAT_B10G11R11_UFLOAT_PACK32]: 'rg11b10ufloat',\r\n    // 64-bit formats\r\n    [ktxp.VK_FORMAT_R32G32_UINT]: 'rg32uint',\r\n    [ktxp.VK_FORMAT_R32G32_SINT]: 'rg32sint',\r\n    [ktxp.VK_FORMAT_R32G32_SFLOAT]: 'rg32float',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_UINT]: 'rgba16uint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SINT]: 'rgba16sint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SFLOAT]: 'rgba16float',\r\n    // 128-bit formats\r\n    [ktxp.VK_FORMAT_R32G32B32A32_UINT]: 'rgba32uint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SINT]: 'rgba32sint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SFLOAT]: 'rgba32float',\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    [ktxp.VK_FORMAT_BC1_RGBA_UNORM_BLOCK]: 'bc1-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC1_RGBA_SRGB_BLOCK]: 'bc1-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC2_UNORM_BLOCK]: 'bc2-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC2_SRGB_BLOCK]: 'bc2-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC3_UNORM_BLOCK]: 'bc3-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC3_SRGB_BLOCK]: 'bc3-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC4_UNORM_BLOCK]: 'bc4-r-unorm',\r\n    [ktxp.VK_FORMAT_BC4_SNORM_BLOCK]: 'bc4-r-snorm',\r\n    [ktxp.VK_FORMAT_BC5_UNORM_BLOCK]: 'bc5-rg-unorm',\r\n    [ktxp.VK_FORMAT_BC5_SNORM_BLOCK]: 'bc5-rg-snorm',\r\n    [ktxp.VK_FORMAT_BC6H_UFLOAT_BLOCK]: 'bc6h-rgb-ufloat',\r\n    [ktxp.VK_FORMAT_BC6H_SFLOAT_BLOCK]: 'bc6h-rgb-float',\r\n    [ktxp.VK_FORMAT_BC7_UNORM_BLOCK]: 'bc7-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC7_SRGB_BLOCK]: 'bc7-rgba-unorm-srgb',\r\n    // Currently unsupported extension formats:\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"etc2-rgb8unorm\",\r\n    // \"etc2-rgb8unorm-srgb\",\r\n    // \"etc2-rgb8a1unorm\",\r\n    // \"etc2-rgb8a1unorm-srgb\",\r\n    // \"etc2-rgba8unorm\",\r\n    // \"etc2-rgba8unorm-srgb\",\r\n    // \"eac-r11unorm\",\r\n    // \"eac-r11snorm\",\r\n    // \"eac-rg11unorm\",\r\n    // \"eac-rg11snorm\",\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"astc-4x4-unorm\",\r\n    // \"astc-4x4-unorm-srgb\",\r\n    // \"astc-5x4-unorm\",\r\n    // \"astc-5x4-unorm-srgb\",\r\n    // \"astc-5x5-unorm\",\r\n    // \"astc-5x5-unorm-srgb\",\r\n    // \"astc-6x5-unorm\",\r\n    // \"astc-6x5-unorm-srgb\",\r\n    // \"astc-6x6-unorm\",\r\n    // \"astc-6x6-unorm-srgb\",\r\n    // \"astc-8x5-unorm\",\r\n    // \"astc-8x5-unorm-srgb\",\r\n    // \"astc-8x6-unorm\",\r\n    // \"astc-8x6-unorm-srgb\",\r\n    // \"astc-8x8-unorm\",\r\n    // \"astc-8x8-unorm-srgb\",\r\n    // \"astc-10x5-unorm\",\r\n    // \"astc-10x5-unorm-srgb\",\r\n    // \"astc-10x6-unorm\",\r\n    // \"astc-10x6-unorm-srgb\",\r\n    // \"astc-10x8-unorm\",\r\n    // \"astc-10x8-unorm-srgb\",\r\n    // \"astc-10x10-unorm\",\r\n    // \"astc-10x10-unorm-srgb\",\r\n    // \"astc-12x10-unorm\",\r\n    // \"astc-12x10-unorm-srgb\",\r\n    // \"astc-12x12-unorm\",\r\n};\r\n\r\nexport const TextureFormatToSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 2,\r\n    rg8snorm: 2,\r\n    rg8uint: 2,\r\n    rg8sint: 2,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 4,\r\n    rg16sint: 4,\r\n    rg16float: 4,\r\n    rgba8unorm: 4,\r\n    'rgba8unorm-srgb': 4,\r\n    rgba8snorm: 4,\r\n    rgba8uint: 4,\r\n    rgba8sint: 4,\r\n    bgra8unorm: 4,\r\n    'bgra8unorm-srgb': 4,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 8,\r\n    rg32sint: 8,\r\n    rg32float: 8,\r\n    rgba16uint: 8,\r\n    rgba16sint: 8,\r\n    rgba16float: 8,\r\n    // 128-bit formats\r\n    rgba32uint: 16,\r\n    rgba32sint: 16,\r\n    rgba32float: 16,\r\n};\r\n\r\nexport const TextureFormatToChannelSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 1,\r\n    rg8snorm: 1,\r\n    rg8uint: 1,\r\n    rg8sint: 1,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 2,\r\n    rg16sint: 2,\r\n    rg16float: 2,\r\n    rgba8unorm: 1,\r\n    'rgba8unorm-srgb': 1,\r\n    rgba8snorm: 1,\r\n    rgba8uint: 1,\r\n    rgba8sint: 1,\r\n    bgra8unorm: 1,\r\n    'bgra8unorm-srgb': 1,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 4,\r\n    rg32sint: 4,\r\n    rg32float: 4,\r\n    rgba16uint: 2,\r\n    rgba16sint: 2,\r\n    rgba16float: 2,\r\n    // 128-bit formats\r\n    rgba32uint: 4,\r\n    rgba32sint: 4,\r\n    rgba32float: 4,\r\n};\r\n\r\nexport const WebGPUToVkFormat = Object.fromEntries(\r\n    Object.entries(VkFormatToWebGPU).map(([vk, wgpu]) => [wgpu, parseInt(vk, 10)]),\r\n) as Record<GPUTextureFormat, ktxp.VKFormat>;\r\n\r\nexport const textureTypeToDimension: Record<string, GPUTextureViewDimension> = {\r\n    texture_cube: 'cube',\r\n    texture_3d: '3d',\r\n    texture_2d: '2d',\r\n};\r\n","export type Branch = string | (() => string);\r\n\r\nfunction resolveBranch(branch: Branch) {\r\n    return typeof branch === 'string' ? branch : branch();\r\n}\r\n\r\nclass PreprocessorStatement {\r\n    res?: string;\r\n\r\n    constructor(cond: boolean, branch: Branch) {\r\n        if (cond) this.res = resolveBranch(branch);\r\n    }\r\n\r\n    elif(cond: boolean, branch: Branch) {\r\n        if (cond) this.res ??= resolveBranch(branch);\r\n        return this;\r\n    }\r\n\r\n    else = (branch: Branch) => this.res ?? resolveBranch(branch);\r\n\r\n    toString = () => this.res ?? '';\r\n\r\n    get [Symbol.toStringTag]() { return this.toString(); }\r\n}\r\n\r\nexport function preprocessors(flags: number) {\r\n    return {\r\n        ifdef(sym: number, branch: Branch) {\r\n            return new PreprocessorStatement((flags & sym) === sym, branch);\r\n        },\r\n        ifndef(sym: number, branch: Branch) {\r\n            return new PreprocessorStatement((flags & sym) !== sym, branch);\r\n        },\r\n    };\r\n}\r\n\r\nexport function wrapWithIncrement<T>(fn: (counter: number) => T, start = 0): () => T {\r\n    return () => fn(start++);\r\n}\r\n","/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\nimport { PipelineFeatureFlags, featureFlagsToString } from '../core/default-forward-pass/pipeline-feature-flags';\nimport { preprocessors, wrapWithIncrement } from '../utils/shader';\nimport GlobalUniforms from '../core/global-uniforms';\nimport { GBufferGroupIndices } from '../core/gbuffer';\n\nexport function getBindgroupInfo(flags: PipelineFeatureFlags): GPUBindGroupLayoutDescriptor {\n    const entries: GPUBindGroupLayoutEntry[] = [];\n\n    function pushItem(item: Omit<GPUBindGroupLayoutEntry, 'binding' | 'visibility'>) {\n        entries.push({ ...item, binding: entries.length, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX });\n    }\n\n    pushItem({ buffer: { type: 'uniform' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    if (flags & PipelineFeatureFlags.Emissive) {\n        pushItem({ sampler: {} });\n        pushItem({ texture: { viewDimension: '2d' } });\n    }\n\n    return { label: featureFlagsToString(flags), entries };\n}\n\n/**\n * @param flags A flag enum containing the features this code should be generated for\n * @returns A string containing preprocessed wgsl shader code for the given features\n */\nexport default function include(flags: PipelineFeatureFlags) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { ifdef } = preprocessors(flags as number);\n    const vertexInLocation = wrapWithIncrement((idx) => /* wgsl */`@location(${idx})`);\n    const varyingsLocation = wrapWithIncrement((idx) => /* wgsl */`@location(${idx})`);\n\n    const materialBinding = wrapWithIncrement((idx) => /* wgsl */`\n        @group(1) @binding(${idx})\n    `);\n\n    const varyings = /* wgsl */`\n        ${varyingsLocation()} pos: vec3f,\n        ${varyingsLocation()} camPos: vec3f,\n        ${varyingsLocation()} uv: vec2f,\n\n        ${ifdef(PipelineFeatureFlags.VertexNormals, () => /* wgsl */`\n            ${varyingsLocation()} tangent: vec4f,\n            ${varyingsLocation()} normal: vec3f,\n        `)}\n\n        ${ifdef(PipelineFeatureFlags.VertexColors, () => /* wgsl */`\n            ${varyingsLocation()} color: vec4f,\n        `)}\n    `;\n\n    return /* wgsl */`\n        ${GlobalUniforms.code(0)}\n\n        struct ForwardOut {\n            @location(${GBufferGroupIndices.Normal}) normal: vec4f,\n            @location(${GBufferGroupIndices.Albedo}) albedo: vec4f,\n            @location(${GBufferGroupIndices.Emission}) emission: vec4f,\n            @location(${GBufferGroupIndices.MetallicRoughness}) metallicRoughness: vec4f,\n        }\n\n        struct MaterialProperties {\n            baseColorFactor: vec4f,\n            metallicFactor: f32,\n            roughnessFactor: f32,\n\n            ${ifdef(PipelineFeatureFlags.AlphaCutoff, 'alphaCutoff: f32,')}\n            ${ifdef(PipelineFeatureFlags.Emissive, 'emissiveFactor: vec3f,')}\n        }\n\n        ${materialBinding()} var<uniform> material: MaterialProperties;\n\n        ${materialBinding()} var baseColorSampler: sampler;\n        ${materialBinding()} var baseColorTexture: texture_2d<f32>;\n\n        ${materialBinding()} var normalSampler: sampler;\n        ${materialBinding()} var normalTexture: texture_2d<f32>;\n\n        ${materialBinding()} var metallicRoughnessSampler: sampler;\n        ${materialBinding()} var metallicRoughnessTexture: texture_2d<f32>;\n\n        ${ifdef(PipelineFeatureFlags.Emissive, () => /* wgsl */`\n            ${materialBinding()} var emissionSampler: sampler;\n            ${materialBinding()} var emissionTexture: texture_2d<f32>;\n        `)}\n\n        struct ModelProperties {\n            modelToWorldMatrix: mat4x4f,\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, 'normalMatrix: mat3x3f,')}\n        }\n\n        @group(2) @binding(0) var<storage, read> instances : array<ModelProperties>;\n\n        struct VertIn {\n            @builtin(instance_index) instance: u32,\n            ${vertexInLocation()} pos: vec3f,\n            ${vertexInLocation()} uv: vec2f,\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, () => /* wgsl */`\n                ${vertexInLocation()} tangent: vec4f,\n                ${vertexInLocation()} normal: vec3f,\n            `)}\n\n            ${ifdef(PipelineFeatureFlags.VertexColors, () => /* wgsl */`\n                ${vertexInLocation()} color: vec4f,\n            `)}\n        }\n\n        struct VertOut {\n            ${varyings}\n            @builtin(position) Position: vec4f,\n        }\n\n        struct FragIn {\n            ${varyings}\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals | PipelineFeatureFlags.DoubleSided, /* wgsl */`\n                @builtin(front_facing) front_facing: bool,\n            `)}\n        }\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @vertex \n        fn vs(inData: VertIn) -> VertOut {\n            var vsOut: VertOut;\n            let instance = instances[inData.instance];\n            let worldPos = instance.modelToWorldMatrix * vec4f(inData.pos, 1);\n            vsOut.pos = worldPos.xyz;\n            vsOut.Position = globals.worldToClip * worldPos;\n            vsOut.camPos = globals.inverseWorldToView[3].xyz;\n            vsOut.uv = inData.uv;\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, /* wgsl */`\n                vsOut.normal = normalize(instance.normalMatrix * inData.normal);\n                let wsTangent = normalize((instance.modelToWorldMatrix * vec4(inData.tangent.xyz, 0.0)).xyz);\n                vsOut.tangent = vec4(wsTangent, inData.tangent.w);\n            `)}\n\n            return vsOut;\n        }\n\n        // much of this code is adapted from https://learnopengl.com/PBR\n        @fragment\n        fn fs(inData: FragIn) -> ForwardOut {\n            var out: ForwardOut;\n            let rawColor = textureSample(baseColorTexture, baseColorSampler, inData.uv);\n\n            ${ifdef(PipelineFeatureFlags.AlphaCutoff, /* wgsl */`\n                var alpha = rawColor.a * material.baseColorFactor.a;\n\n                ${ifdef(PipelineFeatureFlags.VertexColors, /* wgsl */`\n                    alpha *= inData.color.a;\n                `)}\n\n                if (alpha <= material.alphaCutoff) { \n                    discard;\n                }\n            `)}\n\n            out.albedo = vec4f(rawColor.rgb * material.baseColorFactor.rgb, 1);\n\n            ${ifdef(PipelineFeatureFlags.VertexColors, /* wgsl */`\n                out.albedo *= vec4f(inData.color.rgb, 1);\n            `)}\n\n            let metallicRoughness = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, inData.uv);\n            out.metallicRoughness.r = saturate(metallicRoughness.b * material.metallicFactor);\n            out.metallicRoughness.g = saturate(metallicRoughness.g * material.roughnessFactor);\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, /* wgsl */`\n                let normalSample = textureSample(normalTexture, normalSampler, inData.uv).xyz;\n                let tangentNormal = normalize(normalSample * 2.0 - 1.0);\n                let bitangent =inData.tangent.w * cross(inData.normal, inData.tangent.xyz);\n                let tbn = mat3x3f(normalize(inData.tangent.xyz), bitangent, normalize(inData.normal));\n                var normal = normalize(tbn * tangentNormal);\n\n                ${ifdef(PipelineFeatureFlags.DoubleSided, /* wgsl */`\n                    if (!inData.front_facing) { normal *= -1.0; }\n                `)}\n            `).else(/* wgsl */`\n                let fdx = dpdx(inData.pos);\n                let fdy = dpdy(inData.pos);\n                let normal = normalize(cross(fdy, fdx));\n            `)}\n\n            out.normal = vec4f(normal, 1);\n\n            ${ifdef(PipelineFeatureFlags.Emissive, /* wgsl */`\n                let emission = textureSample(emissionTexture, emissionSampler, inData.uv).rgb;\n                out.emission = vec4f(emission, 1);\n            `)}\n\n            return out;\n        }\n    `;\n}\n","import { PipelineFeatureFlags } from './pipeline-feature-flags';\nimport * as PipelineFeatures from './pipeline-feature-flags';\nimport include, { getBindgroupInfo as getBindGroupInfo } from '../../shaders/forward.shader';\n\nimport GBuffer from '../gbuffer';\nimport GlobalUniforms from '../global-uniforms';\n\ntype PipelineFeatureMap<T> = Partial<Record<number, T>>;\n\nexport default class DescriptorMap {\n    static readonly flagToTopology: Partial<Record<PipelineFeatureFlags, GPUPrimitiveTopology>> = {\n        [PipelineFeatureFlags.TriangleList]: 'triangle-list',\n        [PipelineFeatureFlags.TriangleStrip]: 'triangle-strip',\n        [PipelineFeatureFlags.PointList]: 'point-list',\n        [PipelineFeatureFlags.LineList]: 'line-list',\n        [PipelineFeatureFlags.LineStrip]: 'line-strip',\n    };\n\n    readonly pipelineLayouts: PipelineFeatureMap<GPUPipelineLayout> = {};\n    readonly primitiveStates: PipelineFeatureMap<GPUPrimitiveState> = {};\n    readonly vertexLayouts: PipelineFeatureMap<GPUVertexBufferLayout> = {};\n    readonly shaderModules: PipelineFeatureMap<GPUShaderModule> = {};\n    readonly bindgroupLayouts: PipelineFeatureMap<GPUBindGroupLayout> = {};\n\n    readonly samplers: Partial<Record<string, GPUSampler>> = {};\n\n    readonly forwardBindgroupLayout = this.device.createBindGroupLayout({\n        label: `forward material`,\n        entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n            buffer: { type: 'read-only-storage' },\n        }],\n    });\n\n    constructor(\n        public readonly device: GPUDevice,\n        public readonly gbuffer: GBuffer,\n        public readonly globals: GlobalUniforms,\n    ) { }\n\n    getSampler(descriptor: GPUSamplerDescriptor) {\n        const key = JSON.stringify(descriptor);\n        this.samplers[key] ??= this.device.createSampler(descriptor);\n        return this.samplers[key];\n    }\n\n    getVertexLayout(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.VertexBufferLayoutMask;\n\n        if (this.vertexLayouts[masked] == null) {\n            const attributes: GPUVertexAttribute[] = [\n                { shaderLocation: 0, offset: 0, format: 'float32x3' }, // position\n                { shaderLocation: 1, offset: 12, format: 'float32x2' }, // uv\n            ];\n\n            let arrayStride = 20;\n            let shaderLocation = 2;\n\n            if (masked & PipelineFeatureFlags.VertexNormals) {\n                attributes.push({ shaderLocation, offset: arrayStride, format: 'float32x4' }); // tangent\n                attributes.push({ shaderLocation: shaderLocation + 1, offset: arrayStride + 16, format: 'float32x3' }); // normal\n                shaderLocation += 2;\n                arrayStride += 28;\n            }\n\n            if (masked & PipelineFeatureFlags.VertexColors) {\n                attributes.push({ shaderLocation, offset: arrayStride, format: 'float32x4' }); // color\n                arrayStride += 16;\n            }\n\n            this.vertexLayouts[masked] = { attributes, arrayStride, stepMode: 'vertex' };\n        }\n\n        return this.vertexLayouts[masked];\n    }\n\n    getForwardPipelineLayout(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.PipelineLayoutMask;\n\n        this.pipelineLayouts[masked] ??= this.device.createPipelineLayout({\n            label: PipelineFeatures.featureFlagsToString(masked),\n            bindGroupLayouts: [\n                this.globals.bindGroupLayout,\n                this.getMaterialBindGroup(flags),\n                this.forwardBindgroupLayout,\n            ],\n        });\n\n        return this.pipelineLayouts[masked];\n    }\n\n    getShaderModule(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.CodeMask;\n        this.shaderModules[masked] ??= this.device.createShaderModule({\n            label: PipelineFeatures.featureFlagsToString(masked),\n            code: include(masked),\n        });\n        return this.shaderModules[masked];\n    }\n\n    getPrimitiveState(flags: PipelineFeatureFlags) {\n        const masked = flags & PipelineFeatures.PrimitiveStateMask;\n\n        this.primitiveStates[masked] ??= {\n            topology: DescriptorMap.flagToTopology[(flags & PipelineFeatures.TopologyFormatMask) as PipelineFeatureFlags],\n            cullMode: masked & PipelineFeatureFlags.DoubleSided ? 'none' : 'back',\n            frontFace: masked & PipelineFeatureFlags.ClockwiseWinding ? 'cw' : 'ccw',\n        };\n\n        return this.primitiveStates[masked];\n    }\n\n    getMaterialBindGroup(flags: PipelineFeatureFlags) {\n        const masked = flags & PipelineFeatures.MaterialBindgroupLayoutMask;\n        this.bindgroupLayouts[masked] ??= this.device.createBindGroupLayout(getBindGroupInfo(masked));\n        return this.bindgroupLayouts[masked];\n    }\n}\n","export enum PipelineFeatureFlags {\n    Defaults = 0,\n\n    /**\n     * If the meshes have vertex normals.\n     * If absent, meshes are shaded with flat normals.\n    */\n    VertexNormals = 1 << 0,\n\n    /**\n     * If the meshes have vertex colors.\n     * If absent, mesh is shaded with a base color texture.\n    */\n    VertexColors = 1 << 1,\n\n    AlphaCutoff = 1 << 2,\n    Emissive = 1 << 3,\n\n    DoubleSided = 1 << 4,\n    ClockwiseWinding = 1 << 5,\n\n    // Topology formats\n    TriangleList = 0 << 6,\n    TriangleStrip = 1 << 6,\n    PointList = 2 << 6,\n    LineList = 3 << 6,\n    LineStrip = 4 << 6,\n    Unindexed = 5 << 6,\n    // LINE_LOOP (currently unsupported by webgpu)\n    // TRIANGLE_FAN (currently unsupported by webgpu)\n}\n\nexport const TopologyFormatMask = 0x111 << 6;\n\nexport const PrimitiveStateMask = (\n    TopologyFormatMask\n    | PipelineFeatureFlags.DoubleSided\n    | PipelineFeatureFlags.ClockwiseWinding\n);\n\nexport const CodeMask = ~(\n    TopologyFormatMask\n    | PipelineFeatureFlags.ClockwiseWinding\n);\n\nexport const InstanceBufferLayoutMask = (\n    PipelineFeatureFlags.VertexNormals\n);\n\nexport const VertexBufferLayoutMask = (\n    PipelineFeatureFlags.VertexNormals\n    | PipelineFeatureFlags.VertexColors\n);\n\nexport const MaterialBufferLayoutMask = (\n    PipelineFeatureFlags.AlphaCutoff\n);\n\nexport const MaterialBindgroupLayoutMask = (\n    MaterialBufferLayoutMask\n    | PipelineFeatureFlags.Emissive\n);\n\nexport const MaterialMask = (\n    MaterialBindgroupLayoutMask\n    | PipelineFeatureFlags.DoubleSided\n);\n\nexport const PipelineLayoutMask = (\n    InstanceBufferLayoutMask\n    | MaterialMask\n);\n\nexport function featureFlagsToNames(val: number) {\n    return Object.entries(PipelineFeatureFlags)\n        .flatMap(([key, flag]) => typeof flag === 'number' && (flag & val) ? key : []);\n}\n\nexport function featureFlagsToString(val: number) {\n    return featureFlagsToNames(val).toString();\n}\n\nexport function maskRedundantFeatures(flags: PipelineFeatureFlags) {\n    let masked = flags;\n    if (masked & PipelineFeatureFlags.DoubleSided) masked &= ~PipelineFeatureFlags.ClockwiseWinding;\n    return masked;\n}\n","import Camera from './camera/camera';\r\n\r\nconst label = 'global uniforms';\r\n\r\nexport default class GlobalUniforms {\r\n    static readonly code = (group: number) => /* wgsl */`\r\n        struct GlobalUniforms {\r\n            worldToView: mat4x4f,\r\n            viewToClip: mat4x4f,\r\n            worldToClip: mat4x4f,\r\n            inverseWorldToView: mat4x4f,\r\n            inverseViewToClip: mat4x4f,\r\n            inverseWorldToClip: mat4x4f,\r\n        }\r\n\r\n        @group(${group}) @binding(0) var<uniform> globals: GlobalUniforms;\r\n    `;\r\n\r\n    static readonly bufferSize = Camera.bufferLength;\r\n\r\n    static readonly layoutDescriptor: GPUBindGroupLayoutDescriptor = {\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                buffer: { minBindingSize: GlobalUniforms.bufferSize },\r\n                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\r\n            },\r\n        ],\r\n    };\r\n\r\n    static readonly bufferDescriptor: GPUBufferDescriptor = {\r\n        label,\r\n        size: GlobalUniforms.bufferSize,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    };\r\n\r\n    deviceBuffer: GPUBuffer;\r\n    bindGroupLayout: GPUBindGroupLayout;\r\n    bindGroupDescriptor!: GPUBindGroupDescriptor;\r\n    bindgroup!: GPUBindGroup;\r\n\r\n    constructor(device: GPUDevice) {\r\n        this.deviceBuffer = device.createBuffer(GlobalUniforms.bufferDescriptor);\r\n        this.bindGroupLayout = device.createBindGroupLayout(GlobalUniforms.layoutDescriptor);\r\n\r\n        this.bindGroupDescriptor = {\r\n            label,\r\n            layout: this.bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.deviceBuffer,\r\n                        offset: 0,\r\n                        size: GlobalUniforms.bufferSize,\r\n                    },\r\n                },\r\n            ],\r\n        };\r\n\r\n        this.bindgroup = device.createBindGroup(this.bindGroupDescriptor);\r\n    }\r\n\r\n    updateDeviceBuffer(queue: GPUQueue, camera: Camera) {\r\n        camera.cacheView();\r\n        queue.writeBuffer(this.deviceBuffer, 0, camera.buffer);\r\n    }\r\n}\r\n","/* eslint @stylistic/max-len: \"error\" */\r\n\r\nimport {\r\n    toWorldDir,\r\n    cubemapSampleConversions,\r\n} from '../../shaders/cubemap-sampling.shader';\r\n\r\nimport { createAndCopyBuffer } from '../../utils/data-copy';\r\nimport { mapRange } from '../../../utils/general';\r\n\r\nconst DEFAULT_MAX_OPS = 6 * ((17 * 256) ** 2);\r\n\r\nconst createMipBlurCode = (\r\n    groups: number,\r\n    format: GPUTextureFormat,\r\n) => /* wgsl */`\r\n    ${cubemapSampleConversions}\r\n    ${toWorldDir}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    struct Params {\r\n        offset: u32,\r\n        sigmas: array<f32>,\r\n    }\r\n\r\n    @group(0) @binding(0) \r\n    var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    @group(0) @binding(2) \r\n    var<storage> params: Params;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + params.offset;\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = toWorldDir(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&params.sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = params.sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = toWorldDir(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\r\n\r\n/**\r\n *  the minimum angular distance between any pixel on a cubemap\r\n *  of the given face width and any pixel lying on a perimeter\r\n *  the given number of steps away\r\n */\r\nfunction minStepDistance(steps: number, width: number) {\r\n    // the angular distance\r\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\r\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\r\n\r\n    // It's likely possible to programmatically determine whether the\r\n    // destination pixel should be v = 0 or v = 1, but checking both works fine\r\n\r\n    const nextMipWidth = width >> 1;\r\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\r\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\r\n    const baseUN = (1 / nextMipWidth) - 1;\r\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\r\n\r\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\r\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\r\n    const samp0VN = (1 / width) - 1;\r\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\r\n    const samp1VN = (3 / width) - 1;\r\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\r\n\r\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN)\r\n        / Math.sqrt(samp0Mag2 * baseMag2);\r\n\r\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN)\r\n        / Math.sqrt(samp1Mag2 * baseMag2);\r\n\r\n    return Math.min(1 - dot0, 1 - dot1);\r\n}\r\n\r\nexport type GaussianPyramidDescriptor = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    /**\r\n     * If the pyramid should overwrite the existing mips\r\n     * of the given texture\r\n     *\r\n     * @defaultValue `false`\r\n     */\r\n    inPlace?: boolean,\r\n    /**\r\n     * The maximum width of the smallest mip level.\r\n     *\r\n     * @defaultValue `8`\r\n     */\r\n    minWidth?: number,\r\n    /**\r\n     * The kernel extent distance, in pixels.\r\n     *\r\n     * @defaultValue `4`\r\n     */\r\n    steps?: number,\r\n    /**\r\n     * A function to delay the processing of additional pixels,\r\n     * e.g. `requestAnimationFrame`. Spaces work to allow additional\r\n     * rendering and interactivity during heavy blurring workloads.\r\n     *\r\n     * If undefined, all pixels are processed at once.\r\n     */\r\n    delayWork?: (fn: () => Promise<void> | void) => void,\r\n    /**\r\n     * The maximum number of pixels to process within a batch.\r\n     * Unused if `delayWork` is undefined.\r\n     *\r\n     * @defaultValue 6 * ((17 * 256) ** 2)\r\n     *\r\n     * @remarks\r\n     * Allowing cubemap 256 pixels in width with `steps = 8` to run\r\n     * in a single pass. This is a conservatively low default for\r\n     * compatibility with lower-end hardware.\r\n     */\r\n    maxOpsPerPass?: number,\r\n    /**\r\n     * A prefix string for error message thrown from the function\r\n     *\r\n     * @defaultValue `cubemapGuassianPyramid --`\r\n     */\r\n    label?: string,\r\n    /**\r\n     * The label to pass the output GPUTexture.\r\n     *\r\n     * @remarks\r\n     * Unused if `inPlace == true`\r\n     */\r\n    outputTextureLabel?: string,\r\n};\r\n\r\nexport default async function cubemapGuassianPyramid({\r\n    device,\r\n    texture,\r\n    outputTextureLabel,\r\n    inPlace = false,\r\n    minWidth = 8,\r\n    steps = 4,\r\n    maxOpsPerPass = DEFAULT_MAX_OPS,\r\n    label = cubemapGuassianPyramid.name,\r\n    delayWork,\r\n}: GaussianPyramidDescriptor) {\r\n    const { width, format } = texture;\r\n    const mipLevelCount = inPlace\r\n        ? texture.mipLevelCount\r\n        : (Math.log2(width) - Math.log2(minWidth) + 1);\r\n\r\n    if (mipLevelCount <= 1) return texture;\r\n\r\n    const groups = Math.min(\r\n        device.limits.maxComputeWorkgroupSizeX,\r\n        device.limits.maxComputeInvocationsPerWorkgroup,\r\n    );\r\n\r\n    const shader = device.createShaderModule({\r\n        label,\r\n        code: createMipBlurCode(groups, format),\r\n    });\r\n\r\n    const bindgroupLayout = device.createBindGroupLayout({\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                texture: { viewDimension: '2d-array' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 1,\r\n                storageTexture: {\r\n                    access: 'write-only',\r\n                    viewDimension: '2d-array',\r\n                    format,\r\n                },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 2,\r\n                buffer: { type: 'read-only-storage' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n        ],\r\n    });\r\n\r\n    const pipeline = device.createComputePipeline({\r\n        label,\r\n        layout: device.createPipelineLayout({\r\n            label,\r\n            bindGroupLayouts: [bindgroupLayout],\r\n        }),\r\n        compute: {\r\n            module: shader,\r\n            entryPoint: 'main',\r\n            constants: { STEPS: Math.ceil(steps) },\r\n        },\r\n    });\r\n\r\n    let gaussianPyramid = texture;\r\n    if (!inPlace) {\r\n        const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n        gaussianPyramid = device.createTexture({\r\n            label: outputTextureLabel,\r\n            usage: GPUTextureUsage.STORAGE_BINDING\r\n                | GPUTextureUsage.TEXTURE_BINDING\r\n                | GPUTextureUsage.COPY_SRC\r\n                | GPUTextureUsage.COPY_DST,\r\n            dimension: '2d',\r\n            format,\r\n            mipLevelCount,\r\n            size,\r\n        });\r\n\r\n        const copyEncoder = device.createCommandEncoder({\r\n            label: `${label} copy encoder`,\r\n        });\r\n\r\n        copyEncoder.copyTextureToTexture(\r\n            { texture, mipLevel: 0 },\r\n            { texture: gaussianPyramid, mipLevel: 0 },\r\n            size,\r\n        );\r\n\r\n        device.queue.submit([copyEncoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n\r\n    const mipViews = mapRange(mipLevelCount, (i) => gaussianPyramid.createView({\r\n        label: `${label} mip view ${i}`,\r\n        dimension: '2d-array',\r\n        baseMipLevel: i,\r\n        mipLevelCount: 1,\r\n    }));\r\n\r\n    const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\r\n    const maxLayers = Math.ceil(Math.log2(width));\r\n    const maxDispatches = Math.max(\r\n        (maxOpsPerPass / (((1 + (steps * 2)) ** 2) * groups)) | 0,\r\n        1,\r\n    );\r\n\r\n    const propertyArray = new ArrayBuffer((maxLayers + 1) * 4);\r\n    const offset = new Uint32Array(propertyArray, 0, 1);\r\n    const simgas = new Float32Array(propertyArray, 4, maxLayers);\r\n\r\n    simgas.set(mapRange(maxLayers, (i) => {\r\n        const w = width >> i;\r\n        return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\r\n    }));\r\n\r\n    const propertyBuffer = createAndCopyBuffer(\r\n        propertyArray,\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        device,\r\n    );\r\n\r\n    let mipLevel = 0;\r\n    let mipPasses = 0;\r\n    let requiredMipDispatches = 0;\r\n    let currentMipDispatches = 0;\r\n    let batchDispatches = 0;\r\n    let bindgroup: GPUBindGroup;\r\n\r\n    async function runPass() {\r\n        if (currentMipDispatches >= requiredMipDispatches) {\r\n            mipLevel += 1;\r\n            currentMipDispatches = 0;\r\n            mipPasses = 0;\r\n\r\n            if (mipLevel >= mipLevelCount) {\r\n                return;\r\n            }\r\n\r\n            const mipPixels = 6 * ((width >> mipLevel) ** 2);\r\n            requiredMipDispatches = Math.ceil(mipPixels / groups);\r\n\r\n            bindgroup = device.createBindGroup({\r\n                layout: bindgroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: mipViews[mipLevel - 1],\r\n                    },\r\n                    {\r\n                        binding: 1,\r\n                        resource: mipViews[mipLevel],\r\n                    },\r\n                    {\r\n                        binding: 2,\r\n                        resource: { buffer: propertyBuffer },\r\n                    },\r\n                ],\r\n            });\r\n        }\r\n\r\n        offset[0] = currentMipDispatches * groups;\r\n        device.queue.writeBuffer(propertyBuffer, 0, offset);\r\n\r\n        const passDispatches = Math.min(\r\n            requiredMipDispatches - currentMipDispatches,\r\n            maxDispatches - batchDispatches,\r\n            maxWorkgroups,\r\n        );\r\n\r\n        const passLabel = `${label} mip ${mipLevel}, pass ${mipPasses}`;\r\n        const encoder = device.createCommandEncoder({ label: passLabel });\r\n        const pass = encoder.beginComputePass({ label: passLabel });\r\n\r\n        pass.setPipeline(pipeline);\r\n        pass.setBindGroup(0, bindgroup);\r\n        pass.dispatchWorkgroups(passDispatches, 1, 1);\r\n        pass.end();\r\n\r\n        device.queue.submit([encoder.finish()]);\r\n\r\n        currentMipDispatches += passDispatches;\r\n        batchDispatches += passDispatches;\r\n        mipPasses += 1;\r\n\r\n        if (delayWork != null && batchDispatches >= maxDispatches) {\r\n            batchDispatches = 0;\r\n            await device.queue.onSubmittedWorkDone();\r\n            delayWork(runPass);\r\n        } else {\r\n            await runPass();\r\n        }\r\n    }\r\n\r\n    await runPass();\r\n\r\n    return gaussianPyramid;\r\n}\r\n","import { FullRenderModel } from '../settings/sample-spec';\nimport propertyListener, { ListenerSyms } from '../settings/property-listener';\nimport getSkyboxOptions from '../settings/skybox-options';\n\nimport GeometryPipeline from '../../core/default-forward-pass/geometry-pipeline';\nimport DescriptorMap from '../../core/default-forward-pass/descriptor-map';\nimport Renderer, { ForwardPassParams } from '../../core/renderer';\nimport { MaterialDescriptor } from '../../core/default-forward-pass/material-draw-data';\nimport { PipelineFeatureFlags } from '../../core/default-forward-pass/pipeline-feature-flags';\n\nimport cubemapGuassianPyramid from '../cubemap-blur/cubemap-guassian-pyramid';\n\nimport { AttributeDetails, ComponentType } from './loader/type-conversions';\nimport importGltf from './loader/gltf-loader';\nimport { DataType } from '@loaders.gl/core';\nimport { isObject } from '../../../utils/general';\n\nconst gltfIndex = await getGltfIndex();\n\nasync function getGltfIndex() {\n    const indexUrl = GLTF_BASE_URL__ + GLTF_INDEX_FILE__;\n    const indexRes = await fetch(indexUrl);\n    const indexStr = await indexRes.text();\n    const indexJson = JSON.parse(indexStr) as unknown;\n\n    if (!Array.isArray(indexJson)) {\n        throw new Error('could not load gtlf model index');\n    }\n\n    const entries: [string, string][] = indexJson.flatMap((gltf: unknown) => {\n        if (\n            !isObject(gltf)\n            || !('label' in gltf)\n            || typeof gltf.label !== 'string'\n            || !('name' in gltf)\n            || typeof gltf.name !== 'string'\n            || !('variants' in gltf)\n            || !isObject(gltf.variants)\n            || typeof gltf.variants.glTF !== 'string'\n        ) return [];\n\n        const { variants: { glTF: file }, label, name } = gltf;\n        const path = `${GLTF_BASE_URL__}${name}/glTF/${file}`;\n        return [[label, path]];\n    });\n\n    return Object.fromEntries(entries);\n}\n\nexport default class GltfModel implements FullRenderModel {\n    static readonly title = 'glTF Model Viewer';\n    static readonly description = '';\n\n    static readonly goalLayout: AttributeDetails[] = [\n        {\n            name: 'POSITION',\n            type: 'VEC3',\n            componentType: ComponentType.float32,\n        },\n        {\n            name: 'TEXCOORD_0',\n            type: 'VEC2',\n            componentType: ComponentType.float32,\n        },\n        {\n            name: 'TANGENT',\n            type: 'VEC4',\n            componentType: ComponentType.float32,\n            depends: ['NORMAL'],\n            fill: [1, 0, 0, 1],\n        },\n        {\n            name: 'NORMAL',\n            type: 'VEC3',\n            componentType: ComponentType.float32,\n            strip: true,\n            feature: PipelineFeatureFlags.VertexNormals,\n        },\n        {\n            name: 'COLOR_0',\n            type: 'VEC4',\n            componentType: ComponentType.float32,\n            strip: true,\n            feature: PipelineFeatureFlags.VertexColors,\n            fill: [1, 1, 1, 1],\n        },\n    ];\n\n    geometryPipelines: Partial<Record<number, GeometryPipeline>> = {};\n    descriptorMap: DescriptorMap;\n    device: GPUDevice;\n\n    get depthTextureView() {\n        return this.descriptorMap.gbuffer.depth.view;\n    }\n\n    readonly #settings = propertyListener({\n        skybox: getSkyboxOptions(this),\n        model: {\n            [ListenerSyms.$type]: 'file' as const,\n            [ListenerSyms.$callback]: (val: unknown, key: PropertyKey) => {\n                if (key !== 'value' || val == null) return;\n                if (typeof val === 'string' || val instanceof File) {\n                    void this.setModel(val);\n                }\n            },\n            accept: '.hdr',\n            selection: {\n                value: 'Environment Test',\n                initialValues: gltfIndex,\n            },\n            process: (file: File) => file,\n        },\n    });\n\n    readonly settings = this.#settings.publicSettings;\n    readonly priority = 1000;\n\n    constructor(public renderer: Renderer) {\n        this.descriptorMap = new DescriptorMap(renderer.device, renderer.gbuffer, renderer.globals);\n        this.device = renderer.device;\n        this.renderer.addForwardPass(this);\n    }\n\n    async setSkybox(skybox: GPUTexture) {\n        await cubemapGuassianPyramid({\n            texture: skybox,\n            device: this.renderer.device,\n            inPlace: true,\n            delayWork: requestAnimationFrame,\n        });\n\n        this.renderer.skybox = skybox;\n    }\n\n    async setModel(modelPath: string | DataType) {\n        const size = { width: 1, height: 1 };\n        const colorArray = new Float32Array([1, 1, 1, 1]);\n\n        const opaqueWhite = this.renderer.device.createTexture({\n            size,\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        this.renderer.device.queue.writeTexture({ texture: opaqueWhite }, colorArray, {}, size);\n\n        const normalMap = this.renderer.device.createTexture({\n            size,\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        colorArray.set([0.5, 0.5, 1, 1]);\n        this.renderer.device.queue.writeTexture({ texture: normalMap }, colorArray, {}, size);\n\n        const sampler = {\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'linear',\n            mipmapFilter: 'linear',\n        } as GPUSamplerDescriptor;\n\n        const matData: MaterialDescriptor = {\n            baseColorTexture: opaqueWhite,\n            baseColorFactor: [1, 1, 1, 1],\n            normalTexture: normalMap,\n            metallicRoughnessTexture: opaqueWhite,\n            metallicFactor: 1,\n            roughnessFactor: 1,\n            baseColorSampler: sampler,\n            normalSampler: sampler,\n            metallicRoughnessSampler: sampler,\n        };\n\n        this.geometryPipelines = await importGltf(\n            modelPath,\n            this.renderer.device,\n            this.descriptorMap,\n            matData,\n            GltfModel.goalLayout,\n            {},\n        );\n    }\n\n    render({ encoder, gbuffer, globals }: ForwardPassParams) {\n        const pass = encoder.beginRenderPass(gbuffer.passDescriptor);\n        pass.setBindGroup(0, globals.bindgroup);\n\n        for (const pipeline of Object.values(this.geometryPipelines)) {\n            pipeline?.draw(pass, this.renderer.device.queue);\n        }\n        pass.end();\n    }\n}\n","import AttributeWrapper from './attribute-wrapper';\n\n/**\n * Adapted from gltf-transform's version:\n * github.com/donmccurdy/glTF-Transform/blob/main/packages/functions/src/weld.ts\n */\nclass HashTable {\n    private attributes: { u8: Uint8Array, byteStride: number }[] = [];\n    private u8: Uint8Array;\n    private u32: Uint32Array;\n\n    constructor(prim: Record<string, AttributeWrapper>) {\n        let byteStride = 0;\n        for (const attribute of Object.values(prim)) {\n            byteStride += this.initAttribute(attribute);\n        }\n        const paddedByteStride = (byteStride + 3) & ~3;\n        this.u8 = new Uint8Array(paddedByteStride);\n        this.u32 = new Uint32Array(this.u8.buffer);\n    }\n\n    private initAttribute(attribute: AttributeWrapper): number {\n        const u8 = attribute.data instanceof Uint8Array\n            ? attribute.data\n            : new Uint8Array(attribute.data.buffer);\n        const byteStride = attribute.bytesPerComponent * attribute.componentsPerElement;\n        this.attributes.push({ u8, byteStride });\n        return byteStride;\n    }\n\n    hash(index: number): number {\n        let byteOffset = 0;\n        for (const { u8, byteStride } of this.attributes) {\n            for (let i = 0; i < byteStride; i += 1) {\n                this.u8[byteOffset + i] = u8[index * byteStride + i];\n            }\n            byteOffset += byteStride;\n        }\n        return this.murmurHash2();\n    }\n\n    equal(a: number, b: number): boolean {\n        for (const { u8, byteStride } of this.attributes) {\n            for (let j = 0; j < byteStride; j += 1) {\n                if (u8[a * byteStride + j] !== u8[b * byteStride + j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    hashLookup(table: TypedArray, buckets: number, key: number, empty: number): number {\n        const hashmod = buckets - 1;\n        const hashval = this.hash(key);\n        let bucket = hashval & hashmod;\n\n        for (let probe = 0; probe <= hashmod; probe += 1) {\n            const item = table[bucket];\n\n            if (item === empty || this.equal(item, key)) {\n                return bucket;\n            }\n\n            bucket = (bucket + probe + 1) & hashmod; // Hash collision.\n        }\n\n        throw new Error('Hash table full.');\n    }\n\n    /**\n     * References:\n     * - https://github.com/mikolalysenko/murmurhash-js/blob/f19136e9f9c17f8cddc216ca3d44ec7c5c502f60/murmurhash2_gc.js#L14\n     * - https://github.com/zeux/meshoptimizer/blob/e47e1be6d3d9513153188216455bdbed40a206ef/src/indexgenerator.cpp#L12\n     */\n    murmurHash2(): number {\n        const m = 0x5bd1e995;\n        const r = 24;\n        let h = 0;\n\n        for (let k of this.u32) {\n            k = Math.imul(k, m) >>> 0;\n            k = (k ^ (k >> r)) >>> 0;\n            k = Math.imul(k, m) >>> 0;\n\n            h = Math.imul(h, m) >>> 0;\n            h = (h ^ k) >>> 0;\n        }\n\n        return h;\n    }\n}\n\nfunction ceilPowerOfTwo(value: number): number {\n    return 2 ** Math.ceil(Math.log(value) / Math.LN2);\n}\n\n/**\n * Weld and merge, combining vertices that are bitwise-equal.\n *\n * Adapted from gltf-transform's _weldPrimitiveStrict:\n * github.com/donmccurdy/glTF-Transform/blob/main/packages/functions/src/weld.ts#L193\n */\nexport default function weld(prim: Record<string, AttributeWrapper>) {\n    const srcVertexCount = prim.POSITION.count;\n    const hash = new HashTable(prim);\n    const tableSize = ceilPowerOfTwo(srcVertexCount + (srcVertexCount / 4));\n    const is16Bit = srcVertexCount < (2 ** 16 - 1);\n    const empty = 2 ** (is16Bit ? 16 : 32) - 1;\n    const indexFormat: GPUIndexFormat = is16Bit ? 'uint16' : 'uint32';\n    const writeMap = is16Bit ? new Uint16Array(srcVertexCount) : new Uint32Array(srcVertexCount);\n    const table = is16Bit ? new Uint16Array(tableSize) : new Uint32Array(tableSize);\n    table.fill(empty);\n\n    let dstVertexCount = 0;\n\n    for (let i = 0; i < srcVertexCount; i += 1) {\n        const hashIndex = hash.hashLookup(table, tableSize, i, empty);\n        const dstIndex = table[hashIndex];\n\n        if (dstIndex === empty) {\n            table[hashIndex] = i;\n            writeMap[i] = dstVertexCount;\n            dstVertexCount += 1;\n        } else {\n            writeMap[i] = writeMap[dstIndex];\n        }\n    }\n\n    for (const attribute of Object.values(prim)) {\n        attribute.remap(writeMap, dstVertexCount);\n    }\n\n    // The gltf-transform version checks for degenerate triangles to remove.\n    // This is omitted here.\n    return { indexArray: writeMap, indexFormat, vertexCount: dstVertexCount };\n}\n","import { mat3, mat4, Mat3, Mat4 } from 'wgpu-matrix';\n\nimport { TypeSizes } from '../constants';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\nimport { PipelineFeatureFlags } from './pipeline-feature-flags';\nimport DescriptorMap from './descriptor-map';\n\nexport type PrimitiveDescriptor = {\n    name?: string,\n    // vertexBufferLayouts: GPUVertexBufferLayout;\n    features: PipelineFeatureFlags,\n    vertexCount: number,\n    vertexArray: ArrayBuffer | TypedArray | GPUBuffer,\n    indexArray?: ArrayBuffer | TypedArray,\n    indexFormat?: GPUIndexFormat,\n};\n\nexport type IndexData = {\n    indexBuffer: GPUBuffer,\n    indexCount: number,\n    indexFormat: GPUIndexFormat,\n};\n\nexport class PrimitiveDrawData {\n    name: string;\n    vertexBuffer: GPUBuffer;\n    indexData?: IndexData;\n    instanceBuffer: GPUBuffer;\n    instanceBindGroup: GPUBindGroup;\n    vertexCount: number;\n    features: number;\n\n    instanceSize: number;\n\n    instances: ArrayBuffer;\n    modelMatrices: Mat4[];\n    normalMatrices!: Mat3[];\n    max: number;\n\n    instanceCount: number = 0;\n    dirty: boolean = false;\n\n    constructor(\n        primitive: PrimitiveDescriptor,\n        device: GPUDevice,\n        max: number,\n        descriptorMap: DescriptorMap,\n        instances?: Mat4[],\n    ) {\n        this.max = max;\n        this.features = primitive.features;\n        this.name = primitive.name ?? 'mesh';\n        this.vertexCount = primitive.vertexCount;\n\n        if (primitive.vertexArray instanceof GPUBuffer) {\n            this.vertexBuffer = primitive.vertexArray;\n        } else {\n            this.vertexBuffer = createAndCopyBuffer(\n                primitive.vertexArray,\n                GPUBufferUsage.VERTEX,\n                device,\n                `${this.name} vertex buffer`,\n            );\n        }\n\n        if (primitive.indexArray && primitive.indexFormat) {\n            const { indexArray, indexFormat } = primitive;\n            this.indexData = {\n                indexFormat,\n                indexCount: indexArray.byteLength / (indexFormat === 'uint16' ? 2 : 4),\n                indexBuffer: createAndCopyBuffer(\n                    primitive.indexArray,\n                    GPUBufferUsage.INDEX,\n                    device,\n                    `${this.name} index buffer`,\n                ),\n            };\n        }\n\n        this.instanceSize = TypeSizes.sizeofMat4x4f;\n        if (this.features & PipelineFeatureFlags.VertexNormals) {\n            this.instanceSize += 12 * 4;\n        }\n\n        this.instances = new ArrayBuffer(max * this.instanceSize);\n        this.modelMatrices = new Array(max) as Float32Array[];\n\n        for (let i = 0; i < max; i += 1) {\n            const offset = i * this.instanceSize;\n            this.modelMatrices[i] = new Float32Array(this.instances, offset, 16);\n        }\n\n        if (this.features & PipelineFeatureFlags.VertexNormals) {\n            this.normalMatrices = new Array(max) as Float32Array[];\n\n            for (let i = 0; i < max; i += 1) {\n                const offset = (i * this.instanceSize) + TypeSizes.sizeofMat4x4f;\n                this.normalMatrices[i] = new Float32Array(this.instances, offset, 12);\n            }\n        }\n\n        this.instanceBuffer = device.createBuffer({\n            label: `${this.name} instance buffer`,\n            size: this.instances.byteLength,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        });\n\n        this.instanceBindGroup = device.createBindGroup({\n            label: `PrimitiveDrawData instance bind group`,\n            layout: descriptorMap.forwardBindgroupLayout,\n            entries: [{\n                binding: 0,\n                resource: { buffer: this.instanceBuffer },\n            }],\n        });\n\n        if (instances) {\n            for (const instance of instances) {\n                this.addInstance(instance);\n            }\n        }\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        if (this.dirty) {\n            queue.writeBuffer(this.instanceBuffer, 0, this.instances);\n            this.dirty = false;\n        }\n\n        passEncoder.setVertexBuffer(0, this.vertexBuffer);\n        passEncoder.setBindGroup(2, this.instanceBindGroup);\n\n        if (this.indexData != null) {\n            const { indexBuffer, indexCount, indexFormat } = this.indexData;\n            passEncoder.setIndexBuffer(indexBuffer, indexFormat);\n            passEncoder.drawIndexed(indexCount, this.instanceCount);\n        } else {\n            passEncoder.draw(this.vertexCount, this.instanceCount);\n        }\n    }\n\n    addInstance(transform: Mat4) {\n        if (this.instanceCount === this.max) return;\n        mat4.copy(transform, this.modelMatrices[this.instanceCount]);\n        this.calculateNormalMatrix(this.instanceCount);\n        this.instanceCount += 1;\n        this.dirty = true;\n    }\n\n    calculateNormalMatrix(idx: number) {\n        if (!(this.features & PipelineFeatureFlags.VertexNormals)) return;\n        const normalMatrix = this.normalMatrices[idx];\n        mat3.fromMat4(this.modelMatrices[idx], normalMatrix);\n        mat3.invert(normalMatrix, normalMatrix);\n        mat3.transpose(normalMatrix, normalMatrix);\n    }\n}\n","import { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\n\nexport type AccessorComponentType = 5120 | 5121 | 5122 | 5123 | 5125 | 5126;\n\nexport type AccessorType = 'SCALAR' | 'VEC2' | 'VEC3' | 'VEC4' | 'MAT2' | 'MAT3' | 'MAT4';\n\nexport type AttributeDetails = {\n    name: string,\n    type: AccessorType,\n    componentType: AccessorComponentType,\n    strip?: boolean,\n    depends?: string[],\n    feature?: PipelineFeatureFlags,\n    fill?: number[],\n};\n\nexport const enum ComponentType {\n    int8 = 5120,\n    uint8 = 5121,\n    int16 = 5122,\n    uint16 = 5123,\n    uint32 = 5125,\n    float32 = 5126,\n}\n\nexport const typeToElementCount: Record<AccessorType, number> = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 12,\n    MAT4: 16,\n};\n\nexport const componentToSize: Record<ComponentType, number> = {\n    [ComponentType.int8]: 1,\n    [ComponentType.uint8]: 1,\n    [ComponentType.int16]: 2,\n    [ComponentType.uint16]: 2,\n    [ComponentType.uint32]: 4,\n    [ComponentType.float32]: 4,\n};\n\nexport const enum TopologyMode {\n    Points = 0,\n    LineList = 1,\n    LineLoop = 2,\n    LineStrip = 3,\n    TriangleList = 4,\n    TriangleStrip = 5,\n    TriangleFan = 6,\n}\n\nexport const modeToTopology: Partial<Record<TopologyMode, PipelineFeatureFlags>> = {\n    [TopologyMode.Points]: PipelineFeatureFlags.PointList, // POINTS\n    [TopologyMode.LineList]: PipelineFeatureFlags.LineList, // LINES\n    // 2: LINE_LOOP (unsupported by webgpu)\n    // 3: PipelineFeatureFlags.LineStrip, // LINE_STRIP\n    [TopologyMode.TriangleList]: PipelineFeatureFlags.TriangleList, // TRIANGLES\n    // 5: PipelineFeatureFlags.TriangleStrip, // TRIANGLE_STRIP\n    // 6: TRIANGLE_FAN (unsupported by webgpu)\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\nimport { GLTFAccessorPostprocessed } from '@loaders.gl/gltf';\nimport { ComponentType } from './type-conversions';\n\nexport default class AttributeWrapper {\n    data: TypedArray;\n    processed: boolean;\n    componentsPerElement: number;\n    bytesPerComponent: number;\n    count: number;\n\n    copyFrom: (srcIdx: number, dstIdx: number, dst: Float32Array) => void;\n\n    at?: (i: number, j: number) => number;\n    view?: DataView;\n\n    unwelded = false;\n\n    constructor(accessor: GLTFAccessorPostprocessed);\n    constructor(array: Float32Array, componentCount: number);\n\n    constructor(accessor: GLTFAccessorPostprocessed | Float32Array, componentCount?: number) {\n        if (accessor instanceof Float32Array) {\n            this.data = accessor;\n            this.componentsPerElement = componentCount!;\n            this.count = accessor.length / componentCount!;\n            this.processed = true;\n            this.bytesPerComponent = 4;\n            this.copyFrom = this.copyProcessed.bind(this);\n        } else {\n            this.data = accessor.value;\n            this.componentsPerElement = accessor.components;\n            this.count = accessor.count;\n            this.bytesPerComponent = accessor.bytesPerComponent;\n            this.processed = false;\n            this.view = new DataView(this.data.buffer);\n            this.copyFrom = this.copyUnprocessed.bind(this);\n\n            switch (accessor.componentType as ComponentType) {\n                case ComponentType.int8: {\n                    this.at = (i, j) => this.view!.getInt8(i * this.componentsPerElement + j);\n                    break;\n                }\n                case ComponentType.uint8: {\n                    this.at = (i, j) => this.view!.getUint8(i * this.componentsPerElement + j);\n                    break;\n                }\n                case ComponentType.int16: {\n                    this.at = (i, j) => {\n                        const offset = 2 * (i * this.componentsPerElement + j);\n                        return this.view!.getInt16(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.uint16: {\n                    this.at = (i, j) => {\n                        const offset = 2 * (i * this.componentsPerElement + j);\n                        return this.view!.getUint16(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.uint32: {\n                    this.at = (i, j) => {\n                        const offset = 4 * (i * this.componentsPerElement + j);\n                        return this.view!.getUint32(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.float32: {\n                    this.at = (i, j) => {\n                        const offset = 4 * (i * this.componentsPerElement + j);\n                        return this.view!.getFloat32(offset, true);\n                    };\n                    break;\n                }\n                default: throw new Error(`gltf importer -- invalid componentType ${accessor.componentType}`);\n            }\n\n            if (accessor.normalized) {\n                let val: number;\n                switch (accessor.componentType as ComponentType) {\n                    case ComponentType.uint8: val = 255; break;\n                    case ComponentType.int8: val = 127; break;\n                    case ComponentType.uint16: val = 65535; break;\n                    case ComponentType.int16: val = 32767; break;\n                    case ComponentType.uint32: val = 4294967295; break;\n                    default: throw new Error(`gltf importer -- invalid componentType ${accessor.componentType}`);\n                }\n\n                this.at = (i, j) => this.at!(i, j) / val;\n            }\n        }\n    }\n\n    get array(): Float32Array {\n        if (!this.processed) this.process();\n        return this.data as Float32Array;\n    }\n\n    copyProcessed(srcIdx: number, dstIdx: number, dst: Float32Array) {\n        for (let j = 0; j < this.componentsPerElement; j += 1) {\n            dst[dstIdx + j] = this.data[(srcIdx * this.componentsPerElement) + j];\n        }\n    }\n\n    copyUnprocessed(srcIdx: number, dstIdx: number, dst: Float32Array) {\n        for (let j = 0; j < this.componentsPerElement; j += 1) {\n            dst[dstIdx + j] = this.at!(srcIdx, j);\n        }\n    }\n\n    markProcessed() {\n        this.processed = true;\n        this.copyFrom = this.copyProcessed.bind(this);\n        delete this.view;\n        delete this.at;\n    }\n\n    process() {\n        if (this.processed) return;\n        const newView = new Float32Array(this.count * this.componentsPerElement);\n\n        for (let i = 0; i < this.count; i += 1) {\n            this.copyFrom(i, i * this.componentsPerElement, newView);\n        }\n\n        this.data = newView;\n        this.markProcessed();\n    }\n\n    unweld(indexArray: TypedArray): void {\n        if (this.unwelded) return;\n        this.unwelded = true;\n        const newView = new Float32Array(indexArray.length * this.componentsPerElement);\n\n        for (let i = 0; i < indexArray.length; i += 1) {\n            this.copyFrom(indexArray[i], i * this.componentsPerElement, newView);\n        }\n\n        this.count = indexArray.length;\n        this.data = newView;\n        this.markProcessed();\n    }\n\n    remap(remap: TypedArray, dstCount: number): void {\n        const dstArray = new Float32Array(dstCount * this.componentsPerElement);\n        const done = new Uint8Array(dstCount);\n\n        for (let srcIndex = 0; srcIndex < this.count; srcIndex += 1) {\n            const dstIndex = remap[srcIndex];\n            if (done[dstIndex]) continue;\n            this.copyFrom(srcIndex, dstIndex * this.componentsPerElement, dstArray);\n            done[dstIndex] = 1;\n        }\n\n        this.data = dstArray;\n        this.markProcessed();\n    }\n}\n","import { Mat4, mat4 } from 'wgpu-matrix';\nimport { GLTFAccessorPostprocessed, GLTFMaterialPostprocessed, GLTFMeshPrimitivePostprocessed } from '@loaders.gl/gltf';\n\nimport weld from './weld';\nimport { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\nimport { PrimitiveDrawData } from '../../../core/default-forward-pass/primitive-draw-data';\nimport { AttributeDetails, TopologyMode, modeToTopology } from './type-conversions';\nimport DescriptorMap from '../../../core/default-forward-pass/descriptor-map';\nimport AttributeWrapper from './attribute-wrapper';\nimport interleaveVertices from './interleave-vertices';\nimport { mapValues } from '../../../../utils/general';\n\nexport type NamedAttribute = 'POSITION' | 'NORMAL' | 'TANGENT';\nexport type NumberedAttribute = 'TEXCOORD' | 'COLOR' | 'JOINTS' | 'WEIGHTS';\nexport type PrimitiveAttributeKey = NamedAttribute | `${NumberedAttribute}_${number}` | `_${string}`;\n\nconst generateTangentsAsync = import('mikktspace').then((module) => module.generateTangents);\n\nfunction wrapIndices(indices: GLTFAccessorPostprocessed) {\n    switch (indices.bytesPerComponent) {\n        case 2: return {\n            indexArray: new Uint16Array(indices.value.buffer),\n            indexFormat: 'uint16' as GPUIndexFormat,\n        };\n        case 4: return {\n            indexArray: new Uint32Array(indices.value.buffer),\n            indexFormat: 'uint32' as GPUIndexFormat,\n        };\n        case 1:\n        default: return {\n            indexArray: new Uint16Array(indices.value),\n            indexFormat: 'uint16' as GPUIndexFormat,\n        };\n    }\n}\n\nfunction reindex(indices: GLTFAccessorPostprocessed, originalMode?: number) {\n    switch (originalMode) {\n        case TopologyMode.LineLoop:\n        case TopologyMode.LineStrip:\n        case TopologyMode.TriangleFan:\n        case TopologyMode.TriangleStrip: {\n            // TODO: convert non-list topologies into lists.\n            throw new Error('Topology currently unsupported');\n        }\n        default: return { ...wrapIndices(indices), mode: TopologyMode.TriangleList };\n    }\n}\n\n/**\n * Checks the determinant of each given matrix and returns a culling mode such that\n * a primitive will render correctly for all nodes containing it, using 'none'\n * for primitive which are rendered both inverted and normally.\n *\n * @param instanceMatrices the instance matrices to render the primitive with\n * @returns The cull mode to use on the primitive.\n *\n * @remarks\n * The glFT spec determines the winding direction of a model by the\n * determinant of the transform of the node which uses it, allowing\n * inversion through negative scale. Changing cullMode instead\n * more easily integrates with instanced rendering, although comes\n * at a performance cost.\n */\nfunction getCullMode(instanceMatrices: Mat4[]) {\n    let overallSign: number | undefined;\n\n    for (let i = 0; i < instanceMatrices.length; i += 1) {\n        const det = mat4.determinant(instanceMatrices[i]);\n        const sign = Math.sign(det);\n        overallSign ??= sign;\n\n        if (sign !== overallSign) return PipelineFeatureFlags.DoubleSided;\n    }\n\n    return (overallSign == null || overallSign > 0)\n        ? PipelineFeatureFlags.Defaults\n        : PipelineFeatureFlags.ClockwiseWinding;\n}\n\nexport default async function loadPrimitive(\n    layout: AttributeDetails[],\n    primitive: GLTFMeshPrimitivePostprocessed,\n    instances: Mat4[],\n    descriptorMap: DescriptorMap,\n    device: GPUDevice,\n): Promise<{ drawData?: PrimitiveDrawData, material?: GLTFMaterialPostprocessed }> {\n    const attributes = primitive.attributes as Partial<Record<PrimitiveAttributeKey, GLTFAccessorPostprocessed>>;\n    if (attributes.POSITION == null) return {};\n\n    const { indices } = primitive;\n    const atrs = mapValues(attributes, (atr) => new AttributeWrapper(atr as GLTFAccessorPostprocessed));\n    let { mode } = primitive;\n    let vertexCount = attributes.POSITION.count;\n    let indexArray: TypedArray | undefined;\n    let indexFormat: GPUIndexFormat | undefined;\n\n    if (indices != null) {\n        ({ indexArray, indexFormat } = wrapIndices(indices));\n\n        if (\n            mode !== TopologyMode.Points\n            && mode !== TopologyMode.LineList\n            && mode !== TopologyMode.TriangleList\n        ) {\n            ({ indexArray, indexFormat, mode } = reindex(indices, mode));\n        }\n    }\n\n    if (atrs.NORMAL != null && atrs.TANGENT == null) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (atrs.TEXCOORD_0 != null) {\n            if (indexArray != null) {\n                vertexCount = indexArray.length;\n                for (const atr of Object.values(atrs)) {\n                    atr.unweld(indexArray);\n                }\n            }\n\n            const start = Date.now();\n\n            const tangent = await generateTangentsAsync.then((func) => func(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                atrs.POSITION!.array,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                atrs.NORMAL!.array,\n                atrs.TEXCOORD_0.array,\n            ));\n\n            for (let i = 3; i < tangent.length; i += 4) {\n                tangent[i] *= -1;\n            }\n            console.log(`tangents generated in ${Date.now() - start}`);\n\n            atrs.TANGENT = new AttributeWrapper(tangent, 4);\n\n            ({ indexArray, indexFormat, vertexCount } = weld(atrs));\n            mode = TopologyMode.TriangleList;\n        } else {\n            const tangent = new Float32Array(vertexCount * 4);\n            for (let i = 0; i < vertexCount; i += 1) {\n                tangent.set([1, 0, 0, 1], i * 4);\n            }\n            atrs.TANGENT = new AttributeWrapper(tangent, 4);\n        }\n    }\n\n    const { vertexArray, vertexFeatures } = interleaveVertices(atrs, vertexCount);\n    let features = getCullMode(instances) | vertexFeatures;\n    if (mode != null) features |= modeToTopology[mode as TopologyMode] || 0;\n\n    const drawData = new PrimitiveDrawData({\n        features,\n        indexArray,\n        indexFormat,\n        vertexCount,\n        vertexArray,\n    }, device, instances.length, descriptorMap, instances);\n\n    return { material: primitive.material, drawData };\n}\n","import AttributeWrapper from './attribute-wrapper';\nimport { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\n\n// const goalLayout: AttributeDetails[] = [\n//     {\n//         name: 'POSITION',\n//         type: 'VEC3',\n//         componentType: ComponentType.float32,\n//     },\n//     {\n//         name: 'TEXCOORD_0',\n//         type: 'VEC2',\n//         componentType: ComponentType.float32,\n//     },\n//     {\n//         name: 'TANGENT',\n//         type: 'VEC4',\n//         componentType: ComponentType.float32,\n//         depends: ['NORMAL'],\n//         fill: [1, 0, 0, 1],\n//     },\n//     {\n//         name: 'NORMAL',\n//         type: 'VEC3',\n//         componentType: ComponentType.float32,\n//         strip: true,\n//         feature: PipelineFeatureFlags.VertexNormals,\n//     },\n//     {\n//         name: 'COLOR_0',\n//         type: 'VEC4',\n//         componentType: ComponentType.float32,\n//         strip: true,\n//         feature: PipelineFeatureFlags.VertexColors,\n//         fill: [1, 1, 1, 1],\n//     },\n// ];\n\nexport default function interleaveVertices(\n    attributes: Partial<Record<string, AttributeWrapper>>,\n    count: number,\n) {\n    let vertexFeatures: PipelineFeatureFlags = PipelineFeatureFlags.Defaults;\n    let stride = 5;\n    if (attributes.NORMAL != null) stride += 7;\n    if (attributes.COLOR_0 != null) stride += 4;\n\n    const vertexArray = new ArrayBuffer(stride * count * 4);\n    const vertexView = new Float32Array(vertexArray);\n\n    for (let i = 0; i < count; i += 1) {\n        attributes.POSITION?.copyFrom(i, stride * i, vertexView);\n    }\n\n    const uv = attributes.TEXCOORD_0 ?? new AttributeWrapper(new Float32Array(count * 2), 2);\n    for (let i = 0; i < count; i += 1) {\n        uv.copyFrom(i, i * stride + 3, vertexView);\n    }\n\n    if (attributes.NORMAL != null && attributes.TANGENT != null) {\n        vertexFeatures |= PipelineFeatureFlags.VertexNormals;\n\n        for (let i = 0; i < count; i += 1) {\n            attributes.TANGENT.copyFrom(i, i * stride + 5, vertexView);\n        }\n\n        for (let i = 0; i < count; i += 1) {\n            attributes.NORMAL.copyFrom(i, i * stride + 9, vertexView);\n        }\n    }\n\n    if (attributes.COLOR_0 != null) {\n        vertexFeatures |= PipelineFeatureFlags.VertexColors;\n        const step = attributes.NORMAL != null ? 12 : 5;\n        for (let i = 0; i < count; i += 1) {\n            attributes.COLOR_0.copyFrom(i, i * stride + step, vertexView);\n            vertexView[i * stride + step + 3] = 1;\n        }\n    }\n\n    return { vertexArray, vertexFeatures };\n}\n","import { GLTFMaterialPostprocessed, GLTFSampler, GLTFTexturePostprocessed } from '@loaders.gl/gltf';\n\nimport { vec3 } from 'wgpu-matrix';\nimport { MaterialDescriptor } from '../../../core/default-forward-pass/material-draw-data';\nimport { imageToTexture } from '../../../utils/texture-importing';\n\nconst DEFAULT_METALLIC = 0.0;\nconst DEFAULT_ROUGHNESS = 1.0;\n\nconst gltfToMagDescription: Record<number, GPUFilterMode> = {\n    9728: 'nearest',\n    9729: 'linear',\n    9984: 'nearest', // NEAREST_MIPMAP_NEAREST\n    9985: 'linear', // LINEAR_MIPMAP_NEAREST\n    9986: 'nearest', // NEAREST_MIPMAP_LINEAR\n    9987: 'linear', // LINEAR_MIPMAP_LINEAR\n};\n\nconst gltfToMipDescription: Partial<Record<number, GPUFilterMode>> = {\n    9984: 'nearest', // NEAREST_MIPMAP_NEAREST\n    9985: 'nearest', // LINEAR_MIPMAP_NEAREST\n    9986: 'linear', // NEAREST_MIPMAP_LINEAR\n    9987: 'linear', // LINEAR_MIPMAP_LINEAR\n};\n\nconst gltfToAddressMode: Record<number, GPUAddressMode> = {\n    33071: 'clamp-to-edge', // CLAMP_TO_EDGE\n    33648: 'mirror-repeat', // MIRRORED_REPEAT\n    10497: 'repeat', // REPEAT\n};\n\nfunction toSamplerDescription(sampler: GLTFSampler): GPUSamplerDescriptor {\n    const { magFilter, minFilter, wrapS, wrapT } = sampler;\n\n    return {\n        addressModeU: gltfToAddressMode[wrapS ?? 10497],\n        addressModeV: gltfToAddressMode[wrapT ?? 10497],\n        minFilter: gltfToMagDescription[minFilter ?? 9987],\n        magFilter: gltfToMagDescription[magFilter ?? 9729],\n        mipmapFilter: gltfToMipDescription[minFilter ?? 9987] ?? 'linear',\n    };\n}\n\nfunction getImageData(handle: GLTFTexturePostprocessed) {\n    const { source, sampler } = handle;\n    if (source == null) return {};\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const data = source.image.data ?? source.bufferView?.data;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (data == null) return {};\n\n    return { data, mimeType: source.mimeType, sampler };\n}\n\nexport default async function loadMaterial(\n    material: GLTFMaterialPostprocessed,\n    defaultMaterial: MaterialDescriptor,\n    device: GPUDevice,\n): Promise<MaterialDescriptor> {\n    const mat: Partial<MaterialDescriptor> = {};\n    if (material.pbrMetallicRoughness != null) {\n        const {\n            baseColorFactor,\n            baseColorTexture,\n            metallicFactor,\n            metallicRoughnessTexture,\n            roughnessFactor,\n        } = material.pbrMetallicRoughness;\n\n        if (metallicRoughnessTexture?.texture.source == null) {\n            if (metallicFactor == null) mat.metallicFactor = DEFAULT_METALLIC;\n            if (roughnessFactor == null) mat.roughnessFactor = DEFAULT_ROUGHNESS;\n        } else {\n            const { data, mimeType, sampler } = getImageData(metallicRoughnessTexture.texture);\n            if (data != null) {\n                mat.metallicRoughnessTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                });\n                if (sampler) mat.metallicRoughnessSampler = toSamplerDescription(sampler);\n            }\n        }\n\n        if (baseColorTexture?.texture.source != null) {\n            const { data, mimeType, sampler } = getImageData(baseColorTexture.texture);\n            if (data != null) {\n                mat.baseColorTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                    srgbToLinear: true,\n                });\n                if (sampler) mat.baseColorSampler = toSamplerDescription(sampler);\n            }\n        }\n\n        if (baseColorFactor != null) mat.baseColorFactor = baseColorFactor;\n        if (metallicFactor != null) mat.metallicFactor = metallicFactor;\n        if (roughnessFactor != null) mat.metallicFactor = roughnessFactor;\n    } else {\n        mat.metallicFactor = DEFAULT_METALLIC;\n        mat.roughnessFactor = DEFAULT_ROUGHNESS;\n    }\n\n    if (material.normalTexture?.texture.source != null) {\n        const { data, mimeType, sampler } = getImageData(material.normalTexture.texture);\n\n        if (data != null) {\n            mat.normalTexture = await imageToTexture({\n                label: `${material.id} mr texture`,\n                data,\n                mimeType,\n                usage: GPUTextureUsage.TEXTURE_BINDING,\n                device,\n            });\n            if (sampler) mat.normalSampler = toSamplerDescription(sampler);\n        }\n    }\n\n    const { emissiveFactor, emissiveTexture } = material;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    const emissiveStrength = material.extensions?.KHR_materials_emissive_strength?.emissiveStrength;\n\n    if (emissiveTexture != null || emissiveFactor?.some((x) => x > 0)) {\n        mat.emissiveFactor = emissiveFactor ?? [1, 1, 1];\n        mat.emissiveSampler = { magFilter: 'linear', minFilter: 'linear' };\n\n        if (emissiveTexture?.texture.source != null) {\n            const { data, mimeType, sampler } = getImageData(emissiveTexture.texture);\n            if (data != null) {\n                mat.emissiveTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                    srgbToLinear: true,\n                });\n                if (sampler) mat.emissiveSampler = toSamplerDescription(sampler);\n            }\n        } else {\n            mat.emissiveTexture = defaultMaterial.baseColorTexture;\n        }\n\n        if (emissiveStrength != null && typeof emissiveStrength === 'number') {\n            vec3.scale(mat.emissiveFactor, emissiveStrength, mat.emissiveFactor);\n        }\n    }\n\n    if (material.doubleSided) mat.doubleSided = true;\n    if (material.alphaMode === 'MASK') mat.alphaCutoff = material.alphaCutoff ?? 0.5;\n\n    return { ...defaultMaterial, ...mat };\n}\n","import { Vec3n, Vec4n } from 'wgpu-matrix';\nimport DescriptorMap from './descriptor-map';\nimport { featureFlagsToString, PipelineFeatureFlags } from './pipeline-feature-flags';\nimport { PrimitiveDrawData } from './primitive-draw-data';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\n\nexport type MaterialDescriptor = {\n    name?: string,\n\n    baseColorFactor: Vec4n,\n    baseColorTexture: GPUTexture,\n    baseColorSampler: GPUSamplerDescriptor,\n\n    roughnessFactor: number,\n    metallicFactor: number,\n    metallicRoughnessTexture: GPUTexture,\n    metallicRoughnessSampler: GPUSamplerDescriptor,\n\n    normalTexture: GPUTexture,\n    normalSampler: GPUSamplerDescriptor,\n\n    alphaCutoff?: number,\n\n    emissiveFactor?: Vec3n,\n    emissiveTexture?: GPUTexture,\n    emissiveSampler?: GPUSamplerDescriptor,\n\n    doubleSided?: boolean,\n};\n\nexport class MaterialDrawData {\n    layout: GPUBindGroupLayout;\n    primitives: PrimitiveDrawData[] = [];\n    matData: MaterialDescriptor;\n    bindGroup: GPUBindGroup;\n    propertiesBuffer: GPUBuffer;\n    features: PipelineFeatureFlags;\n\n    constructor(\n        data: MaterialDescriptor,\n        device: GPUDevice,\n        descriptorMap: DescriptorMap,\n        primitiveFeatures: PipelineFeatureFlags,\n        primitives?: PrimitiveDrawData[],\n    ) {\n        this.features = primitiveFeatures;\n        if (data.doubleSided) this.features |= PipelineFeatureFlags.DoubleSided;\n\n        // TODO : don't hardcode the properties features\n        const properties = new Float32Array(12);\n        properties.set(data.baseColorFactor);\n        properties[4] = data.metallicFactor;\n        properties[5] = data.roughnessFactor;\n\n        if (data.alphaCutoff != null) {\n            this.features |= PipelineFeatureFlags.AlphaCutoff;\n            properties[6] = data.alphaCutoff;\n        }\n\n        if (data.emissiveFactor != null) {\n            properties.set(data.emissiveFactor, 8);\n        }\n\n        this.propertiesBuffer = createAndCopyBuffer(\n            properties,\n            GPUBufferUsage.UNIFORM,\n            device,\n        );\n\n        const entries = [\n            { binding: 0, resource: { buffer: this.propertiesBuffer } },\n            { binding: 1, resource: descriptorMap.getSampler(data.baseColorSampler) },\n            { binding: 2, resource: data.baseColorTexture.createView({ dimension: '2d' }) },\n            { binding: 3, resource: descriptorMap.getSampler(data.normalSampler) },\n            { binding: 4, resource: data.normalTexture.createView({ dimension: '2d' }) },\n            { binding: 5, resource: descriptorMap.getSampler(data.metallicRoughnessSampler) },\n            { binding: 6, resource: data.metallicRoughnessTexture.createView({ dimension: '2d' }) },\n        ];\n\n        if (data.emissiveTexture != null) {\n            this.features |= PipelineFeatureFlags.Emissive;\n\n            entries.push({\n                binding: 7,\n                resource: descriptorMap.getSampler(data.emissiveSampler ?? {}),\n            });\n\n            entries.push({\n                binding: 8,\n                resource: data.emissiveTexture.createView({ dimension: '2d' }),\n            });\n        }\n\n        this.layout = descriptorMap.getMaterialBindGroup(this.features);\n        this.matData = data;\n        this.bindGroup = device.createBindGroup({\n            label: featureFlagsToString(this.features),\n            layout: this.layout,\n            entries,\n        });\n\n        if (primitives != null) {\n            this.addPrimitives(...primitives);\n        }\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        if (this.primitives.length === 0) return;\n\n        passEncoder.setBindGroup(1, this.bindGroup);\n        for (const primitive of this.primitives) {\n            primitive.draw(passEncoder, queue);\n        }\n    }\n\n    addPrimitives(...drawData: PrimitiveDrawData[]) {\n        const filtered = drawData.filter((data) => {\n            if ((data.features & this.features) === data.features) return true;\n            console.warn(`invalid primitive added to material: \nprimitive: ${data.name}\nprimitive features: ${featureFlagsToString(data.features).toString()}\nmaterial: ${this.matData.name}\nmaterial features: ${featureFlagsToString(this.features).toString()}`);\n            return false;\n        });\n        this.primitives.push(...filtered);\n    }\n}\n","import DescriptorMap from './descriptor-map';\nimport { MaterialDrawData } from './material-draw-data';\nimport { PipelineFeatureFlags, featureFlagsToString, maskRedundantFeatures } from './pipeline-feature-flags';\n\nexport default class GeometryPipeline {\n    features: PipelineFeatureFlags;\n    pipeline: GPURenderPipeline;\n\n    materials: MaterialDrawData[] = [];\n\n    constructor(features: PipelineFeatureFlags, maps: DescriptorMap) {\n        this.features = maskRedundantFeatures(features);\n\n        const module = maps.getShaderModule(features);\n\n        this.pipeline = maps.device.createRenderPipeline({\n            label: featureFlagsToString(features),\n            layout: maps.getForwardPipelineLayout(features),\n            primitive: maps.getPrimitiveState(features),\n            vertex: {\n                entryPoint: 'vs',\n                buffers: [maps.getVertexLayout(features)],\n                module,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                module,\n                targets: maps.gbuffer.targets,\n            },\n            depthStencil: {\n                depthWriteEnabled: true,\n                depthCompare: 'less-equal',\n                format: maps.gbuffer.depth.format,\n            },\n        });\n    }\n\n    addMaterials(...materials: MaterialDrawData[]) {\n        if (materials.some((data) => data.features !== this.features)) {\n            throw new Error('invalid primitive added to material');\n        }\n        this.materials.push(...materials);\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        passEncoder.setPipeline(this.pipeline);\n        for (const mat of this.materials) {\n            mat.draw(passEncoder, queue);\n        }\n    }\n}\n","import { Mat4, mat4, Mat4Arg, Mat4Type, quat } from 'wgpu-matrix';\nimport { DataType, load } from '@loaders.gl/core';\nimport { GLTFLoader, GLTFMeshPostprocessed, GLTFNodePostprocessed, postProcessGLTF } from '@loaders.gl/gltf';\n\nimport { ComponentType, AttributeDetails } from './type-conversions';\nimport loadPrimitive from './primitive-loader';\nimport loadMaterial from './material-loader';\n\nimport { MaterialDescriptor, MaterialDrawData } from '../../../core/default-forward-pass/material-draw-data';\nimport { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\nimport { PrimitiveDrawData } from '../../../core/default-forward-pass/primitive-draw-data';\nimport DescriptorMap from '../../../core/default-forward-pass/descriptor-map';\nimport GeometryPipeline from '../../../core/default-forward-pass/geometry-pipeline';\n\nconst defaultLayout: AttributeDetails[] = [\n    {\n        name: 'POSITION',\n        type: 'VEC3',\n        componentType: ComponentType.float32,\n    },\n    {\n        name: 'TEXCOORD_0',\n        type: 'VEC2',\n        componentType: ComponentType.float32,\n    },\n    {\n        name: 'TANGENT',\n        type: 'VEC4',\n        componentType: ComponentType.float32,\n        depends: ['NORMAL'],\n        fill: [1, 0, 0, 1],\n    },\n    {\n        name: 'NORMAL',\n        type: 'VEC3',\n        componentType: ComponentType.float32,\n        strip: true,\n        feature: PipelineFeatureFlags.VertexNormals,\n    },\n    {\n        name: 'COLOR_0',\n        type: 'VEC4',\n        componentType: ComponentType.float32,\n        strip: true,\n        feature: PipelineFeatureFlags.VertexColors,\n        fill: [1, 1, 1, 1],\n    },\n];\n\nconst recurseNode = (\n    parentMatrix: Mat4Type<Mat4Arg>,\n    meshes: Map<GLTFMeshPostprocessed, Mat4Type<Mat4Arg>[]>,\n) => (node: GLTFNodePostprocessed) => {\n    const matrix = node.matrix ?? mat4.identity();\n\n    if (node.matrix == null) {\n        if (node.scale) mat4.scaling(node.scale, matrix);\n\n        if (node.rotation) {\n            const { axis, angle } = quat.toAxisAngle(node.rotation);\n            mat4.rotate(matrix, axis, angle, matrix);\n        }\n\n        if (node.translation != null) {\n            mat4.setTranslation(matrix, node.translation, matrix);\n        }\n    }\n\n    mat4.mul(parentMatrix, matrix, matrix);\n\n    if (node.mesh != null) {\n        if (!meshes.has(node.mesh)) meshes.set(node.mesh, []);\n        meshes.get(node.mesh)!.push(matrix); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    }\n\n    node.children?.forEach(recurseNode(matrix, meshes));\n};\n\nexport default async function importGltf(\n    url: string | DataType,\n    device: GPUDevice,\n    descriptorMap: DescriptorMap,\n    defaultMaterial: MaterialDescriptor,\n    layout: AttributeDetails[] = defaultLayout,\n    pipelines: Partial<Record<number, GeometryPipeline>> = {},\n    // eslint-disable-next-line no-console\n    log: ((msg: unknown) => void) = console.log,\n) {\n    log('starting import');\n\n    const start = Date.now();\n    const gltfWithBuffers = await load(url, GLTFLoader);\n    log(`finished loading: ${Date.now() - start}`);\n\n    const { scene } = postProcessGLTF(gltfWithBuffers);\n    if (scene?.nodes == null) return pipelines;\n    log(`finished processing: ${Date.now() - start}`);\n\n    const meshes = new Map<GLTFMeshPostprocessed, Mat4[]>();\n    scene.nodes.forEach(recurseNode(mat4.identity(), meshes));\n    log(`finished creating instances: ${Date.now() - start}`);\n\n    const meshEntries = Array.from(meshes.entries());\n    const primitivePromises = meshEntries.flatMap(([{ primitives }, instances]) =>\n        primitives.map((prim) => loadPrimitive(\n            layout,\n            prim,\n            instances,\n            descriptorMap,\n            device,\n        )),\n    );\n\n    const primitiveDescriptors = await Promise.all(primitivePromises);\n    log(`finished creating primitives: ${Date.now() - start}`);\n\n    type MaterialKey = { materialId?: string, features: number };\n    const materialMap = new Map<MaterialKey, PrimitiveDrawData[]>();\n    const materialPromises: Record<string, Promise<MaterialDescriptor>> = {};\n\n    for (const { material, drawData } of primitiveDescriptors) {\n        if (drawData == null) continue;\n\n        const key = { materialId: material?.id, features: drawData.features };\n        if (!materialMap.has(key)) materialMap.set(key, []);\n        materialMap.get(key)!.push(drawData); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n\n        if (material != null) {\n            materialPromises[material.id] = loadMaterial(material, defaultMaterial, device);\n        }\n    }\n\n    const materialEntries = Object.entries(materialPromises)\n        .map(async ([id, mat]) => [id, await mat]);\n\n    const materialDescriptors = Object.fromEntries(await Promise.all(materialEntries)) as Record<string, MaterialDescriptor>;\n    log(`finished creating material descriptors: ${Date.now() - start}`);\n\n    const fullDefaultMat: MaterialDescriptor = { ...defaultMaterial, metallicFactor: 0 };\n\n    for (const [{ features, materialId }, drawDatas] of materialMap.entries()) {\n        const descriptor = materialId != null ? materialDescriptors[materialId] : fullDefaultMat;\n        const mat = new MaterialDrawData(descriptor, device, descriptorMap, features, drawDatas);\n        const { features: f } = mat;\n\n        pipelines[f] ??= new GeometryPipeline(f, descriptorMap);\n        pipelines[f].addMaterials(mat);\n    }\n\n    log(`finished: ${Date.now() - start}`);\n    return pipelines;\n}\n","import { parseHDR } from '../../utils/texture-importing';\nimport { equirectangularToCubemap } from '../../utils/texture-processing';\nimport { ListenerSyms } from './property-listener';\n\nconst hdrPromises = await fetch(HDR_BASE_URL__, { headers: { 'Content-Type': 'application/vnd.github.object+json' } })\n    .then((res) => res.json()) as Record<string, unknown>[];\n\nexport const hdrs = Object.fromEntries(hdrPromises.flatMap(({ name, download_url }) => typeof name === 'string' && typeof download_url === 'string' && download_url.endsWith('.hdr') ? [[name, download_url]] : []));\n\nasync function processSkybox(device: GPUDevice, file: string | URL | File | ArrayBuffer) {\n    let buffer: ArrayBuffer;\n    if (file instanceof ArrayBuffer) {\n        buffer = file;\n    } else if (file instanceof File) {\n        buffer = await file.arrayBuffer();\n    } else {\n        const res = await fetch(file);\n        buffer = await res.arrayBuffer();\n    }\n\n    const hdr = parseHDR(buffer);\n\n    return equirectangularToCubemap(\n        device,\n        hdr,\n        {\n            format: 'rgba16float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        },\n    );\n}\n\nexport type SkyboxTarget = { device: GPUDevice, setSkybox: (resource: GPUTexture) => unknown };\n\nexport default function getSkyboxOptions(target: SkyboxTarget) {\n    return {\n        [ListenerSyms.$type]: 'file' as const,\n        [ListenerSyms.$callback]: async (val: unknown, key: PropertyKey) => {\n            if (key !== 'value' || val == null) return;\n            if (typeof val === 'string' || val instanceof File) {\n                const texture = await processSkybox(target.device, val);\n                const res = target.setSkybox(texture);\n                if (res instanceof Promise) await res;\n            }\n        },\n        accept: '.hdr',\n        selection: {\n            value: Object.keys(hdrs)[0],\n            initialValues: hdrs,\n        },\n        process: (file: File) => file,\n    };\n}\n","export default /* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`;\r\n","export const toWorldDir: string = /* wgsl */`\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nexport const cubemapSampleConversions: string = /* wgsl */`\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n","import * as ktxparse from 'ktx-parse';\r\n\r\nimport { TextureFormatToSize, TextureFormatToChannelSize, WebGPUToVkFormat } from '../core/constants';\r\nimport { mapRange, padTemplate } from '../../utils/general';\r\n\r\nexport function createAndCopyBuffer(\r\n    arr: ArrayBuffer | ArrayBufferView,\r\n    usage: GPUFlagsConstant,\r\n    device: GPUDevice,\r\n    label?: string,\r\n    alignment = 4,\r\n): GPUBuffer {\r\n    const pad = alignment - 1;\r\n    const buffer = device.createBuffer({\r\n        label,\r\n        usage,\r\n        size: (arr.byteLength + pad) & ~pad,\r\n        mappedAtCreation: true,\r\n    } as GPUBufferDescriptor);\r\n\r\n    const writeArray = new Uint8Array(buffer.getMappedRange());\r\n    const readArray = arr instanceof ArrayBuffer\r\n        ? new Uint8Array(arr)\r\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n\r\n    writeArray.set(readArray);\r\n    buffer.unmap();\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function createAndCopyCubemap(\r\n    device: GPUDevice,\r\n    data: ArrayBuffer,\r\n    format: GPUTextureFormat,\r\n    usage: number,\r\n    label?: string,\r\n) {\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\r\n    }\r\n\r\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\r\n    const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n    const texture = device.createTexture({\r\n        usage: usage | GPUTextureUsage.COPY_DST,\r\n        label,\r\n        format,\r\n        size,\r\n    });\r\n\r\n    device.queue.writeTexture(\r\n        { texture },\r\n        data,\r\n        { bytesPerRow: width * pixelSize, rowsPerImage: width },\r\n        size,\r\n    );\r\n\r\n    return texture;\r\n}\r\n\r\nexport type TextureToArrayBufferOptions = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    mipLevel?: number,\r\n    resultBuffer?: Uint8Array,\r\n    storageBuffer?: GPUBuffer,\r\n    returnBuffer?: boolean,\r\n    description?: string,\r\n};\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer?: false },\r\n): Promise<{ imageData: Uint8Array }>;\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer: true },\r\n): Promise<{ imageData: Uint8Array, storageBuffer: GPUBuffer }>;\r\n\r\nexport async function textureToArrayBuffer({\r\n    device,\r\n    texture,\r\n    mipLevel = 0,\r\n    returnBuffer,\r\n    storageBuffer,\r\n    resultBuffer,\r\n    description,\r\n}: TextureToArrayBufferOptions) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const fullDescription = padTemplate`[textureToKTX${description ?? ''}${texture.label}] --`;\r\n\r\n    if (pixelSize == null) {\r\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\r\n    }\r\n\r\n    const width = texture.width >> mipLevel;\r\n    const height = texture.height >> mipLevel;\r\n    const rawBytesPerRow = width * pixelSize;\r\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n    const rowsPerImage = height;\r\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\r\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\r\n\r\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\r\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\r\n    }\r\n\r\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\r\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\r\n    }\r\n\r\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\r\n\r\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\r\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\r\n    }\r\n\r\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\r\n    const storage = storageBuffer ?? device.createBuffer({\r\n        label: `${fullDescription} storage buffer`,\r\n        size: byteSize,\r\n        usage: requiredUsage,\r\n    });\r\n\r\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\r\n    encoder.copyTextureToBuffer(\r\n        { texture, mipLevel },\r\n        { buffer: storage, rowsPerImage, bytesPerRow },\r\n        { width, height, depthOrArrayLayers: texture.depthOrArrayLayers },\r\n    );\r\n    device.queue.submit([encoder.finish()]);\r\n\r\n    await Promise.all([\r\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\r\n        device.queue.onSubmittedWorkDone(),\r\n    ]);\r\n\r\n    const mapped = storage.getMappedRange(0, byteSize);\r\n    imageData.set(new Uint8Array(mapped));\r\n    storage.unmap();\r\n\r\n    if (bytesPerRow > rawBytesPerRow) {\r\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\r\n            }\r\n        }\r\n        imageData = imageData.slice(0, resultSize);\r\n    }\r\n\r\n    return {\r\n        imageData,\r\n        storageBuffer: returnBuffer ? storage : undefined,\r\n    };\r\n}\r\n\r\nexport async function textureToKTX(device: GPUDevice, texture: GPUTexture, cube = false) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const typeSize = TextureFormatToChannelSize[texture.format];\r\n\r\n    if (pixelSize == null || typeSize == null) {\r\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\r\n    }\r\n\r\n    const container = new ktxparse.KTX2Container();\r\n    container.pixelWidth = texture.width;\r\n    container.pixelHeight = texture.height;\r\n    container.vkFormat = WebGPUToVkFormat[texture.format];\r\n    container.typeSize = typeSize;\r\n    delete container.keyValue.KTXswizzle;\r\n\r\n    const dataFormat = container.dataFormatDescriptor[0];\r\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\r\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\r\n    dataFormat.bytesPlane[0] = pixelSize;\r\n\r\n    dataFormat.samples = mapRange(4, (i) => ({\r\n        channelType: [192, 193, 194, 207][i],\r\n        samplePosition: [0, 0, 0, 0],\r\n        bitLength: container.typeSize * 8 - 1,\r\n        bitOffset: container.typeSize * 8 * i,\r\n        sampleLower: -1082130432,\r\n        sampleUpper: 1065353216,\r\n    }));\r\n\r\n    if (texture.dimension === '3d') {\r\n        container.faceCount = 1;\r\n        container.pixelDepth = texture.depthOrArrayLayers;\r\n    } else if (cube) {\r\n        const cubeLayers = texture.depthOrArrayLayers / 6;\r\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\r\n        container.faceCount = 6;\r\n    } else {\r\n        container.layerCount = texture.depthOrArrayLayers;\r\n        container.faceCount = 1;\r\n    }\r\n\r\n    let storageBuffer: GPUBuffer | undefined;\r\n    let imageData: Uint8Array;\r\n\r\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\r\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\r\n            mipLevel: i,\r\n            returnBuffer: true,\r\n            device,\r\n            texture,\r\n            storageBuffer,\r\n        }));\r\n\r\n        container.levels.push({\r\n            levelData: imageData,\r\n            uncompressedByteLength: imageData.byteLength,\r\n        });\r\n    }\r\n\r\n    return ktxparse.write(container);\r\n}\r\n","const { baseTable, shiftTable } = (() => {\n    const baseTable = new Uint32Array(256);\n    const shiftTable = new Uint32Array(256);\n\n    for (let i = 0; i < 255; ++i) {\n        const e = i - 127;\n        if (e < -27) { // very small number (0, -0)\n            baseTable[i] = 0x0000;\n            shiftTable[i] = 24;\n        } else if (e < -14) { // small number (denorm)\n            baseTable[i] = 0x0400 >> (-e - 14);\n            shiftTable[i] = -e - 1;\n        } else if (e <= 15) { // normal number\n            baseTable[i] = (e + 15) << 10;\n            shiftTable[i] = 13;\n        } else { // e < 128, large number (Infinity, -Infinity)\n            baseTable[i] = 0x7c00;\n            shiftTable[i] = 24;\n        }\n    }\n\n    // e == 128, stay (NaN, Infinity, -Infinity)\n    baseTable[255] = 0x7c00;\n    shiftTable[255] = 13;\n\n    return { baseTable, shiftTable };\n})();\n\nconst conversionBuffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(conversionBuffer);\nconst uintView = new Uint32Array(conversionBuffer);\n\nexport function toFloat16Bytes(val: number) {\n    floatView[0] = val;\n    const bits = uintView[0];\n    const mantissa = (bits >> 23) & 0x1ff;\n    const idx = mantissa & 0xff;\n\n    const shifted = (bits & 0x007fffff) >> shiftTable[idx];\n    const sign = (mantissa & 0x100) << 7;\n\n    return sign + baseTable[idx] + shifted;\n}\n","import { toFloat16Bytes } from './data-conversion';\nimport { srgbTextureToLinear, generateMips } from './texture-processing';\n\nexport type imageToTextureDescriptor = {\n    device: GPUDevice,\n    data: Uint8Array | Blob | File | ImageBitmap,\n    mimeType?: string,\n    label?: string,\n    usage?: number,\n    format?: GPUTextureFormat,\n    mips?: boolean,\n    srgbToLinear?: boolean,\n    colorSpace?: PredefinedColorSpace,\n};\n\nexport async function imageToTexture({\n    device,\n    data,\n    mimeType,\n    usage = GPUTextureUsage.TEXTURE_BINDING,\n    mips = true,\n    format = 'rgba8unorm',\n    colorSpace = 'srgb',\n    label = '',\n    srgbToLinear,\n}: imageToTextureDescriptor) {\n    let bitmap: ImageBitmap;\n\n    if (data instanceof ImageBitmap) {\n        bitmap = data;\n    } else {\n        const blob = (data instanceof Blob || data instanceof File)\n            ? data\n            : new Blob([data], { type: mimeType });\n        bitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n    }\n\n    const size = { width: bitmap.width, height: bitmap.height };\n\n    const texture = device.createTexture({\n        label,\n        format,\n        size: size,\n        usage: usage | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: mips ? 1 + (Math.log2(Math.max(bitmap.width, bitmap.height)) | 0) : 1,\n    });\n\n    device.queue.copyExternalImageToTexture(\n        { source: bitmap },\n        { texture, colorSpace },\n        size,\n    );\n\n    if (srgbToLinear) srgbTextureToLinear(device, texture);\n    if (mips) void generateMips(device, texture);\n\n    return texture;\n}\n\nexport function parseHDR(inData: Uint8Array | ArrayBuffer) {\n    const decoder = new TextDecoder();\n    const buffer = inData instanceof Uint8Array ? inData : new Uint8Array(inData);\n    let pos = 0;\n\n    const getLine = (lineLimit = 1024) => {\n        const limit = Math.min(buffer.length, lineLimit + pos);\n        const sub = buffer.subarray(pos, limit);\n        const end = sub.indexOf(0x0A) + 1;\n        pos += end;\n        return end === 0 ? undefined : decoder.decode(sub.subarray(0, end));\n    };\n\n    const importError = (msg: string) => new Error('HDR Import Error: ' + msg);\n\n    // #region Read Header\n    const magicTokenRegex = /^#\\?(\\S+)/;\n    const magicTokenLine = getLine();\n\n    if (magicTokenLine == null) throw importError('no header found');\n    if (!magicTokenRegex.test(magicTokenLine)) throw importError('bad initial token');\n\n    const headerRegs = [\n        /FORMAT=(?<format>\\S+)/, // format\n        /-Y\\s+(?<Y>\\d+)\\s+\\+X\\s+(?<X>\\d+)/, // size\n        /EXPOSURE\\s*=\\s*(?<exposure>\\d+(\\.\\d+)?)/, // exposure\n        /GAMMA\\s*=\\s*(?<gamma>\\d+(\\.\\d+)?)/, // gamma\n    ];\n\n    const headerReg = new RegExp(`^\\\\s*(${\n        headerRegs.map(({ source }) => `(${source})`).join('|')\n    })\\\\s*$`);\n\n    let noFormat = true;\n    let gamma = 1; /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n    let exposure = 1; /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n    let width: number | undefined = undefined;\n    let height: number | undefined = undefined;\n\n    for (let line = getLine(); line != null; line = width == null ? getLine() : undefined) {\n        const groups = line.match(headerReg)?.groups as Partial<Record<string, string>> | undefined;\n        if (groups == null) continue;\n\n        if (groups.format != null) {\n            noFormat = false;\n        } else if (groups.X != null && groups.Y != null) {\n            width = parseInt(groups.X);\n            height = parseInt(groups.Y);\n        } else if (groups.gamma != null) {\n            gamma = parseFloat(groups.gamma);\n        } else if (groups.exposure != null) {\n            exposure = parseFloat(groups.exposure);\n        }\n    }\n\n    if (noFormat) throw importError('missing format specifier');\n    if (width == null || height == null) throw importError('missing image size specifier');\n    // #endregion\n\n    // #region Read Scanline Data\n    let rawData: Uint8Array;\n    const unencodable = width < 8 || width > 0x7fff;\n    const flatData = buffer[pos] !== 2 || buffer[pos + 1] !== 2 || (buffer[pos + 2] & 0x80) !== 0;\n\n    if (unencodable || flatData) {\n        rawData = buffer.subarray(pos);\n    } else {\n        rawData = new Uint8Array(width * height * 4);\n        const end = 4 * width;\n        const scanline_buffer = new Uint8Array(end);\n        const len = buffer.byteLength;\n\n        for (let k = 0, offset = 0; k < height && pos < len; k++) {\n            if (pos + 4 > len)\n                throw importError('file ended durning scanline');\n\n            if ((2 != buffer[pos++]) || (2 != buffer[pos++]) || (((buffer[pos++] << 8) | buffer[pos++]) != width))\n                throw importError('bad rgbe scanline format');\n\n            let count;\n            for (let ptr = 0; ptr < end && pos < len; ptr += count) {\n                count = buffer[pos++];\n                const isEncodedRun = count > 128;\n                if (isEncodedRun) count -= 128;\n\n                if (count == 0 || ptr + count > end)\n                    throw importError('bad scanline data');\n\n                if (isEncodedRun) {\n                    scanline_buffer.fill(buffer[pos], ptr, ptr + count);\n                    pos += 1;\n                } else {\n                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                    pos += count;\n                }\n            }\n\n            for (let i = 0; i < width; i++)\n                for (let j = 0; j < end; j += width)\n                    rawData[offset++] = scanline_buffer[i + j];\n        }\n    }\n    // #endregion\n\n    // #region Convert to Float16\n    const data = new Uint16Array(rawData.length);\n    const float16One = toFloat16Bytes(1);\n\n    for (let i = 0; i < width * height * 4; i += 4) {\n        const raw_e = rawData[i + 3];\n        const scale = Math.pow(2.0, raw_e - 128.0) / 255.0;\n\n        for (let j = 0; j < 3; j += 1) {\n            data[i + j] = toFloat16Bytes(Math.min(rawData[i + j] * scale, 65504));\n        }\n        data[i + 3] = float16One;\n    }\n    // #endregion\n\n    return { data, width, height, gamma, exposure };\n}\n","import blit from '../shaders/blit-vert.shader';\nimport { toWorldDir } from '../shaders/cubemap-sampling.shader';\nimport { createAndCopyBuffer } from './data-copy';\nimport { padTemplate } from '../../utils/general';\n\ntype EquirectangularDescriptor = {\n    data: SharedArrayBuffer | BufferSource | GPUTexture,\n    width: number,\n    height: number,\n    gamma?: number,\n    exposure?: number,\n};\n\nexport async function equirectangularToCubemap(\n    device: GPUDevice,\n    { data, width, height, gamma = 1, exposure = 1 }: EquirectangularDescriptor,\n    outputDescriptor: Omit<GPUTextureDescriptor, 'dimension' | 'size'>,\n) {\n    const code = /* wgsl */ `\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${blit}\n        ${toWorldDir}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;\n\n    let FLIP_Y = 0;\n    let equirectangular: GPUTexture;\n    if (data instanceof GPUTexture) {\n        equirectangular = data;\n    } else {\n        FLIP_Y = 1;\n        equirectangular = device.createTexture({\n            label: `${outputDescriptor.label} equirectangular`,\n            dimension: '2d',\n            format: 'rgba16float',\n            size: { width, height },\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        device.queue.writeTexture(\n            { texture: equirectangular, mipLevel: 0 },\n            data,\n            { bytesPerRow: width * 2 * 4 },\n            { width, height, depthOrArrayLayers: 1 },\n        );\n        await device.queue.onSubmittedWorkDone();\n    }\n\n    const faceSize = equirectangular.height >> 1;\n    const cubemapDescriptor = outputDescriptor as GPUTextureDescriptor;\n    cubemapDescriptor.mipLevelCount ??= Math.log2(faceSize) | 0;\n    cubemapDescriptor.size = { width: faceSize, height: faceSize, depthOrArrayLayers: 6 };\n    cubemapDescriptor.dimension = '2d';\n    cubemapDescriptor.usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    const cubemap = device.createTexture(cubemapDescriptor);\n\n    const label = padTemplate`hdr copy${outputDescriptor.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 2,\n                buffer: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const module = device.createShaderModule({ label, code });\n    const sampler = device.createSampler({ label, minFilter: 'linear', magFilter: 'linear' });\n    const params = new Uint32Array(1);\n    const paramBuffer = createAndCopyBuffer(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device, label);\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            { binding: 0, resource: equirectangular.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: paramBuffer } },\n        ],\n    });\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: { module },\n        fragment: {\n            module,\n            targets: [{ format: cubemap.format }],\n            constants: {\n                GAMMA: gamma,\n                EXPOSURE: exposure,\n                FLIP_Y,\n            },\n        },\n    });\n\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n\n        const view = cubemap.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n            mipLevelCount: 1,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [{\n                view,\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n\n    return cubemap;\n}\nexport async function generateMips(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${blit}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `;\n\n    const label = padTemplate`mip generation${texture.label}`;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d', sampleType: 'float' },\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const colorAttachment = {\n        view: undefined as GPUTextureView | undefined,\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: 0 });\n    await device.queue.onSubmittedWorkDone();\n\n    for (let i = 1; i < texture.mipLevelCount; i += 1) {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: colorAttachment.view,\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n\n        colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: i });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [colorAttachment as GPURenderPassColorAttachment],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n\n        device.queue.submit([encoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport function srgbTextureToLinear(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${blit}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `;\n\n    const label = padTemplate`srgb to linear${texture.label}`;\n\n    const size = { width: texture.width, height: texture.height };\n\n    const tempTexture = device.createTexture({\n        format: texture.format,\n        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        size,\n    });\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n\n    const module = device.createShaderModule({ label, code: code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: tempTexture.createView(),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n        ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n        { texture },\n        { texture: tempTexture },\n        size,\n    );\n\n    const pass = encoder.beginRenderPass({\n        label,\n        colorAttachments: [{\n            view: texture.createView({ mipLevelCount: 1, baseMipLevel: 0 }),\n            loadOp: 'clear',\n            storeOp: 'store',\n        }],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindgroup);\n    pass.draw(3);\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n}\n"],"names":["Camera","constructor","viewParams","buffer","ArrayBuffer","bufferLength","worldToView","Float32Array","this","worldToViewOffset","mat4x4Count","viewToClip","viewToClipOffset","worldToClip","worldToClipOffset","viewToWorld","viewToWorldOffset","clipToView","clipToViewOffset","clipToWorld","clipToWorldOffset","location","rotation","params","nearPlane","farPlane","fov","width","height","projection","updateParams","val","cacheView","fromQuat","setTranslation","invert","mul","perspective","Math","PI","x","y","ortho","sizeofMat4x4f","TypeSizes","BYTES_PER_ELEMENT","VkFormatToWebGPU","Object","fromEntries","entries","map","vk","wgpu","parseInt","resolveBranch","branch","PreprocessorStatement","cond","else","res","toString","elif","Symbol","toStringTag","wrapWithIncrement","fn","start","include","flags","ifdef","sym","ifndef","preprocessors","vertexInLocation","idx","varyingsLocation","materialBinding","varyings","VertexNormals","VertexColors","code","AlphaCutoff","Emissive","DoubleSided","DescriptorMap","device","gbuffer","globals","pipelineLayouts","primitiveStates","vertexLayouts","shaderModules","bindgroupLayouts","samplers","forwardBindgroupLayout","createBindGroupLayout","label","binding","visibility","GPUShaderStage","VERTEX","FRAGMENT","type","getSampler","descriptor","key","JSON","stringify","createSampler","getVertexLayout","masked","attributes","shaderLocation","offset","format","arrayStride","push","stepMode","getForwardPipelineLayout","createPipelineLayout","bindGroupLayouts","bindGroupLayout","getMaterialBindGroup","getShaderModule","createShaderModule","getPrimitiveState","topology","flagToTopology","cullMode","frontFace","ClockwiseWinding","pushItem","item","length","sampler","texture","viewDimension","TriangleList","TriangleStrip","PointList","LineList","LineStrip","PipelineFeatureFlags","TopologyFormatMask","PrimitiveStateMask","CodeMask","InstanceBufferLayoutMask","VertexBufferLayoutMask","MaterialBindgroupLayoutMask","PipelineLayoutMask","featureFlagsToString","flatMap","flag","featureFlagsToNames","maskRedundantFeatures","GlobalUniforms","deviceBuffer","createBuffer","bufferDescriptor","layoutDescriptor","bindGroupDescriptor","layout","resource","size","bufferSize","bindgroup","createBindGroup","updateDeviceBuffer","queue","camera","writeBuffer","group","minBindingSize","usage","GPUBufferUsage","UNIFORM","COPY_DST","DEFAULT_MAX_OPS","createMipBlurCode","groups","async","cubemapGuassianPyramid","outputTextureLabel","inPlace","minWidth","steps","maxOpsPerPass","name","delayWork","mipLevelCount","log2","min","limits","maxComputeWorkgroupSizeX","maxComputeInvocationsPerWorkgroup","shader","bindgroupLayout","COMPUTE","storageTexture","access","pipeline","createComputePipeline","compute","module","entryPoint","constants","STEPS","ceil","gaussianPyramid","depthOrArrayLayers","createTexture","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","COPY_SRC","dimension","copyEncoder","createCommandEncoder","copyTextureToTexture","mipLevel","submit","finish","onSubmittedWorkDone","mipViews","i","createView","baseMipLevel","maxWorkgroups","maxComputeWorkgroupsPerDimension","maxLayers","maxDispatches","max","propertyArray","Uint32Array","set","w","acos","nextMipWidth","baseV","floor","baseVN","baseUN","baseMag2","sampUN","samp0VN","samp0Mag2","samp1VN","samp1Mag2","dot0","sqrt","dot1","minStepDistance","propertyBuffer","STORAGE","mipPasses","requiredMipDispatches","currentMipDispatches","batchDispatches","runPass","mipPixels","passDispatches","passLabel","encoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","gltfIndex","getGltfIndex","indexRes","fetch","indexStr","text","indexJson","parse","Array","isArray","Error","gltf","variants","glTF","file","GltfModel","depthTextureView","descriptorMap","depth","view","renderer","geometryPipelines","skybox","model","$type","$callback","File","setModel","accept","selection","value","initialValues","process","settings","publicSettings","priority","addForwardPass","setSkybox","requestAnimationFrame","modelPath","colorArray","opaqueWhite","writeTexture","normalMap","addressModeU","addressModeV","magFilter","minFilter","mipmapFilter","matData","baseColorTexture","baseColorFactor","normalTexture","metallicRoughnessTexture","metallicFactor","roughnessFactor","baseColorSampler","normalSampler","metallicRoughnessSampler","goalLayout","render","beginRenderPass","passDescriptor","values","draw","title","description","componentType","depends","fill","strip","feature","HashTable","prim","byteStride","attribute","initAttribute","paddedByteStride","u8","Uint8Array","u32","data","bytesPerComponent","componentsPerElement","hash","index","byteOffset","murmurHash2","equal","a","b","j","hashLookup","table","buckets","empty","hashmod","bucket","probe","m","h","k","imul","weld","srcVertexCount","POSITION","count","tableSize","log","LN2","is16Bit","indexFormat","writeMap","Uint16Array","dstVertexCount","hashIndex","dstIndex","remap","indexArray","vertexCount","PrimitiveDrawData","primitive","instances","instanceCount","dirty","features","vertexArray","GPUBuffer","vertexBuffer","indexData","indexCount","byteLength","indexBuffer","INDEX","instanceSize","modelMatrices","normalMatrices","instanceBuffer","instanceBindGroup","instance","addInstance","passEncoder","setVertexBuffer","setIndexBuffer","drawIndexed","transform","copy","calculateNormalMatrix","normalMatrix","fromMat4","transpose","modeToTopology","AttributeWrapper","accessor","componentCount","unwelded","processed","copyFrom","copyProcessed","bind","components","DataView","copyUnprocessed","at","getInt8","getUint8","getInt16","getUint16","getUint32","getFloat32","normalized","array","srcIdx","dstIdx","dst","markProcessed","newView","unweld","dstCount","dstArray","done","srcIndex","generateTangentsAsync","then","generateTangents","wrapIndices","indices","loadPrimitive","atrs","atr","mode","originalMode","reindex","NORMAL","TANGENT","TEXCOORD_0","Date","now","tangent","func","console","vertexFeatures","Defaults","stride","COLOR_0","vertexView","uv","step","interleaveVertices","instanceMatrices","overallSign","det","determinant","sign","getCullMode","drawData","material","DEFAULT_METALLIC","DEFAULT_ROUGHNESS","gltfToMagDescription","gltfToMipDescription","gltfToAddressMode","toSamplerDescription","wrapS","wrapT","getImageData","handle","source","image","bufferView","mimeType","loadMaterial","defaultMaterial","mat","pbrMetallicRoughness","id","srgbToLinear","emissiveFactor","emissiveTexture","emissiveStrength","extensions","KHR_materials_emissive_strength","some","emissiveSampler","scale","doubleSided","alphaMode","alphaCutoff","MaterialDrawData","primitiveFeatures","primitives","properties","propertiesBuffer","bindGroup","addPrimitives","filtered","filter","warn","GeometryPipeline","maps","materials","createRenderPipeline","vertex","buffers","fragment","targets","depthStencil","depthWriteEnabled","depthCompare","addMaterials","defaultLayout","recurseNode","parentMatrix","meshes","node","matrix","identity","scaling","axis","angle","toAxisAngle","rotate","translation","mesh","has","get","children","forEach","importGltf","url","pipelines","gltfWithBuffers","load","scene","nodes","Map","primitivePromises","from","primitiveDescriptors","Promise","all","materialMap","materialPromises","materialId","materialEntries","materialDescriptors","fullDefaultMat","drawDatas","f","hdrPromises","headers","json","hdrs","download_url","endsWith","processSkybox","arrayBuffer","hdr","getSkyboxOptions","target","keys","toWorldDir","cubemapSampleConversions","createAndCopyBuffer","arr","alignment","pad","mappedAtCreation","writeArray","getMappedRange","readArray","unmap","baseTable","shiftTable","e","conversionBuffer","floatView","uintView","toFloat16Bytes","bits","mantissa","shifted","imageToTexture","mips","colorSpace","bitmap","ImageBitmap","blob","Blob","createImageBitmap","colorSpaceConversion","RENDER_ATTACHMENT","copyExternalImageToTexture","parseHDR","inData","decoder","TextDecoder","pos","getLine","lineLimit","limit","sub","subarray","indexOf","undefined","decode","importError","msg","magicTokenLine","test","headerReg","RegExp","join","rawData","noFormat","gamma","exposure","line","match","X","Y","parseFloat","unencodable","flatData","scanline_buffer","len","ptr","isEncodedRun","float16One","raw_e","pow","equirectangularToCubemap","outputDescriptor","equirectangular","FLIP_Y","GPUTexture","bytesPerRow","faceSize","cubemapDescriptor","cubemap","paramBuffer","pipelineLayout","GAMMA","EXPOSURE","arrayLayerCount","baseArrayLayer","colorAttachments","loadOp","storeOp","generateMips","sampleType","colorAttachment","srgbTextureToLinear","tempTexture"],"sourceRoot":""}