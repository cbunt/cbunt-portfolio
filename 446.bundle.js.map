{"version":3,"file":"446.bundle.js","mappings":"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","sources":["webpack://cbunt-portfolio/./src/rendering/core/camera/camera.ts","webpack://cbunt-portfolio/./src/rendering/core/constants.ts","webpack://cbunt-portfolio/./src/rendering/utils/shader.ts","webpack://cbunt-portfolio/./src/rendering/shaders/forward.shader.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/descriptor-map.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/pipeline-feature-flags.ts","webpack://cbunt-portfolio/./src/rendering/core/global-uniforms.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/gltf-viewer-sample.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/weld.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/primitive-draw-data.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/type-conversions.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/attribute-wrapper.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/primitive-loader.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/interleave-vertices.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/material-loader.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/material-draw-data.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/geometry-pipeline.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/gltf-loader.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-copy.ts","webpack://cbunt-portfolio/./src/rendering/utils/texture-importing.ts","webpack://cbunt-portfolio/./src/rendering/utils/texture-processing.ts","webpack://cbunt-portfolio/./src/utils/general.ts"],"sourcesContent":["import { Vec3, Mat4, mat4, Quat } from 'wgpu-matrix';\r\nimport { TypeSizes } from '../constants';\r\n\r\nexport type CameraParams = {\r\n    nearPlane: number,\r\n    farPlane: number,\r\n    fov: number,\r\n    width: number,\r\n    height: number,\r\n    projection: 'perspective' | 'ortho',\r\n};\r\n\r\nexport default class Camera {\r\n    static readonly worldToViewOffset = 0;\r\n    static readonly viewToClipOffset = this.worldToViewOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly worldToClipOffset = this.viewToClipOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly viewToWorldOffset = this.worldToClipOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly clipToViewOffset = this.viewToWorldOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly clipToWorldOffset = this.clipToViewOffset + TypeSizes.sizeofMat4x4f;\r\n\r\n    static readonly bufferLength = this.clipToWorldOffset + TypeSizes.sizeofMat4x4f;\r\n\r\n    /**\r\n   *  An ArrayBuffer containing the camera's worldToView, viewToClip, worldToClip,\r\n   *  viewToWorld, clipToView, and clipToWorld matrices as Float32Arrays for\r\n   *  easier transfer. Ordered as listed above.\r\n   */\r\n    readonly buffer: ArrayBuffer = new ArrayBuffer(Camera.bufferLength);\r\n\r\n    readonly worldToView: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.worldToViewOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly viewToClip: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.viewToClipOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly worldToClip: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.worldToClipOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly viewToWorld: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.viewToWorldOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly clipToView: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.clipToViewOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly clipToWorld: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.clipToWorldOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly location: Vec3 = new Float32Array([0, 0, 0]);\r\n    readonly rotation: Quat = new Float32Array([0, 0, 0, 1]);\r\n\r\n    params: CameraParams = {\r\n        nearPlane: 0.01,\r\n        farPlane: 500.0,\r\n        fov: 40,\r\n        width: 1920,\r\n        height: 1080,\r\n        projection: 'perspective',\r\n    };\r\n\r\n    constructor(viewParams: Partial<CameraParams> = {}) {\r\n        this.updateParams(viewParams);\r\n    }\r\n\r\n    updateParams(val: Partial<CameraParams>) {\r\n        this.params = { ...this.params, ...val };\r\n        this.#cacheProjection();\r\n    }\r\n\r\n    cacheView(): void {\r\n        mat4.fromQuat(this.rotation, this.viewToWorld);\r\n        mat4.setTranslation(this.viewToWorld, this.location, this.viewToWorld);\r\n        mat4.invert(this.viewToWorld, this.worldToView);\r\n        mat4.mul(this.viewToClip, this.worldToView, this.worldToClip);\r\n        mat4.mul(this.viewToWorld, this.clipToView, this.clipToWorld);\r\n    }\r\n\r\n    #cacheProjection(): void {\r\n        if (this.params.projection === 'perspective') {\r\n            mat4.perspective(\r\n                this.params.fov * (Math.PI / 180),\r\n                this.params.width / this.params.height,\r\n                this.params.nearPlane,\r\n                this.params.farPlane,\r\n                this.viewToClip,\r\n            );\r\n        } else {\r\n            const x = this.params.width / 2;\r\n            const y = this.params.height / 2;\r\n\r\n            mat4.ortho(\r\n                -x,\r\n                x,\r\n                -y,\r\n                y,\r\n                this.params.nearPlane,\r\n                this.params.farPlane,\r\n                this.viewToClip,\r\n            );\r\n        }\r\n\r\n        mat4.invert(this.viewToClip, this.clipToView);\r\n    }\r\n}\r\n","import * as ktxp from 'ktx-parse';\r\n\r\nexport const TypeSizes = {\r\n    mat4x4Count: 16,\r\n    sizeofMat4x4f: 16 * Float32Array.BYTES_PER_ELEMENT,\r\n};\r\n\r\nexport const VkFormatToWebGPU: Record<number, GPUTextureFormat | undefined> = {\r\n    // 8-bit formats\r\n    [ktxp.VK_FORMAT_R8_UNORM]: 'r8unorm',\r\n    [ktxp.VK_FORMAT_R8_SNORM]: 'r8snorm',\r\n    [ktxp.VK_FORMAT_R8_UINT]: 'r8uint',\r\n    [ktxp.VK_FORMAT_R8_SINT]: 'r8sint',\r\n    // 16-bit formats\r\n    [ktxp.VK_FORMAT_R16_UINT]: 'r16uint',\r\n    [ktxp.VK_FORMAT_R16_SINT]: 'r16sint',\r\n    [ktxp.VK_FORMAT_R16_SFLOAT]: 'r16float',\r\n    [ktxp.VK_FORMAT_R8G8_UNORM]: 'rg8unorm',\r\n    [ktxp.VK_FORMAT_R8G8_SNORM]: 'rg8snorm',\r\n    [ktxp.VK_FORMAT_R8G8_UINT]: 'rg8uint',\r\n    [ktxp.VK_FORMAT_R8G8_SINT]: 'rg8sint',\r\n    // 32-bit formats\r\n    [ktxp.VK_FORMAT_R32_UINT]: 'r32uint',\r\n    [ktxp.VK_FORMAT_R32_SINT]: 'r32sint',\r\n    [ktxp.VK_FORMAT_R32_SFLOAT]: 'r32float',\r\n    [ktxp.VK_FORMAT_R16G16_UINT]: 'rg16uint',\r\n    [ktxp.VK_FORMAT_R16G16_SINT]: 'rg16sint',\r\n    [ktxp.VK_FORMAT_R16G16_SFLOAT]: 'rg16float',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UNORM]: 'rgba8unorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SRGB]: 'rgba8unorm-srgb',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SNORM]: 'rgba8snorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UINT]: 'rgba8uint',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SINT]: 'rgba8sint',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_UNORM]: 'bgra8unorm',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_SRGB]: 'bgra8unorm-srgb',\r\n    // Packed 32-bit formats\r\n    [ktxp.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32]: 'rgb9e5ufloat',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UINT_PACK32]: 'rgb10a2uint',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UNORM_PACK32]: 'rgb10a2unorm',\r\n    [ktxp.VK_FORMAT_B10G11R11_UFLOAT_PACK32]: 'rg11b10ufloat',\r\n    // 64-bit formats\r\n    [ktxp.VK_FORMAT_R32G32_UINT]: 'rg32uint',\r\n    [ktxp.VK_FORMAT_R32G32_SINT]: 'rg32sint',\r\n    [ktxp.VK_FORMAT_R32G32_SFLOAT]: 'rg32float',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_UINT]: 'rgba16uint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SINT]: 'rgba16sint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SFLOAT]: 'rgba16float',\r\n    // 128-bit formats\r\n    [ktxp.VK_FORMAT_R32G32B32A32_UINT]: 'rgba32uint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SINT]: 'rgba32sint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SFLOAT]: 'rgba32float',\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    [ktxp.VK_FORMAT_BC1_RGBA_UNORM_BLOCK]: 'bc1-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC1_RGBA_SRGB_BLOCK]: 'bc1-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC2_UNORM_BLOCK]: 'bc2-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC2_SRGB_BLOCK]: 'bc2-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC3_UNORM_BLOCK]: 'bc3-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC3_SRGB_BLOCK]: 'bc3-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC4_UNORM_BLOCK]: 'bc4-r-unorm',\r\n    [ktxp.VK_FORMAT_BC4_SNORM_BLOCK]: 'bc4-r-snorm',\r\n    [ktxp.VK_FORMAT_BC5_UNORM_BLOCK]: 'bc5-rg-unorm',\r\n    [ktxp.VK_FORMAT_BC5_SNORM_BLOCK]: 'bc5-rg-snorm',\r\n    [ktxp.VK_FORMAT_BC6H_UFLOAT_BLOCK]: 'bc6h-rgb-ufloat',\r\n    [ktxp.VK_FORMAT_BC6H_SFLOAT_BLOCK]: 'bc6h-rgb-float',\r\n    [ktxp.VK_FORMAT_BC7_UNORM_BLOCK]: 'bc7-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC7_SRGB_BLOCK]: 'bc7-rgba-unorm-srgb',\r\n    // Currently unsupported extension formats:\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"etc2-rgb8unorm\",\r\n    // \"etc2-rgb8unorm-srgb\",\r\n    // \"etc2-rgb8a1unorm\",\r\n    // \"etc2-rgb8a1unorm-srgb\",\r\n    // \"etc2-rgba8unorm\",\r\n    // \"etc2-rgba8unorm-srgb\",\r\n    // \"eac-r11unorm\",\r\n    // \"eac-r11snorm\",\r\n    // \"eac-rg11unorm\",\r\n    // \"eac-rg11snorm\",\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"astc-4x4-unorm\",\r\n    // \"astc-4x4-unorm-srgb\",\r\n    // \"astc-5x4-unorm\",\r\n    // \"astc-5x4-unorm-srgb\",\r\n    // \"astc-5x5-unorm\",\r\n    // \"astc-5x5-unorm-srgb\",\r\n    // \"astc-6x5-unorm\",\r\n    // \"astc-6x5-unorm-srgb\",\r\n    // \"astc-6x6-unorm\",\r\n    // \"astc-6x6-unorm-srgb\",\r\n    // \"astc-8x5-unorm\",\r\n    // \"astc-8x5-unorm-srgb\",\r\n    // \"astc-8x6-unorm\",\r\n    // \"astc-8x6-unorm-srgb\",\r\n    // \"astc-8x8-unorm\",\r\n    // \"astc-8x8-unorm-srgb\",\r\n    // \"astc-10x5-unorm\",\r\n    // \"astc-10x5-unorm-srgb\",\r\n    // \"astc-10x6-unorm\",\r\n    // \"astc-10x6-unorm-srgb\",\r\n    // \"astc-10x8-unorm\",\r\n    // \"astc-10x8-unorm-srgb\",\r\n    // \"astc-10x10-unorm\",\r\n    // \"astc-10x10-unorm-srgb\",\r\n    // \"astc-12x10-unorm\",\r\n    // \"astc-12x10-unorm-srgb\",\r\n    // \"astc-12x12-unorm\",\r\n};\r\n\r\nexport const TextureFormatToSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 2,\r\n    rg8snorm: 2,\r\n    rg8uint: 2,\r\n    rg8sint: 2,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 4,\r\n    rg16sint: 4,\r\n    rg16float: 4,\r\n    rgba8unorm: 4,\r\n    'rgba8unorm-srgb': 4,\r\n    rgba8snorm: 4,\r\n    rgba8uint: 4,\r\n    rgba8sint: 4,\r\n    bgra8unorm: 4,\r\n    'bgra8unorm-srgb': 4,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 8,\r\n    rg32sint: 8,\r\n    rg32float: 8,\r\n    rgba16uint: 8,\r\n    rgba16sint: 8,\r\n    rgba16float: 8,\r\n    // 128-bit formats\r\n    rgba32uint: 16,\r\n    rgba32sint: 16,\r\n    rgba32float: 16,\r\n};\r\n\r\nexport const TextureFormatToChannelSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 1,\r\n    rg8snorm: 1,\r\n    rg8uint: 1,\r\n    rg8sint: 1,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 2,\r\n    rg16sint: 2,\r\n    rg16float: 2,\r\n    rgba8unorm: 1,\r\n    'rgba8unorm-srgb': 1,\r\n    rgba8snorm: 1,\r\n    rgba8uint: 1,\r\n    rgba8sint: 1,\r\n    bgra8unorm: 1,\r\n    'bgra8unorm-srgb': 1,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 4,\r\n    rg32sint: 4,\r\n    rg32float: 4,\r\n    rgba16uint: 2,\r\n    rgba16sint: 2,\r\n    rgba16float: 2,\r\n    // 128-bit formats\r\n    rgba32uint: 4,\r\n    rgba32sint: 4,\r\n    rgba32float: 4,\r\n};\r\n\r\nexport const WebGPUToVkFormat = Object.fromEntries(\r\n    Object.entries(VkFormatToWebGPU).map(([vk, wgpu]) => [wgpu, parseInt(vk, 10)]),\r\n) as Record<GPUTextureFormat, ktxp.VKFormat>;\r\n\r\nexport const textureTypeToDimension: Record<string, GPUTextureViewDimension> = {\r\n    texture_cube: 'cube',\r\n    texture_3d: '3d',\r\n    texture_2d: '2d',\r\n};\r\n","export type Branch = string | (() => string);\r\n\r\nfunction resolveBranch(branch: Branch) {\r\n    return typeof branch === 'string' ? branch : branch();\r\n}\r\n\r\nclass PreprocessorStatement {\r\n    res?: string;\r\n\r\n    constructor(cond: boolean, branch: Branch) {\r\n        if (cond) this.res = resolveBranch(branch);\r\n    }\r\n\r\n    elif(cond: boolean, branch: Branch) {\r\n        if (cond) this.res ??= resolveBranch(branch);\r\n        return this;\r\n    }\r\n\r\n    else = (branch: Branch) => this.res ?? resolveBranch(branch);\r\n\r\n    toString = () => this.res ?? '';\r\n\r\n    get [Symbol.toStringTag]() { return this.toString(); }\r\n}\r\n\r\nexport function preprocessors(flags: number) {\r\n    return {\r\n        ifdef(sym: number, branch: Branch) {\r\n            return new PreprocessorStatement((flags & sym) === sym, branch);\r\n        },\r\n        ifndef(sym: number, branch: Branch) {\r\n            return new PreprocessorStatement((flags & sym) !== sym, branch);\r\n        },\r\n    };\r\n}\r\n\r\nexport function wrapWithIncrement<T>(fn: (counter: number) => T, start = 0): () => T {\r\n    return () => fn(start++);\r\n}\r\n","/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\nimport { PipelineFeatureFlags, featureFlagsToString } from '../core/default-forward-pass/pipeline-feature-flags';\nimport { preprocessors, wrapWithIncrement } from '../utils/shader';\nimport GlobalUniforms from '../core/global-uniforms';\nimport { GBufferGroupIndices } from '../core/gbuffer';\n\nexport function getBindgroupInfo(flags: PipelineFeatureFlags): GPUBindGroupLayoutDescriptor {\n    const entries: GPUBindGroupLayoutEntry[] = [];\n\n    function pushItem(item: Omit<GPUBindGroupLayoutEntry, 'binding' | 'visibility'>) {\n        entries.push({ ...item, binding: entries.length, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX });\n    }\n\n    pushItem({ buffer: { type: 'uniform' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    if (flags & PipelineFeatureFlags.Emissive) {\n        pushItem({ sampler: {} });\n        pushItem({ texture: { viewDimension: '2d' } });\n    }\n\n    return { label: featureFlagsToString(flags), entries };\n}\n\n/**\n * @param flags A flag enum containing the features this code should be generated for\n * @returns A string containing preprocessed wgsl shader code for the given features\n */\nexport default function include(flags: PipelineFeatureFlags) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { ifdef } = preprocessors(flags as number);\n    const vertexInLocation = wrapWithIncrement((idx) => /* wgsl */`@location(${idx})`);\n    const varyingsLocation = wrapWithIncrement((idx) => /* wgsl */`@location(${idx})`);\n\n    const materialBinding = wrapWithIncrement((idx) => /* wgsl */`\n        @group(1) @binding(${idx})\n    `);\n\n    const varyings = /* wgsl */`\n        ${varyingsLocation()} pos: vec3f,\n        ${varyingsLocation()} camPos: vec3f,\n        ${varyingsLocation()} uv: vec2f,\n\n        ${ifdef(PipelineFeatureFlags.VertexNormals, () => /* wgsl */`\n            ${varyingsLocation()} tangent: vec4f,\n            ${varyingsLocation()} normal: vec3f,\n        `)}\n\n        ${ifdef(PipelineFeatureFlags.VertexColors, () => /* wgsl */`\n            ${varyingsLocation()} color: vec4f,\n        `)}\n    `;\n\n    return /* wgsl */`\n        ${GlobalUniforms.code(0)}\n\n        struct ForwardOut {\n            @location(${GBufferGroupIndices.Normal}) normal: vec4f,\n            @location(${GBufferGroupIndices.Albedo}) albedo: vec4f,\n            @location(${GBufferGroupIndices.Emission}) emission: vec4f,\n            @location(${GBufferGroupIndices.MetallicRoughness}) metallicRoughness: vec4f,\n        }\n\n        struct MaterialProperties {\n            baseColorFactor: vec4f,\n            metallicFactor: f32,\n            roughnessFactor: f32,\n\n            ${ifdef(PipelineFeatureFlags.AlphaCutoff, 'alphaCutoff: f32,')}\n            ${ifdef(PipelineFeatureFlags.Emissive, 'emissiveFactor: vec3f,')}\n        }\n\n        ${materialBinding()} var<uniform> material: MaterialProperties;\n\n        ${materialBinding()} var baseColorSampler: sampler;\n        ${materialBinding()} var baseColorTexture: texture_2d<f32>;\n\n        ${materialBinding()} var normalSampler: sampler;\n        ${materialBinding()} var normalTexture: texture_2d<f32>;\n\n        ${materialBinding()} var metallicRoughnessSampler: sampler;\n        ${materialBinding()} var metallicRoughnessTexture: texture_2d<f32>;\n\n        ${ifdef(PipelineFeatureFlags.Emissive, () => /* wgsl */`\n            ${materialBinding()} var emissionSampler: sampler;\n            ${materialBinding()} var emissionTexture: texture_2d<f32>;\n        `)}\n\n        struct ModelProperties {\n            modelToWorldMatrix: mat4x4f,\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, 'normalMatrix: mat3x3f,')}\n        }\n\n        @group(2) @binding(0) var<storage, read> instances : array<ModelProperties>;\n\n        struct VertIn {\n            @builtin(instance_index) instance: u32,\n            ${vertexInLocation()} pos: vec3f,\n            ${vertexInLocation()} uv: vec2f,\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, () => /* wgsl */`\n                ${vertexInLocation()} tangent: vec4f,\n                ${vertexInLocation()} normal: vec3f,\n            `)}\n\n            ${ifdef(PipelineFeatureFlags.VertexColors, () => /* wgsl */`\n                ${vertexInLocation()} color: vec4f,\n            `)}\n        }\n\n        struct VertOut {\n            ${varyings}\n            @builtin(position) Position: vec4f,\n        }\n\n        struct FragIn {\n            ${varyings}\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals | PipelineFeatureFlags.DoubleSided, /* wgsl */`\n                @builtin(front_facing) front_facing: bool,\n            `)}\n        }\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @vertex \n        fn vs(inData: VertIn) -> VertOut {\n            var vsOut: VertOut;\n            let instance = instances[inData.instance];\n            let worldPos = instance.modelToWorldMatrix * vec4f(inData.pos, 1);\n            vsOut.pos = worldPos.xyz;\n            vsOut.Position = globals.worldToClip * worldPos;\n            vsOut.camPos = globals.inverseWorldToView[3].xyz;\n            vsOut.uv = inData.uv;\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, /* wgsl */`\n                vsOut.normal = normalize(instance.normalMatrix * inData.normal);\n                let wsTangent = normalize((instance.modelToWorldMatrix * vec4(inData.tangent.xyz, 0.0)).xyz);\n                vsOut.tangent = vec4(wsTangent, inData.tangent.w);\n            `)}\n\n            return vsOut;\n        }\n\n        // much of this code is adapted from https://learnopengl.com/PBR\n        @fragment\n        fn fs(inData: FragIn) -> ForwardOut {\n            var out: ForwardOut;\n            let rawColor = textureSample(baseColorTexture, baseColorSampler, inData.uv);\n\n            ${ifdef(PipelineFeatureFlags.AlphaCutoff, /* wgsl */`\n                var alpha = rawColor.a * material.baseColorFactor.a;\n\n                ${ifdef(PipelineFeatureFlags.VertexColors, /* wgsl */`\n                    alpha *= inData.color.a;\n                `)}\n\n                if (alpha <= material.alphaCutoff) { \n                    discard;\n                }\n            `)}\n\n            out.albedo = vec4f(rawColor.rgb * material.baseColorFactor.rgb, 1);\n\n            ${ifdef(PipelineFeatureFlags.VertexColors, /* wgsl */`\n                out.albedo *= vec4f(inData.color.rgb, 1);\n            `)}\n\n            let metallicRoughness = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, inData.uv);\n            out.metallicRoughness.r = saturate(metallicRoughness.b * material.metallicFactor);\n            out.metallicRoughness.g = saturate(metallicRoughness.g * material.roughnessFactor);\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, /* wgsl */`\n                let normalSample = textureSample(normalTexture, normalSampler, inData.uv).xyz;\n                let tangentNormal = normalize(normalSample * 2.0 - 1.0);\n                let bitangent =inData.tangent.w * cross(inData.normal, inData.tangent.xyz);\n                let tbn = mat3x3f(normalize(inData.tangent.xyz), bitangent, normalize(inData.normal));\n                var normal = normalize(tbn * tangentNormal);\n\n                ${ifdef(PipelineFeatureFlags.DoubleSided, /* wgsl */`\n                    if (!inData.front_facing) { normal *= -1.0; }\n                `)}\n            `).else(/* wgsl */`\n                let fdx = dpdx(inData.pos);\n                let fdy = dpdy(inData.pos);\n                let normal = normalize(cross(fdy, fdx));\n            `)}\n\n            out.normal = vec4f(normal, 1);\n\n            ${ifdef(PipelineFeatureFlags.Emissive, /* wgsl */`\n                let emission = textureSample(emissionTexture, emissionSampler, inData.uv).rgb;\n                out.emission = vec4f(emission, 1);\n            `)}\n\n            return out;\n        }\n    `;\n}\n","import { PipelineFeatureFlags } from './pipeline-feature-flags';\nimport * as PipelineFeatures from './pipeline-feature-flags';\nimport include, { getBindgroupInfo as getBindGroupInfo } from '../../shaders/forward.shader';\n\nimport GBuffer from '../gbuffer';\nimport GlobalUniforms from '../global-uniforms';\n\ntype PipelineFeatureMap<T> = Partial<Record<number, T>>;\n\nexport default class DescriptorMap {\n    static readonly flagToTopology: Partial<Record<PipelineFeatureFlags, GPUPrimitiveTopology>> = {\n        [PipelineFeatureFlags.TriangleList]: 'triangle-list',\n        [PipelineFeatureFlags.TriangleStrip]: 'triangle-strip',\n        [PipelineFeatureFlags.PointList]: 'point-list',\n        [PipelineFeatureFlags.LineList]: 'line-list',\n        [PipelineFeatureFlags.LineStrip]: 'line-strip',\n    };\n\n    readonly pipelineLayouts: PipelineFeatureMap<GPUPipelineLayout> = {};\n    readonly primitiveStates: PipelineFeatureMap<GPUPrimitiveState> = {};\n    readonly vertexLayouts: PipelineFeatureMap<GPUVertexBufferLayout> = {};\n    readonly shaderModules: PipelineFeatureMap<GPUShaderModule> = {};\n    readonly bindgroupLayouts: PipelineFeatureMap<GPUBindGroupLayout> = {};\n\n    readonly samplers: Partial<Record<string, GPUSampler>> = {};\n\n    readonly forwardBindgroupLayout = this.device.createBindGroupLayout({\n        label: `forward material`,\n        entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n            buffer: { type: 'read-only-storage' },\n        }],\n    });\n\n    constructor(\n        public readonly device: GPUDevice,\n        public readonly gbuffer: GBuffer,\n        public readonly globals: GlobalUniforms,\n    ) { }\n\n    getSampler(descriptor: GPUSamplerDescriptor) {\n        const key = JSON.stringify(descriptor);\n        this.samplers[key] ??= this.device.createSampler(descriptor);\n        return this.samplers[key];\n    }\n\n    getVertexLayout(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.VertexBufferLayoutMask;\n\n        if (this.vertexLayouts[masked] == null) {\n            const attributes: GPUVertexAttribute[] = [\n                { shaderLocation: 0, offset: 0, format: 'float32x3' }, // position\n                { shaderLocation: 1, offset: 12, format: 'float32x2' }, // uv\n            ];\n\n            let arrayStride = 20;\n            let shaderLocation = 2;\n\n            if (masked & PipelineFeatureFlags.VertexNormals) {\n                attributes.push({ shaderLocation, offset: arrayStride, format: 'float32x4' }); // tangent\n                attributes.push({ shaderLocation: shaderLocation + 1, offset: arrayStride + 16, format: 'float32x3' }); // normal\n                shaderLocation += 2;\n                arrayStride += 28;\n            }\n\n            if (masked & PipelineFeatureFlags.VertexColors) {\n                attributes.push({ shaderLocation, offset: arrayStride, format: 'float32x4' }); // color\n                arrayStride += 16;\n            }\n\n            this.vertexLayouts[masked] = { attributes, arrayStride, stepMode: 'vertex' };\n        }\n\n        return this.vertexLayouts[masked];\n    }\n\n    getForwardPipelineLayout(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.PipelineLayoutMask;\n\n        this.pipelineLayouts[masked] ??= this.device.createPipelineLayout({\n            label: PipelineFeatures.featureFlagsToString(masked),\n            bindGroupLayouts: [\n                this.globals.bindGroupLayout,\n                this.getMaterialBindGroup(flags),\n                this.forwardBindgroupLayout,\n            ],\n        });\n\n        return this.pipelineLayouts[masked];\n    }\n\n    getShaderModule(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.CodeMask;\n        this.shaderModules[masked] ??= this.device.createShaderModule({\n            label: PipelineFeatures.featureFlagsToString(masked),\n            code: include(masked),\n        });\n        return this.shaderModules[masked];\n    }\n\n    getPrimitiveState(flags: PipelineFeatureFlags) {\n        const masked = flags & PipelineFeatures.PrimitiveStateMask;\n\n        this.primitiveStates[masked] ??= {\n            topology: DescriptorMap.flagToTopology[(flags & PipelineFeatures.TopologyFormatMask) as PipelineFeatureFlags],\n            cullMode: masked & PipelineFeatureFlags.DoubleSided ? 'none' : 'back',\n            frontFace: masked & PipelineFeatureFlags.ClockwiseWinding ? 'cw' : 'ccw',\n        };\n\n        return this.primitiveStates[masked];\n    }\n\n    getMaterialBindGroup(flags: PipelineFeatureFlags) {\n        const masked = flags & PipelineFeatures.MaterialBindgroupLayoutMask;\n        this.bindgroupLayouts[masked] ??= this.device.createBindGroupLayout(getBindGroupInfo(masked));\n        return this.bindgroupLayouts[masked];\n    }\n}\n","export enum PipelineFeatureFlags {\n    Defaults = 0,\n\n    /**\n     * If the meshes have vertex normals.\n     * If absent, meshes are shaded with flat normals.\n    */\n    VertexNormals = 1 << 0,\n\n    /**\n     * If the meshes have vertex colors.\n     * If absent, mesh is shaded with a base color texture.\n    */\n    VertexColors = 1 << 1,\n\n    AlphaCutoff = 1 << 2,\n    Emissive = 1 << 3,\n\n    DoubleSided = 1 << 4,\n    ClockwiseWinding = 1 << 5,\n\n    // Topology formats\n    TriangleList = 0 << 6,\n    TriangleStrip = 1 << 6,\n    PointList = 2 << 6,\n    LineList = 3 << 6,\n    LineStrip = 4 << 6,\n    Unindexed = 5 << 6,\n    // LINE_LOOP (currently unsupported by webgpu)\n    // TRIANGLE_FAN (currently unsupported by webgpu)\n}\n\nexport const TopologyFormatMask = 0x111 << 6;\n\nexport const PrimitiveStateMask = (\n    TopologyFormatMask\n    | PipelineFeatureFlags.DoubleSided\n    | PipelineFeatureFlags.ClockwiseWinding\n);\n\nexport const CodeMask = ~(\n    TopologyFormatMask\n    | PipelineFeatureFlags.ClockwiseWinding\n);\n\nexport const InstanceBufferLayoutMask = (\n    PipelineFeatureFlags.VertexNormals\n);\n\nexport const VertexBufferLayoutMask = (\n    PipelineFeatureFlags.VertexNormals\n    | PipelineFeatureFlags.VertexColors\n);\n\nexport const MaterialBufferLayoutMask = (\n    PipelineFeatureFlags.AlphaCutoff\n);\n\nexport const MaterialBindgroupLayoutMask = (\n    MaterialBufferLayoutMask\n    | PipelineFeatureFlags.Emissive\n);\n\nexport const MaterialMask = (\n    MaterialBindgroupLayoutMask\n    | PipelineFeatureFlags.DoubleSided\n);\n\nexport const PipelineLayoutMask = (\n    InstanceBufferLayoutMask\n    | MaterialMask\n);\n\nexport function featureFlagsToNames(val: number) {\n    return Object.entries(PipelineFeatureFlags)\n        .flatMap(([key, flag]) => typeof flag === 'number' && (flag & val) ? key : []);\n}\n\nexport function featureFlagsToString(val: number) {\n    return featureFlagsToNames(val).toString();\n}\n\nexport function maskRedundantFeatures(flags: PipelineFeatureFlags) {\n    let masked = flags;\n    if (masked & PipelineFeatureFlags.DoubleSided) masked &= ~PipelineFeatureFlags.ClockwiseWinding;\n    return masked;\n}\n","import Camera from './camera/camera';\r\n\r\nconst label = 'global uniforms';\r\n\r\nexport default class GlobalUniforms {\r\n    static readonly code = (group: number) => /* wgsl */`\r\n        struct GlobalUniforms {\r\n            worldToView: mat4x4f,\r\n            viewToClip: mat4x4f,\r\n            worldToClip: mat4x4f,\r\n            inverseWorldToView: mat4x4f,\r\n            inverseViewToClip: mat4x4f,\r\n            inverseWorldToClip: mat4x4f,\r\n        }\r\n\r\n        @group(${group}) @binding(0) var<uniform> globals: GlobalUniforms;\r\n    `;\r\n\r\n    static readonly bufferSize = Camera.bufferLength;\r\n\r\n    static readonly layoutDescriptor: GPUBindGroupLayoutDescriptor = {\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                buffer: { minBindingSize: GlobalUniforms.bufferSize },\r\n                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\r\n            },\r\n        ],\r\n    };\r\n\r\n    static readonly bufferDescriptor: GPUBufferDescriptor = {\r\n        label,\r\n        size: GlobalUniforms.bufferSize,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    };\r\n\r\n    deviceBuffer: GPUBuffer;\r\n    bindGroupLayout: GPUBindGroupLayout;\r\n    bindGroupDescriptor!: GPUBindGroupDescriptor;\r\n    bindgroup!: GPUBindGroup;\r\n\r\n    constructor(device: GPUDevice) {\r\n        this.deviceBuffer = device.createBuffer(GlobalUniforms.bufferDescriptor);\r\n        this.bindGroupLayout = device.createBindGroupLayout(GlobalUniforms.layoutDescriptor);\r\n\r\n        this.bindGroupDescriptor = {\r\n            label,\r\n            layout: this.bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.deviceBuffer,\r\n                        offset: 0,\r\n                        size: GlobalUniforms.bufferSize,\r\n                    },\r\n                },\r\n            ],\r\n        };\r\n\r\n        this.bindgroup = device.createBindGroup(this.bindGroupDescriptor);\r\n    }\r\n\r\n    updateDeviceBuffer(queue: GPUQueue, camera: Camera) {\r\n        camera.cacheView();\r\n        queue.writeBuffer(this.deviceBuffer, 0, camera.buffer);\r\n    }\r\n}\r\n","import { RenderModel } from '../settings/sample-spec';\nimport propertyListener, { ListenerSyms } from '../settings/property-listener';\nimport getSkyboxOptions from '../settings/skybox-options';\n\nimport GeometryPipeline from '../../core/default-forward-pass/geometry-pipeline';\nimport DescriptorMap from '../../core/default-forward-pass/descriptor-map';\nimport Renderer, { ForwardPassParams } from '../../core/renderer';\nimport { MaterialDescriptor } from '../../core/default-forward-pass/material-draw-data';\nimport { PipelineFeatureFlags } from '../../core/default-forward-pass/pipeline-feature-flags';\n\nimport cubemapGuassianPyramid from '../cubemap-blur/cubemap-guassian-pyramid';\n\nimport { AttributeDetails, ComponentType } from './loader/type-conversions';\nimport importGltf from './loader/gltf-loader';\nimport { DataType } from '@loaders.gl/core';\nimport { isObject } from '../../../utils/general';\n\nconst gltfIndex = await getGltfIndex();\n\nasync function getGltfIndex() {\n    const indexUrl = GLTF_BASE_URL__ + GLTF_INDEX_FILE__;\n    const indexRes = await fetch(indexUrl);\n    const indexStr = await indexRes.text();\n    const indexJson = JSON.parse(indexStr) as unknown;\n\n    if (!Array.isArray(indexJson)) {\n        throw new Error('Could not load index for glTF sample models.');\n    }\n\n    const entries: [string, string][] = indexJson.flatMap((gltf: unknown) => {\n        if (\n            !isObject(gltf)\n            || !('label' in gltf)\n            || typeof gltf.label !== 'string'\n            || !('name' in gltf)\n            || typeof gltf.name !== 'string'\n            || !('variants' in gltf)\n            || !isObject(gltf.variants)\n            || typeof gltf.variants.glTF !== 'string'\n        ) return [];\n\n        const { variants: { glTF: file }, label, name } = gltf;\n        const path = `${GLTF_BASE_URL__}${name}/glTF/${file}`;\n        return [[label, path]];\n    });\n\n    return Object.fromEntries(entries);\n}\n\nexport default class GltfModel implements RenderModel {\n    static readonly goalLayout: AttributeDetails[] = [\n        {\n            name: 'POSITION',\n            type: 'VEC3',\n            componentType: ComponentType.float32,\n        },\n        {\n            name: 'TEXCOORD_0',\n            type: 'VEC2',\n            componentType: ComponentType.float32,\n        },\n        {\n            name: 'TANGENT',\n            type: 'VEC4',\n            componentType: ComponentType.float32,\n            depends: ['NORMAL'],\n            fill: [1, 0, 0, 1],\n        },\n        {\n            name: 'NORMAL',\n            type: 'VEC3',\n            componentType: ComponentType.float32,\n            strip: true,\n            feature: PipelineFeatureFlags.VertexNormals,\n        },\n        {\n            name: 'COLOR_0',\n            type: 'VEC4',\n            componentType: ComponentType.float32,\n            strip: true,\n            feature: PipelineFeatureFlags.VertexColors,\n            fill: [1, 1, 1, 1],\n        },\n    ];\n\n    geometryPipelines: Partial<Record<number, GeometryPipeline>> = {};\n    descriptorMap: DescriptorMap;\n    device: GPUDevice;\n\n    get depthTextureView() {\n        return this.descriptorMap.gbuffer.depth.view;\n    }\n\n    readonly #settings = propertyListener({\n        skybox: getSkyboxOptions(this),\n        model: {\n            [ListenerSyms.$type]: 'file' as const,\n            [ListenerSyms.$callback]: (val: unknown, key: PropertyKey) => {\n                if (key !== 'value' || val == null) return;\n                if (typeof val === 'string' || val instanceof File) {\n                    void this.setModel(val);\n                }\n            },\n            accept: '.hdr',\n            selection: {\n                value: 'Environment Test',\n                initialValues: gltfIndex,\n            },\n            process: (file: File) => file,\n        },\n    });\n\n    readonly settings = this.#settings.publicSettings;\n    readonly priority = 1000;\n\n    constructor(public renderer: Renderer) {\n        this.descriptorMap = new DescriptorMap(renderer.device, renderer.gbuffer, renderer.globals);\n        this.device = renderer.device;\n        this.renderer.addForwardPass(this);\n    }\n\n    async setSkybox(skybox: GPUTexture) {\n        await cubemapGuassianPyramid({\n            texture: skybox,\n            device: this.renderer.device,\n            inPlace: true,\n            delayWork: requestAnimationFrame,\n        });\n\n        this.renderer.skybox = skybox;\n    }\n\n    async setModel(modelPath: string | DataType) {\n        const size = { width: 1, height: 1 };\n        const colorArray = new Float32Array([1, 1, 1, 1]);\n\n        const opaqueWhite = this.renderer.device.createTexture({\n            size,\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        this.renderer.device.queue.writeTexture({ texture: opaqueWhite }, colorArray, {}, size);\n\n        const normalMap = this.renderer.device.createTexture({\n            size,\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        colorArray.set([0.5, 0.5, 1, 1]);\n        this.renderer.device.queue.writeTexture({ texture: normalMap }, colorArray, {}, size);\n\n        const sampler = {\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'linear',\n            mipmapFilter: 'linear',\n        } as GPUSamplerDescriptor;\n\n        const matData: MaterialDescriptor = {\n            baseColorTexture: opaqueWhite,\n            baseColorFactor: [1, 1, 1, 1],\n            normalTexture: normalMap,\n            metallicRoughnessTexture: opaqueWhite,\n            metallicFactor: 1,\n            roughnessFactor: 1,\n            baseColorSampler: sampler,\n            normalSampler: sampler,\n            metallicRoughnessSampler: sampler,\n        };\n\n        this.geometryPipelines = await importGltf(\n            modelPath,\n            this.renderer.device,\n            this.descriptorMap,\n            matData,\n            GltfModel.goalLayout,\n            {},\n        );\n    }\n\n    render({ encoder, gbuffer, globals }: ForwardPassParams) {\n        const pass = encoder.beginRenderPass(gbuffer.passDescriptor);\n        pass.setBindGroup(0, globals.bindgroup);\n\n        for (const pipeline of Object.values(this.geometryPipelines)) {\n            pipeline?.draw(pass, this.renderer.device.queue);\n        }\n        pass.end();\n    }\n}\n","import AttributeWrapper from './attribute-wrapper';\n\n/**\n * Adapted from gltf-transform's version:\n * github.com/donmccurdy/glTF-Transform/blob/main/packages/functions/src/weld.ts\n */\nclass HashTable {\n    private attributes: { u8: Uint8Array, byteStride: number }[] = [];\n    private u8: Uint8Array;\n    private u32: Uint32Array;\n\n    constructor(prim: Record<string, AttributeWrapper>) {\n        let byteStride = 0;\n        for (const attribute of Object.values(prim)) {\n            byteStride += this.initAttribute(attribute);\n        }\n        const paddedByteStride = (byteStride + 3) & ~3;\n        this.u8 = new Uint8Array(paddedByteStride);\n        this.u32 = new Uint32Array(this.u8.buffer);\n    }\n\n    private initAttribute(attribute: AttributeWrapper): number {\n        const u8 = attribute.data instanceof Uint8Array\n            ? attribute.data\n            : new Uint8Array(attribute.data.buffer);\n        const byteStride = attribute.bytesPerComponent * attribute.componentsPerElement;\n        this.attributes.push({ u8, byteStride });\n        return byteStride;\n    }\n\n    hash(index: number): number {\n        let byteOffset = 0;\n        for (const { u8, byteStride } of this.attributes) {\n            for (let i = 0; i < byteStride; i += 1) {\n                this.u8[byteOffset + i] = u8[index * byteStride + i];\n            }\n            byteOffset += byteStride;\n        }\n        return this.murmurHash2();\n    }\n\n    equal(a: number, b: number): boolean {\n        for (const { u8, byteStride } of this.attributes) {\n            for (let j = 0; j < byteStride; j += 1) {\n                if (u8[a * byteStride + j] !== u8[b * byteStride + j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    hashLookup(table: TypedArray, buckets: number, key: number, empty: number): number {\n        const hashmod = buckets - 1;\n        const hashval = this.hash(key);\n        let bucket = hashval & hashmod;\n\n        for (let probe = 0; probe <= hashmod; probe += 1) {\n            const item = table[bucket];\n\n            if (item === empty || this.equal(item, key)) {\n                return bucket;\n            }\n\n            bucket = (bucket + probe + 1) & hashmod; // Hash collision.\n        }\n\n        throw new Error('Hash table full.');\n    }\n\n    /**\n     * References:\n     * - https://github.com/mikolalysenko/murmurhash-js/blob/f19136e9f9c17f8cddc216ca3d44ec7c5c502f60/murmurhash2_gc.js#L14\n     * - https://github.com/zeux/meshoptimizer/blob/e47e1be6d3d9513153188216455bdbed40a206ef/src/indexgenerator.cpp#L12\n     */\n    murmurHash2(): number {\n        const m = 0x5bd1e995;\n        const r = 24;\n        let h = 0;\n\n        for (let k of this.u32) {\n            k = Math.imul(k, m) >>> 0;\n            k = (k ^ (k >> r)) >>> 0;\n            k = Math.imul(k, m) >>> 0;\n\n            h = Math.imul(h, m) >>> 0;\n            h = (h ^ k) >>> 0;\n        }\n\n        return h;\n    }\n}\n\nfunction ceilPowerOfTwo(value: number): number {\n    return 2 ** Math.ceil(Math.log(value) / Math.LN2);\n}\n\n/**\n * Weld and merge, combining vertices that are bitwise-equal.\n *\n * Adapted from gltf-transform's _weldPrimitiveStrict:\n * github.com/donmccurdy/glTF-Transform/blob/main/packages/functions/src/weld.ts#L193\n */\nexport default function weld(prim: Record<string, AttributeWrapper>) {\n    const srcVertexCount = prim.POSITION.count;\n    const hash = new HashTable(prim);\n    const tableSize = ceilPowerOfTwo(srcVertexCount + (srcVertexCount / 4));\n    const is16Bit = srcVertexCount < (2 ** 16 - 1);\n    const empty = 2 ** (is16Bit ? 16 : 32) - 1;\n    const indexFormat: GPUIndexFormat = is16Bit ? 'uint16' : 'uint32';\n    const writeMap = is16Bit ? new Uint16Array(srcVertexCount) : new Uint32Array(srcVertexCount);\n    const table = is16Bit ? new Uint16Array(tableSize) : new Uint32Array(tableSize);\n    table.fill(empty);\n\n    let dstVertexCount = 0;\n\n    for (let i = 0; i < srcVertexCount; i += 1) {\n        const hashIndex = hash.hashLookup(table, tableSize, i, empty);\n        const dstIndex = table[hashIndex];\n\n        if (dstIndex === empty) {\n            table[hashIndex] = i;\n            writeMap[i] = dstVertexCount;\n            dstVertexCount += 1;\n        } else {\n            writeMap[i] = writeMap[dstIndex];\n        }\n    }\n\n    for (const attribute of Object.values(prim)) {\n        attribute.remap(writeMap, dstVertexCount);\n    }\n\n    // The gltf-transform version checks for degenerate triangles to remove.\n    // This is omitted here.\n    return { indexArray: writeMap, indexFormat, vertexCount: dstVertexCount };\n}\n","import { mat3, mat4, Mat3, Mat4 } from 'wgpu-matrix';\n\nimport { TypeSizes } from '../constants';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\nimport { PipelineFeatureFlags } from './pipeline-feature-flags';\nimport DescriptorMap from './descriptor-map';\n\nexport type PrimitiveDescriptor = {\n    name?: string,\n    // vertexBufferLayouts: GPUVertexBufferLayout;\n    features: PipelineFeatureFlags,\n    vertexCount: number,\n    vertexArray: ArrayBuffer | TypedArray | GPUBuffer,\n    indexArray?: ArrayBuffer | TypedArray,\n    indexFormat?: GPUIndexFormat,\n};\n\nexport type IndexData = {\n    indexBuffer: GPUBuffer,\n    indexCount: number,\n    indexFormat: GPUIndexFormat,\n};\n\nexport class PrimitiveDrawData {\n    name: string;\n    vertexBuffer: GPUBuffer;\n    indexData?: IndexData;\n    instanceBuffer: GPUBuffer;\n    instanceBindGroup: GPUBindGroup;\n    vertexCount: number;\n    features: number;\n\n    instanceSize: number;\n\n    instances: ArrayBuffer;\n    modelMatrices: Mat4[];\n    normalMatrices!: Mat3[];\n    max: number;\n\n    instanceCount: number = 0;\n    dirty: boolean = false;\n\n    constructor(\n        primitive: PrimitiveDescriptor,\n        device: GPUDevice,\n        max: number,\n        descriptorMap: DescriptorMap,\n        instances?: Mat4[],\n    ) {\n        this.max = max;\n        this.features = primitive.features;\n        this.name = primitive.name ?? 'mesh';\n        this.vertexCount = primitive.vertexCount;\n\n        if (primitive.vertexArray instanceof GPUBuffer) {\n            this.vertexBuffer = primitive.vertexArray;\n        } else {\n            this.vertexBuffer = createAndCopyBuffer(\n                primitive.vertexArray,\n                GPUBufferUsage.VERTEX,\n                device,\n                `${this.name} vertex buffer`,\n            );\n        }\n\n        if (primitive.indexArray && primitive.indexFormat) {\n            const { indexArray, indexFormat } = primitive;\n            this.indexData = {\n                indexFormat,\n                indexCount: indexArray.byteLength / (indexFormat === 'uint16' ? 2 : 4),\n                indexBuffer: createAndCopyBuffer(\n                    primitive.indexArray,\n                    GPUBufferUsage.INDEX,\n                    device,\n                    `${this.name} index buffer`,\n                ),\n            };\n        }\n\n        this.instanceSize = TypeSizes.sizeofMat4x4f;\n        if (this.features & PipelineFeatureFlags.VertexNormals) {\n            this.instanceSize += 12 * 4;\n        }\n\n        this.instances = new ArrayBuffer(max * this.instanceSize);\n        this.modelMatrices = new Array(max) as Float32Array[];\n\n        for (let i = 0; i < max; i += 1) {\n            const offset = i * this.instanceSize;\n            this.modelMatrices[i] = new Float32Array(this.instances, offset, 16);\n        }\n\n        if (this.features & PipelineFeatureFlags.VertexNormals) {\n            this.normalMatrices = new Array(max) as Float32Array[];\n\n            for (let i = 0; i < max; i += 1) {\n                const offset = (i * this.instanceSize) + TypeSizes.sizeofMat4x4f;\n                this.normalMatrices[i] = new Float32Array(this.instances, offset, 12);\n            }\n        }\n\n        this.instanceBuffer = device.createBuffer({\n            label: `${this.name} instance buffer`,\n            size: this.instances.byteLength,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        });\n\n        this.instanceBindGroup = device.createBindGroup({\n            label: `PrimitiveDrawData instance bind group`,\n            layout: descriptorMap.forwardBindgroupLayout,\n            entries: [{\n                binding: 0,\n                resource: { buffer: this.instanceBuffer },\n            }],\n        });\n\n        if (instances) {\n            for (const instance of instances) {\n                this.addInstance(instance);\n            }\n        }\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        if (this.dirty) {\n            queue.writeBuffer(this.instanceBuffer, 0, this.instances);\n            this.dirty = false;\n        }\n\n        passEncoder.setVertexBuffer(0, this.vertexBuffer);\n        passEncoder.setBindGroup(2, this.instanceBindGroup);\n\n        if (this.indexData != null) {\n            const { indexBuffer, indexCount, indexFormat } = this.indexData;\n            passEncoder.setIndexBuffer(indexBuffer, indexFormat);\n            passEncoder.drawIndexed(indexCount, this.instanceCount);\n        } else {\n            passEncoder.draw(this.vertexCount, this.instanceCount);\n        }\n    }\n\n    addInstance(transform: Mat4) {\n        if (this.instanceCount === this.max) return;\n        mat4.copy(transform, this.modelMatrices[this.instanceCount]);\n        this.calculateNormalMatrix(this.instanceCount);\n        this.instanceCount += 1;\n        this.dirty = true;\n    }\n\n    calculateNormalMatrix(idx: number) {\n        if (!(this.features & PipelineFeatureFlags.VertexNormals)) return;\n        const normalMatrix = this.normalMatrices[idx];\n        mat3.fromMat4(this.modelMatrices[idx], normalMatrix);\n        mat3.invert(normalMatrix, normalMatrix);\n        mat3.transpose(normalMatrix, normalMatrix);\n    }\n}\n","import { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\n\nexport type AccessorComponentType = 5120 | 5121 | 5122 | 5123 | 5125 | 5126;\n\nexport type AccessorType = 'SCALAR' | 'VEC2' | 'VEC3' | 'VEC4' | 'MAT2' | 'MAT3' | 'MAT4';\n\nexport type AttributeDetails = {\n    name: string,\n    type: AccessorType,\n    componentType: AccessorComponentType,\n    strip?: boolean,\n    depends?: string[],\n    feature?: PipelineFeatureFlags,\n    fill?: number[],\n};\n\nexport const enum ComponentType {\n    int8 = 5120,\n    uint8 = 5121,\n    int16 = 5122,\n    uint16 = 5123,\n    uint32 = 5125,\n    float32 = 5126,\n}\n\nexport const typeToElementCount: Record<AccessorType, number> = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 12,\n    MAT4: 16,\n};\n\nexport const componentToSize: Record<ComponentType, number> = {\n    [ComponentType.int8]: 1,\n    [ComponentType.uint8]: 1,\n    [ComponentType.int16]: 2,\n    [ComponentType.uint16]: 2,\n    [ComponentType.uint32]: 4,\n    [ComponentType.float32]: 4,\n};\n\nexport const enum TopologyMode {\n    Points = 0,\n    LineList = 1,\n    LineLoop = 2,\n    LineStrip = 3,\n    TriangleList = 4,\n    TriangleStrip = 5,\n    TriangleFan = 6,\n}\n\nexport const modeToTopology: Partial<Record<TopologyMode, PipelineFeatureFlags>> = {\n    [TopologyMode.Points]: PipelineFeatureFlags.PointList, // POINTS\n    [TopologyMode.LineList]: PipelineFeatureFlags.LineList, // LINES\n    // 2: LINE_LOOP (unsupported by webgpu)\n    // 3: PipelineFeatureFlags.LineStrip, // LINE_STRIP\n    [TopologyMode.TriangleList]: PipelineFeatureFlags.TriangleList, // TRIANGLES\n    // 5: PipelineFeatureFlags.TriangleStrip, // TRIANGLE_STRIP\n    // 6: TRIANGLE_FAN (unsupported by webgpu)\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\nimport { GLTFAccessorPostprocessed } from '@loaders.gl/gltf';\nimport { ComponentType } from './type-conversions';\n\nexport default class AttributeWrapper {\n    data: TypedArray;\n    processed: boolean;\n    componentsPerElement: number;\n    bytesPerComponent: number;\n    count: number;\n\n    copyFrom: (srcIdx: number, dstIdx: number, dst: Float32Array) => void;\n\n    at?: (i: number, j: number) => number;\n    view?: DataView;\n\n    unwelded = false;\n\n    constructor(accessor: GLTFAccessorPostprocessed);\n    constructor(array: Float32Array, componentCount: number);\n\n    constructor(accessor: GLTFAccessorPostprocessed | Float32Array, componentCount?: number) {\n        if (accessor instanceof Float32Array) {\n            this.data = accessor;\n            this.componentsPerElement = componentCount!;\n            this.count = accessor.length / componentCount!;\n            this.processed = true;\n            this.bytesPerComponent = 4;\n            this.copyFrom = this.copyProcessed.bind(this);\n        } else {\n            this.data = accessor.value;\n            this.componentsPerElement = accessor.components;\n            this.count = accessor.count;\n            this.bytesPerComponent = accessor.bytesPerComponent;\n            this.processed = false;\n            this.view = new DataView(this.data.buffer);\n            this.copyFrom = this.copyUnprocessed.bind(this);\n\n            switch (accessor.componentType as ComponentType) {\n                case ComponentType.int8: {\n                    this.at = (i, j) => this.view!.getInt8(i * this.componentsPerElement + j);\n                    break;\n                }\n                case ComponentType.uint8: {\n                    this.at = (i, j) => this.view!.getUint8(i * this.componentsPerElement + j);\n                    break;\n                }\n                case ComponentType.int16: {\n                    this.at = (i, j) => {\n                        const offset = 2 * (i * this.componentsPerElement + j);\n                        return this.view!.getInt16(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.uint16: {\n                    this.at = (i, j) => {\n                        const offset = 2 * (i * this.componentsPerElement + j);\n                        return this.view!.getUint16(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.uint32: {\n                    this.at = (i, j) => {\n                        const offset = 4 * (i * this.componentsPerElement + j);\n                        return this.view!.getUint32(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.float32: {\n                    this.at = (i, j) => {\n                        const offset = 4 * (i * this.componentsPerElement + j);\n                        return this.view!.getFloat32(offset, true);\n                    };\n                    break;\n                }\n                default: throw new Error(`gltf importer -- invalid componentType ${accessor.componentType}`);\n            }\n\n            if (accessor.normalized) {\n                let val: number;\n                switch (accessor.componentType as ComponentType) {\n                    case ComponentType.uint8: val = 255; break;\n                    case ComponentType.int8: val = 127; break;\n                    case ComponentType.uint16: val = 65535; break;\n                    case ComponentType.int16: val = 32767; break;\n                    case ComponentType.uint32: val = 4294967295; break;\n                    default: throw new Error(`gltf importer -- invalid componentType ${accessor.componentType}`);\n                }\n\n                this.at = (i, j) => this.at!(i, j) / val;\n            }\n        }\n    }\n\n    get array(): Float32Array {\n        if (!this.processed) this.process();\n        return this.data as Float32Array;\n    }\n\n    copyProcessed(srcIdx: number, dstIdx: number, dst: Float32Array) {\n        for (let j = 0; j < this.componentsPerElement; j += 1) {\n            dst[dstIdx + j] = this.data[(srcIdx * this.componentsPerElement) + j];\n        }\n    }\n\n    copyUnprocessed(srcIdx: number, dstIdx: number, dst: Float32Array) {\n        for (let j = 0; j < this.componentsPerElement; j += 1) {\n            dst[dstIdx + j] = this.at!(srcIdx, j);\n        }\n    }\n\n    markProcessed() {\n        this.processed = true;\n        this.copyFrom = this.copyProcessed.bind(this);\n        delete this.view;\n        delete this.at;\n    }\n\n    process() {\n        if (this.processed) return;\n        const newView = new Float32Array(this.count * this.componentsPerElement);\n\n        for (let i = 0; i < this.count; i += 1) {\n            this.copyFrom(i, i * this.componentsPerElement, newView);\n        }\n\n        this.data = newView;\n        this.markProcessed();\n    }\n\n    unweld(indexArray: TypedArray): void {\n        if (this.unwelded) return;\n        this.unwelded = true;\n        const newView = new Float32Array(indexArray.length * this.componentsPerElement);\n\n        for (let i = 0; i < indexArray.length; i += 1) {\n            this.copyFrom(indexArray[i], i * this.componentsPerElement, newView);\n        }\n\n        this.count = indexArray.length;\n        this.data = newView;\n        this.markProcessed();\n    }\n\n    remap(remap: TypedArray, dstCount: number): void {\n        const dstArray = new Float32Array(dstCount * this.componentsPerElement);\n        const done = new Uint8Array(dstCount);\n\n        for (let srcIndex = 0; srcIndex < this.count; srcIndex += 1) {\n            const dstIndex = remap[srcIndex];\n            if (done[dstIndex]) continue;\n            this.copyFrom(srcIndex, dstIndex * this.componentsPerElement, dstArray);\n            done[dstIndex] = 1;\n        }\n\n        this.data = dstArray;\n        this.markProcessed();\n    }\n}\n","import { Mat4, mat4 } from 'wgpu-matrix';\nimport { GLTFAccessorPostprocessed, GLTFMaterialPostprocessed, GLTFMeshPrimitivePostprocessed } from '@loaders.gl/gltf';\n\nimport weld from './weld';\nimport { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\nimport { PrimitiveDrawData } from '../../../core/default-forward-pass/primitive-draw-data';\nimport { AttributeDetails, TopologyMode, modeToTopology } from './type-conversions';\nimport DescriptorMap from '../../../core/default-forward-pass/descriptor-map';\nimport AttributeWrapper from './attribute-wrapper';\nimport interleaveVertices from './interleave-vertices';\nimport { mapValues } from '../../../../utils/general';\n\nexport type NamedAttribute = 'POSITION' | 'NORMAL' | 'TANGENT';\nexport type NumberedAttribute = 'TEXCOORD' | 'COLOR' | 'JOINTS' | 'WEIGHTS';\nexport type PrimitiveAttributeKey = NamedAttribute | `${NumberedAttribute}_${number}` | `_${string}`;\n\nconst generateTangentsAsync = import('mikktspace').then((module) => module.generateTangents);\n\nfunction wrapIndices(indices: GLTFAccessorPostprocessed) {\n    switch (indices.bytesPerComponent) {\n        case 2: return {\n            indexArray: new Uint16Array(indices.value.buffer),\n            indexFormat: 'uint16' as GPUIndexFormat,\n        };\n        case 4: return {\n            indexArray: new Uint32Array(indices.value.buffer),\n            indexFormat: 'uint32' as GPUIndexFormat,\n        };\n        case 1:\n        default: return {\n            indexArray: new Uint16Array(indices.value),\n            indexFormat: 'uint16' as GPUIndexFormat,\n        };\n    }\n}\n\nfunction reindex(indices: GLTFAccessorPostprocessed, originalMode?: number) {\n    switch (originalMode) {\n        case TopologyMode.LineLoop:\n        case TopologyMode.LineStrip:\n        case TopologyMode.TriangleFan:\n        case TopologyMode.TriangleStrip: {\n            // TODO: convert non-list topologies into lists.\n            throw new Error('Topology currently unsupported');\n        }\n        default: return { ...wrapIndices(indices), mode: TopologyMode.TriangleList };\n    }\n}\n\n/**\n * Checks the determinant of each given matrix and returns a culling mode such that\n * a primitive will render correctly for all nodes containing it, using 'none'\n * for primitive which are rendered both inverted and normally.\n *\n * @param instanceMatrices the instance matrices to render the primitive with\n * @returns The cull mode to use on the primitive.\n *\n * @remarks\n * The glFT spec determines the winding direction of a model by the\n * determinant of the transform of the node which uses it, allowing\n * inversion through negative scale. Changing cullMode instead\n * more easily integrates with instanced rendering, although comes\n * at a performance cost.\n */\nfunction getCullMode(instanceMatrices: Mat4[]) {\n    let overallSign: number | undefined;\n\n    for (let i = 0; i < instanceMatrices.length; i += 1) {\n        const det = mat4.determinant(instanceMatrices[i]);\n        const sign = Math.sign(det);\n        overallSign ??= sign;\n\n        if (sign !== overallSign) return PipelineFeatureFlags.DoubleSided;\n    }\n\n    return (overallSign == null || overallSign > 0)\n        ? PipelineFeatureFlags.Defaults\n        : PipelineFeatureFlags.ClockwiseWinding;\n}\n\nexport default async function loadPrimitive(\n    layout: AttributeDetails[],\n    primitive: GLTFMeshPrimitivePostprocessed,\n    instances: Mat4[],\n    descriptorMap: DescriptorMap,\n    device: GPUDevice,\n): Promise<{ drawData?: PrimitiveDrawData, material?: GLTFMaterialPostprocessed }> {\n    const attributes = primitive.attributes as Partial<Record<PrimitiveAttributeKey, GLTFAccessorPostprocessed>>;\n    if (attributes.POSITION == null) return {};\n\n    const { indices } = primitive;\n    const atrs = mapValues(attributes, (atr) => new AttributeWrapper(atr as GLTFAccessorPostprocessed));\n    let { mode } = primitive;\n    let vertexCount = attributes.POSITION.count;\n    let indexArray: TypedArray | undefined;\n    let indexFormat: GPUIndexFormat | undefined;\n\n    if (indices != null) {\n        ({ indexArray, indexFormat } = wrapIndices(indices));\n\n        if (\n            mode !== TopologyMode.Points\n            && mode !== TopologyMode.LineList\n            && mode !== TopologyMode.TriangleList\n        ) {\n            ({ indexArray, indexFormat, mode } = reindex(indices, mode));\n        }\n    }\n\n    if (atrs.NORMAL != null && atrs.TANGENT == null) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (atrs.TEXCOORD_0 != null) {\n            if (indexArray != null) {\n                vertexCount = indexArray.length;\n                for (const atr of Object.values(atrs)) {\n                    atr.unweld(indexArray);\n                }\n            }\n\n            const start = Date.now();\n\n            const tangent = await generateTangentsAsync.then((func) => func(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                atrs.POSITION!.array,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                atrs.NORMAL!.array,\n                atrs.TEXCOORD_0.array,\n            ));\n\n            for (let i = 3; i < tangent.length; i += 4) {\n                tangent[i] *= -1;\n            }\n            console.log(`tangents generated in ${Date.now() - start}`);\n\n            atrs.TANGENT = new AttributeWrapper(tangent, 4);\n\n            ({ indexArray, indexFormat, vertexCount } = weld(atrs));\n            mode = TopologyMode.TriangleList;\n        } else {\n            const tangent = new Float32Array(vertexCount * 4);\n            for (let i = 0; i < vertexCount; i += 1) {\n                tangent.set([1, 0, 0, 1], i * 4);\n            }\n            atrs.TANGENT = new AttributeWrapper(tangent, 4);\n        }\n    }\n\n    const { vertexArray, vertexFeatures } = interleaveVertices(atrs, vertexCount);\n    let features = getCullMode(instances) | vertexFeatures;\n    if (mode != null) features |= modeToTopology[mode as TopologyMode] || 0;\n\n    const drawData = new PrimitiveDrawData({\n        features,\n        indexArray,\n        indexFormat,\n        vertexCount,\n        vertexArray,\n    }, device, instances.length, descriptorMap, instances);\n\n    return { material: primitive.material, drawData };\n}\n","import AttributeWrapper from './attribute-wrapper';\nimport { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\n\n// const goalLayout: AttributeDetails[] = [\n//     {\n//         name: 'POSITION',\n//         type: 'VEC3',\n//         componentType: ComponentType.float32,\n//     },\n//     {\n//         name: 'TEXCOORD_0',\n//         type: 'VEC2',\n//         componentType: ComponentType.float32,\n//     },\n//     {\n//         name: 'TANGENT',\n//         type: 'VEC4',\n//         componentType: ComponentType.float32,\n//         depends: ['NORMAL'],\n//         fill: [1, 0, 0, 1],\n//     },\n//     {\n//         name: 'NORMAL',\n//         type: 'VEC3',\n//         componentType: ComponentType.float32,\n//         strip: true,\n//         feature: PipelineFeatureFlags.VertexNormals,\n//     },\n//     {\n//         name: 'COLOR_0',\n//         type: 'VEC4',\n//         componentType: ComponentType.float32,\n//         strip: true,\n//         feature: PipelineFeatureFlags.VertexColors,\n//         fill: [1, 1, 1, 1],\n//     },\n// ];\n\nexport default function interleaveVertices(\n    attributes: Partial<Record<string, AttributeWrapper>>,\n    count: number,\n) {\n    let vertexFeatures: PipelineFeatureFlags = PipelineFeatureFlags.Defaults;\n    let stride = 5;\n    if (attributes.NORMAL != null) stride += 7;\n    if (attributes.COLOR_0 != null) stride += 4;\n\n    const vertexArray = new ArrayBuffer(stride * count * 4);\n    const vertexView = new Float32Array(vertexArray);\n\n    for (let i = 0; i < count; i += 1) {\n        attributes.POSITION?.copyFrom(i, stride * i, vertexView);\n    }\n\n    const uv = attributes.TEXCOORD_0 ?? new AttributeWrapper(new Float32Array(count * 2), 2);\n    for (let i = 0; i < count; i += 1) {\n        uv.copyFrom(i, i * stride + 3, vertexView);\n    }\n\n    if (attributes.NORMAL != null && attributes.TANGENT != null) {\n        vertexFeatures |= PipelineFeatureFlags.VertexNormals;\n\n        for (let i = 0; i < count; i += 1) {\n            attributes.TANGENT.copyFrom(i, i * stride + 5, vertexView);\n        }\n\n        for (let i = 0; i < count; i += 1) {\n            attributes.NORMAL.copyFrom(i, i * stride + 9, vertexView);\n        }\n    }\n\n    if (attributes.COLOR_0 != null) {\n        vertexFeatures |= PipelineFeatureFlags.VertexColors;\n        const step = attributes.NORMAL != null ? 12 : 5;\n        for (let i = 0; i < count; i += 1) {\n            attributes.COLOR_0.copyFrom(i, i * stride + step, vertexView);\n            vertexView[i * stride + step + 3] = 1;\n        }\n    }\n\n    return { vertexArray, vertexFeatures };\n}\n","import { GLTFMaterialPostprocessed, GLTFSampler, GLTFTexturePostprocessed } from '@loaders.gl/gltf';\n\nimport { vec3 } from 'wgpu-matrix';\nimport { MaterialDescriptor } from '../../../core/default-forward-pass/material-draw-data';\nimport { imageToTexture } from '../../../utils/texture-importing';\n\nconst DEFAULT_METALLIC = 0.0;\nconst DEFAULT_ROUGHNESS = 1.0;\n\nconst gltfToMagDescription: Record<number, GPUFilterMode> = {\n    9728: 'nearest',\n    9729: 'linear',\n    9984: 'nearest', // NEAREST_MIPMAP_NEAREST\n    9985: 'linear', // LINEAR_MIPMAP_NEAREST\n    9986: 'nearest', // NEAREST_MIPMAP_LINEAR\n    9987: 'linear', // LINEAR_MIPMAP_LINEAR\n};\n\nconst gltfToMipDescription: Partial<Record<number, GPUFilterMode>> = {\n    9984: 'nearest', // NEAREST_MIPMAP_NEAREST\n    9985: 'nearest', // LINEAR_MIPMAP_NEAREST\n    9986: 'linear', // NEAREST_MIPMAP_LINEAR\n    9987: 'linear', // LINEAR_MIPMAP_LINEAR\n};\n\nconst gltfToAddressMode: Record<number, GPUAddressMode> = {\n    33071: 'clamp-to-edge', // CLAMP_TO_EDGE\n    33648: 'mirror-repeat', // MIRRORED_REPEAT\n    10497: 'repeat', // REPEAT\n};\n\nfunction toSamplerDescription(sampler: GLTFSampler): GPUSamplerDescriptor {\n    const { magFilter, minFilter, wrapS, wrapT } = sampler;\n\n    return {\n        addressModeU: gltfToAddressMode[wrapS ?? 10497],\n        addressModeV: gltfToAddressMode[wrapT ?? 10497],\n        minFilter: gltfToMagDescription[minFilter ?? 9987],\n        magFilter: gltfToMagDescription[magFilter ?? 9729],\n        mipmapFilter: gltfToMipDescription[minFilter ?? 9987] ?? 'linear',\n    };\n}\n\nfunction getImageData(handle: GLTFTexturePostprocessed) {\n    const { source, sampler } = handle;\n    if (source == null) return {};\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const data = source.image.data ?? source.bufferView?.data;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (data == null) return {};\n\n    return { data, mimeType: source.mimeType, sampler };\n}\n\nexport default async function loadMaterial(\n    material: GLTFMaterialPostprocessed,\n    defaultMaterial: MaterialDescriptor,\n    device: GPUDevice,\n): Promise<MaterialDescriptor> {\n    const mat: Partial<MaterialDescriptor> = {};\n    if (material.pbrMetallicRoughness != null) {\n        const {\n            baseColorFactor,\n            baseColorTexture,\n            metallicFactor,\n            metallicRoughnessTexture,\n            roughnessFactor,\n        } = material.pbrMetallicRoughness;\n\n        if (metallicRoughnessTexture?.texture.source == null) {\n            if (metallicFactor == null) mat.metallicFactor = DEFAULT_METALLIC;\n            if (roughnessFactor == null) mat.roughnessFactor = DEFAULT_ROUGHNESS;\n        } else {\n            const { data, mimeType, sampler } = getImageData(metallicRoughnessTexture.texture);\n            if (data != null) {\n                mat.metallicRoughnessTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                });\n                if (sampler) mat.metallicRoughnessSampler = toSamplerDescription(sampler);\n            }\n        }\n\n        if (baseColorTexture?.texture.source != null) {\n            const { data, mimeType, sampler } = getImageData(baseColorTexture.texture);\n            if (data != null) {\n                mat.baseColorTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                    srgbToLinear: true,\n                });\n                if (sampler) mat.baseColorSampler = toSamplerDescription(sampler);\n            }\n        }\n\n        if (baseColorFactor != null) mat.baseColorFactor = baseColorFactor;\n        if (metallicFactor != null) mat.metallicFactor = metallicFactor;\n        if (roughnessFactor != null) mat.metallicFactor = roughnessFactor;\n    } else {\n        mat.metallicFactor = DEFAULT_METALLIC;\n        mat.roughnessFactor = DEFAULT_ROUGHNESS;\n    }\n\n    if (material.normalTexture?.texture.source != null) {\n        const { data, mimeType, sampler } = getImageData(material.normalTexture.texture);\n\n        if (data != null) {\n            mat.normalTexture = await imageToTexture({\n                label: `${material.id} mr texture`,\n                data,\n                mimeType,\n                usage: GPUTextureUsage.TEXTURE_BINDING,\n                device,\n            });\n            if (sampler) mat.normalSampler = toSamplerDescription(sampler);\n        }\n    }\n\n    const { emissiveFactor, emissiveTexture } = material;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    const emissiveStrength = material.extensions?.KHR_materials_emissive_strength?.emissiveStrength;\n\n    if (emissiveTexture != null || emissiveFactor?.some((x) => x > 0)) {\n        mat.emissiveFactor = emissiveFactor ?? [1, 1, 1];\n        mat.emissiveSampler = { magFilter: 'linear', minFilter: 'linear' };\n\n        if (emissiveTexture?.texture.source != null) {\n            const { data, mimeType, sampler } = getImageData(emissiveTexture.texture);\n            if (data != null) {\n                mat.emissiveTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                    srgbToLinear: true,\n                });\n                if (sampler) mat.emissiveSampler = toSamplerDescription(sampler);\n            }\n        } else {\n            mat.emissiveTexture = defaultMaterial.baseColorTexture;\n        }\n\n        if (emissiveStrength != null && typeof emissiveStrength === 'number') {\n            vec3.scale(mat.emissiveFactor, emissiveStrength, mat.emissiveFactor);\n        }\n    }\n\n    if (material.doubleSided) mat.doubleSided = true;\n    if (material.alphaMode === 'MASK') mat.alphaCutoff = material.alphaCutoff ?? 0.5;\n\n    return { ...defaultMaterial, ...mat };\n}\n","import { Vec3n, Vec4n } from 'wgpu-matrix';\nimport DescriptorMap from './descriptor-map';\nimport { featureFlagsToString, PipelineFeatureFlags } from './pipeline-feature-flags';\nimport { PrimitiveDrawData } from './primitive-draw-data';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\n\nexport type MaterialDescriptor = {\n    name?: string,\n\n    baseColorFactor: Vec4n,\n    baseColorTexture: GPUTexture,\n    baseColorSampler: GPUSamplerDescriptor,\n\n    roughnessFactor: number,\n    metallicFactor: number,\n    metallicRoughnessTexture: GPUTexture,\n    metallicRoughnessSampler: GPUSamplerDescriptor,\n\n    normalTexture: GPUTexture,\n    normalSampler: GPUSamplerDescriptor,\n\n    alphaCutoff?: number,\n\n    emissiveFactor?: Vec3n,\n    emissiveTexture?: GPUTexture,\n    emissiveSampler?: GPUSamplerDescriptor,\n\n    doubleSided?: boolean,\n};\n\nexport class MaterialDrawData {\n    layout: GPUBindGroupLayout;\n    primitives: PrimitiveDrawData[] = [];\n    matData: MaterialDescriptor;\n    bindGroup: GPUBindGroup;\n    propertiesBuffer: GPUBuffer;\n    features: PipelineFeatureFlags;\n\n    constructor(\n        data: MaterialDescriptor,\n        device: GPUDevice,\n        descriptorMap: DescriptorMap,\n        primitiveFeatures: PipelineFeatureFlags,\n        primitives?: PrimitiveDrawData[],\n    ) {\n        this.features = primitiveFeatures;\n        if (data.doubleSided) this.features |= PipelineFeatureFlags.DoubleSided;\n\n        // TODO : don't hardcode the properties features\n        const properties = new Float32Array(12);\n        properties.set(data.baseColorFactor);\n        properties[4] = data.metallicFactor;\n        properties[5] = data.roughnessFactor;\n\n        if (data.alphaCutoff != null) {\n            this.features |= PipelineFeatureFlags.AlphaCutoff;\n            properties[6] = data.alphaCutoff;\n        }\n\n        if (data.emissiveFactor != null) {\n            properties.set(data.emissiveFactor, 8);\n        }\n\n        this.propertiesBuffer = createAndCopyBuffer(\n            properties,\n            GPUBufferUsage.UNIFORM,\n            device,\n        );\n\n        const entries = [\n            { binding: 0, resource: { buffer: this.propertiesBuffer } },\n            { binding: 1, resource: descriptorMap.getSampler(data.baseColorSampler) },\n            { binding: 2, resource: data.baseColorTexture.createView({ dimension: '2d' }) },\n            { binding: 3, resource: descriptorMap.getSampler(data.normalSampler) },\n            { binding: 4, resource: data.normalTexture.createView({ dimension: '2d' }) },\n            { binding: 5, resource: descriptorMap.getSampler(data.metallicRoughnessSampler) },\n            { binding: 6, resource: data.metallicRoughnessTexture.createView({ dimension: '2d' }) },\n        ];\n\n        if (data.emissiveTexture != null) {\n            this.features |= PipelineFeatureFlags.Emissive;\n\n            entries.push({\n                binding: 7,\n                resource: descriptorMap.getSampler(data.emissiveSampler ?? {}),\n            });\n\n            entries.push({\n                binding: 8,\n                resource: data.emissiveTexture.createView({ dimension: '2d' }),\n            });\n        }\n\n        this.layout = descriptorMap.getMaterialBindGroup(this.features);\n        this.matData = data;\n        this.bindGroup = device.createBindGroup({\n            label: featureFlagsToString(this.features),\n            layout: this.layout,\n            entries,\n        });\n\n        if (primitives != null) {\n            this.addPrimitives(...primitives);\n        }\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        if (this.primitives.length === 0) return;\n\n        passEncoder.setBindGroup(1, this.bindGroup);\n        for (const primitive of this.primitives) {\n            primitive.draw(passEncoder, queue);\n        }\n    }\n\n    addPrimitives(...drawData: PrimitiveDrawData[]) {\n        const filtered = drawData.filter((data) => {\n            if ((data.features & this.features) === data.features) return true;\n            console.warn(`invalid primitive added to material: \nprimitive: ${data.name}\nprimitive features: ${featureFlagsToString(data.features).toString()}\nmaterial: ${this.matData.name}\nmaterial features: ${featureFlagsToString(this.features).toString()}`);\n            return false;\n        });\n        this.primitives.push(...filtered);\n    }\n}\n","import DescriptorMap from './descriptor-map';\nimport { MaterialDrawData } from './material-draw-data';\nimport { PipelineFeatureFlags, featureFlagsToString, maskRedundantFeatures } from './pipeline-feature-flags';\n\nexport default class GeometryPipeline {\n    features: PipelineFeatureFlags;\n    pipeline: GPURenderPipeline;\n\n    materials: MaterialDrawData[] = [];\n\n    constructor(features: PipelineFeatureFlags, maps: DescriptorMap) {\n        this.features = maskRedundantFeatures(features);\n\n        const module = maps.getShaderModule(features);\n\n        this.pipeline = maps.device.createRenderPipeline({\n            label: featureFlagsToString(features),\n            layout: maps.getForwardPipelineLayout(features),\n            primitive: maps.getPrimitiveState(features),\n            vertex: {\n                entryPoint: 'vs',\n                buffers: [maps.getVertexLayout(features)],\n                module,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                module,\n                targets: maps.gbuffer.targets,\n            },\n            depthStencil: {\n                depthWriteEnabled: true,\n                depthCompare: 'less-equal',\n                format: maps.gbuffer.depth.format,\n            },\n        });\n    }\n\n    addMaterials(...materials: MaterialDrawData[]) {\n        if (materials.some((data) => data.features !== this.features)) {\n            throw new Error('invalid primitive added to material');\n        }\n        this.materials.push(...materials);\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        passEncoder.setPipeline(this.pipeline);\n        for (const mat of this.materials) {\n            mat.draw(passEncoder, queue);\n        }\n    }\n}\n","import { Mat4, mat4, Mat4Arg, Mat4Type, quat } from 'wgpu-matrix';\nimport { DataType, load } from '@loaders.gl/core';\nimport { GLTFLoader, GLTFMeshPostprocessed, GLTFNodePostprocessed, postProcessGLTF } from '@loaders.gl/gltf';\n\nimport { ComponentType, AttributeDetails } from './type-conversions';\nimport loadPrimitive from './primitive-loader';\nimport loadMaterial from './material-loader';\n\nimport { MaterialDescriptor, MaterialDrawData } from '../../../core/default-forward-pass/material-draw-data';\nimport { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\nimport { PrimitiveDrawData } from '../../../core/default-forward-pass/primitive-draw-data';\nimport DescriptorMap from '../../../core/default-forward-pass/descriptor-map';\nimport GeometryPipeline from '../../../core/default-forward-pass/geometry-pipeline';\n\nconst defaultLayout: AttributeDetails[] = [\n    {\n        name: 'POSITION',\n        type: 'VEC3',\n        componentType: ComponentType.float32,\n    },\n    {\n        name: 'TEXCOORD_0',\n        type: 'VEC2',\n        componentType: ComponentType.float32,\n    },\n    {\n        name: 'TANGENT',\n        type: 'VEC4',\n        componentType: ComponentType.float32,\n        depends: ['NORMAL'],\n        fill: [1, 0, 0, 1],\n    },\n    {\n        name: 'NORMAL',\n        type: 'VEC3',\n        componentType: ComponentType.float32,\n        strip: true,\n        feature: PipelineFeatureFlags.VertexNormals,\n    },\n    {\n        name: 'COLOR_0',\n        type: 'VEC4',\n        componentType: ComponentType.float32,\n        strip: true,\n        feature: PipelineFeatureFlags.VertexColors,\n        fill: [1, 1, 1, 1],\n    },\n];\n\nconst recurseNode = (\n    parentMatrix: Mat4Type<Mat4Arg>,\n    meshes: Map<GLTFMeshPostprocessed, Mat4Type<Mat4Arg>[]>,\n) => (node: GLTFNodePostprocessed) => {\n    const matrix = node.matrix ?? mat4.identity();\n\n    if (node.matrix == null) {\n        if (node.scale) mat4.scaling(node.scale, matrix);\n\n        if (node.rotation) {\n            const { axis, angle } = quat.toAxisAngle(node.rotation);\n            mat4.rotate(matrix, axis, angle, matrix);\n        }\n\n        if (node.translation != null) {\n            mat4.setTranslation(matrix, node.translation, matrix);\n        }\n    }\n\n    mat4.mul(parentMatrix, matrix, matrix);\n\n    if (node.mesh != null) {\n        if (!meshes.has(node.mesh)) meshes.set(node.mesh, []);\n        meshes.get(node.mesh)!.push(matrix); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    }\n\n    node.children?.forEach(recurseNode(matrix, meshes));\n};\n\nexport default async function importGltf(\n    url: string | DataType,\n    device: GPUDevice,\n    descriptorMap: DescriptorMap,\n    defaultMaterial: MaterialDescriptor,\n    layout: AttributeDetails[] = defaultLayout,\n    pipelines: Partial<Record<number, GeometryPipeline>> = {},\n    // eslint-disable-next-line no-console\n    log: ((msg: unknown) => void) = console.log,\n) {\n    log('starting import');\n\n    const start = Date.now();\n    const gltfWithBuffers = await load(url, GLTFLoader);\n    log(`finished loading: ${Date.now() - start}`);\n\n    const { scene } = postProcessGLTF(gltfWithBuffers);\n    if (scene?.nodes == null) return pipelines;\n    log(`finished processing: ${Date.now() - start}`);\n\n    const meshes = new Map<GLTFMeshPostprocessed, Mat4[]>();\n    scene.nodes.forEach(recurseNode(mat4.identity(), meshes));\n    log(`finished creating instances: ${Date.now() - start}`);\n\n    const meshEntries = Array.from(meshes.entries());\n    const primitivePromises = meshEntries.flatMap(([{ primitives }, instances]) =>\n        primitives.map((prim) => loadPrimitive(\n            layout,\n            prim,\n            instances,\n            descriptorMap,\n            device,\n        )),\n    );\n\n    const primitiveDescriptors = await Promise.all(primitivePromises);\n    log(`finished creating primitives: ${Date.now() - start}`);\n\n    type MaterialKey = { materialId?: string, features: number };\n    const materialMap = new Map<MaterialKey, PrimitiveDrawData[]>();\n    const materialPromises: Record<string, Promise<MaterialDescriptor>> = {};\n\n    for (const { material, drawData } of primitiveDescriptors) {\n        if (drawData == null) continue;\n\n        const key = { materialId: material?.id, features: drawData.features };\n        if (!materialMap.has(key)) materialMap.set(key, []);\n        materialMap.get(key)!.push(drawData); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n\n        if (material != null) {\n            materialPromises[material.id] = loadMaterial(material, defaultMaterial, device);\n        }\n    }\n\n    const materialEntries = Object.entries(materialPromises)\n        .map(async ([id, mat]) => [id, await mat]);\n\n    const materialDescriptors = Object.fromEntries(await Promise.all(materialEntries)) as Record<string, MaterialDescriptor>;\n    log(`finished creating material descriptors: ${Date.now() - start}`);\n\n    const fullDefaultMat: MaterialDescriptor = { ...defaultMaterial, metallicFactor: 0 };\n\n    for (const [{ features, materialId }, drawDatas] of materialMap.entries()) {\n        const descriptor = materialId != null ? materialDescriptors[materialId] : fullDefaultMat;\n        const mat = new MaterialDrawData(descriptor, device, descriptorMap, features, drawDatas);\n        const { features: f } = mat;\n\n        pipelines[f] ??= new GeometryPipeline(f, descriptorMap);\n        pipelines[f].addMaterials(mat);\n    }\n\n    log(`finished: ${Date.now() - start}`);\n    return pipelines;\n}\n","import * as ktxparse from 'ktx-parse';\r\n\r\nimport { TextureFormatToSize, TextureFormatToChannelSize, WebGPUToVkFormat } from '../core/constants';\r\nimport { mapRange, padTemplate } from '../../utils/general';\r\n\r\nexport function createAndCopyBuffer(\r\n    arr: ArrayBuffer | ArrayBufferView,\r\n    usage: GPUFlagsConstant,\r\n    device: GPUDevice,\r\n    label?: string,\r\n    alignment = 4,\r\n): GPUBuffer {\r\n    const pad = alignment - 1;\r\n    const buffer = device.createBuffer({\r\n        label,\r\n        usage,\r\n        size: (arr.byteLength + pad) & ~pad,\r\n        mappedAtCreation: true,\r\n    } as GPUBufferDescriptor);\r\n\r\n    const writeArray = new Uint8Array(buffer.getMappedRange());\r\n    const readArray = arr instanceof ArrayBuffer\r\n        ? new Uint8Array(arr)\r\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n\r\n    writeArray.set(readArray);\r\n    buffer.unmap();\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function createAndCopyCubemap(\r\n    device: GPUDevice,\r\n    data: ArrayBuffer,\r\n    format: GPUTextureFormat,\r\n    usage: number,\r\n    label?: string,\r\n) {\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\r\n    }\r\n\r\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\r\n    const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n    const texture = device.createTexture({\r\n        usage: usage | GPUTextureUsage.COPY_DST,\r\n        label,\r\n        format,\r\n        size,\r\n    });\r\n\r\n    device.queue.writeTexture(\r\n        { texture },\r\n        data,\r\n        { bytesPerRow: width * pixelSize, rowsPerImage: width },\r\n        size,\r\n    );\r\n\r\n    return texture;\r\n}\r\n\r\nexport type TextureToArrayBufferOptions = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    mipLevel?: number,\r\n    resultBuffer?: Uint8Array,\r\n    storageBuffer?: GPUBuffer,\r\n    returnBuffer?: boolean,\r\n    description?: string,\r\n};\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer?: false },\r\n): Promise<{ imageData: Uint8Array }>;\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer: true },\r\n): Promise<{ imageData: Uint8Array, storageBuffer: GPUBuffer }>;\r\n\r\nexport async function textureToArrayBuffer({\r\n    device,\r\n    texture,\r\n    mipLevel = 0,\r\n    returnBuffer,\r\n    storageBuffer,\r\n    resultBuffer,\r\n    description,\r\n}: TextureToArrayBufferOptions) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const fullDescription = padTemplate`[textureToKTX${description ?? ''}${texture.label}] --`;\r\n\r\n    if (pixelSize == null) {\r\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\r\n    }\r\n\r\n    const width = texture.width >> mipLevel;\r\n    const height = texture.height >> mipLevel;\r\n    const rawBytesPerRow = width * pixelSize;\r\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n    const rowsPerImage = height;\r\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\r\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\r\n\r\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\r\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\r\n    }\r\n\r\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\r\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\r\n    }\r\n\r\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\r\n\r\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\r\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\r\n    }\r\n\r\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\r\n    const storage = storageBuffer ?? device.createBuffer({\r\n        label: `${fullDescription} storage buffer`,\r\n        size: byteSize,\r\n        usage: requiredUsage,\r\n    });\r\n\r\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\r\n    encoder.copyTextureToBuffer(\r\n        { texture, mipLevel },\r\n        { buffer: storage, rowsPerImage, bytesPerRow },\r\n        { width, height, depthOrArrayLayers: texture.depthOrArrayLayers },\r\n    );\r\n    device.queue.submit([encoder.finish()]);\r\n\r\n    await Promise.all([\r\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\r\n        device.queue.onSubmittedWorkDone(),\r\n    ]);\r\n\r\n    const mapped = storage.getMappedRange(0, byteSize);\r\n    imageData.set(new Uint8Array(mapped));\r\n    storage.unmap();\r\n\r\n    if (bytesPerRow > rawBytesPerRow) {\r\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\r\n            }\r\n        }\r\n        imageData = imageData.slice(0, resultSize);\r\n    }\r\n\r\n    return {\r\n        imageData,\r\n        storageBuffer: returnBuffer ? storage : undefined,\r\n    };\r\n}\r\n\r\nexport async function textureToKTX(device: GPUDevice, texture: GPUTexture, cube = false) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const typeSize = TextureFormatToChannelSize[texture.format];\r\n\r\n    if (pixelSize == null || typeSize == null) {\r\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\r\n    }\r\n\r\n    const container = new ktxparse.KTX2Container();\r\n    container.pixelWidth = texture.width;\r\n    container.pixelHeight = texture.height;\r\n    container.vkFormat = WebGPUToVkFormat[texture.format];\r\n    container.typeSize = typeSize;\r\n    delete container.keyValue.KTXswizzle;\r\n\r\n    const dataFormat = container.dataFormatDescriptor[0];\r\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\r\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\r\n    dataFormat.bytesPlane[0] = pixelSize;\r\n\r\n    dataFormat.samples = mapRange(4, (i) => ({\r\n        channelType: [192, 193, 194, 207][i],\r\n        samplePosition: [0, 0, 0, 0],\r\n        bitLength: container.typeSize * 8 - 1,\r\n        bitOffset: container.typeSize * 8 * i,\r\n        sampleLower: -1082130432,\r\n        sampleUpper: 1065353216,\r\n    }));\r\n\r\n    if (texture.dimension === '3d') {\r\n        container.faceCount = 1;\r\n        container.pixelDepth = texture.depthOrArrayLayers;\r\n    } else if (cube) {\r\n        const cubeLayers = texture.depthOrArrayLayers / 6;\r\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\r\n        container.faceCount = 6;\r\n    } else {\r\n        container.layerCount = texture.depthOrArrayLayers;\r\n        container.faceCount = 1;\r\n    }\r\n\r\n    let storageBuffer: GPUBuffer | undefined;\r\n    let imageData: Uint8Array;\r\n\r\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\r\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\r\n            mipLevel: i,\r\n            returnBuffer: true,\r\n            device,\r\n            texture,\r\n            storageBuffer,\r\n        }));\r\n\r\n        container.levels.push({\r\n            levelData: imageData,\r\n            uncompressedByteLength: imageData.byteLength,\r\n        });\r\n    }\r\n\r\n    return ktxparse.write(container);\r\n}\r\n","import { toFloat16Bytes } from './data-conversion';\nimport { srgbTextureToLinear, generateMips } from './texture-processing';\n\nexport type imageToTextureDescriptor = {\n    device: GPUDevice,\n    data: Uint8Array | Blob | File | ImageBitmap,\n    mimeType?: string,\n    label?: string,\n    usage?: number,\n    format?: GPUTextureFormat,\n    mips?: boolean,\n    srgbToLinear?: boolean,\n    colorSpace?: PredefinedColorSpace,\n};\n\nexport async function imageToTexture({\n    device,\n    data,\n    mimeType,\n    usage = GPUTextureUsage.TEXTURE_BINDING,\n    mips = true,\n    format = 'rgba8unorm',\n    colorSpace = 'srgb',\n    label = '',\n    srgbToLinear,\n}: imageToTextureDescriptor) {\n    let bitmap: ImageBitmap;\n\n    if (data instanceof ImageBitmap) {\n        bitmap = data;\n    } else {\n        const blob = (data instanceof Blob || data instanceof File)\n            ? data\n            : new Blob([data], { type: mimeType });\n        bitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n    }\n\n    const size = { width: bitmap.width, height: bitmap.height };\n\n    const texture = device.createTexture({\n        label,\n        format,\n        size: size,\n        usage: usage | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: mips ? 1 + (Math.log2(Math.max(bitmap.width, bitmap.height)) | 0) : 1,\n    });\n\n    device.queue.copyExternalImageToTexture(\n        { source: bitmap },\n        { texture, colorSpace },\n        size,\n    );\n\n    if (srgbToLinear) srgbTextureToLinear(device, texture);\n    if (mips) void generateMips(device, texture);\n\n    return texture;\n}\n\nexport function parseHDR(inData: Uint8Array | ArrayBuffer) {\n    const decoder = new TextDecoder();\n    const buffer = inData instanceof Uint8Array ? inData : new Uint8Array(inData);\n    let pos = 0;\n\n    const getLine = (lineLimit = 1024) => {\n        const limit = Math.min(buffer.length, lineLimit + pos);\n        const sub = buffer.subarray(pos, limit);\n        const end = sub.indexOf(0x0A) + 1;\n        pos += end;\n        return end === 0 ? undefined : decoder.decode(sub.subarray(0, end));\n    };\n\n    const importError = (msg: string) => new Error('HDR Import Error: ' + msg);\n\n    // #region Read Header\n    const magicTokenRegex = /^#\\?(\\S+)/;\n    const magicTokenLine = getLine();\n\n    if (magicTokenLine == null) throw importError('no header found');\n    if (!magicTokenRegex.test(magicTokenLine)) throw importError('bad initial token');\n\n    const headerRegs = [\n        /FORMAT=(?<format>\\S+)/, // format\n        /-Y\\s+(?<Y>\\d+)\\s+\\+X\\s+(?<X>\\d+)/, // size\n        /EXPOSURE\\s*=\\s*(?<exposure>\\d+(\\.\\d+)?)/, // exposure\n        /GAMMA\\s*=\\s*(?<gamma>\\d+(\\.\\d+)?)/, // gamma\n    ];\n\n    const headerReg = new RegExp(`^\\\\s*(${\n        headerRegs.map(({ source }) => `(${source})`).join('|')\n    })\\\\s*$`);\n\n    let noFormat = true;\n    let gamma = 1; /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n    let exposure = 1; /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n    let width: number | undefined = undefined;\n    let height: number | undefined = undefined;\n\n    for (let line = getLine(); line != null; line = width == null ? getLine() : undefined) {\n        const groups = line.match(headerReg)?.groups as Partial<Record<string, string>> | undefined;\n        if (groups == null) continue;\n\n        if (groups.format != null) {\n            noFormat = false;\n        } else if (groups.X != null && groups.Y != null) {\n            width = parseInt(groups.X);\n            height = parseInt(groups.Y);\n        } else if (groups.gamma != null) {\n            gamma = parseFloat(groups.gamma);\n        } else if (groups.exposure != null) {\n            exposure = parseFloat(groups.exposure);\n        }\n    }\n\n    if (noFormat) throw importError('missing format specifier');\n    if (width == null || height == null) throw importError('missing image size specifier');\n    // #endregion\n\n    // #region Read Scanline Data\n    let rawData: Uint8Array;\n    const unencodable = width < 8 || width > 0x7fff;\n    const flatData = buffer[pos] !== 2 || buffer[pos + 1] !== 2 || (buffer[pos + 2] & 0x80) !== 0;\n\n    if (unencodable || flatData) {\n        rawData = buffer.subarray(pos);\n    } else {\n        rawData = new Uint8Array(width * height * 4);\n        const end = 4 * width;\n        const scanline_buffer = new Uint8Array(end);\n        const len = buffer.byteLength;\n\n        for (let k = 0, offset = 0; k < height && pos < len; k++) {\n            if (pos + 4 > len)\n                throw importError('file ended durning scanline');\n\n            if ((2 != buffer[pos++]) || (2 != buffer[pos++]) || (((buffer[pos++] << 8) | buffer[pos++]) != width))\n                throw importError('bad rgbe scanline format');\n\n            let count;\n            for (let ptr = 0; ptr < end && pos < len; ptr += count) {\n                count = buffer[pos++];\n                const isEncodedRun = count > 128;\n                if (isEncodedRun) count -= 128;\n\n                if (count == 0 || ptr + count > end)\n                    throw importError('bad scanline data');\n\n                if (isEncodedRun) {\n                    scanline_buffer.fill(buffer[pos], ptr, ptr + count);\n                    pos += 1;\n                } else {\n                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                    pos += count;\n                }\n            }\n\n            for (let i = 0; i < width; i++)\n                for (let j = 0; j < end; j += width)\n                    rawData[offset++] = scanline_buffer[i + j];\n        }\n    }\n    // #endregion\n\n    // #region Convert to Float16\n    const data = new Uint16Array(rawData.length);\n    const float16One = toFloat16Bytes(1);\n\n    for (let i = 0; i < width * height * 4; i += 4) {\n        const raw_e = rawData[i + 3];\n        const scale = Math.pow(2.0, raw_e - 128.0) / 255.0;\n\n        for (let j = 0; j < 3; j += 1) {\n            data[i + j] = toFloat16Bytes(Math.min(rawData[i + j] * scale, 65504));\n        }\n        data[i + 3] = float16One;\n    }\n    // #endregion\n\n    return { data, width, height, gamma, exposure };\n}\n","import blit from '../shaders/blit-vert.shader';\nimport { toWorldDir } from '../shaders/cubemap-sampling.shader';\nimport { createAndCopyBuffer } from './data-copy';\nimport { padTemplate } from '../../utils/general';\n\ntype EquirectangularDescriptor = {\n    data: SharedArrayBuffer | BufferSource | GPUTexture,\n    width: number,\n    height: number,\n    gamma?: number,\n    exposure?: number,\n};\n\nexport async function equirectangularToCubemap(\n    device: GPUDevice,\n    { data, width, height, gamma = 1, exposure = 1 }: EquirectangularDescriptor,\n    outputDescriptor: Omit<GPUTextureDescriptor, 'dimension' | 'size'>,\n) {\n    const code = /* wgsl */ `\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${blit}\n        ${toWorldDir}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;\n\n    let FLIP_Y = 0;\n    let equirectangular: GPUTexture;\n    if (data instanceof GPUTexture) {\n        equirectangular = data;\n    } else {\n        FLIP_Y = 1;\n        equirectangular = device.createTexture({\n            label: `${outputDescriptor.label} equirectangular`,\n            dimension: '2d',\n            format: 'rgba16float',\n            size: { width, height },\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        device.queue.writeTexture(\n            { texture: equirectangular, mipLevel: 0 },\n            data,\n            { bytesPerRow: width * 2 * 4 },\n            { width, height, depthOrArrayLayers: 1 },\n        );\n        await device.queue.onSubmittedWorkDone();\n    }\n\n    const faceSize = equirectangular.height >> 1;\n    const cubemapDescriptor = outputDescriptor as GPUTextureDescriptor;\n    cubemapDescriptor.mipLevelCount ??= Math.log2(faceSize) | 0;\n    cubemapDescriptor.size = { width: faceSize, height: faceSize, depthOrArrayLayers: 6 };\n    cubemapDescriptor.dimension = '2d';\n    cubemapDescriptor.usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    const cubemap = device.createTexture(cubemapDescriptor);\n\n    const label = padTemplate`hdr copy${outputDescriptor.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 2,\n                buffer: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const module = device.createShaderModule({ label, code });\n    const sampler = device.createSampler({ label, minFilter: 'linear', magFilter: 'linear' });\n    const params = new Uint32Array(1);\n    const paramBuffer = createAndCopyBuffer(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device, label);\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            { binding: 0, resource: equirectangular.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: paramBuffer } },\n        ],\n    });\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: { module },\n        fragment: {\n            module,\n            targets: [{ format: cubemap.format }],\n            constants: {\n                GAMMA: gamma,\n                EXPOSURE: exposure,\n                FLIP_Y,\n            },\n        },\n    });\n\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n\n        const view = cubemap.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n            mipLevelCount: 1,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [{\n                view,\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n\n    return cubemap;\n}\nexport async function generateMips(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${blit}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `;\n\n    const label = padTemplate`mip generation${texture.label}`;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d', sampleType: 'float' },\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const colorAttachment = {\n        view: undefined as GPUTextureView | undefined,\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: 0 });\n    await device.queue.onSubmittedWorkDone();\n\n    for (let i = 1; i < texture.mipLevelCount; i += 1) {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: colorAttachment.view,\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n\n        colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: i });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [colorAttachment as GPURenderPassColorAttachment],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n\n        device.queue.submit([encoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport function srgbTextureToLinear(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${blit}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `;\n\n    const label = padTemplate`srgb to linear${texture.label}`;\n\n    const size = { width: texture.width, height: texture.height };\n\n    const tempTexture = device.createTexture({\n        format: texture.format,\n        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        size,\n    });\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n\n    const module = device.createShaderModule({ label, code: code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: tempTexture.createView(),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n        ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n        { texture },\n        { texture: tempTexture },\n        size,\n    );\n\n    const pass = encoder.beginRenderPass({\n        label,\n        colorAttachments: [{\n            view: texture.createView({ mipLevelCount: 1, baseMipLevel: 0 }),\n            loadOp: 'clear',\n            storeOp: 'store',\n        }],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindgroup);\n    pass.draw(3);\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n}\n","export type UnknownObject = Record<PropertyKey, unknown>;\r\n\r\nexport function mapValues<Input, ObjectType extends Partial<Record<keyof ObjectType, Input>>, Output>(\r\n    obj: ObjectType,\r\n    fn: (val: Input) => Output,\r\n) {\r\n    const entries = Object.entries(obj) as [keyof ObjectType, Input][];\r\n    const mapped = entries.map(([key, val]) => [key, fn(val)]);\r\n    return Object.fromEntries(mapped) as { [K in keyof ObjectType]: Output };\r\n}\r\n\r\nexport function clamp(num: number, min: number, max: number) {\r\n    return Math.max(min, Math.min(max, num));\r\n}\r\n\r\nexport function padCheck(str: string | undefined) {\r\n    return str == null || str === '' ? '' : ` ${str}`;\r\n}\r\n\r\nexport function padTemplate(strings: TemplateStringsArray, ...values: (string | undefined)[]) {\r\n    const result = [strings[0]];\r\n    values.forEach((key, i) => result.push(padCheck(key), strings[i + 1]));\r\n    return result.join('');\r\n}\r\n\r\nexport function range(n: number) {\r\n    return [...Array(n).keys()];\r\n}\r\n\r\nexport function mapRange<T>(n: number, fn: (i: number) => T) {\r\n    return range(n).map(fn);\r\n}\r\n\r\nexport function debounce<Args extends Array<unknown>>(callback: (...args: Args) => unknown, delay: number) {\r\n    let tid: ReturnType<typeof setTimeout> | undefined;\r\n    return function (...args: Args) {\r\n        const ctx = self;\r\n        if (tid != null) clearTimeout(tid);\r\n        tid = setTimeout(() => { callback.apply(ctx, args); }, delay);\r\n    };\r\n};\r\n\r\n// adapted from https://stackoverflow.com/a/60702475/17108769\r\nexport function binaryInsert<T>(\r\n    arr: T[],\r\n    element: T,\r\n    comparator: (a: T, b: T) => number,\r\n    left = 0,\r\n    right = arr.length - 1,\r\n) {\r\n    if (right - left <= 1) {\r\n        if (comparator(element, arr[left] ?? element) < 0) arr.splice(left, 0, element);\r\n        else if (comparator(element, arr[right] ?? element) > 0) arr.splice(right + 1, 0, element);\r\n        else arr.splice(right, 0, element);\r\n    } else {\r\n        const pivot = Math.floor((right - left) / 2) + left;\r\n        if (comparator(element, arr[pivot]) < 0) binaryInsert(arr, element, comparator, left, pivot);\r\n        else binaryInsert(arr, element, comparator, pivot, right);\r\n    }\r\n}\r\n\r\nexport function isObject(val: unknown): val is NonNullable<UnknownObject> {\r\n    return typeof val === 'object' && val != null;\r\n}\r\n"],"names":["Camera","constructor","viewParams","buffer","ArrayBuffer","bufferLength","worldToView","Float32Array","this","worldToViewOffset","mat4x4Count","viewToClip","viewToClipOffset","worldToClip","worldToClipOffset","viewToWorld","viewToWorldOffset","clipToView","clipToViewOffset","clipToWorld","clipToWorldOffset","location","rotation","params","nearPlane","farPlane","fov","width","height","projection","updateParams","val","cacheView","fromQuat","setTranslation","invert","mul","perspective","Math","PI","x","y","ortho","sizeofMat4x4f","TypeSizes","BYTES_PER_ELEMENT","VkFormatToWebGPU","Object","fromEntries","entries","map","vk","wgpu","parseInt","resolveBranch","branch","PreprocessorStatement","cond","else","res","toString","elif","Symbol","toStringTag","wrapWithIncrement","fn","start","include","flags","ifdef","sym","ifndef","preprocessors","vertexInLocation","idx","varyingsLocation","materialBinding","varyings","VertexNormals","VertexColors","code","AlphaCutoff","Emissive","DoubleSided","DescriptorMap","device","gbuffer","globals","pipelineLayouts","primitiveStates","vertexLayouts","shaderModules","bindgroupLayouts","samplers","forwardBindgroupLayout","createBindGroupLayout","label","binding","visibility","GPUShaderStage","VERTEX","FRAGMENT","type","getSampler","descriptor","key","JSON","stringify","createSampler","getVertexLayout","masked","attributes","shaderLocation","offset","format","arrayStride","push","stepMode","getForwardPipelineLayout","createPipelineLayout","bindGroupLayouts","bindGroupLayout","getMaterialBindGroup","getShaderModule","createShaderModule","getPrimitiveState","topology","flagToTopology","cullMode","frontFace","ClockwiseWinding","pushItem","item","length","sampler","texture","viewDimension","TriangleList","TriangleStrip","PointList","LineList","LineStrip","PipelineFeatureFlags","TopologyFormatMask","PrimitiveStateMask","CodeMask","InstanceBufferLayoutMask","VertexBufferLayoutMask","MaterialBindgroupLayoutMask","PipelineLayoutMask","featureFlagsToString","flatMap","flag","featureFlagsToNames","maskRedundantFeatures","GlobalUniforms","deviceBuffer","createBuffer","bufferDescriptor","layoutDescriptor","bindGroupDescriptor","layout","resource","size","bufferSize","bindgroup","createBindGroup","updateDeviceBuffer","queue","camera","writeBuffer","group","minBindingSize","usage","GPUBufferUsage","UNIFORM","COPY_DST","gltfIndex","getGltfIndex","async","indexRes","fetch","indexStr","text","indexJson","parse","Array","isArray","Error","gltf","name","variants","glTF","file","GltfModel","depthTextureView","descriptorMap","depth","view","renderer","geometryPipelines","skybox","model","$type","$callback","File","setModel","accept","selection","value","initialValues","process","settings","publicSettings","priority","addForwardPass","setSkybox","inPlace","delayWork","requestAnimationFrame","modelPath","colorArray","opaqueWhite","createTexture","GPUTextureUsage","TEXTURE_BINDING","writeTexture","normalMap","set","addressModeU","addressModeV","magFilter","minFilter","mipmapFilter","matData","baseColorTexture","baseColorFactor","normalTexture","metallicRoughnessTexture","metallicFactor","roughnessFactor","baseColorSampler","normalSampler","metallicRoughnessSampler","goalLayout","render","encoder","pass","beginRenderPass","passDescriptor","setBindGroup","pipeline","values","draw","end","componentType","depends","fill","strip","feature","HashTable","prim","byteStride","attribute","initAttribute","paddedByteStride","u8","Uint8Array","u32","Uint32Array","data","bytesPerComponent","componentsPerElement","hash","index","byteOffset","i","murmurHash2","equal","a","b","j","hashLookup","table","buckets","empty","hashmod","bucket","probe","m","h","k","imul","weld","srcVertexCount","POSITION","count","tableSize","ceil","log","LN2","is16Bit","indexFormat","writeMap","Uint16Array","dstVertexCount","hashIndex","dstIndex","remap","indexArray","vertexCount","PrimitiveDrawData","primitive","max","instances","instanceCount","dirty","features","vertexArray","GPUBuffer","vertexBuffer","indexData","indexCount","byteLength","indexBuffer","INDEX","instanceSize","modelMatrices","normalMatrices","instanceBuffer","STORAGE","instanceBindGroup","instance","addInstance","passEncoder","setVertexBuffer","setIndexBuffer","drawIndexed","transform","copy","calculateNormalMatrix","normalMatrix","fromMat4","transpose","modeToTopology","AttributeWrapper","accessor","componentCount","unwelded","processed","copyFrom","copyProcessed","bind","components","DataView","copyUnprocessed","at","getInt8","getUint8","getInt16","getUint16","getUint32","getFloat32","normalized","array","srcIdx","dstIdx","dst","markProcessed","newView","unweld","dstCount","dstArray","done","srcIndex","generateTangentsAsync","then","module","generateTangents","wrapIndices","indices","loadPrimitive","atrs","atr","mode","originalMode","reindex","NORMAL","TANGENT","TEXCOORD_0","Date","now","tangent","func","console","vertexFeatures","Defaults","stride","COLOR_0","vertexView","uv","step","interleaveVertices","instanceMatrices","overallSign","det","determinant","sign","getCullMode","drawData","material","DEFAULT_METALLIC","DEFAULT_ROUGHNESS","gltfToMagDescription","gltfToMipDescription","gltfToAddressMode","toSamplerDescription","wrapS","wrapT","getImageData","handle","source","image","bufferView","mimeType","loadMaterial","defaultMaterial","mat","pbrMetallicRoughness","id","srgbToLinear","emissiveFactor","emissiveTexture","emissiveStrength","extensions","KHR_materials_emissive_strength","some","emissiveSampler","scale","doubleSided","alphaMode","alphaCutoff","MaterialDrawData","primitiveFeatures","primitives","properties","propertiesBuffer","createView","dimension","bindGroup","addPrimitives","filtered","filter","warn","GeometryPipeline","maps","materials","createRenderPipeline","vertex","entryPoint","buffers","fragment","targets","depthStencil","depthWriteEnabled","depthCompare","addMaterials","setPipeline","defaultLayout","recurseNode","parentMatrix","meshes","node","matrix","identity","scaling","axis","angle","toAxisAngle","rotate","translation","mesh","has","get","children","forEach","importGltf","url","pipelines","gltfWithBuffers","load","scene","nodes","Map","primitivePromises","from","primitiveDescriptors","Promise","all","materialMap","materialPromises","materialId","materialEntries","materialDescriptors","fullDefaultMat","drawDatas","f","createAndCopyBuffer","arr","alignment","pad","mappedAtCreation","writeArray","getMappedRange","readArray","unmap","imageToTexture","mips","colorSpace","bitmap","ImageBitmap","blob","Blob","createImageBitmap","colorSpaceConversion","COPY_SRC","RENDER_ATTACHMENT","mipLevelCount","log2","copyExternalImageToTexture","parseHDR","inData","decoder","TextDecoder","pos","getLine","lineLimit","limit","min","sub","subarray","indexOf","undefined","decode","importError","msg","magicTokenLine","test","headerReg","RegExp","join","rawData","noFormat","gamma","exposure","line","groups","match","X","Y","parseFloat","unencodable","flatData","scanline_buffer","len","ptr","isEncodedRun","float16One","raw_e","pow","equirectangularToCubemap","outputDescriptor","equirectangular","FLIP_Y","GPUTexture","mipLevel","bytesPerRow","depthOrArrayLayers","onSubmittedWorkDone","faceSize","cubemapDescriptor","cubemap","bindgroupLayout","paramBuffer","pipelineLayout","constants","GAMMA","EXPOSURE","arrayLayerCount","baseArrayLayer","createCommandEncoder","colorAttachments","loadOp","storeOp","submit","finish","generateMips","sampleType","colorAttachment","baseMipLevel","srgbTextureToLinear","tempTexture","copyTextureToTexture","mapValues","obj","mapped","clamp","num","padTemplate","strings","result","str","mapRange","n","keys","range","debounce","callback","delay","tid","args","ctx","self","clearTimeout","setTimeout","apply","binaryInsert","element","comparator","left","right","splice","pivot","floor","isObject"],"sourceRoot":""}