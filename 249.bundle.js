"use strict";(self.webpackChunkwebgpu_basic=self.webpackChunkwebgpu_basic||[]).push([[249],{249:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileHandle: () => (/* binding */ FileHandle)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(275);\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);\n\n\n\nconst {\n  WritableStream,\n  TransformStream,\n  DOMException,\n  Blob\n} = _config_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A\n\nconst { GONE } = _util_js__WEBPACK_IMPORTED_MODULE_0__.errors\n// @ts-ignore - Don't match newer versions of Safari, but that's okay\nconst isOldSafari = /constructor/i.test(window.HTMLElement)\n\nclass FileHandle {\n  constructor (name = 'unkown') {\n    this.name = name\n    this.kind = 'file'\n  }\n\n  async getFile () {\n    throw new DOMException(...GONE)\n  }\n\n  async isSameEntry(other) {\n    return this === other\n  }\n\n  /**\n   * @param {object} [options={}]\n   */\n  async createWritable (options = {}) {\n    const sw = await navigator.serviceWorker?.getRegistration()\n    const link = document.createElement('a')\n    const ts = new TransformStream()\n    const sink = ts.writable\n\n    link.download = this.name\n\n    if (isOldSafari || !sw) {\n      /** @type {Blob[]} */\n      let chunks = []\n      ts.readable.pipeTo(new WritableStream({\n        write (chunk) {\n          chunks.push(new Blob([chunk]))\n        },\n        close () {\n          const blob = new Blob(chunks, { type: 'application/octet-stream; charset=utf-8' })\n          chunks = []\n          link.href = URL.createObjectURL(blob)\n          link.click()\n          setTimeout(() => URL.revokeObjectURL(link.href), 10000)\n        }\n      }))\n    } else {\n      const { writable, readablePort } = new RemoteWritableStream(WritableStream)\n      // Make filename RFC5987 compatible\n      const fileName = encodeURIComponent(this.name).replace(/['()]/g, escape).replace(/\\*/g, '%2A')\n      const headers = {\n        'content-disposition': \"attachment; filename*=UTF-8''\" + fileName,\n        'content-type': 'application/octet-stream; charset=utf-8',\n        ...(options.size ? { 'content-length': options.size } : {})\n      }\n\n      const keepAlive = setTimeout(() => sw.active.postMessage(0), 10000)\n\n      ts.readable.pipeThrough(new TransformStream({\n        transform (chunk, ctrl) {\n          if (chunk instanceof Uint8Array) return ctrl.enqueue(chunk)\n          const reader = new Response(chunk).body.getReader()\n          const pump = _ => reader.read().then(e => e.done ? 0 : pump(ctrl.enqueue(e.value)))\n          return pump()\n        }\n      })).pipeTo(writable).finally(() => {\n        clearInterval(keepAlive)\n      })\n\n      // Transfer the stream to service worker\n      sw.active.postMessage({\n        url: sw.scope + fileName,\n        headers,\n        readablePort\n      }, [readablePort])\n\n      // Trigger the download with a hidden iframe\n      const iframe = document.createElement('iframe')\n      iframe.hidden = true\n      iframe.src = sw.scope + fileName\n      document.body.appendChild(iframe)\n    }\n\n    return sink.getWriter()\n  }\n}\n\n// Want to remove this postMessage hack, tell them u want transferable streams:\n// https://bugs.webkit.org/show_bug.cgi?id=215485\n\nconst WRITE = 0\nconst PULL = 0\nconst ERROR = 1\nconst ABORT = 1\nconst CLOSE = 2\n\nclass MessagePortSink {\n  /** @param {MessagePort} port */\n  constructor (port) {\n    port.onmessage = event => this._onMessage(event.data)\n    this._port = port\n    this._resetReady()\n  }\n\n  start (controller) {\n    this._controller = controller\n    // Apply initial backpressure\n    return this._readyPromise\n  }\n\n  write (chunk) {\n    const message = { type: WRITE, chunk }\n\n    // Send chunk\n    this._port.postMessage(message, [chunk.buffer])\n\n    // Assume backpressure after every write, until sender pulls\n    this._resetReady()\n\n    // Apply backpressure\n    return this._readyPromise\n  }\n\n  close () {\n    this._port.postMessage({ type: CLOSE })\n    this._port.close()\n  }\n\n  abort (reason) {\n    this._port.postMessage({ type: ABORT, reason })\n    this._port.close()\n  }\n\n  _onMessage (message) {\n    if (message.type === PULL) this._resolveReady()\n    if (message.type === ERROR) this._onError(message.reason)\n  }\n\n  _onError (reason) {\n    this._controller.error(reason)\n    this._rejectReady(reason)\n    this._port.close()\n  }\n\n  _resetReady () {\n    this._readyPromise = new Promise((resolve, reject) => {\n      this._readyResolve = resolve\n      this._readyReject = reject\n    })\n    this._readyPending = true\n  }\n\n  _resolveReady () {\n    this._readyResolve()\n    this._readyPending = false\n  }\n\n  _rejectReady (reason) {\n    if (!this._readyPending) this._resetReady()\n    this._readyPromise.catch(() => {})\n    this._readyReject(reason)\n    this._readyPending = false\n  }\n}\n\nclass RemoteWritableStream {\n  constructor (WritableStream) {\n    const channel = new MessageChannel()\n    this.readablePort = channel.port1\n    this.writable = new WritableStream(\n      new MessagePortSink(channel.port2)\n    )\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1DO0FBQ0Y7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsMkRBQU07O0FBRVYsUUFBUSxPQUFPLEVBQUUsNENBQU07QUFDdkI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVEsV0FBVztBQUNoQztBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMENBQTBDLGlDQUFpQyxnQkFBZ0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLG1EQUFtRDtBQUNuRCw2QkFBNkIsaUNBQWlDLElBQUk7QUFDbEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViZ3B1LWJhc2ljLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25hdGl2ZS1maWxlLXN5c3RlbS1hZGFwdGVyQDMuMC4xL25vZGVfbW9kdWxlcy9uYXRpdmUtZmlsZS1zeXN0ZW0tYWRhcHRlci9zcmMvYWRhcHRlcnMvZG93bmxvYWRlci5qcz80NDdkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVycm9ycyB9IGZyb20gJy4uL3V0aWwuanMnXG5pbXBvcnQgY29uZmlnIGZyb20gJy4uL2NvbmZpZy5qcydcblxuY29uc3Qge1xuICBXcml0YWJsZVN0cmVhbSxcbiAgVHJhbnNmb3JtU3RyZWFtLFxuICBET01FeGNlcHRpb24sXG4gIEJsb2Jcbn0gPSBjb25maWdcblxuY29uc3QgeyBHT05FIH0gPSBlcnJvcnNcbi8vIEB0cy1pZ25vcmUgLSBEb24ndCBtYXRjaCBuZXdlciB2ZXJzaW9ucyBvZiBTYWZhcmksIGJ1dCB0aGF0J3Mgb2theVxuY29uc3QgaXNPbGRTYWZhcmkgPSAvY29uc3RydWN0b3IvaS50ZXN0KHdpbmRvdy5IVE1MRWxlbWVudClcblxuZXhwb3J0IGNsYXNzIEZpbGVIYW5kbGUge1xuICBjb25zdHJ1Y3RvciAobmFtZSA9ICd1bmtvd24nKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMua2luZCA9ICdmaWxlJ1xuICB9XG5cbiAgYXN5bmMgZ2V0RmlsZSAoKSB7XG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbiguLi5HT05FKVxuICB9XG5cbiAgYXN5bmMgaXNTYW1lRW50cnkob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dXG4gICAqL1xuICBhc3luYyBjcmVhdGVXcml0YWJsZSAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc3cgPSBhd2FpdCBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlcj8uZ2V0UmVnaXN0cmF0aW9uKClcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgY29uc3QgdHMgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKClcbiAgICBjb25zdCBzaW5rID0gdHMud3JpdGFibGVcblxuICAgIGxpbmsuZG93bmxvYWQgPSB0aGlzLm5hbWVcblxuICAgIGlmIChpc09sZFNhZmFyaSB8fCAhc3cpIHtcbiAgICAgIC8qKiBAdHlwZSB7QmxvYltdfSAqL1xuICAgICAgbGV0IGNodW5rcyA9IFtdXG4gICAgICB0cy5yZWFkYWJsZS5waXBlVG8obmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgd3JpdGUgKGNodW5rKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2gobmV3IEJsb2IoW2NodW5rXSkpXG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlICgpIHtcbiAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoY2h1bmtzLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07IGNoYXJzZXQ9dXRmLTgnIH0pXG4gICAgICAgICAgY2h1bmtzID0gW11cbiAgICAgICAgICBsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICAgICAgbGluay5jbGljaygpXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBVUkwucmV2b2tlT2JqZWN0VVJMKGxpbmsuaHJlZiksIDEwMDAwKVxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB3cml0YWJsZSwgcmVhZGFibGVQb3J0IH0gPSBuZXcgUmVtb3RlV3JpdGFibGVTdHJlYW0oV3JpdGFibGVTdHJlYW0pXG4gICAgICAvLyBNYWtlIGZpbGVuYW1lIFJGQzU5ODcgY29tcGF0aWJsZVxuICAgICAgY29uc3QgZmlsZU5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQodGhpcy5uYW1lKS5yZXBsYWNlKC9bJygpXS9nLCBlc2NhcGUpLnJlcGxhY2UoL1xcKi9nLCAnJTJBJylcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICdjb250ZW50LWRpc3Bvc2l0aW9uJzogXCJhdHRhY2htZW50OyBmaWxlbmFtZSo9VVRGLTgnJ1wiICsgZmlsZU5hbWUsXG4gICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtOyBjaGFyc2V0PXV0Zi04JyxcbiAgICAgICAgLi4uKG9wdGlvbnMuc2l6ZSA/IHsgJ2NvbnRlbnQtbGVuZ3RoJzogb3B0aW9ucy5zaXplIH0gOiB7fSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2VlcEFsaXZlID0gc2V0VGltZW91dCgoKSA9PiBzdy5hY3RpdmUucG9zdE1lc3NhZ2UoMCksIDEwMDAwKVxuXG4gICAgICB0cy5yZWFkYWJsZS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtIChjaHVuaywgY3RybCkge1xuICAgICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHJldHVybiBjdHJsLmVucXVldWUoY2h1bmspXG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IFJlc3BvbnNlKGNodW5rKS5ib2R5LmdldFJlYWRlcigpXG4gICAgICAgICAgY29uc3QgcHVtcCA9IF8gPT4gcmVhZGVyLnJlYWQoKS50aGVuKGUgPT4gZS5kb25lID8gMCA6IHB1bXAoY3RybC5lbnF1ZXVlKGUudmFsdWUpKSlcbiAgICAgICAgICByZXR1cm4gcHVtcCgpXG4gICAgICAgIH1cbiAgICAgIH0pKS5waXBlVG8od3JpdGFibGUpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBjbGVhckludGVydmFsKGtlZXBBbGl2ZSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIFRyYW5zZmVyIHRoZSBzdHJlYW0gdG8gc2VydmljZSB3b3JrZXJcbiAgICAgIHN3LmFjdGl2ZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHVybDogc3cuc2NvcGUgKyBmaWxlTmFtZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgcmVhZGFibGVQb3J0XG4gICAgICB9LCBbcmVhZGFibGVQb3J0XSlcblxuICAgICAgLy8gVHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGhpZGRlbiBpZnJhbWVcbiAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpXG4gICAgICBpZnJhbWUuaGlkZGVuID0gdHJ1ZVxuICAgICAgaWZyYW1lLnNyYyA9IHN3LnNjb3BlICsgZmlsZU5hbWVcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKVxuICAgIH1cblxuICAgIHJldHVybiBzaW5rLmdldFdyaXRlcigpXG4gIH1cbn1cblxuLy8gV2FudCB0byByZW1vdmUgdGhpcyBwb3N0TWVzc2FnZSBoYWNrLCB0ZWxsIHRoZW0gdSB3YW50IHRyYW5zZmVyYWJsZSBzdHJlYW1zOlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIxNTQ4NVxuXG5jb25zdCBXUklURSA9IDBcbmNvbnN0IFBVTEwgPSAwXG5jb25zdCBFUlJPUiA9IDFcbmNvbnN0IEFCT1JUID0gMVxuY29uc3QgQ0xPU0UgPSAyXG5cbmNsYXNzIE1lc3NhZ2VQb3J0U2luayB7XG4gIC8qKiBAcGFyYW0ge01lc3NhZ2VQb3J0fSBwb3J0ICovXG4gIGNvbnN0cnVjdG9yIChwb3J0KSB7XG4gICAgcG9ydC5vbm1lc3NhZ2UgPSBldmVudCA9PiB0aGlzLl9vbk1lc3NhZ2UoZXZlbnQuZGF0YSlcbiAgICB0aGlzLl9wb3J0ID0gcG9ydFxuICAgIHRoaXMuX3Jlc2V0UmVhZHkoKVxuICB9XG5cbiAgc3RhcnQgKGNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLl9jb250cm9sbGVyID0gY29udHJvbGxlclxuICAgIC8vIEFwcGx5IGluaXRpYWwgYmFja3ByZXNzdXJlXG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZVxuICB9XG5cbiAgd3JpdGUgKGNodW5rKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHsgdHlwZTogV1JJVEUsIGNodW5rIH1cblxuICAgIC8vIFNlbmQgY2h1bmtcbiAgICB0aGlzLl9wb3J0LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFtjaHVuay5idWZmZXJdKVxuXG4gICAgLy8gQXNzdW1lIGJhY2twcmVzc3VyZSBhZnRlciBldmVyeSB3cml0ZSwgdW50aWwgc2VuZGVyIHB1bGxzXG4gICAgdGhpcy5fcmVzZXRSZWFkeSgpXG5cbiAgICAvLyBBcHBseSBiYWNrcHJlc3N1cmVcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlQcm9taXNlXG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgdGhpcy5fcG9ydC5wb3N0TWVzc2FnZSh7IHR5cGU6IENMT1NFIH0pXG4gICAgdGhpcy5fcG9ydC5jbG9zZSgpXG4gIH1cblxuICBhYm9ydCAocmVhc29uKSB7XG4gICAgdGhpcy5fcG9ydC5wb3N0TWVzc2FnZSh7IHR5cGU6IEFCT1JULCByZWFzb24gfSlcbiAgICB0aGlzLl9wb3J0LmNsb3NlKClcbiAgfVxuXG4gIF9vbk1lc3NhZ2UgKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS50eXBlID09PSBQVUxMKSB0aGlzLl9yZXNvbHZlUmVhZHkoKVxuICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IEVSUk9SKSB0aGlzLl9vbkVycm9yKG1lc3NhZ2UucmVhc29uKVxuICB9XG5cbiAgX29uRXJyb3IgKHJlYXNvbikge1xuICAgIHRoaXMuX2NvbnRyb2xsZXIuZXJyb3IocmVhc29uKVxuICAgIHRoaXMuX3JlamVjdFJlYWR5KHJlYXNvbilcbiAgICB0aGlzLl9wb3J0LmNsb3NlKClcbiAgfVxuXG4gIF9yZXNldFJlYWR5ICgpIHtcbiAgICB0aGlzLl9yZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9yZWFkeVJlc29sdmUgPSByZXNvbHZlXG4gICAgICB0aGlzLl9yZWFkeVJlamVjdCA9IHJlamVjdFxuICAgIH0pXG4gICAgdGhpcy5fcmVhZHlQZW5kaW5nID0gdHJ1ZVxuICB9XG5cbiAgX3Jlc29sdmVSZWFkeSAoKSB7XG4gICAgdGhpcy5fcmVhZHlSZXNvbHZlKClcbiAgICB0aGlzLl9yZWFkeVBlbmRpbmcgPSBmYWxzZVxuICB9XG5cbiAgX3JlamVjdFJlYWR5IChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWR5UGVuZGluZykgdGhpcy5fcmVzZXRSZWFkeSgpXG4gICAgdGhpcy5fcmVhZHlQcm9taXNlLmNhdGNoKCgpID0+IHt9KVxuICAgIHRoaXMuX3JlYWR5UmVqZWN0KHJlYXNvbilcbiAgICB0aGlzLl9yZWFkeVBlbmRpbmcgPSBmYWxzZVxuICB9XG59XG5cbmNsYXNzIFJlbW90ZVdyaXRhYmxlU3RyZWFtIHtcbiAgY29uc3RydWN0b3IgKFdyaXRhYmxlU3RyZWFtKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpXG4gICAgdGhpcy5yZWFkYWJsZVBvcnQgPSBjaGFubmVsLnBvcnQxXG4gICAgdGhpcy53cml0YWJsZSA9IG5ldyBXcml0YWJsZVN0cmVhbShcbiAgICAgIG5ldyBNZXNzYWdlUG9ydFNpbmsoY2hhbm5lbC5wb3J0MilcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///249\n")}}]);