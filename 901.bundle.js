"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[901],{901:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileHandle: () => (/* binding */ FileHandle),\n/* harmony export */   FolderHandle: () => (/* binding */ FolderHandle),\n/* harmony export */   Sink: () => (/* binding */ Sink),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(275);\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);\n\n\n\nconst { File, Blob, DOMException } = _config_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A\nconst { INVALID, GONE, MISMATCH, MOD_ERR, SYNTAX, SECURITY, DISALLOWED } = _util_js__WEBPACK_IMPORTED_MODULE_0__.errors\n\nclass Sink {\n\n  /**\n   * @param {FileHandle} fileHandle\n   * @param {File} file\n   */\n  constructor (fileHandle, file) {\n    this.fileHandle = fileHandle\n    this.file = file\n    this.size = file.size\n    this.position = 0\n  }\n\n  write (chunk) {\n    let file = this.file\n\n    if (typeof chunk === 'object') {\n      if (chunk.type === 'write') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          this.position = chunk.position\n          if (this.size < chunk.position) {\n            this.file = new File(\n              [this.file, new ArrayBuffer(chunk.position - this.size)],\n              this.file.name,\n              this.file\n            )\n          }\n        }\n        if (!('data' in chunk)) {\n          throw new DOMException(...SYNTAX('write requires a data argument'))\n        }\n        chunk = chunk.data\n      } else if (chunk.type === 'seek') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          if (this.size < chunk.position) {\n            throw new DOMException(...INVALID)\n          }\n          this.position = chunk.position\n          return\n        } else {\n          throw new DOMException(...SYNTAX('seek requires a position argument'))\n        }\n      } else if (chunk.type === 'truncate') {\n        if (Number.isInteger(chunk.size) && chunk.size >= 0) {\n          file = chunk.size < this.size\n            ? new File([file.slice(0, chunk.size)], file.name, file)\n            : new File([file, new Uint8Array(chunk.size - this.size)], file.name)\n\n          this.size = file.size\n          if (this.position > file.size) {\n            this.position = file.size\n          }\n          this.file = file\n          return\n        } else {\n          throw new DOMException(...SYNTAX('truncate requires a size argument'))\n        }\n      }\n    }\n\n    chunk = new Blob([chunk])\n\n    let blob = this.file\n    // Calc the head and tail fragments\n    const head = blob.slice(0, this.position)\n    const tail = blob.slice(this.position + chunk.size)\n\n    // Calc the padding\n    let padding = this.position - head.size\n    if (padding < 0) {\n      padding = 0\n    }\n    blob = new File([\n      head,\n      new Uint8Array(padding),\n      chunk,\n      tail\n    ], blob.name)\n\n    this.size = blob.size\n    this.position += chunk.size\n\n    this.file = blob\n  }\n  close () {\n    if (this.fileHandle._deleted) throw new DOMException(...GONE)\n    this.fileHandle._file = this.file\n    this.file =\n    this.position =\n    this.size = null\n    if (this.fileHandle.onclose) {\n      this.fileHandle.onclose(this.fileHandle)\n    }\n  }\n}\n\nclass FileHandle {\n  constructor (name = '', file = new File([], name), writable = true) {\n    this._file = file\n    this.name = name\n    this.kind = 'file'\n    this._deleted = false\n    this.writable = writable\n    this.readable = true\n  }\n\n  async getFile () {\n    if (this._deleted) throw new DOMException(...GONE)\n    return this._file\n  }\n\n  async createWritable (opts) {\n    if (!this.writable) throw new DOMException(...DISALLOWED)\n    if (this._deleted) throw new DOMException(...GONE)\n\n    const file = opts.keepExistingData\n      ? await this.getFile()\n      : new File([], this.name)\n\n    return new Sink(this, file)\n  }\n\n  async isSameEntry (other) {\n    return this === other\n  }\n\n  async _destroy () {\n    this._deleted = true\n    this._file = null\n  }\n}\n\nclass FolderHandle {\n\n  /** @param {string} name */\n  constructor (name, writable = true) {\n    this.name = name\n    this.kind = 'directory'\n    this._deleted = false\n    /** @type {Object.<string, (FolderHandle|FileHandle)>} */\n    this._entries = {}\n    this.writable = writable\n    this.readable = true\n  }\n\n  /** @returns {AsyncGenerator<[string, FileHandle | FolderHandle]>} */\n  async * entries () {\n    if (this._deleted) throw new DOMException(...GONE)\n    yield* Object.entries(this._entries)\n  }\n\n  async isSameEntry (other) {\n    return this === other\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   */\n  async getDirectoryHandle (name, opts) {\n    if (this._deleted) throw new DOMException(...GONE)\n    const entry = this._entries[name]\n    if (entry) { // entry exist\n      if (entry instanceof FileHandle) {\n        throw new DOMException(...MISMATCH)\n      } else {\n        return entry\n      }\n    } else {\n      if (opts.create) {\n        return (this._entries[name] = new FolderHandle(name))\n      } else {\n        throw new DOMException(...GONE)\n      }\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   */\n  async getFileHandle (name, opts) {\n    const entry = this._entries[name]\n    const isFile = entry instanceof FileHandle\n    if (entry && isFile) return entry\n    if (entry && !isFile) throw new DOMException(...MISMATCH)\n    if (!entry && !opts.create) throw new DOMException(...GONE)\n    if (!entry && opts.create) {\n      return (this._entries[name] = new FileHandle(name))\n    }\n  }\n\n  async removeEntry (name, opts) {\n    const entry = this._entries[name]\n    if (!entry) throw new DOMException(...GONE)\n    await entry._destroy(opts.recursive)\n    delete this._entries[name]\n  }\n\n  async _destroy (recursive) {\n    for (let x of Object.values(this._entries)) {\n      if (!recursive) throw new DOMException(...MOD_ERR)\n      await x._destroy(recursive)\n    }\n    this._entries = {}\n    this._deleted = true\n  }\n}\n\nconst fs = new FolderHandle('')\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => fs);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtQztBQUNGOztBQUVqQyxRQUFRLDJCQUEyQixFQUFFLDJEQUFNO0FBQzNDLFFBQVEsaUVBQWlFLEVBQUUsNENBQU07O0FBRTFFOztBQUVQO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUCxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUE0QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy8ucG5wbS9uYXRpdmUtZmlsZS1zeXN0ZW0tYWRhcHRlckAzLjAuMS9ub2RlX21vZHVsZXMvbmF0aXZlLWZpbGUtc3lzdGVtLWFkYXB0ZXIvc3JjL2FkYXB0ZXJzL21lbW9yeS5qcz9kOGQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVycm9ycyB9IGZyb20gJy4uL3V0aWwuanMnXG5pbXBvcnQgY29uZmlnIGZyb20gJy4uL2NvbmZpZy5qcydcblxuY29uc3QgeyBGaWxlLCBCbG9iLCBET01FeGNlcHRpb24gfSA9IGNvbmZpZ1xuY29uc3QgeyBJTlZBTElELCBHT05FLCBNSVNNQVRDSCwgTU9EX0VSUiwgU1lOVEFYLCBTRUNVUklUWSwgRElTQUxMT1dFRCB9ID0gZXJyb3JzXG5cbmV4cG9ydCBjbGFzcyBTaW5rIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtGaWxlSGFuZGxlfSBmaWxlSGFuZGxlXG4gICAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGZpbGVIYW5kbGUsIGZpbGUpIHtcbiAgICB0aGlzLmZpbGVIYW5kbGUgPSBmaWxlSGFuZGxlXG4gICAgdGhpcy5maWxlID0gZmlsZVxuICAgIHRoaXMuc2l6ZSA9IGZpbGUuc2l6ZVxuICAgIHRoaXMucG9zaXRpb24gPSAwXG4gIH1cblxuICB3cml0ZSAoY2h1bmspIHtcbiAgICBsZXQgZmlsZSA9IHRoaXMuZmlsZVxuXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChjaHVuay50eXBlID09PSAnd3JpdGUnKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGNodW5rLnBvc2l0aW9uKSAmJiBjaHVuay5wb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGNodW5rLnBvc2l0aW9uXG4gICAgICAgICAgaWYgKHRoaXMuc2l6ZSA8IGNodW5rLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGUgPSBuZXcgRmlsZShcbiAgICAgICAgICAgICAgW3RoaXMuZmlsZSwgbmV3IEFycmF5QnVmZmVyKGNodW5rLnBvc2l0aW9uIC0gdGhpcy5zaXplKV0sXG4gICAgICAgICAgICAgIHRoaXMuZmlsZS5uYW1lLFxuICAgICAgICAgICAgICB0aGlzLmZpbGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoJ2RhdGEnIGluIGNodW5rKSkge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oLi4uU1lOVEFYKCd3cml0ZSByZXF1aXJlcyBhIGRhdGEgYXJndW1lbnQnKSlcbiAgICAgICAgfVxuICAgICAgICBjaHVuayA9IGNodW5rLmRhdGFcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsudHlwZSA9PT0gJ3NlZWsnKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGNodW5rLnBvc2l0aW9uKSAmJiBjaHVuay5wb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2l6ZSA8IGNodW5rLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKC4uLklOVkFMSUQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBjaHVuay5wb3NpdGlvblxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oLi4uU1lOVEFYKCdzZWVrIHJlcXVpcmVzIGEgcG9zaXRpb24gYXJndW1lbnQnKSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaHVuay50eXBlID09PSAndHJ1bmNhdGUnKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGNodW5rLnNpemUpICYmIGNodW5rLnNpemUgPj0gMCkge1xuICAgICAgICAgIGZpbGUgPSBjaHVuay5zaXplIDwgdGhpcy5zaXplXG4gICAgICAgICAgICA/IG5ldyBGaWxlKFtmaWxlLnNsaWNlKDAsIGNodW5rLnNpemUpXSwgZmlsZS5uYW1lLCBmaWxlKVxuICAgICAgICAgICAgOiBuZXcgRmlsZShbZmlsZSwgbmV3IFVpbnQ4QXJyYXkoY2h1bmsuc2l6ZSAtIHRoaXMuc2l6ZSldLCBmaWxlLm5hbWUpXG5cbiAgICAgICAgICB0aGlzLnNpemUgPSBmaWxlLnNpemVcbiAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA+IGZpbGUuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGZpbGUuc2l6ZVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZpbGUgPSBmaWxlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbiguLi5TWU5UQVgoJ3RydW5jYXRlIHJlcXVpcmVzIGEgc2l6ZSBhcmd1bWVudCcpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2h1bmsgPSBuZXcgQmxvYihbY2h1bmtdKVxuXG4gICAgbGV0IGJsb2IgPSB0aGlzLmZpbGVcbiAgICAvLyBDYWxjIHRoZSBoZWFkIGFuZCB0YWlsIGZyYWdtZW50c1xuICAgIGNvbnN0IGhlYWQgPSBibG9iLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pXG4gICAgY29uc3QgdGFpbCA9IGJsb2Iuc2xpY2UodGhpcy5wb3NpdGlvbiArIGNodW5rLnNpemUpXG5cbiAgICAvLyBDYWxjIHRoZSBwYWRkaW5nXG4gICAgbGV0IHBhZGRpbmcgPSB0aGlzLnBvc2l0aW9uIC0gaGVhZC5zaXplXG4gICAgaWYgKHBhZGRpbmcgPCAwKSB7XG4gICAgICBwYWRkaW5nID0gMFxuICAgIH1cbiAgICBibG9iID0gbmV3IEZpbGUoW1xuICAgICAgaGVhZCxcbiAgICAgIG5ldyBVaW50OEFycmF5KHBhZGRpbmcpLFxuICAgICAgY2h1bmssXG4gICAgICB0YWlsXG4gICAgXSwgYmxvYi5uYW1lKVxuXG4gICAgdGhpcy5zaXplID0gYmxvYi5zaXplXG4gICAgdGhpcy5wb3NpdGlvbiArPSBjaHVuay5zaXplXG5cbiAgICB0aGlzLmZpbGUgPSBibG9iXG4gIH1cbiAgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzLmZpbGVIYW5kbGUuX2RlbGV0ZWQpIHRocm93IG5ldyBET01FeGNlcHRpb24oLi4uR09ORSlcbiAgICB0aGlzLmZpbGVIYW5kbGUuX2ZpbGUgPSB0aGlzLmZpbGVcbiAgICB0aGlzLmZpbGUgPVxuICAgIHRoaXMucG9zaXRpb24gPVxuICAgIHRoaXMuc2l6ZSA9IG51bGxcbiAgICBpZiAodGhpcy5maWxlSGFuZGxlLm9uY2xvc2UpIHtcbiAgICAgIHRoaXMuZmlsZUhhbmRsZS5vbmNsb3NlKHRoaXMuZmlsZUhhbmRsZSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVIYW5kbGUge1xuICBjb25zdHJ1Y3RvciAobmFtZSA9ICcnLCBmaWxlID0gbmV3IEZpbGUoW10sIG5hbWUpLCB3cml0YWJsZSA9IHRydWUpIHtcbiAgICB0aGlzLl9maWxlID0gZmlsZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmtpbmQgPSAnZmlsZSdcbiAgICB0aGlzLl9kZWxldGVkID0gZmFsc2VcbiAgICB0aGlzLndyaXRhYmxlID0gd3JpdGFibGVcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZVxuICB9XG5cbiAgYXN5bmMgZ2V0RmlsZSAoKSB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHRocm93IG5ldyBET01FeGNlcHRpb24oLi4uR09ORSlcbiAgICByZXR1cm4gdGhpcy5fZmlsZVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlV3JpdGFibGUgKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHRocm93IG5ldyBET01FeGNlcHRpb24oLi4uRElTQUxMT1dFRClcbiAgICBpZiAodGhpcy5fZGVsZXRlZCkgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbiguLi5HT05FKVxuXG4gICAgY29uc3QgZmlsZSA9IG9wdHMua2VlcEV4aXN0aW5nRGF0YVxuICAgICAgPyBhd2FpdCB0aGlzLmdldEZpbGUoKVxuICAgICAgOiBuZXcgRmlsZShbXSwgdGhpcy5uYW1lKVxuXG4gICAgcmV0dXJuIG5ldyBTaW5rKHRoaXMsIGZpbGUpXG4gIH1cblxuICBhc3luYyBpc1NhbWVFbnRyeSAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXJcbiAgfVxuXG4gIGFzeW5jIF9kZXN0cm95ICgpIHtcbiAgICB0aGlzLl9kZWxldGVkID0gdHJ1ZVxuICAgIHRoaXMuX2ZpbGUgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZvbGRlckhhbmRsZSB7XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCB3cml0YWJsZSA9IHRydWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5raW5kID0gJ2RpcmVjdG9yeSdcbiAgICB0aGlzLl9kZWxldGVkID0gZmFsc2VcbiAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCAoRm9sZGVySGFuZGxlfEZpbGVIYW5kbGUpPn0gKi9cbiAgICB0aGlzLl9lbnRyaWVzID0ge31cbiAgICB0aGlzLndyaXRhYmxlID0gd3JpdGFibGVcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtBc3luY0dlbmVyYXRvcjxbc3RyaW5nLCBGaWxlSGFuZGxlIHwgRm9sZGVySGFuZGxlXT59ICovXG4gIGFzeW5jICogZW50cmllcyAoKSB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHRocm93IG5ldyBET01FeGNlcHRpb24oLi4uR09ORSlcbiAgICB5aWVsZCogT2JqZWN0LmVudHJpZXModGhpcy5fZW50cmllcylcbiAgfVxuXG4gIGFzeW5jIGlzU2FtZUVudHJ5IChvdGhlcikge1xuICAgIHJldHVybiB0aGlzID09PSBvdGhlclxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7eyBjcmVhdGU6IGJvb2xlYW47IH19IG9wdHNcbiAgICovXG4gIGFzeW5jIGdldERpcmVjdG9yeUhhbmRsZSAobmFtZSwgb3B0cykge1xuICAgIGlmICh0aGlzLl9kZWxldGVkKSB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKC4uLkdPTkUpXG4gICAgY29uc3QgZW50cnkgPSB0aGlzLl9lbnRyaWVzW25hbWVdXG4gICAgaWYgKGVudHJ5KSB7IC8vIGVudHJ5IGV4aXN0XG4gICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBGaWxlSGFuZGxlKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oLi4uTUlTTUFUQ0gpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW50cnlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdHMuY3JlYXRlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZW50cmllc1tuYW1lXSA9IG5ldyBGb2xkZXJIYW5kbGUobmFtZSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKC4uLkdPTkUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7eyBjcmVhdGU6IGJvb2xlYW47IH19IG9wdHNcbiAgICovXG4gIGFzeW5jIGdldEZpbGVIYW5kbGUgKG5hbWUsIG9wdHMpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuX2VudHJpZXNbbmFtZV1cbiAgICBjb25zdCBpc0ZpbGUgPSBlbnRyeSBpbnN0YW5jZW9mIEZpbGVIYW5kbGVcbiAgICBpZiAoZW50cnkgJiYgaXNGaWxlKSByZXR1cm4gZW50cnlcbiAgICBpZiAoZW50cnkgJiYgIWlzRmlsZSkgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbiguLi5NSVNNQVRDSClcbiAgICBpZiAoIWVudHJ5ICYmICFvcHRzLmNyZWF0ZSkgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbiguLi5HT05FKVxuICAgIGlmICghZW50cnkgJiYgb3B0cy5jcmVhdGUpIHtcbiAgICAgIHJldHVybiAodGhpcy5fZW50cmllc1tuYW1lXSA9IG5ldyBGaWxlSGFuZGxlKG5hbWUpKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlbW92ZUVudHJ5IChuYW1lLCBvcHRzKSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLl9lbnRyaWVzW25hbWVdXG4gICAgaWYgKCFlbnRyeSkgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbiguLi5HT05FKVxuICAgIGF3YWl0IGVudHJ5Ll9kZXN0cm95KG9wdHMucmVjdXJzaXZlKVxuICAgIGRlbGV0ZSB0aGlzLl9lbnRyaWVzW25hbWVdXG4gIH1cblxuICBhc3luYyBfZGVzdHJveSAocmVjdXJzaXZlKSB7XG4gICAgZm9yIChsZXQgeCBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2VudHJpZXMpKSB7XG4gICAgICBpZiAoIXJlY3Vyc2l2ZSkgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbiguLi5NT0RfRVJSKVxuICAgICAgYXdhaXQgeC5fZGVzdHJveShyZWN1cnNpdmUpXG4gICAgfVxuICAgIHRoaXMuX2VudHJpZXMgPSB7fVxuICAgIHRoaXMuX2RlbGV0ZWQgPSB0cnVlXG4gIH1cbn1cblxuY29uc3QgZnMgPSBuZXcgRm9sZGVySGFuZGxlKCcnKVxuXG5leHBvcnQgZGVmYXVsdCAoKSA9PiBmc1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///901\n")}}]);