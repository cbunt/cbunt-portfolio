"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[234],{5234:(module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var native_file_system_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8777);\n/* harmony import */ var _settings_skybox_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5427);\n/* harmony import */ var _settings_property_listener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9528);\n/* harmony import */ var _utils_data_copy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5752);\n/* harmony import */ var _cubemap_guassian_pyramid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3156);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_settings_skybox_options__WEBPACK_IMPORTED_MODULE_1__]);\n_settings_skybox_options__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CubemapBlurModel_settings;\n\n\n\n\n\nvar BlurState;\n(function (BlurState) {\n    BlurState[BlurState[\"IDLE\"] = 0] = \"IDLE\";\n    BlurState[BlurState[\"BLUR\"] = 1] = \"BLUR\";\n    BlurState[BlurState[\"WAIT\"] = 2] = \"WAIT\";\n})(BlurState || (BlurState = {}));\nclass CubemapBlurModel {\n    constructor(renderer) {\n        this.renderer = renderer;\n        this.state = BlurState.IDLE;\n        _CubemapBlurModel_settings.set(this, (0,_settings_property_listener__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A)({\n            nearestSample: {\n                [_settings_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$type]: 'checkbox',\n                [_settings_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$callback]: (val) => {\n                    if (typeof val === 'boolean')\n                        this.renderer.skyboxPass.useNearestSample = val;\n                },\n                value: false,\n                description: 'Disables linear sampling in the viewer.',\n            },\n            mipLevel: {\n                [_settings_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$type]: 'slider',\n                [_settings_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$callback]: (value) => {\n                    if (typeof value === 'number')\n                        this.renderer.skyboxPass.mipLevel = value;\n                },\n                value: 0,\n                min: 0,\n                max: 1,\n                step: 0.1,\n                description: 'The mip level to display in the viewer. 0 is the original image, max is completely blurred with 1 pixel faces.',\n            },\n            filterDistance: {\n                [_settings_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$type]: 'slider',\n                [_settings_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$callback]: this.reblur.bind(this),\n                value: 2,\n                max: 64,\n                min: 0,\n                step: 0.1,\n                description: 'The number of pixels to blur from.',\n            },\n            skybox: (0,_settings_skybox_options__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(this),\n            'Download Result': {\n                [_settings_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$type]: 'button',\n                onClick: () => { void this.saveFile(); },\n            },\n        }));\n        this.settings = __classPrivateFieldGet(this, _CubemapBlurModel_settings, \"f\").publicSettings;\n        this.priority = 0;\n        renderer.addForwardPass(this);\n        this.device = renderer.device;\n    }\n    setSkybox(skybox) {\n        this.skybox = skybox;\n        __classPrivateFieldGet(this, _CubemapBlurModel_settings, \"f\").privateSettings.mipLevel.max = this.skybox.mipLevelCount - 1;\n        __classPrivateFieldGet(this, _CubemapBlurModel_settings, \"f\").privateSettings.mipLevel.value = 1;\n        this.renderer.skyboxPass.mipLevel = 1;\n        this.refresh();\n        void this.reblur();\n    }\n    resolve() {\n        this.refresh();\n        const lastState = this.state;\n        this.state = BlurState.IDLE;\n        if (lastState === BlurState.WAIT)\n            void this.reblur();\n    }\n    async reblur() {\n        if (this.skybox == null || this.state === BlurState.WAIT)\n            return;\n        if (this.state === BlurState.BLUR) {\n            this.state = BlurState.WAIT;\n            return;\n        }\n        this.state = BlurState.BLUR;\n        await (0,_cubemap_guassian_pyramid__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A)({\n            device: this.renderer.device,\n            texture: this.skybox,\n            steps: this.settings.filterDistance.value,\n            inPlace: true,\n            delayWork: requestAnimationFrame,\n        });\n        this.resolve();\n    }\n    refresh() {\n        if (this.skybox == null)\n            return;\n        this.renderer.skyboxPass.skyTexture = this.skybox.createView({ dimension: 'cube' });\n    }\n    async saveFile() {\n        if (this.skybox == null)\n            return;\n        try {\n            const proms = Promise.all([\n                (0,_utils_data_copy__WEBPACK_IMPORTED_MODULE_3__/* .textureToKTX */ .gU)(this.renderer.device, this.skybox, true)\n                    .then((ktx2) => new Blob([ktx2], { type: 'image/ktx2' })),\n                (0,native_file_system_adapter__WEBPACK_IMPORTED_MODULE_0__/* .showSaveFilePicker */ .H1)({\n                    types: [{ accept: { 'image/ktx2': ['.ktx2'] } }],\n                    suggestedName: 'blurred-skybox.ktx2',\n                }).then((handle) => handle.createWritable({ keepExistingData: false })),\n            ]);\n            const [blob, stream] = await proms;\n            await blob.stream().pipeTo(stream);\n        }\n        catch (e) {\n            console.warn(e);\n        }\n    }\n    render({ encoder, gbuffer }) {\n        encoder.beginRenderPass({\n            colorAttachments: [],\n            depthStencilAttachment: {\n                depthClearValue: 1,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                view: gbuffer.depth.view,\n            },\n        }).end();\n    }\n}\n_CubemapBlurModel_settings = new WeakMap();\nCubemapBlurModel.title = '';\nCubemapBlurModel.description = '';\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CubemapBlurModel);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGVBQWUsQ0FBQztZQUNwQixnQkFBZ0IsRUFBRSxFQUFFO1lBQ3BCLHNCQUFzQixFQUFFO2dCQUNwQixlQUFlLEVBQUUsQ0FBQztnQkFDbEIsV0FBVyxFQUFFLE9BQU87Z0JBQ3BCLFlBQVksRUFBRSxPQUFPO2dCQUNyQixvRUFBb0U7Z0JBQ3BFLElBQUksRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUk7YUFDM0I7U0FDSixDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDYixDQUFDOzs7QUE1SE0sc0JBQUssR0FBRyxFQUFFLENBQUM7QUFDWCw0QkFBVyxHQUFHLEVBQUUsQ0FBQztpRUFGUCxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvc2FtcGxlcy9jdWJlbWFwLWJsdXIvY3ViZW1hcC1ibHVyLXNhbXBsZS50cz80ZTI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNob3dTYXZlRmlsZVBpY2tlciB9IGZyb20gJ25hdGl2ZS1maWxlLXN5c3RlbS1hZGFwdGVyJztcblxuaW1wb3J0IGdldFNreWJveE9wdGlvbnMgZnJvbSAnLi4vc2V0dGluZ3Mvc2t5Ym94LW9wdGlvbnMnO1xuaW1wb3J0IHsgRnVsbFJlbmRlck1vZGVsIH0gZnJvbSAnLi4vc2V0dGluZ3Mvc2FtcGxlLXNwZWMnO1xuaW1wb3J0IHByb3BlcnR5TGlzdGVuZXIsIHsgTGlzdGVuZXJTeW1zIH0gZnJvbSAnLi4vc2V0dGluZ3MvcHJvcGVydHktbGlzdGVuZXInO1xuXG5pbXBvcnQgeyB0ZXh0dXJlVG9LVFggfSBmcm9tICcuLi8uLi91dGlscy9kYXRhLWNvcHknO1xuaW1wb3J0IFJlbmRlcmVyLCB7IEZvcndhcmRQYXNzUGFyYW1zIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVyJztcblxuaW1wb3J0IGN1YmVtYXBHdWFzc2lhblB5cmFtaWQgZnJvbSAnLi9jdWJlbWFwLWd1YXNzaWFuLXB5cmFtaWQnO1xuXG5lbnVtIEJsdXJTdGF0ZSB7IElETEUsIEJMVVIsIFdBSVQgfVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdWJlbWFwQmx1ck1vZGVsIGltcGxlbWVudHMgRnVsbFJlbmRlck1vZGVsIHtcbiAgICBzdGF0aWMgdGl0bGUgPSAnJztcbiAgICBzdGF0aWMgZGVzY3JpcHRpb24gPSAnJztcblxuICAgIHNreWJveD86IEdQVVRleHR1cmU7XG4gICAgc3RhdGU6IEJsdXJTdGF0ZSA9IEJsdXJTdGF0ZS5JRExFO1xuXG4gICAgcmVhZG9ubHkgI3NldHRpbmdzID0gcHJvcGVydHlMaXN0ZW5lcih7XG4gICAgICAgIG5lYXJlc3RTYW1wbGU6IHtcbiAgICAgICAgICAgIFtMaXN0ZW5lclN5bXMuJHR5cGVdOiAnY2hlY2tib3gnIGFzIGNvbnN0LFxuICAgICAgICAgICAgW0xpc3RlbmVyU3ltcy4kY2FsbGJhY2tdOiAodmFsOiB1bmtub3duKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykgdGhpcy5yZW5kZXJlci5za3lib3hQYXNzLnVzZU5lYXJlc3RTYW1wbGUgPSB2YWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdEaXNhYmxlcyBsaW5lYXIgc2FtcGxpbmcgaW4gdGhlIHZpZXdlci4nLFxuICAgICAgICB9LFxuICAgICAgICBtaXBMZXZlbDoge1xuICAgICAgICAgICAgW0xpc3RlbmVyU3ltcy4kdHlwZV06ICdzbGlkZXInIGFzIGNvbnN0LFxuICAgICAgICAgICAgW0xpc3RlbmVyU3ltcy4kY2FsbGJhY2tdOiAodmFsdWU6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgdGhpcy5yZW5kZXJlci5za3lib3hQYXNzLm1pcExldmVsID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDEsXG4gICAgICAgICAgICBzdGVwOiAwLjEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBtaXAgbGV2ZWwgdG8gZGlzcGxheSBpbiB0aGUgdmlld2VyLiAwIGlzIHRoZSBvcmlnaW5hbCBpbWFnZSwgbWF4IGlzIGNvbXBsZXRlbHkgYmx1cnJlZCB3aXRoIDEgcGl4ZWwgZmFjZXMuJyxcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyRGlzdGFuY2U6IHtcbiAgICAgICAgICAgIFtMaXN0ZW5lclN5bXMuJHR5cGVdOiAnc2xpZGVyJyBhcyBjb25zdCxcbiAgICAgICAgICAgIFtMaXN0ZW5lclN5bXMuJGNhbGxiYWNrXTogdGhpcy5yZWJsdXIuYmluZCh0aGlzKSBhcyAoKSA9PiB2b2lkLFxuICAgICAgICAgICAgdmFsdWU6IDIsXG4gICAgICAgICAgICBtYXg6IDY0LFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgc3RlcDogMC4xLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgbnVtYmVyIG9mIHBpeGVscyB0byBibHVyIGZyb20uJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2t5Ym94OiBnZXRTa3lib3hPcHRpb25zKHRoaXMpLFxuICAgICAgICAnRG93bmxvYWQgUmVzdWx0Jzoge1xuICAgICAgICAgICAgW0xpc3RlbmVyU3ltcy4kdHlwZV06ICdidXR0b24nIGFzIGNvbnN0LFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4geyB2b2lkIHRoaXMuc2F2ZUZpbGUoKTsgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJlYWRvbmx5IHNldHRpbmdzID0gdGhpcy4jc2V0dGluZ3MucHVibGljU2V0dGluZ3M7XG4gICAgcmVhZG9ubHkgcHJpb3JpdHkgPSAwO1xuICAgIGRldmljZTogR1BVRGV2aWNlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHJlbmRlcmVyOiBSZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlci5hZGRGb3J3YXJkUGFzcyh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXZpY2UgPSByZW5kZXJlci5kZXZpY2U7XG4gICAgfVxuXG4gICAgc2V0U2t5Ym94KHNreWJveDogR1BVVGV4dHVyZSkge1xuICAgICAgICB0aGlzLnNreWJveCA9IHNreWJveDtcbiAgICAgICAgdGhpcy4jc2V0dGluZ3MucHJpdmF0ZVNldHRpbmdzLm1pcExldmVsLm1heCA9IHRoaXMuc2t5Ym94Lm1pcExldmVsQ291bnQgLSAxO1xuICAgICAgICB0aGlzLiNzZXR0aW5ncy5wcml2YXRlU2V0dGluZ3MubWlwTGV2ZWwudmFsdWUgPSAxO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNreWJveFBhc3MubWlwTGV2ZWwgPSAxO1xuXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB2b2lkIHRoaXMucmVibHVyKCk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZSgpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIGNvbnN0IGxhc3RTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBCbHVyU3RhdGUuSURMRTtcbiAgICAgICAgaWYgKGxhc3RTdGF0ZSA9PT0gQmx1clN0YXRlLldBSVQpIHZvaWQgdGhpcy5yZWJsdXIoKTtcbiAgICB9XG5cbiAgICBhc3luYyByZWJsdXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnNreWJveCA9PSBudWxsIHx8IHRoaXMuc3RhdGUgPT09IEJsdXJTdGF0ZS5XQUlUKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IEJsdXJTdGF0ZS5CTFVSKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQmx1clN0YXRlLldBSVQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gQmx1clN0YXRlLkJMVVI7XG5cbiAgICAgICAgYXdhaXQgY3ViZW1hcEd1YXNzaWFuUHlyYW1pZCh7XG4gICAgICAgICAgICBkZXZpY2U6IHRoaXMucmVuZGVyZXIuZGV2aWNlLFxuICAgICAgICAgICAgdGV4dHVyZTogdGhpcy5za3lib3gsXG4gICAgICAgICAgICBzdGVwczogdGhpcy5zZXR0aW5ncy5maWx0ZXJEaXN0YW5jZS52YWx1ZSxcbiAgICAgICAgICAgIGluUGxhY2U6IHRydWUsXG4gICAgICAgICAgICBkZWxheVdvcms6IHJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2t5Ym94ID09IG51bGwpIHJldHVybjtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5za3lib3hQYXNzLnNreVRleHR1cmUgPSB0aGlzLnNreWJveC5jcmVhdGVWaWV3KHsgZGltZW5zaW9uOiAnY3ViZScgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2F2ZUZpbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNreWJveCA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tcyA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlVG9LVFgodGhpcy5yZW5kZXJlci5kZXZpY2UsIHRoaXMuc2t5Ym94LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoa3R4MikgPT4gbmV3IEJsb2IoW2t0eDJdLCB7IHR5cGU6ICdpbWFnZS9rdHgyJyB9KSksXG4gICAgICAgICAgICAgICAgc2hvd1NhdmVGaWxlUGlja2VyKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFt7IGFjY2VwdDogeyAnaW1hZ2Uva3R4Mic6IFsnLmt0eDInXSB9IH1dLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWROYW1lOiAnYmx1cnJlZC1za3lib3gua3R4MicsXG4gICAgICAgICAgICAgICAgfSkudGhlbigoaGFuZGxlKSA9PiBoYW5kbGUuY3JlYXRlV3JpdGFibGUoeyBrZWVwRXhpc3RpbmdEYXRhOiBmYWxzZSB9KSksXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgY29uc3QgW2Jsb2IsIHN0cmVhbV0gPSBhd2FpdCBwcm9tcztcbiAgICAgICAgICAgIGF3YWl0IGJsb2Iuc3RyZWFtKCkucGlwZVRvKHN0cmVhbSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcih7IGVuY29kZXIsIGdidWZmZXIgfTogRm9yd2FyZFBhc3NQYXJhbXMpIHtcbiAgICAgICAgZW5jb2Rlci5iZWdpblJlbmRlclBhc3Moe1xuICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW10sXG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50OiB7XG4gICAgICAgICAgICAgICAgZGVwdGhDbGVhclZhbHVlOiAxLFxuICAgICAgICAgICAgICAgIGRlcHRoTG9hZE9wOiAnY2xlYXInLFxuICAgICAgICAgICAgICAgIGRlcHRoU3RvcmVPcDogJ3N0b3JlJyxcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIHZpZXc6IGdidWZmZXIuZGVwdGgudmlldyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLmVuZCgpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5234\n")},3156:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ cubemapGuassianPyramid)\n/* harmony export */ });\n/* harmony import */ var _shaders_cubemap_sampling_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6097);\n/* harmony import */ var _utils_data_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5752);\n/* harmony import */ var _utils_general__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4742);\n/* eslint @stylistic/max-len: \"error\" */\n\n\n\nconst createMipBlurCode = (groups, format) => /* wgsl */ `\r\n    ${_shaders_cubemap_sampling_shader__WEBPACK_IMPORTED_MODULE_1__/* .cubemapSampleConversions */ .X}\r\n    ${_shaders_cubemap_sampling_shader__WEBPACK_IMPORTED_MODULE_1__/* .toWorldDir */ .V}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    struct Params {\r\n        offset: u32,\r\n        sigmas: array<f32>,\r\n    }\r\n\r\n    @group(0) @binding(0) var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    // sigma[0] reserved for work offset\r\n    @group(0) @binding(2) var<storage> params: Params;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + params.offset;\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = toWorldDir(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&params.sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = params.sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = toWorldDir(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\n/**\n *  the minimum angular distance between any pixel on a cubemap\n *  of the given face width and any pixel lying on a perimeter\n *  the given number of steps away\n */\nfunction minStepDistance(steps, width) {\n    // the angular distance\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\n    // It's likely possible to programmatically determine whether the\n    // destination pixel should be v = 0 or v = 1, but checking both works fine\n    const nextMipWidth = width >> 1;\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\n    const baseUN = (1 / nextMipWidth) - 1;\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\n    const samp0VN = (1 / width) - 1;\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\n    const samp1VN = (3 / width) - 1;\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN)\n        / Math.sqrt(samp0Mag2 * baseMag2);\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN)\n        / Math.sqrt(samp1Mag2 * baseMag2);\n    return Math.min(1 - dot0, 1 - dot1);\n}\nasync function cubemapGuassianPyramid({ device, texture, outputTextureLabel, inPlace = false, minWidth = 8, steps = 4, maxOpsPerPass = 6 * ((17 * 256) ** 2), label = cubemapGuassianPyramid.name, delayWork, }) {\n    const { width, format } = texture;\n    const mipLevelCount = inPlace\n        ? texture.mipLevelCount\n        : (Math.log2(width) - Math.log2(minWidth) + 1);\n    if (mipLevelCount <= 1)\n        return texture;\n    const groups = Math.min(device.limits.maxComputeWorkgroupSizeX, device.limits.maxComputeInvocationsPerWorkgroup);\n    const shader = device.createShaderModule({\n        label,\n        code: createMipBlurCode(groups, format),\n    });\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d-array' },\n                visibility: GPUShaderStage.COMPUTE,\n            },\n            {\n                binding: 1,\n                storageTexture: {\n                    access: 'write-only',\n                    viewDimension: '2d-array',\n                    format,\n                },\n                visibility: GPUShaderStage.COMPUTE,\n            },\n            {\n                binding: 2,\n                buffer: { type: 'read-only-storage' },\n                visibility: GPUShaderStage.COMPUTE,\n            },\n        ],\n    });\n    const pipeline = device.createComputePipeline({\n        label,\n        layout: device.createPipelineLayout({\n            label,\n            bindGroupLayouts: [bindgroupLayout],\n        }),\n        compute: {\n            module: shader,\n            entryPoint: 'main',\n            constants: { STEPS: Math.ceil(steps) },\n        },\n    });\n    let gaussianPyramid = texture;\n    if (!inPlace) {\n        const size = { width, height: width, depthOrArrayLayers: 6 };\n        gaussianPyramid = device.createTexture({\n            label: outputTextureLabel,\n            usage: GPUTextureUsage.STORAGE_BINDING\n                | GPUTextureUsage.TEXTURE_BINDING\n                | GPUTextureUsage.COPY_SRC\n                | GPUTextureUsage.COPY_DST,\n            dimension: '2d',\n            format,\n            mipLevelCount,\n            size,\n        });\n        const copyEncoder = device.createCommandEncoder({\n            label: `${label} copy encoder`,\n        });\n        copyEncoder.copyTextureToTexture({ texture, mipLevel: 0 }, { texture: gaussianPyramid, mipLevel: 0 }, size);\n        device.queue.submit([copyEncoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n    const mipViews = (0,_utils_general__WEBPACK_IMPORTED_MODULE_2__/* .mapRange */ ._b)(mipLevelCount, (i) => gaussianPyramid.createView({\n        label: `${label} mip view ${i}`,\n        dimension: '2d-array',\n        baseMipLevel: i,\n        mipLevelCount: 1,\n    }));\n    const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\n    const maxLayers = Math.ceil(Math.log2(width));\n    const maxDispatches = Math.max((maxOpsPerPass / (((1 + (steps * 2)) ** 2) * groups)) | 0, 1);\n    const propertyArray = new ArrayBuffer((maxLayers + 1) * 4);\n    const offset = new Uint32Array(propertyArray, 0, 1);\n    const simgas = new Float32Array(propertyArray, 4, maxLayers);\n    simgas.set((0,_utils_general__WEBPACK_IMPORTED_MODULE_2__/* .mapRange */ ._b)(maxLayers, (i) => {\n        const w = width >> i;\n        return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\n    }));\n    const propertyBuffer = (0,_utils_data_copy__WEBPACK_IMPORTED_MODULE_0__/* .createAndCopyBuffer */ .Lr)(propertyArray, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, device);\n    await new Promise((resolve) => {\n        let mipLevel = 0;\n        let mipPasses = 0;\n        let requiredMipDispatches = 0;\n        let currentMipDispatches = 0;\n        let batchDispatches = 0;\n        let bindgroup;\n        async function runPass() {\n            if (currentMipDispatches >= requiredMipDispatches) {\n                mipLevel += 1;\n                currentMipDispatches = 0;\n                mipPasses = 0;\n                if (mipLevel >= mipLevelCount) {\n                    resolve();\n                    return;\n                }\n                const mipPixels = 6 * ((width >> mipLevel) ** 2);\n                requiredMipDispatches = Math.ceil(mipPixels / groups);\n                bindgroup = device.createBindGroup({\n                    layout: bindgroupLayout,\n                    entries: [\n                        {\n                            binding: 0,\n                            resource: mipViews[mipLevel - 1],\n                        },\n                        {\n                            binding: 1,\n                            resource: mipViews[mipLevel],\n                        },\n                        {\n                            binding: 2,\n                            resource: { buffer: propertyBuffer },\n                        },\n                    ],\n                });\n            }\n            offset[0] = currentMipDispatches * groups;\n            device.queue.writeBuffer(propertyBuffer, 0, offset);\n            const passDispatches = Math.min(requiredMipDispatches - currentMipDispatches, maxDispatches - batchDispatches, maxWorkgroups);\n            const passLabel = `${label} mip ${mipLevel}, pass ${mipPasses}`;\n            const encoder = device.createCommandEncoder({ label: passLabel });\n            const pass = encoder.beginComputePass({ label: passLabel });\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindgroup);\n            pass.dispatchWorkgroups(passDispatches, 1, 1);\n            pass.end();\n            device.queue.submit([encoder.finish()]);\n            currentMipDispatches += passDispatches;\n            batchDispatches += passDispatches;\n            mipPasses += 1;\n            if (delayWork != null && batchDispatches >= maxDispatches) {\n                batchDispatches = 0;\n                await device.queue.onSubmittedWorkDone();\n                delayWork(runPass);\n            }\n            else {\n                void runPass();\n            }\n        }\n        void runPass();\n    });\n    return gaussianPyramid;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzlDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUVYLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUV4QyxvQkFBb0IsSUFBSSxjQUFjLENBQUM7WUFDdkMsZUFBZSxJQUFJLGNBQWMsQ0FBQztZQUNsQyxTQUFTLElBQUksQ0FBQyxDQUFDO1lBRWYsSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLGVBQWUsSUFBSSxhQUFhLEVBQUUsQ0FBQztnQkFDeEQsZUFBZSxHQUFHLENBQUMsQ0FBQztnQkFDcEIsTUFBTSxNQUFNLENBQUMsS0FBSyxDQUFDLG1CQUFtQixFQUFFLENBQUM7Z0JBQ3pDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN2QixDQUFDO2lCQUFNLENBQUM7Z0JBQ0osS0FBSyxPQUFPLEVBQUUsQ0FBQztZQUNuQixDQUFDO1FBQ0wsQ0FBQztRQUVELEtBQUssT0FBTyxFQUFFLENBQUM7SUFDbkIsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLGVBQWUsQ0FBQztBQUMzQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3NhbXBsZXMvY3ViZW1hcC1ibHVyL2N1YmVtYXAtZ3Vhc3NpYW4tcHlyYW1pZC50cz9kNzhlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBAc3R5bGlzdGljL21heC1sZW46IFwiZXJyb3JcIiAqL1xyXG5cclxuaW1wb3J0IHtcclxuICAgIHRvV29ybGREaXIsXHJcbiAgICBjdWJlbWFwU2FtcGxlQ29udmVyc2lvbnMsXHJcbn0gZnJvbSAnLi4vLi4vc2hhZGVycy9jdWJlbWFwLXNhbXBsaW5nLnNoYWRlcic7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVBbmRDb3B5QnVmZmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvZGF0YS1jb3B5JztcclxuaW1wb3J0IHsgbWFwUmFuZ2UgfSBmcm9tICcuLi8uLi91dGlscy9nZW5lcmFsJztcclxuXHJcbmNvbnN0IGNyZWF0ZU1pcEJsdXJDb2RlID0gKFxyXG4gICAgZ3JvdXBzOiBudW1iZXIsXHJcbiAgICBmb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXQsXHJcbikgPT4gLyogd2dzbCAqL2BcclxuICAgICR7Y3ViZW1hcFNhbXBsZUNvbnZlcnNpb25zfVxyXG4gICAgJHt0b1dvcmxkRGlyfVxyXG5cclxuICAgIG92ZXJyaWRlIFNURVBTOiBpMzIgPSA0O1xyXG5cclxuICAgIHN0cnVjdCBQYXJhbXMge1xyXG4gICAgICAgIG9mZnNldDogdTMyLFxyXG4gICAgICAgIHNpZ21hczogYXJyYXk8ZjMyPixcclxuICAgIH1cclxuXHJcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyIHByZXZpb3VzTWlwOiB0ZXh0dXJlXzJkX2FycmF5PGYzMj47XHJcblxyXG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIFxyXG4gICAgdmFyIG91dHB1dFRleHR1cmU6IHRleHR1cmVfc3RvcmFnZV8yZF9hcnJheTwke2Zvcm1hdH0sIHdyaXRlPjtcclxuXHJcbiAgICAvLyBzaWdtYVswXSByZXNlcnZlZCBmb3Igd29yayBvZmZzZXRcclxuICAgIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZT4gcGFyYW1zOiBQYXJhbXM7XHJcbiAgICBcclxuICAgIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke2dyb3Vwc30sIDEsIDEpXHJcbiAgICBmbiBtYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnaWQ6IHZlYzN1KSB7XHJcbiAgICAgICAgbGV0IG1pcFNpemUgPSB0ZXh0dXJlRGltZW5zaW9ucyhvdXRwdXRUZXh0dXJlKS54O1xyXG5cclxuICAgICAgICBsZXQgaWR4ID0gZ2lkLnggKyBwYXJhbXMub2Zmc2V0O1xyXG4gICAgICAgIGxldCBmYWNlU2l6ZSA9IG1pcFNpemUgKiBtaXBTaXplO1xyXG4gICAgICAgIGxldCBmYWNlSWR4ID0gaWR4ICUgZmFjZVNpemU7XHJcbiAgICAgICAgbGV0IGNvb3JkID0gdmVjM3UoXHJcbiAgICAgICAgICAgIGZhY2VJZHggJSBtaXBTaXplLCBcclxuICAgICAgICAgICAgZmFjZUlkeCAvIG1pcFNpemUsIFxyXG4gICAgICAgICAgICBpZHggLyBmYWNlU2l6ZSxcclxuICAgICAgICApOyBcclxuXHJcbiAgICAgICAgaWYgKGNvb3JkLnggPj0gbWlwU2l6ZSB8fCBjb29yZC55ID49IG1pcFNpemUgfHwgY29vcmQueiA+PSA2KSB7IFxyXG4gICAgICAgICAgICByZXR1cm47IFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHByZXZpb3VzU2l6ZSA9IHRleHR1cmVEaW1lbnNpb25zKHByZXZpb3VzTWlwKS54O1xyXG4gICAgICAgIGxldCBiYXNlQ29vcmQgPSB2ZWMzaSh2ZWMzdShjb29yZC54ICogMiwgY29vcmQueSAqIDIsIGNvb3JkLnopKTtcclxuICAgICAgICBsZXQgcG9zID0gdG9Xb3JsZERpcih2ZWMzdShjb29yZCksIG1pcFNpemUpO1xyXG5cclxuICAgICAgICBsZXQgc2l6ZSA9IGFycmF5TGVuZ3RoKCZwYXJhbXMuc2lnbWFzKTtcclxuICAgICAgICBsZXQgbGV2ZWwgPSBzaXplIC0gdTMyKGNlaWwobG9nMihmMzIocHJldmlvdXNTaXplKSkpKTtcclxuICAgICAgICBsZXQgc2lnbWEgPSBwYXJhbXMuc2lnbWFzW2xldmVsXTtcclxuICAgICAgICBsZXQgZ3Vhc3NpYW5fZmFjdG9yID0gLTAuNSAvIChzaWdtYSAqIHNpZ21hKTtcclxuXHJcbiAgICAgICAgdmFyIHdlaWdodCA9IDAuMDtcclxuICAgICAgICB2YXIgcmVzID0gdmVjMygwLjApO1xyXG5cclxuICAgICAgICBmb3IgKHZhciB1ID0gLVNURVBTOyB1IDw9IFNURVBTICsgMTsgdSArPSAxKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSAtU1RFUFM7IHYgPD0gU1RFUFMgKyAxOyB2ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXRDb29yZCA9IGJhc2VDb29yZCArIHZlYzNpKHUsIHYsIDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNhbXBsZSA9IGN1YmVTYW1wbGVDb29yZChvZmZzZXRDb29yZCwgcHJldmlvdXNTaXplKTtcclxuICAgICAgICAgICAgICAgIGlmIChzYW1wbGUueiA9PSBJTlZBTElEX0ZBQ0UpIHsgY29udGludWU7IH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgc2FtcGxlUG9zID0gdG9Xb3JsZERpcihzYW1wbGUsIHByZXZpb3VzU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IG1heCgwLjAsIGFjb3MoZG90KHNhbXBsZVBvcywgcG9zKSkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHcgPSBleHAoeCAqIHggKiBndWFzc2lhbl9mYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gdGV4dHVyZUxvYWQocHJldmlvdXNNaXAsIHNhbXBsZS54eSwgc2FtcGxlLnosIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlcyArPSBjb2xvci5yZ2IgKiB3O1xyXG4gICAgICAgICAgICAgICAgd2VpZ2h0ICs9IHc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRleHR1cmVTdG9yZShvdXRwdXRUZXh0dXJlLCBjb29yZC54eSwgY29vcmQueiwgdmVjNChyZXMgLyB3ZWlnaHQsIDEpKTtcclxuICAgIH1cclxuYDtcclxuXHJcbi8qKlxyXG4gKiAgdGhlIG1pbmltdW0gYW5ndWxhciBkaXN0YW5jZSBiZXR3ZWVuIGFueSBwaXhlbCBvbiBhIGN1YmVtYXBcclxuICogIG9mIHRoZSBnaXZlbiBmYWNlIHdpZHRoIGFuZCBhbnkgcGl4ZWwgbHlpbmcgb24gYSBwZXJpbWV0ZXJcclxuICogIHRoZSBnaXZlbiBudW1iZXIgb2Ygc3RlcHMgYXdheVxyXG4gKi9cclxuZnVuY3Rpb24gbWluU3RlcERpc3RhbmNlKHN0ZXBzOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcclxuICAgIC8vIHRoZSBhbmd1bGFyIGRpc3RhbmNlXHJcbiAgICAvLyBmcm9tIHRoZSB1dmY6IGZhY2UgPSAwLCB1ID0gMCwgYW5kIHYgPSB3aWR0aCAtIE1hdGguZmxvb3Ioc3RlcHMgLyAyKSAtIDFcclxuICAgIC8vIHRvIHRoZSB1dmY6IGZhY2UgPSAzLCB1ID0gMiAqIHdpZHRoIC0gYmFzZVYgLSBzdGVwcyAtIDIsIGFuZCB2ID0gMCBvciAxXHJcblxyXG4gICAgLy8gSXQncyBsaWtlbHkgcG9zc2libGUgdG8gcHJvZ3JhbW1hdGljYWxseSBkZXRlcm1pbmUgd2hldGhlciB0aGVcclxuICAgIC8vIGRlc3RpbmF0aW9uIHBpeGVsIHNob3VsZCBiZSB2ID0gMCBvciB2ID0gMSwgYnV0IGNoZWNraW5nIGJvdGggd29ya3MgZmluZVxyXG5cclxuICAgIGNvbnN0IG5leHRNaXBXaWR0aCA9IHdpZHRoID4+IDE7XHJcbiAgICBjb25zdCBiYXNlViA9IG5leHRNaXBXaWR0aCAtIE1hdGguZmxvb3Ioc3RlcHMgLyA0KSAtIDE7XHJcbiAgICBjb25zdCBiYXNlVk4gPSAoMiAvIG5leHRNaXBXaWR0aCkgKiAoYmFzZVYgKyAwLjUpIC0gMTtcclxuICAgIGNvbnN0IGJhc2VVTiA9ICgxIC8gbmV4dE1pcFdpZHRoKSAtIDE7XHJcbiAgICBjb25zdCBiYXNlTWFnMiA9IDEgKyBiYXNlVk4gKiBiYXNlVk4gKyBiYXNlVU4gKiBiYXNlVU47XHJcblxyXG4gICAgY29uc3Qgc2FtcFUgPSAyICogd2lkdGggLSAoYmFzZVYgKiAyKSAtIHN0ZXBzIC0gMjtcclxuICAgIGNvbnN0IHNhbXBVTiA9ICgyIC8gd2lkdGgpICogKHNhbXBVICsgMC41KSAtIDE7XHJcbiAgICBjb25zdCBzYW1wMFZOID0gKDEgLyB3aWR0aCkgLSAxO1xyXG4gICAgY29uc3Qgc2FtcDBNYWcyID0gMSArIHNhbXBVTiAqIHNhbXBVTiArIHNhbXAwVk4gKiBzYW1wMFZOO1xyXG4gICAgY29uc3Qgc2FtcDFWTiA9ICgzIC8gd2lkdGgpIC0gMTtcclxuICAgIGNvbnN0IHNhbXAxTWFnMiA9IDEgKyBzYW1wVU4gKiBzYW1wVU4gKyBzYW1wMVZOICogc2FtcDFWTjtcclxuXHJcbiAgICBjb25zdCBkb3QwID0gKHNhbXBVTiArIGJhc2VWTiArIHNhbXAwVk4gKiBiYXNlVU4pXHJcbiAgICAgICAgLyBNYXRoLnNxcnQoc2FtcDBNYWcyICogYmFzZU1hZzIpO1xyXG5cclxuICAgIGNvbnN0IGRvdDEgPSAoc2FtcFVOICsgYmFzZVZOICsgc2FtcDFWTiAqIGJhc2VVTilcclxuICAgICAgICAvIE1hdGguc3FydChzYW1wMU1hZzIgKiBiYXNlTWFnMik7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubWluKDEgLSBkb3QwLCAxIC0gZG90MSk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEdhdXNzaWFuUHlyYW1pZERlc2NyaXB0b3IgPSB7XHJcbiAgICBkZXZpY2U6IEdQVURldmljZSxcclxuICAgIHRleHR1cmU6IEdQVVRleHR1cmUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgSWYgdGhlIHB5cmFtaWQgc2hvdWxkIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgbWlwc1xyXG4gICAgICogIG9mIHRoZSBnaXZlbiB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxyXG4gICAgICovXHJcbiAgICBpblBsYWNlPzogYm9vbGVhbixcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWF4aW11bSB3aWR0aCBvZiB0aGUgc21hbGxlc3QgbWlwIGxldmVsLlxyXG4gICAgICpcclxuICAgICAqICBAZGVmYXVsdFZhbHVlIGA4YFxyXG4gICAgICovXHJcbiAgICBtaW5XaWR0aD86IG51bWJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUga2VybmVsIGV4dGVudCBkaXN0YW5jZSwgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqICBAZGVmYXVsdFZhbHVlIGA0YFxyXG4gICAgICovXHJcbiAgICBzdGVwcz86IG51bWJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqICBBIGZ1bmN0aW9uIHRvIGRlbGF5IHRoZSBwcm9jZXNzaW5nIG9mIGFkZGl0aW9uYWwgcGl4ZWxzLFxyXG4gICAgICogIGUuZy4gYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuIFNwYWNlcyB3b3JrIHRvIGFsbG93IGFkZGl0aW9uYWxcclxuICAgICAqICByZW5kZXJpbmcgYW5kIGludGVyYWN0aXZpdHkgZHVyaW5nIGhlYXZ5IGJsdXJyaW5nIHdvcmtsb2Fkcy5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgdW5kZWZpbmVkLCBhbGwgcGl4ZWxzIGFyZSBwcm9jZXNzZWQgYXQgb25jZS5cclxuICAgICAqL1xyXG4gICAgZGVsYXlXb3JrPzogKGZuOiAoKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZCkgPT4gdm9pZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWF4aW11bSBudW1iZXIgb2YgcGl4ZWxzIHRvIHByb2Nlc3Mgd2l0aGluIGEgYmF0Y2guXHJcbiAgICAgKiAgVW51c2VkIGlmIGBkZWxheVdvcmtgIGlzIHVuZGVmaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiAgQGRlZmF1bHRWYWx1ZSA2ICogKCgxNyAqIDI1NikgKiogMilcclxuICAgICAqXHJcbiAgICAgKiAgQWxsb3dpbmcgY3ViZW1hcCAyNTYgcGl4ZWxzIGluIHdpZHRoIHdpdGggYHN0ZXBzID0gOGAgdG8gcnVuXHJcbiAgICAgKiAgaW4gYSBzaW5nbGUgcGFzcy4gVGhpcyBpcyBhIGNvbnNlcnZhdGl2ZWx5IGxvdyBkZWZhdWx0IGZvclxyXG4gICAgICogIGNvbXBhdGliaWxpdHkgd2l0aCBsb3dlci1lbmQgaGFyZHdhcmUuXHJcbiAgICAgKi9cclxuICAgIG1heE9wc1BlclBhc3M/OiBudW1iZXIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgQSBwcmVmaXggc3RyaW5nIGZvciBlcnJvciBtZXNzYWdlIHRocm93biBmcm9tIHRoZSBmdW5jdGlvblxyXG4gICAgICpcclxuICAgICAqICBAZGVmYXVsdFZhbHVlIGBjdWJlbWFwR3Vhc3NpYW5QeXJhbWlkIC0tYFxyXG4gICAgICovXHJcbiAgICBsYWJlbD86IHN0cmluZyxcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbGFiZWwgdG8gcGFzcyB0aGUgb3V0cHV0IEdQVVRleHR1cmUuXHJcbiAgICAgKlxyXG4gICAgICogIFVudXNlZCBpZiBgaW5QbGFjZSA9PSB0cnVlYFxyXG4gICAgICovXHJcbiAgICBvdXRwdXRUZXh0dXJlTGFiZWw/OiBzdHJpbmcsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBjdWJlbWFwR3Vhc3NpYW5QeXJhbWlkKHtcclxuICAgIGRldmljZSxcclxuICAgIHRleHR1cmUsXHJcbiAgICBvdXRwdXRUZXh0dXJlTGFiZWwsXHJcbiAgICBpblBsYWNlID0gZmFsc2UsXHJcbiAgICBtaW5XaWR0aCA9IDgsXHJcbiAgICBzdGVwcyA9IDQsXHJcbiAgICBtYXhPcHNQZXJQYXNzID0gNiAqICgoMTcgKiAyNTYpICoqIDIpLFxyXG4gICAgbGFiZWwgPSBjdWJlbWFwR3Vhc3NpYW5QeXJhbWlkLm5hbWUsXHJcbiAgICBkZWxheVdvcmssXHJcbn06IEdhdXNzaWFuUHlyYW1pZERlc2NyaXB0b3IpIHtcclxuICAgIGNvbnN0IHsgd2lkdGgsIGZvcm1hdCB9ID0gdGV4dHVyZTtcclxuICAgIGNvbnN0IG1pcExldmVsQ291bnQgPSBpblBsYWNlXHJcbiAgICAgICAgPyB0ZXh0dXJlLm1pcExldmVsQ291bnRcclxuICAgICAgICA6IChNYXRoLmxvZzIod2lkdGgpIC0gTWF0aC5sb2cyKG1pbldpZHRoKSArIDEpO1xyXG5cclxuICAgIGlmIChtaXBMZXZlbENvdW50IDw9IDEpIHJldHVybiB0ZXh0dXJlO1xyXG5cclxuICAgIGNvbnN0IGdyb3VwcyA9IE1hdGgubWluKFxyXG4gICAgICAgIGRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLFxyXG4gICAgICAgIGRldmljZS5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHNoYWRlciA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGNvZGU6IGNyZWF0ZU1pcEJsdXJDb2RlKGdyb3VwcywgZm9ybWF0KSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGJpbmRncm91cExheW91dCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoe1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGVudHJpZXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmluZGluZzogMCxcclxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHsgdmlld0RpbWVuc2lvbjogJzJkLWFycmF5JyB9LFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmluZGluZzogMSxcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2VUZXh0dXJlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzOiAnd3JpdGUtb25seScsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0RpbWVuc2lvbjogJzJkLWFycmF5JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmluZGluZzogMixcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcjogeyB0eXBlOiAncmVhZC1vbmx5LXN0b3JhZ2UnIH0sXHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBwaXBlbGluZSA9IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGxheW91dDogZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtcclxuICAgICAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgICAgIGJpbmRHcm91cExheW91dHM6IFtiaW5kZ3JvdXBMYXlvdXRdLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGNvbXB1dGU6IHtcclxuICAgICAgICAgICAgbW9kdWxlOiBzaGFkZXIsXHJcbiAgICAgICAgICAgIGVudHJ5UG9pbnQ6ICdtYWluJyxcclxuICAgICAgICAgICAgY29uc3RhbnRzOiB7IFNURVBTOiBNYXRoLmNlaWwoc3RlcHMpIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBnYXVzc2lhblB5cmFtaWQgPSB0ZXh0dXJlO1xyXG4gICAgaWYgKCFpblBsYWNlKSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHsgd2lkdGgsIGhlaWdodDogd2lkdGgsIGRlcHRoT3JBcnJheUxheWVyczogNiB9O1xyXG5cclxuICAgICAgICBnYXVzc2lhblB5cmFtaWQgPSBkZXZpY2UuY3JlYXRlVGV4dHVyZSh7XHJcbiAgICAgICAgICAgIGxhYmVsOiBvdXRwdXRUZXh0dXJlTGFiZWwsXHJcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HXHJcbiAgICAgICAgICAgIHwgR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElOR1xyXG4gICAgICAgICAgICB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQ1xyXG4gICAgICAgICAgICB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCxcclxuICAgICAgICAgICAgZGltZW5zaW9uOiAnMmQnLFxyXG4gICAgICAgICAgICBmb3JtYXQsXHJcbiAgICAgICAgICAgIG1pcExldmVsQ291bnQsXHJcbiAgICAgICAgICAgIHNpemUsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvcHlFbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKHtcclxuICAgICAgICAgICAgbGFiZWw6IGAke2xhYmVsfSBjb3B5IGVuY29kZXJgLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb3B5RW5jb2Rlci5jb3B5VGV4dHVyZVRvVGV4dHVyZShcclxuICAgICAgICAgICAgeyB0ZXh0dXJlLCBtaXBMZXZlbDogMCB9LFxyXG4gICAgICAgICAgICB7IHRleHR1cmU6IGdhdXNzaWFuUHlyYW1pZCwgbWlwTGV2ZWw6IDAgfSxcclxuICAgICAgICAgICAgc2l6ZSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBkZXZpY2UucXVldWUuc3VibWl0KFtjb3B5RW5jb2Rlci5maW5pc2goKV0pO1xyXG4gICAgICAgIGF3YWl0IGRldmljZS5xdWV1ZS5vblN1Ym1pdHRlZFdvcmtEb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWlwVmlld3MgPSBtYXBSYW5nZShtaXBMZXZlbENvdW50LCAoaSkgPT4gZ2F1c3NpYW5QeXJhbWlkLmNyZWF0ZVZpZXcoe1xyXG4gICAgICAgIGxhYmVsOiBgJHtsYWJlbH0gbWlwIHZpZXcgJHtpfWAsXHJcbiAgICAgICAgZGltZW5zaW9uOiAnMmQtYXJyYXknLFxyXG4gICAgICAgIGJhc2VNaXBMZXZlbDogaSxcclxuICAgICAgICBtaXBMZXZlbENvdW50OiAxLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIGNvbnN0IG1heFdvcmtncm91cHMgPSBkZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO1xyXG4gICAgY29uc3QgbWF4TGF5ZXJzID0gTWF0aC5jZWlsKE1hdGgubG9nMih3aWR0aCkpO1xyXG4gICAgY29uc3QgbWF4RGlzcGF0Y2hlcyA9IE1hdGgubWF4KFxyXG4gICAgICAgIChtYXhPcHNQZXJQYXNzIC8gKCgoMSArIChzdGVwcyAqIDIpKSAqKiAyKSAqIGdyb3VwcykpIHwgMCxcclxuICAgICAgICAxLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBwcm9wZXJ0eUFycmF5ID0gbmV3IEFycmF5QnVmZmVyKChtYXhMYXllcnMgKyAxKSAqIDQpO1xyXG4gICAgY29uc3Qgb2Zmc2V0ID0gbmV3IFVpbnQzMkFycmF5KHByb3BlcnR5QXJyYXksIDAsIDEpO1xyXG4gICAgY29uc3Qgc2ltZ2FzID0gbmV3IEZsb2F0MzJBcnJheShwcm9wZXJ0eUFycmF5LCA0LCBtYXhMYXllcnMpO1xyXG5cclxuICAgIHNpbWdhcy5zZXQobWFwUmFuZ2UobWF4TGF5ZXJzLCAoaSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHcgPSB3aWR0aCA+PiBpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoMSAtIG1pblN0ZXBEaXN0YW5jZShNYXRoLm1pbih3LCBzdGVwcyksIHcpKSAvIDM7XHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgcHJvcGVydHlCdWZmZXIgPSBjcmVhdGVBbmRDb3B5QnVmZmVyKFxyXG4gICAgICAgIHByb3BlcnR5QXJyYXksXHJcbiAgICAgICAgR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULFxyXG4gICAgICAgIGRldmljZSxcclxuICAgICk7XHJcblxyXG4gICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcclxuICAgICAgICBsZXQgbWlwTGV2ZWwgPSAwO1xyXG4gICAgICAgIGxldCBtaXBQYXNzZXMgPSAwO1xyXG4gICAgICAgIGxldCByZXF1aXJlZE1pcERpc3BhdGNoZXMgPSAwO1xyXG4gICAgICAgIGxldCBjdXJyZW50TWlwRGlzcGF0Y2hlcyA9IDA7XHJcbiAgICAgICAgbGV0IGJhdGNoRGlzcGF0Y2hlcyA9IDA7XHJcbiAgICAgICAgbGV0IGJpbmRncm91cDogR1BVQmluZEdyb3VwO1xyXG5cclxuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5QYXNzKCkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE1pcERpc3BhdGNoZXMgPj0gcmVxdWlyZWRNaXBEaXNwYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBtaXBMZXZlbCArPSAxO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE1pcERpc3BhdGNoZXMgPSAwO1xyXG4gICAgICAgICAgICAgICAgbWlwUGFzc2VzID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWlwTGV2ZWwgPj0gbWlwTGV2ZWxDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWlwUGl4ZWxzID0gNiAqICgod2lkdGggPj4gbWlwTGV2ZWwpICoqIDIpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWRNaXBEaXNwYXRjaGVzID0gTWF0aC5jZWlsKG1pcFBpeGVscyAvIGdyb3Vwcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgYmluZGdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiBiaW5kZ3JvdXBMYXlvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IG1pcFZpZXdzW21pcExldmVsIC0gMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogbWlwVmlld3NbbWlwTGV2ZWxdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHsgYnVmZmVyOiBwcm9wZXJ0eUJ1ZmZlciB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2Zmc2V0WzBdID0gY3VycmVudE1pcERpc3BhdGNoZXMgKiBncm91cHM7XHJcbiAgICAgICAgICAgIGRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihwcm9wZXJ0eUJ1ZmZlciwgMCwgb2Zmc2V0KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhc3NEaXNwYXRjaGVzID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICByZXF1aXJlZE1pcERpc3BhdGNoZXMgLSBjdXJyZW50TWlwRGlzcGF0Y2hlcyxcclxuICAgICAgICAgICAgICAgIG1heERpc3BhdGNoZXMgLSBiYXRjaERpc3BhdGNoZXMsXHJcbiAgICAgICAgICAgICAgICBtYXhXb3JrZ3JvdXBzLFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcGFzc0xhYmVsID0gYCR7bGFiZWx9IG1pcCAke21pcExldmVsfSwgcGFzcyAke21pcFBhc3Nlc31gO1xyXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKHsgbGFiZWw6IHBhc3NMYWJlbCB9KTtcclxuICAgICAgICAgICAgY29uc3QgcGFzcyA9IGVuY29kZXIuYmVnaW5Db21wdXRlUGFzcyh7IGxhYmVsOiBwYXNzTGFiZWwgfSk7XHJcblxyXG4gICAgICAgICAgICBwYXNzLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcclxuICAgICAgICAgICAgcGFzcy5zZXRCaW5kR3JvdXAoMCwgYmluZGdyb3VwKTtcclxuICAgICAgICAgICAgcGFzcy5kaXNwYXRjaFdvcmtncm91cHMocGFzc0Rpc3BhdGNoZXMsIDEsIDEpO1xyXG4gICAgICAgICAgICBwYXNzLmVuZCgpO1xyXG5cclxuICAgICAgICAgICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZW5jb2Rlci5maW5pc2goKV0pO1xyXG5cclxuICAgICAgICAgICAgY3VycmVudE1pcERpc3BhdGNoZXMgKz0gcGFzc0Rpc3BhdGNoZXM7XHJcbiAgICAgICAgICAgIGJhdGNoRGlzcGF0Y2hlcyArPSBwYXNzRGlzcGF0Y2hlcztcclxuICAgICAgICAgICAgbWlwUGFzc2VzICs9IDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVsYXlXb3JrICE9IG51bGwgJiYgYmF0Y2hEaXNwYXRjaGVzID49IG1heERpc3BhdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGJhdGNoRGlzcGF0Y2hlcyA9IDA7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkZXZpY2UucXVldWUub25TdWJtaXR0ZWRXb3JrRG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgZGVsYXlXb3JrKHJ1blBhc3MpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm9pZCBydW5QYXNzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgcnVuUGFzcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGdhdXNzaWFuUHlyYW1pZDtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3156\n")},5427:(module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ getSkyboxOptions)\n/* harmony export */ });\n/* unused harmony export hdrs */\n/* harmony import */ var _utils_texture_importing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8862);\n/* harmony import */ var _utils_texture_processing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9629);\n/* harmony import */ var _property_listener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9528);\n\n\n\nconst hdrPromises = await fetch(\"https://api.github.com/repos/KhronosGroup/glTF-Sample-Environments/contents?ref=low_resolution_hdrs\", { headers: { 'Content-Type': 'application/vnd.github.object+json' } })\n    .then((res) => res.json());\nconst hdrs = Object.fromEntries(hdrPromises.flatMap(({ name, download_url }) => typeof name === 'string' && typeof download_url === 'string' && download_url.endsWith('.hdr') ? [[name, download_url]] : []));\nasync function processSkybox(device, file) {\n    let buffer;\n    if (file instanceof ArrayBuffer) {\n        buffer = file;\n    }\n    else if (file instanceof File) {\n        buffer = await file.arrayBuffer();\n    }\n    else {\n        const res = await fetch(file);\n        buffer = await res.arrayBuffer();\n    }\n    const hdr = (0,_utils_texture_importing__WEBPACK_IMPORTED_MODULE_0__/* .parseHDR */ .y)(buffer);\n    return (0,_utils_texture_processing__WEBPACK_IMPORTED_MODULE_1__/* .equirectangularToCubemap */ .l3)(device, hdr, {\n        format: 'rgba16float',\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n    });\n}\nfunction getSkyboxOptions(target) {\n    return {\n        [_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$type]: 'file',\n        [_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$callback]: async (val, key) => {\n            if (key !== 'value' || val == null)\n                return;\n            if (typeof val === 'string' || val instanceof File) {\n                const texture = await processSkybox(target.device, val);\n                const res = target.setSkybox(texture);\n                if (res instanceof Promise)\n                    await res;\n            }\n        },\n        accept: '.hdr',\n        selection: {\n            value: Object.keys(hdrs)[0],\n            initialValues: hdrs,\n        },\n        process: (file) => file,\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQyNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5RDtBQUNpQjtBQUN2QjtBQUVuRCxNQUFNLFdBQVcsR0FBRyxNQUFNLEtBQUssQ0FBQyxxR0FBYyxFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsY0FBYyxFQUFFLG9DQUFvQyxFQUFFLEVBQUUsQ0FBQztLQUNqSCxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBOEIsQ0FBQztBQUVyRCxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsRUFBRSxFQUFFLENBQUMsT0FBTyxJQUFJLEtBQUssUUFBUSxJQUFJLE9BQU8sWUFBWSxLQUFLLFFBQVEsSUFBSSxZQUFZLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFFck4sS0FBSyxVQUFVLGFBQWEsQ0FBQyxNQUFpQixFQUFFLElBQXVDO0lBQ25GLElBQUksTUFBbUIsQ0FBQztJQUN4QixJQUFJLElBQUksWUFBWSxXQUFXLEVBQUUsQ0FBQztRQUM5QixNQUFNLEdBQUcsSUFBSSxDQUFDO0lBQ2xCLENBQUM7U0FBTSxJQUFJLElBQUksWUFBWSxJQUFJLEVBQUUsQ0FBQztRQUM5QixNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdEMsQ0FBQztTQUFNLENBQUM7UUFDSixNQUFNLEdBQUcsR0FBRyxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM5QixNQUFNLEdBQUcsTUFBTSxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDckMsQ0FBQztJQUVELE1BQU0sR0FBRyxHQUFHLDJFQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFN0IsT0FBTyw2RkFBd0IsQ0FDM0IsTUFBTSxFQUNOLEdBQUcsRUFDSDtRQUNJLE1BQU0sRUFBRSxhQUFhO1FBQ3JCLEtBQUssRUFBRSxlQUFlLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDLFFBQVE7S0FDdEcsQ0FDSixDQUFDO0FBQ04sQ0FBQztBQUljLFNBQVMsZ0JBQWdCLENBQUMsTUFBb0I7SUFDekQsT0FBTztRQUNILENBQUMscUVBQVksQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFlO1FBQ3JDLENBQUMscUVBQVksQ0FBQyxTQUFTLENBQUMsRUFBRSxLQUFLLEVBQUUsR0FBWSxFQUFFLEdBQWdCLEVBQUUsRUFBRTtZQUMvRCxJQUFJLEdBQUcsS0FBSyxPQUFPLElBQUksR0FBRyxJQUFJLElBQUk7Z0JBQUUsT0FBTztZQUMzQyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsSUFBSSxHQUFHLFlBQVksSUFBSSxFQUFFLENBQUM7Z0JBQ2pELE1BQU0sT0FBTyxHQUFHLE1BQU0sYUFBYSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ3hELE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3RDLElBQUksR0FBRyxZQUFZLE9BQU87b0JBQUUsTUFBTSxHQUFHLENBQUM7WUFDMUMsQ0FBQztRQUNMLENBQUM7UUFDRCxNQUFNLEVBQUUsTUFBTTtRQUNkLFNBQVMsRUFBRTtZQUNQLEtBQUssRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzQixhQUFhLEVBQUUsSUFBSTtTQUN0QjtRQUNELE9BQU8sRUFBRSxDQUFDLElBQVUsRUFBRSxFQUFFLENBQUMsSUFBSTtLQUNoQyxDQUFDO0FBQ04sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy9zYW1wbGVzL3NldHRpbmdzL3NreWJveC1vcHRpb25zLnRzP2UxMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VIRFIgfSBmcm9tICcuLi8uLi91dGlscy90ZXh0dXJlLWltcG9ydGluZyc7XG5pbXBvcnQgeyBlcXVpcmVjdGFuZ3VsYXJUb0N1YmVtYXAgfSBmcm9tICcuLi8uLi91dGlscy90ZXh0dXJlLXByb2Nlc3NpbmcnO1xuaW1wb3J0IHsgTGlzdGVuZXJTeW1zIH0gZnJvbSAnLi9wcm9wZXJ0eS1saXN0ZW5lcic7XG5cbmNvbnN0IGhkclByb21pc2VzID0gYXdhaXQgZmV0Y2goSERSX0JBU0VfVVJMX18sIHsgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3ZuZC5naXRodWIub2JqZWN0K2pzb24nIH0gfSlcbiAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdO1xuXG5leHBvcnQgY29uc3QgaGRycyA9IE9iamVjdC5mcm9tRW50cmllcyhoZHJQcm9taXNlcy5mbGF0TWFwKCh7IG5hbWUsIGRvd25sb2FkX3VybCB9KSA9PiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGRvd25sb2FkX3VybCA9PT0gJ3N0cmluZycgJiYgZG93bmxvYWRfdXJsLmVuZHNXaXRoKCcuaGRyJykgPyBbW25hbWUsIGRvd25sb2FkX3VybF1dIDogW10pKTtcblxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NreWJveChkZXZpY2U6IEdQVURldmljZSwgZmlsZTogc3RyaW5nIHwgVVJMIHwgRmlsZSB8IEFycmF5QnVmZmVyKSB7XG4gICAgbGV0IGJ1ZmZlcjogQXJyYXlCdWZmZXI7XG4gICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBidWZmZXIgPSBmaWxlO1xuICAgIH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgYnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGZpbGUpO1xuICAgICAgICBidWZmZXIgPSBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZHIgPSBwYXJzZUhEUihidWZmZXIpO1xuXG4gICAgcmV0dXJuIGVxdWlyZWN0YW5ndWxhclRvQ3ViZW1hcChcbiAgICAgICAgZGV2aWNlLFxuICAgICAgICBoZHIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ3JnYmExNmZsb2F0JyxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQyxcbiAgICAgICAgfSxcbiAgICApO1xufVxuXG5leHBvcnQgdHlwZSBTa3lib3hUYXJnZXQgPSB7IGRldmljZTogR1BVRGV2aWNlLCBzZXRTa3lib3g6IChyZXNvdXJjZTogR1BVVGV4dHVyZSkgPT4gdW5rbm93biB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTa3lib3hPcHRpb25zKHRhcmdldDogU2t5Ym94VGFyZ2V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW0xpc3RlbmVyU3ltcy4kdHlwZV06ICdmaWxlJyBhcyBjb25zdCxcbiAgICAgICAgW0xpc3RlbmVyU3ltcy4kY2FsbGJhY2tdOiBhc3luYyAodmFsOiB1bmtub3duLCBrZXk6IFByb3BlcnR5S2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAndmFsdWUnIHx8IHZhbCA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBhd2FpdCBwcm9jZXNzU2t5Ym94KHRhcmdldC5kZXZpY2UsIHZhbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gdGFyZ2V0LnNldFNreWJveCh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUHJvbWlzZSkgYXdhaXQgcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhY2NlcHQ6ICcuaGRyJyxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgICB2YWx1ZTogT2JqZWN0LmtleXMoaGRycylbMF0sXG4gICAgICAgICAgICBpbml0aWFsVmFsdWVzOiBoZHJzLFxuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzOiAoZmlsZTogRmlsZSkgPT4gZmlsZSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5427\n")},157:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBLDJFQUF5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0J4QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3NoYWRlcnMvYmxpdC12ZXJ0LnNoYWRlci50cz9hNTE4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC8qIHdnc2wgKi9gXHJcbiAgICBzdHJ1Y3QgVmVydE91dCB7XHJcbiAgICAgICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvczogdmVjNGYsXHJcbiAgICAgICAgQGxvY2F0aW9uKDApIHV2OiB2ZWMyZixcclxuICAgIH1cclxuXHJcbiAgICBAdmVydGV4XHJcbiAgICBmbiB2cyhAYnVpbHRpbih2ZXJ0ZXhfaW5kZXgpIGlkeDogdTMyKSAtPiBWZXJ0T3V0IHtcclxuICAgICAgICBjb25zdCBwb3MgPSBhcnJheShcclxuICAgICAgICAgICAgdmVjMmYoLTEsICAzKSxcclxuICAgICAgICAgICAgdmVjMmYoMywgLTEpLFxyXG4gICAgICAgICAgICB2ZWMyZigtMSwgLTEpLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyIHJlczogVmVydE91dDtcclxuICAgICAgICByZXMucG9zID0gdmVjNGYocG9zW2lkeF0sIDAuMCwgMS4wKTtcclxuICAgICAgICByZXMudXYgPSBwb3NbaWR4XSAqIHZlYzJmKDAuNSwgLTAuNSkgKyAwLjU7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuYDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///157\n")},6097:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* binding */ toWorldDir),\n/* harmony export */   X: () => (/* binding */ cubemapSampleConversions)\n/* harmony export */ });\nconst toWorldDir = /* wgsl */ `\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nconst cubemapSampleConversions = /* wgsl */ `\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA5Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTSxVQUFVLEdBQVcsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQzNDLENBQUM7QUFFRjs7R0FFRztBQUNJLE1BQU0sd0JBQXdCLEdBQVcsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThJekQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy9zaGFkZXJzL2N1YmVtYXAtc2FtcGxpbmcuc2hhZGVyLnRzPzZjOTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHRvV29ybGREaXI6IHN0cmluZyA9IC8qIHdnc2wgKi9gXG4gICAgZm4gdG9Xb3JsZERpcihjb29yZDogdmVjM3UsIHNpemU6IHUzMikgLT4gdmVjM2Yge1xuICAgICAgICBsZXQgdXYgPSAoMi4wIC8gZjMyKHNpemUpKSAqICh2ZWMyZihjb29yZC54eSkgKyAwLjUpIC0gMS4wO1xuXG4gICAgICAgIHZhciBwb3M6IHZlYzNmO1xuICAgICAgICBzd2l0Y2ggKGNvb3JkLnopIHtcbiAgICAgICAgICAgIGNhc2UgMCAgeyBwb3MgPSB2ZWMzKCAgMS4wLCAtdXYueSwgLXV2LngpOyB9XG4gICAgICAgICAgICBjYXNlIDEgIHsgcG9zID0gdmVjMyggLTEuMCwgLXV2LnksICB1di54KTsgfVxuICAgICAgICAgICAgY2FzZSAyICB7IHBvcyA9IHZlYzMoIHV2LngsICAgMS4wLCAgdXYueSk7IH1cbiAgICAgICAgICAgIGNhc2UgMyAgeyBwb3MgPSB2ZWMzKCB1di54LCAgLTEuMCwgLXV2LnkpOyB9XG4gICAgICAgICAgICBjYXNlIDQgIHsgcG9zID0gdmVjMyggdXYueCwgLXV2LnksICAgMS4wKTsgfVxuICAgICAgICAgICAgZGVmYXVsdCB7IHBvcyA9IHZlYzMoLXV2LngsIC11di55LCAgLTEuMCk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemUocG9zKTtcbiAgICB9XG5cbiAgICBmbiB0b1dvcmxkRGlyRjMyKGNvb3JkOiB2ZWMyZiwgZmFjZTogdTMyKSAtPiB2ZWMzZiB7XG4gICAgICAgIGxldCB1diA9IDIuMCAqIGNvb3JkIC0gMS4wO1xuXG4gICAgICAgIHZhciBwb3M6IHZlYzNmO1xuICAgICAgICBzd2l0Y2ggKGZhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgMCAgeyBwb3MgPSB2ZWMzKCAgMS4wLCAtdXYueSwgLXV2LngpOyB9XG4gICAgICAgICAgICBjYXNlIDEgIHsgcG9zID0gdmVjMyggLTEuMCwgLXV2LnksICB1di54KTsgfVxuICAgICAgICAgICAgY2FzZSAyICB7IHBvcyA9IHZlYzMoIHV2LngsICAgMS4wLCAgdXYueSk7IH1cbiAgICAgICAgICAgIGNhc2UgMyAgeyBwb3MgPSB2ZWMzKCB1di54LCAgLTEuMCwgLXV2LnkpOyB9XG4gICAgICAgICAgICBjYXNlIDQgIHsgcG9zID0gdmVjMyggdXYueCwgLXV2LnksICAgMS4wKTsgfVxuICAgICAgICAgICAgZGVmYXVsdCB7IHBvcyA9IHZlYzMoLXV2LngsIC11di55LCAgLTEuMCk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemUocG9zKTtcbiAgICB9XG5gO1xuXG4vKipcbiAqICBXR1NMIGZ1bmN0aW9ucyBmb3Igc2FtcGxpbmcgYWNyb3NzIGFkamFjZW50IGZhY2VzIG9mIGEgY3ViZW1hcFxuICovXG5leHBvcnQgY29uc3QgY3ViZW1hcFNhbXBsZUNvbnZlcnNpb25zOiBzdHJpbmcgPSAvKiB3Z3NsICovYFxuICAgIGNvbnN0IElOVkFMSURfRkFDRSA9IDY7XG4gICAgY29uc3QgSU5WQUxJRF9JRFggPSA0Mjk0OTY3Mjk1dTsgLy8gbWF4IHUzMlxuXG4gICAgZm4gY3ViZVNhbXBsZUNvb3JkKGNvb3JkOiB2ZWMzaSwgdzogdTMyKSAtPiB2ZWMzdSB7XG4gICAgICAgIC8vIGEgZmxhdHRlbmVkIG1hdHJpeCBvZiBkZXN0aW5hdGlvbiBmYWNlcyBiYXNlZCBvblxuICAgICAgICAvLyBzdGFydGluZyBmYWNlIGFuZCBkaXJlY3Rpb25cbiAgICAgICAgY29uc3QgZGZhY2VzID0gYXJyYXkoXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJICBVcCBEb3duIExlZnQgUmlnaHQgSW52YWxpZFxuICAgICAgICAgICAgMCwgMiwgMywgNCwgNSwgSU5WQUxJRF9GQUNFLCAvLyArWCAgK1kgICAtWSAgICtaICAgLVogICBcbiAgICAgICAgICAgIDEsIDIsIDMsIDUsIDQsIElOVkFMSURfRkFDRSwgLy8gLVggICtZICAgLVkgICAtWiAgICtaIFxuICAgICAgICAgICAgMiwgNSwgNCwgMSwgMCwgSU5WQUxJRF9GQUNFLCAvLyArWSAgLVogICArWiAgIC1YICAgK1ggXG4gICAgICAgICAgICAzLCA0LCA1LCAxLCAwLCBJTlZBTElEX0ZBQ0UsIC8vIC1ZICArWiAgIC1aICAgLVggICArWCBcbiAgICAgICAgICAgIDQsIDIsIDMsIDEsIDAsIElOVkFMSURfRkFDRSwgLy8gK1ogICtZICAgLVkgICAtWCAgICtYIFxuICAgICAgICAgICAgNSwgMiwgMywgMCwgMSwgSU5WQUxJRF9GQUNFLCAvLyAtWiAgK1kgICAtWSAgICtYICAgLVggXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYSBmbGF0dGVuZWQgbWF0cml4IGluIHRoZSBzYW1lIGZvcm0gYXMgZGZhY2VzXG4gICAgICAgIC8vIGdpdmluZyB0aGUgaW5kZXggb2YgdGhlIGRtYXQgYXJyYXkgY29udGFpbmluZyBcbiAgICAgICAgLy8gdGhlIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIHN0YXJ0aW5nIGZhY2UgdG8gXG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBmYWNlXG4gICAgICAgIGNvbnN0IGRpbmRpY2VzID0gYXJyYXkoXG4gICAgICAgICAgICAwLCAxLCAgMiwgIDMsICA0LCAgMCxcbiAgICAgICAgICAgIDAsIDUsICA2LCAgMywgIDQsICAwLFxuICAgICAgICAgICAgMCwgNywgIDgsICA5LCAgMTAsIDAsXG4gICAgICAgICAgICAwLCAxMSwgMTIsIDEzLCAxNCwgMCxcbiAgICAgICAgICAgIDAsIDExLCA4LCAgMywgIDQsICAwLFxuICAgICAgICAgICAgMCwgNywgIDEyLCAzLCAgNCwgIDAsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gMng0IG1hdHJpY2VzIHRyYW5zZm9ybWluZyBhIGNvb3JkaW5hdGUgdmVjdG9yIDx1LCB2LCB3LCAxPlxuICAgICAgICAvLyBmcm9tIG9uZSBmYWNlIHRvIGFub3RoZXJcbiAgICAgICAgY29uc3QgZG1hdHMgPSBhcnJheShcbiAgICAgICAgICAgIGFycmF5KC8vIDBcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDAsIDApLCAgIC8vIHUgPSB1XG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAwLCAwKSwgICAvLyB2ID0gdlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDEsIDApLCAgIC8vIHUgPSB2ICsgd1xuICAgICAgICAgICAgICAgIHZlYzQoLTEsIDAsIDEsIC0xKSwgLy8gdiA9IHcgLSB1IC0gMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDJcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAyLCAtMSksIC8vIHUgPSAydyAtIHYgLSAxXG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAwLCAwKSwgICAvLyB2ID0gdVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDNcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDEsIDApLCAgIC8vIHUgPSB1ICsgd1xuICAgICAgICAgICAgICAgIHZlYzQoMCwgMSwgMCwgMCksICAgLy8gdiA9IHZcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhcnJheSgvLyA0XG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAtMSwgMCksICAvLyB1ID0gdSAtIHdcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDAsIDApLCAgIC8vIHYgPSB2XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gNVxuICAgICAgICAgICAgICAgIHZlYzQoMCwgLTEsIDAsIC0xKSwgLy8gdSA9IC12IC0gMVxuICAgICAgICAgICAgICAgIHZlYzQoMSwgMCwgMCwgMCksICAgLy8gdiA9IHVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhcnJheSgvLyA2XG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAtMSwgMCksICAvLyB1ID0gdiAtIHdcbiAgICAgICAgICAgICAgICB2ZWM0KC0xLCAwLCAxLCAtMSksIC8vIHYgPSB3IC0gdSAtIDFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhcnJheSgvLyA3XG4gICAgICAgICAgICAgICAgdmVjNCgtMSwgMCwgMSwgLTEpLCAvLyB1ID0gdyAtIHUgLSAxXG4gICAgICAgICAgICAgICAgdmVjNCgwLCAtMSwgMCwgLTEpLCAvLyB2ID0gLXYgLSAxXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gOFxuICAgICAgICAgICAgICAgIHZlYzQoMSwgMCwgMCwgMCksICAgLy8gdSA9IHVcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIC0xLCAwKSwgIC8vIHYgPSB2IC0gd1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDlcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDAsIDApLCAgIC8vIHUgPSB2XG4gICAgICAgICAgICAgICAgdmVjNCgtMSwgMCwgMCwgLTEpLCAvLyB2ID0gLXUgLSAxXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gMTBcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAxLCAtMSksIC8vIHUgPSB3IC0gdiAtIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIC0xLCAwKSwgIC8vIHYgPSB1IC0gd1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDExXG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAwLCAwKSwgICAvLyB1ID0gdVxuICAgICAgICAgICAgICAgIHZlYzQoMCwgMSwgMSwgMCksICAgLy8gdiA9IHYgKyB3XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gMTJcbiAgICAgICAgICAgICAgICB2ZWM0KC0xLCAwLCAxLCAtMSksIC8vIHUgPSB3IC0gdSAtIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAyLCAtMSksIC8vIHYgPSAydyAtIHYgLSAxXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gMTNcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAxLCAtMSksIC8vIHUgPSB3IC0gdiAtIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDEsIDApLCAgIC8vIHYgPSB1ICsgd1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDE0XG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAwLCAwKSwgICAvLyB1ID0gdlxuICAgICAgICAgICAgICAgIHZlYzQoLTEsIDAsIDIsIC0xKSwgLy8gdiA9IDJ3IC0gdSAtIDFcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGl3ID0gaTMyKHcpO1xuXG4gICAgICAgIHZhciBkaXIgPSAwO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb29yZC55ID49IGl3ICogMiAtIDEgXG4gICAgICAgICAgICB8fCBjb29yZC55IDw9IC1pdyBcbiAgICAgICAgICAgIHx8IGNvb3JkLnggPj0gaXcgKiAyIC0gMSBcbiAgICAgICAgICAgIHx8IGNvb3JkLnggPD0gLWl3XG4gICAgICAgICkge1xuICAgICAgICAgICAgZGlyID0gNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb29yZC55IDwgMCkge1xuICAgICAgICAgICAgICAgIGRpciA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvb3JkLnkgPj0gaXcpIHtcbiAgICAgICAgICAgICAgICBkaXIgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvb3JkLnggPCAwKSB7XG4gICAgICAgICAgICAgICAgZGlyID0gc2VsZWN0KDUsIDMsIGRpciA9PSAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29vcmQueCA+PSBpdykge1xuICAgICAgICAgICAgICAgIGRpciA9IHNlbGVjdCg1LCA0LCBkaXIgPT0gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaWR4ID0gY29vcmQueiAqIDYgKyBkaXI7XG4gICAgICAgIGxldCBzYW1wID0gdmVjNChjb29yZC54eSwgaXcsIDEpO1xuICAgICAgICBsZXQgZG1hdCA9IGRtYXRzW2RpbmRpY2VzW2lkeF1dO1xuICAgICAgICByZXR1cm4gdmVjM3UodmVjMyhkb3QoZG1hdFswXSwgc2FtcCksIGRvdChkbWF0WzFdLCBzYW1wKSwgZGZhY2VzW2lkeF0pKTtcbiAgICB9XG5cbiAgICBmbiBjdWJlQ29vcmRUb0lkeChjb29yZDogdmVjM3UsIHc6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkLnggKyBjb29yZC55ICogdyArIGNvb3JkLnogKiB3ICogdztcbiAgICB9XG5cbiAgICBmbiBjdWJlSWR4VG9Db29yZChpZHg6IHUzMiwgdzogdTMyKSAtPiB2ZWMzdSB7XG4gICAgICAgIGxldCB3MiA9IHcgKiB3O1xuICAgICAgICBsZXQgZmlkeCA9IGlkeCAlIHcyO1xuICAgICAgICByZXR1cm4gdmVjM3UoZmlkeCAlIHcsIGZpZHggLyB3LCBpZHggLyB3Mik7XG4gICAgfVxuXG4gICAgZm4gY3ViZVNhbXBsZUlkeCh1dmY6IHZlYzNpLCB3OiB1MzIpIC0+IHUzMiB7XG4gICAgICAgIGxldCBjb29yZCA9IGN1YmVTYW1wbGVDb29yZCh1dmYsIHcpO1xuICAgICAgICByZXR1cm4gc2VsZWN0KFxuICAgICAgICAgICAgY3ViZUNvb3JkVG9JZHgoY29vcmQsIHcpLCBcbiAgICAgICAgICAgIElOVkFMSURfSURYLCBcbiAgICAgICAgICAgIGNvb3JkLnogPT0gSU5WQUxJRF9GQUNFLFxuICAgICAgICApO1xuICAgIH1cbmA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6097\n")},5752:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lr: () => (/* binding */ createAndCopyBuffer),\n/* harmony export */   gU: () => (/* binding */ textureToKTX)\n/* harmony export */ });\n/* unused harmony exports createAndCopyCubemap, ktx2ToTexture, textureToArrayBuffer */\n/* harmony import */ var ktx_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9253);\n/* harmony import */ var _rendering_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3970);\n/* harmony import */ var _general__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4742);\n\n\n\nfunction createAndCopyBuffer(arr, usage, device, label, alignment = 4) {\n    const pad = alignment - 1;\n    const buffer = device.createBuffer({\n        label,\n        usage,\n        size: (arr.byteLength + pad) & ~pad,\n        mappedAtCreation: true,\n    });\n    const writeArray = new Uint8Array(buffer.getMappedRange());\n    const readArray = arr instanceof ArrayBuffer\n        ? new Uint8Array(arr)\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n    writeArray.set(readArray);\n    buffer.unmap();\n    return buffer;\n}\nfunction createAndCopyCubemap(device, data, format, usage, label) {\n    const pixelSize = TextureFormatToSize[format];\n    if (pixelSize == null) {\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\n    }\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\n    const size = { width, height: width, depthOrArrayLayers: 6 };\n    const texture = device.createTexture({\n        usage: usage | GPUTextureUsage.COPY_DST,\n        label,\n        format,\n        size,\n    });\n    device.queue.writeTexture({ texture }, data, { bytesPerRow: width * pixelSize, rowsPerImage: width }, size);\n    return texture;\n}\nfunction ktx2ToTexture(buffer, device, options) {\n    const arr = new Uint8Array(buffer);\n    const ktx = ktxparse.read(arr);\n    const format = VkFormatToWebGPU[ktx.vkFormat];\n    if (format == null) {\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not covert to webgpu`);\n    }\n    const pixelSize = TextureFormatToSize[format];\n    if (pixelSize == null) {\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not get pixel byte size`);\n    }\n    const size = {\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        depthOrArrayLayers: ktx.faceCount,\n    };\n    const maxMipCount = Math.ceil(Math.log2(Math.max(size.width, size.height))) + 1;\n    let mipLevelCount = ktx.levels.length;\n    if (options?.mipLevelCount === 'max') {\n        mipLevelCount = maxMipCount;\n    }\n    else if (typeof options?.mipLevelCount === 'number') {\n        mipLevelCount = Math.min(maxMipCount, options.mipLevelCount);\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (options?.textureUsage)\n        usage |= options.textureUsage;\n    const texture = device.createTexture({\n        label: options?.label,\n        size,\n        mipLevelCount,\n        format,\n        usage,\n    });\n    const mipCopies = Math.min(ktx.levels.length, mipLevelCount) - 1;\n    for (let mipLevel = mipCopies; mipLevel >= 0; mipLevel -= 1) {\n        const width = size.width >> mipLevel;\n        const height = size.height >> mipLevel;\n        const { levelData } = ktx.levels[mipLevel];\n        const rawBytesPerRow = width * pixelSize;\n        const bytesPerRow = Math.max(rawBytesPerRow, 256);\n        const rowsPerImage = height;\n        const bytesPerImage = rowsPerImage * bytesPerRow;\n        let imageData = levelData;\n        if (bytesPerRow > rawBytesPerRow) {\n            imageData = new Uint8Array(bytesPerImage * texture.depthOrArrayLayers);\n            for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\n                for (let w = 0; w < rawBytesPerRow; w += 1) {\n                    imageData[w + h * bytesPerRow] = levelData[w + h * rawBytesPerRow];\n                }\n            }\n        }\n        const layerBatch = Math.min(Math.floor(device.limits.maxBufferSize / bytesPerImage), ktx.faceCount);\n        const layerCount = Math.ceil(ktx.faceCount / layerBatch);\n        for (let l = 0; l < layerCount; l += 1) {\n            const offset = l * layerBatch;\n            const count = Math.min(layerBatch, ktx.faceCount - offset);\n            const data = layerCount > 1\n                ? imageData.subarray(offset * bytesPerImage, (offset + count) * bytesPerImage)\n                : imageData;\n            device.queue.writeTexture({ mipLevel, texture, origin: [0, 0, offset] }, data, { bytesPerRow, rowsPerImage }, [width, height, count]);\n        }\n    }\n    return texture;\n}\nasync function textureToArrayBuffer({ device, texture, mipLevel = 0, returnBuffer, storageBuffer, resultBuffer, description, }) {\n    const pixelSize = _rendering_constants__WEBPACK_IMPORTED_MODULE_0__/* .TextureFormatToSize */ .T2[texture.format];\n    const fullDescription = (0,_general__WEBPACK_IMPORTED_MODULE_1__/* .padTemplate */ .OY) `[textureToKTX${description ?? ''}${texture.label}] --`;\n    if (pixelSize == null) {\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\n    }\n    const width = texture.width >> mipLevel;\n    const height = texture.height >> mipLevel;\n    const rawBytesPerRow = width * pixelSize;\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\n    const rowsPerImage = height;\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\n    }\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\n    }\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\n    }\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\n    const storage = storageBuffer ?? device.createBuffer({\n        label: `${fullDescription} storage buffer`,\n        size: byteSize,\n        usage: requiredUsage,\n    });\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\n    encoder.copyTextureToBuffer({ texture, mipLevel }, { buffer: storage, rowsPerImage, bytesPerRow }, { width, height, depthOrArrayLayers: texture.depthOrArrayLayers });\n    device.queue.submit([encoder.finish()]);\n    await Promise.all([\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\n        device.queue.onSubmittedWorkDone(),\n    ]);\n    const mapped = storage.getMappedRange(0, byteSize);\n    imageData.set(new Uint8Array(mapped));\n    storage.unmap();\n    if (bytesPerRow > rawBytesPerRow) {\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\n            }\n        }\n        imageData = imageData.slice(0, resultSize);\n    }\n    return {\n        imageData,\n        storageBuffer: returnBuffer ? storage : undefined,\n    };\n}\nasync function textureToKTX(device, texture, cube = false) {\n    const pixelSize = _rendering_constants__WEBPACK_IMPORTED_MODULE_0__/* .TextureFormatToSize */ .T2[texture.format];\n    const typeSize = _rendering_constants__WEBPACK_IMPORTED_MODULE_0__/* .TextureFormatToChannelSize */ .GE[texture.format];\n    if (pixelSize == null || typeSize == null) {\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\n    }\n    const container = new ktx_parse__WEBPACK_IMPORTED_MODULE_2__/* .KTX2Container */ .nYd();\n    container.pixelWidth = texture.width;\n    container.pixelHeight = texture.height;\n    container.vkFormat = _rendering_constants__WEBPACK_IMPORTED_MODULE_0__/* .WebGPUToVkFormat */ .KO[texture.format];\n    container.typeSize = typeSize;\n    delete container.keyValue.KTXswizzle;\n    const dataFormat = container.dataFormatDescriptor[0];\n    dataFormat.colorModel = ktx_parse__WEBPACK_IMPORTED_MODULE_2__/* .KHR_DF_MODEL_RGBSDA */ .Tre;\n    dataFormat.transferFunction = ktx_parse__WEBPACK_IMPORTED_MODULE_2__/* .KHR_DF_TRANSFER_LINEAR */ .T5j;\n    dataFormat.bytesPlane[0] = pixelSize;\n    dataFormat.samples = [0, 1, 2, 3].map((i) => ({\n        channelType: [192, 193, 194, 207][i],\n        samplePosition: [0, 0, 0, 0],\n        bitLength: container.typeSize * 8 - 1,\n        bitOffset: container.typeSize * 8 * i,\n        sampleLower: -1082130432,\n        sampleUpper: 1065353216,\n    }));\n    if (texture.dimension === '3d') {\n        container.faceCount = 1;\n        container.pixelDepth = texture.depthOrArrayLayers;\n    }\n    else if (cube) {\n        const cubeLayers = texture.depthOrArrayLayers / 6;\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\n        container.faceCount = 6;\n    }\n    else {\n        container.layerCount = texture.depthOrArrayLayers;\n        container.faceCount = 1;\n    }\n    let storageBuffer;\n    let imageData;\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\n        // eslint-disable-next-line no-await-in-loop\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\n            mipLevel: i,\n            returnBuffer: true,\n            device,\n            texture,\n            storageBuffer,\n        }));\n        container.levels.push({\n            levelData: imageData,\n            uncompressedByteLength: imageData.byteLength,\n        });\n    }\n    return ktx_parse__WEBPACK_IMPORTED_MODULE_2__/* .write */ .M98(container);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUN2RCxRQUFRLEVBQUUsQ0FBQztZQUNYLFlBQVksRUFBRSxJQUFJO1lBQ2xCLE1BQU07WUFDTixPQUFPO1lBQ1AsYUFBYTtTQUNoQixDQUFDLENBQUMsQ0FBQztRQUVKLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2xCLFNBQVMsRUFBRSxTQUFTO1lBQ3BCLHNCQUFzQixFQUFFLFNBQVMsQ0FBQyxVQUFVO1NBQy9DLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRCxPQUFPLHVEQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDckMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy91dGlscy9kYXRhLWNvcHkudHM/YmE1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBrdHhwYXJzZSBmcm9tICdrdHgtcGFyc2UnO1xyXG5cclxuaW1wb3J0IHsgVmtGb3JtYXRUb1dlYkdQVSwgVGV4dHVyZUZvcm1hdFRvU2l6ZSwgVGV4dHVyZUZvcm1hdFRvQ2hhbm5lbFNpemUsIFdlYkdQVVRvVmtGb3JtYXQgfSBmcm9tICcuLi9yZW5kZXJpbmcvY29uc3RhbnRzJztcclxuaW1wb3J0IHsgcGFkVGVtcGxhdGUgfSBmcm9tICcuL2dlbmVyYWwnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFuZENvcHlCdWZmZXIoXHJcbiAgICBhcnI6IEFycmF5QnVmZmVyIHwgVHlwZWRBcnJheUxpa2UsXHJcbiAgICB1c2FnZTogR1BVRmxhZ3NDb25zdGFudCxcclxuICAgIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgbGFiZWw/OiBzdHJpbmcsXHJcbiAgICBhbGlnbm1lbnQgPSA0LFxyXG4pOiBHUFVCdWZmZXIge1xyXG4gICAgY29uc3QgcGFkID0gYWxpZ25tZW50IC0gMTtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIHVzYWdlLFxyXG4gICAgICAgIHNpemU6IChhcnIuYnl0ZUxlbmd0aCArIHBhZCkgJiB+cGFkLFxyXG4gICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXHJcbiAgICB9IGFzIEdQVUJ1ZmZlckRlc2NyaXB0b3IpO1xyXG5cclxuICAgIGNvbnN0IHdyaXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSk7XHJcbiAgICBjb25zdCByZWFkQXJyYXkgPSBhcnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxyXG4gICAgICAgID8gbmV3IFVpbnQ4QXJyYXkoYXJyKVxyXG4gICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcclxuXHJcbiAgICB3cml0ZUFycmF5LnNldChyZWFkQXJyYXkpO1xyXG4gICAgYnVmZmVyLnVubWFwKCk7XHJcblxyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFuZENvcHlDdWJlbWFwKFxyXG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXHJcbiAgICBkYXRhOiBBcnJheUJ1ZmZlcixcclxuICAgIGZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCxcclxuICAgIHVzYWdlOiBudW1iZXIsXHJcbiAgICBsYWJlbD86IHN0cmluZyxcclxuKSB7XHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW2Zvcm1hdF07XHJcbiAgICBpZiAocGl4ZWxTaXplID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvcHkgY3ViZW1hcCAtLSB1bnN1cHBvcnRlZCBmb3JtYXQ6ICR7Zm9ybWF0fWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5zcXJ0KGRhdGEuYnl0ZUxlbmd0aCAvICg2ICogcGl4ZWxTaXplKSk7XHJcbiAgICBjb25zdCBzaXplID0geyB3aWR0aCwgaGVpZ2h0OiB3aWR0aCwgZGVwdGhPckFycmF5TGF5ZXJzOiA2IH07XHJcblxyXG4gICAgY29uc3QgdGV4dHVyZSA9IGRldmljZS5jcmVhdGVUZXh0dXJlKHtcclxuICAgICAgICB1c2FnZTogdXNhZ2UgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1QsXHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgZm9ybWF0LFxyXG4gICAgICAgIHNpemUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXZpY2UucXVldWUud3JpdGVUZXh0dXJlKFxyXG4gICAgICAgIHsgdGV4dHVyZSB9LFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgeyBieXRlc1BlclJvdzogd2lkdGggKiBwaXhlbFNpemUsIHJvd3NQZXJJbWFnZTogd2lkdGggfSxcclxuICAgICAgICBzaXplLFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgS1RYSW1wb3J0T3B0aW9ucyA9IHtcclxuICAgIGxhYmVsPzogc3RyaW5nLFxyXG4gICAgbWlwTGV2ZWxDb3VudD86IG51bWJlciB8ICdtYXgnIHwgJ2RlZmF1bHQnLFxyXG4gICAgdGV4dHVyZVVzYWdlPzogbnVtYmVyLFxyXG4gICAgdmFsaWRhdGU/OiBib29sZWFuLFxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGt0eDJUb1RleHR1cmUoXHJcbiAgICBidWZmZXI6IEFycmF5QnVmZmVyLFxyXG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXHJcbiAgICBvcHRpb25zPzogS1RYSW1wb3J0T3B0aW9ucyxcclxuKSB7XHJcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgY29uc3Qga3R4ID0ga3R4cGFyc2UucmVhZChhcnIpO1xyXG4gICAgY29uc3QgZm9ybWF0ID0gVmtGb3JtYXRUb1dlYkdQVVtrdHgudmtGb3JtYXRdO1xyXG5cclxuICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihga3R4IHRleHR1cmUgaW1wb3J0IC0tIHVuc3VwcG9ydGVkIGZvcm1hdDogJHtrdHgudmtGb3JtYXR9XFxuXFx0Q291bGQgbm90IGNvdmVydCB0byB3ZWJncHVgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW2Zvcm1hdF07XHJcbiAgICBpZiAocGl4ZWxTaXplID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGt0eCB0ZXh0dXJlIGltcG9ydCAtLSB1bnN1cHBvcnRlZCBmb3JtYXQ6ICR7a3R4LnZrRm9ybWF0fVxcblxcdENvdWxkIG5vdCBnZXQgcGl4ZWwgYnl0ZSBzaXplYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2l6ZSA9IHtcclxuICAgICAgICB3aWR0aDoga3R4LnBpeGVsV2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBrdHgucGl4ZWxIZWlnaHQsXHJcbiAgICAgICAgZGVwdGhPckFycmF5TGF5ZXJzOiBrdHguZmFjZUNvdW50LFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBtYXhNaXBDb3VudCA9IE1hdGguY2VpbChNYXRoLmxvZzIoTWF0aC5tYXgoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpKSkgKyAxO1xyXG4gICAgbGV0IG1pcExldmVsQ291bnQgPSBrdHgubGV2ZWxzLmxlbmd0aDtcclxuICAgIGlmIChvcHRpb25zPy5taXBMZXZlbENvdW50ID09PSAnbWF4Jykge1xyXG4gICAgICAgIG1pcExldmVsQ291bnQgPSBtYXhNaXBDb3VudDtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnM/Lm1pcExldmVsQ291bnQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgbWlwTGV2ZWxDb3VudCA9IE1hdGgubWluKG1heE1pcENvdW50LCBvcHRpb25zLm1pcExldmVsQ291bnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB1c2FnZSA9IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1Q7XHJcbiAgICBpZiAob3B0aW9ucz8udGV4dHVyZVVzYWdlKSB1c2FnZSB8PSBvcHRpb25zLnRleHR1cmVVc2FnZTtcclxuXHJcbiAgICBjb25zdCB0ZXh0dXJlID0gZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xyXG4gICAgICAgIGxhYmVsOiBvcHRpb25zPy5sYWJlbCxcclxuICAgICAgICBzaXplLFxyXG4gICAgICAgIG1pcExldmVsQ291bnQsXHJcbiAgICAgICAgZm9ybWF0LFxyXG4gICAgICAgIHVzYWdlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbWlwQ29waWVzID0gTWF0aC5taW4oa3R4LmxldmVscy5sZW5ndGgsIG1pcExldmVsQ291bnQpIC0gMTtcclxuXHJcbiAgICBmb3IgKGxldCBtaXBMZXZlbCA9IG1pcENvcGllczsgbWlwTGV2ZWwgPj0gMDsgbWlwTGV2ZWwgLT0gMSkge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gc2l6ZS53aWR0aCA+PiBtaXBMZXZlbDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBzaXplLmhlaWdodCA+PiBtaXBMZXZlbDtcclxuICAgICAgICBjb25zdCB7IGxldmVsRGF0YSB9ID0ga3R4LmxldmVsc1ttaXBMZXZlbF07XHJcblxyXG4gICAgICAgIGNvbnN0IHJhd0J5dGVzUGVyUm93ID0gd2lkdGggKiBwaXhlbFNpemU7XHJcbiAgICAgICAgY29uc3QgYnl0ZXNQZXJSb3cgPSBNYXRoLm1heChyYXdCeXRlc1BlclJvdywgMjU2KTtcclxuICAgICAgICBjb25zdCByb3dzUGVySW1hZ2UgPSBoZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgYnl0ZXNQZXJJbWFnZSA9IHJvd3NQZXJJbWFnZSAqIGJ5dGVzUGVyUm93O1xyXG5cclxuICAgICAgICBsZXQgaW1hZ2VEYXRhID0gbGV2ZWxEYXRhO1xyXG4gICAgICAgIGlmIChieXRlc1BlclJvdyA+IHJhd0J5dGVzUGVyUm93KSB7XHJcbiAgICAgICAgICAgIGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzUGVySW1hZ2UgKiB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBoID0gMDsgaCA8IGhlaWdodCAqIHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzOyBoICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgcmF3Qnl0ZXNQZXJSb3c7IHcgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YVt3ICsgaCAqIGJ5dGVzUGVyUm93XSA9IGxldmVsRGF0YVt3ICsgaCAqIHJhd0J5dGVzUGVyUm93XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbGF5ZXJCYXRjaCA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICBNYXRoLmZsb29yKGRldmljZS5saW1pdHMubWF4QnVmZmVyU2l6ZSAvIGJ5dGVzUGVySW1hZ2UpLFxyXG4gICAgICAgICAgICBrdHguZmFjZUNvdW50LFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgbGF5ZXJDb3VudCA9IE1hdGguY2VpbChrdHguZmFjZUNvdW50IC8gbGF5ZXJCYXRjaCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgbGF5ZXJDb3VudDsgbCArPSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGwgKiBsYXllckJhdGNoO1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKGxheWVyQmF0Y2gsIGt0eC5mYWNlQ291bnQgLSBvZmZzZXQpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGxheWVyQ291bnQgPiAxXHJcbiAgICAgICAgICAgICAgICA/IGltYWdlRGF0YS5zdWJhcnJheShvZmZzZXQgKiBieXRlc1BlckltYWdlLCAob2Zmc2V0ICsgY291bnQpICogYnl0ZXNQZXJJbWFnZSlcclxuICAgICAgICAgICAgICAgIDogaW1hZ2VEYXRhO1xyXG5cclxuICAgICAgICAgICAgZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZShcclxuICAgICAgICAgICAgICAgIHsgbWlwTGV2ZWwsIHRleHR1cmUsIG9yaWdpbjogWzAsIDAsIG9mZnNldF0gfSxcclxuICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICB7IGJ5dGVzUGVyUm93LCByb3dzUGVySW1hZ2UgfSxcclxuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0LCBjb3VudF0sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBUZXh0dXJlVG9BcnJheUJ1ZmZlck9wdGlvbnMgPSB7XHJcbiAgICBkZXZpY2U6IEdQVURldmljZSxcclxuICAgIHRleHR1cmU6IEdQVVRleHR1cmUsXHJcbiAgICBtaXBMZXZlbD86IG51bWJlcixcclxuICAgIHJlc3VsdEJ1ZmZlcj86IFVpbnQ4QXJyYXksXHJcbiAgICBzdG9yYWdlQnVmZmVyPzogR1BVQnVmZmVyLFxyXG4gICAgcmV0dXJuQnVmZmVyPzogYm9vbGVhbixcclxuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxyXG59O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRleHR1cmVUb0FycmF5QnVmZmVyKFxyXG4gICAgb3B0aW9uczogT21pdDxUZXh0dXJlVG9BcnJheUJ1ZmZlck9wdGlvbnMsICdyZXR1cm5CdWZmZXInPiAmIHsgcmV0dXJuQnVmZmVyPzogZmFsc2UgfSxcclxuKTogUHJvbWlzZTx7IGltYWdlRGF0YTogVWludDhBcnJheSB9PjtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0ZXh0dXJlVG9BcnJheUJ1ZmZlcihcclxuICAgIG9wdGlvbnM6IE9taXQ8VGV4dHVyZVRvQXJyYXlCdWZmZXJPcHRpb25zLCAncmV0dXJuQnVmZmVyJz4gJiB7IHJldHVybkJ1ZmZlcjogdHJ1ZSB9LFxyXG4pOiBQcm9taXNlPHsgaW1hZ2VEYXRhOiBVaW50OEFycmF5LCBzdG9yYWdlQnVmZmVyOiBHUFVCdWZmZXIgfT47XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGV4dHVyZVRvQXJyYXlCdWZmZXIoe1xyXG4gICAgZGV2aWNlLFxyXG4gICAgdGV4dHVyZSxcclxuICAgIG1pcExldmVsID0gMCxcclxuICAgIHJldHVybkJ1ZmZlcixcclxuICAgIHN0b3JhZ2VCdWZmZXIsXHJcbiAgICByZXN1bHRCdWZmZXIsXHJcbiAgICBkZXNjcmlwdGlvbixcclxufTogVGV4dHVyZVRvQXJyYXlCdWZmZXJPcHRpb25zKSB7XHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW3RleHR1cmUuZm9ybWF0XTtcclxuICAgIGNvbnN0IGZ1bGxEZXNjcmlwdGlvbiA9IHBhZFRlbXBsYXRlYFt0ZXh0dXJlVG9LVFgke2Rlc2NyaXB0aW9uID8/ICcnfSR7dGV4dHVyZS5sYWJlbH1dIC0tYDtcclxuXHJcbiAgICBpZiAocGl4ZWxTaXplID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVsbERlc2NyaXB0aW9ufSBmb3JtYXQgJHt0ZXh0dXJlLmZvcm1hdH0gdW5zdXBwb3J0ZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB3aWR0aCA9IHRleHR1cmUud2lkdGggPj4gbWlwTGV2ZWw7XHJcbiAgICBjb25zdCBoZWlnaHQgPSB0ZXh0dXJlLmhlaWdodCA+PiBtaXBMZXZlbDtcclxuICAgIGNvbnN0IHJhd0J5dGVzUGVyUm93ID0gd2lkdGggKiBwaXhlbFNpemU7XHJcbiAgICBjb25zdCBieXRlc1BlclJvdyA9IE1hdGgubWF4KHJhd0J5dGVzUGVyUm93LCAyNTYpO1xyXG4gICAgY29uc3Qgcm93c1BlckltYWdlID0gaGVpZ2h0O1xyXG4gICAgY29uc3QgYnl0ZVNpemUgPSByb3dzUGVySW1hZ2UgKiBieXRlc1BlclJvdyAqIHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzO1xyXG4gICAgY29uc3QgcmVzdWx0U2l6ZSA9IHJhd0J5dGVzUGVyUm93ICogaGVpZ2h0ICogdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnM7XHJcblxyXG4gICAgaWYgKHJlc3VsdEJ1ZmZlciAhPSBudWxsICYmIHJlc3VsdEJ1ZmZlci5ieXRlTGVuZ3RoIDwgYnl0ZVNpemUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVsbERlc2NyaXB0aW9ufSBnaXZlbiByZXN1bHQgYXJyYXkgbm90IGxhcmdlIGVub3VnaC5cclxuJHtyZXN1bHRCdWZmZXIuYnl0ZUxlbmd0aH0gPCAke2J5dGVTaXplfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdG9yYWdlQnVmZmVyICE9IG51bGwgJiYgc3RvcmFnZUJ1ZmZlci5zaXplIDwgYnl0ZVNpemUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVsbERlc2NyaXB0aW9ufSBnaXZlbiBzdG9yYWdlIGJ1ZmZlciBub3QgbGFyZ2UgZW5vdWdoLlxyXG4ke3N0b3JhZ2VCdWZmZXIuc2l6ZX0gPCAke2J5dGVTaXplfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlcXVpcmVkVXNhZ2UgPSBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEO1xyXG5cclxuICAgIGlmIChzdG9yYWdlQnVmZmVyICE9IG51bGwgJiYgKHN0b3JhZ2VCdWZmZXIudXNhZ2UgJiByZXF1aXJlZFVzYWdlKSAhPT0gcmVxdWlyZWRVc2FnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdWxsRGVzY3JpcHRpb259IGdpdmVuIHN0b3JhZ2UgZG9lcyBub3QgaGF2ZSBjb3JyZWN0IHVzYWdlIGZsYWdzLlxyXG5HaXZlbjogJHtzdG9yYWdlQnVmZmVyLnVzYWdlfVxyXG5SZXF1aXJlZDogJHtyZXF1aXJlZFVzYWdlfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpbWFnZURhdGEgPSByZXN1bHRCdWZmZXIgPz8gbmV3IFVpbnQ4QXJyYXkoYnl0ZVNpemUpO1xyXG4gICAgY29uc3Qgc3RvcmFnZSA9IHN0b3JhZ2VCdWZmZXIgPz8gZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XHJcbiAgICAgICAgbGFiZWw6IGAke2Z1bGxEZXNjcmlwdGlvbn0gc3RvcmFnZSBidWZmZXJgLFxyXG4gICAgICAgIHNpemU6IGJ5dGVTaXplLFxyXG4gICAgICAgIHVzYWdlOiByZXF1aXJlZFVzYWdlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgZW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2Rlcih7IGxhYmVsOiBgJHtmdWxsRGVzY3JpcHRpb259IGVuY29kZXJgIH0pO1xyXG4gICAgZW5jb2Rlci5jb3B5VGV4dHVyZVRvQnVmZmVyKFxyXG4gICAgICAgIHsgdGV4dHVyZSwgbWlwTGV2ZWwgfSxcclxuICAgICAgICB7IGJ1ZmZlcjogc3RvcmFnZSwgcm93c1BlckltYWdlLCBieXRlc1BlclJvdyB9LFxyXG4gICAgICAgIHsgd2lkdGgsIGhlaWdodCwgZGVwdGhPckFycmF5TGF5ZXJzOiB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycyB9LFxyXG4gICAgKTtcclxuICAgIGRldmljZS5xdWV1ZS5zdWJtaXQoW2VuY29kZXIuZmluaXNoKCldKTtcclxuXHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgc3RvcmFnZS5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQsIDAsIGJ5dGVTaXplKSxcclxuICAgICAgICBkZXZpY2UucXVldWUub25TdWJtaXR0ZWRXb3JrRG9uZSgpLFxyXG4gICAgXSk7XHJcblxyXG4gICAgY29uc3QgbWFwcGVkID0gc3RvcmFnZS5nZXRNYXBwZWRSYW5nZSgwLCBieXRlU2l6ZSk7XHJcbiAgICBpbWFnZURhdGEuc2V0KG5ldyBVaW50OEFycmF5KG1hcHBlZCkpO1xyXG4gICAgc3RvcmFnZS51bm1hcCgpO1xyXG5cclxuICAgIGlmIChieXRlc1BlclJvdyA+IHJhd0J5dGVzUGVyUm93KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCBoZWlnaHQgKiB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVyczsgaCArPSAxKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgcmF3Qnl0ZXNQZXJSb3c7IHcgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhW3cgKyBoICogcmF3Qnl0ZXNQZXJSb3ddID0gaW1hZ2VEYXRhW3cgKyBoICogYnl0ZXNQZXJSb3ddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGltYWdlRGF0YSA9IGltYWdlRGF0YS5zbGljZSgwLCByZXN1bHRTaXplKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGltYWdlRGF0YSxcclxuICAgICAgICBzdG9yYWdlQnVmZmVyOiByZXR1cm5CdWZmZXIgPyBzdG9yYWdlIDogdW5kZWZpbmVkLFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRleHR1cmVUb0tUWChkZXZpY2U6IEdQVURldmljZSwgdGV4dHVyZTogR1BVVGV4dHVyZSwgY3ViZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW3RleHR1cmUuZm9ybWF0XTtcclxuICAgIGNvbnN0IHR5cGVTaXplID0gVGV4dHVyZUZvcm1hdFRvQ2hhbm5lbFNpemVbdGV4dHVyZS5mb3JtYXRdO1xyXG5cclxuICAgIGlmIChwaXhlbFNpemUgPT0gbnVsbCB8fCB0eXBlU2l6ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZXh0dXJlVG9LVFggLS0gZm9ybWF0ICR7dGV4dHVyZS5mb3JtYXR9IG9mICR7dGV4dHVyZS5sYWJlbH0gdW5zdXBwb3J0ZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcga3R4cGFyc2UuS1RYMkNvbnRhaW5lcigpO1xyXG4gICAgY29udGFpbmVyLnBpeGVsV2lkdGggPSB0ZXh0dXJlLndpZHRoO1xyXG4gICAgY29udGFpbmVyLnBpeGVsSGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQ7XHJcbiAgICBjb250YWluZXIudmtGb3JtYXQgPSBXZWJHUFVUb1ZrRm9ybWF0W3RleHR1cmUuZm9ybWF0XTtcclxuICAgIGNvbnRhaW5lci50eXBlU2l6ZSA9IHR5cGVTaXplO1xyXG4gICAgZGVsZXRlIGNvbnRhaW5lci5rZXlWYWx1ZS5LVFhzd2l6emxlO1xyXG5cclxuICAgIGNvbnN0IGRhdGFGb3JtYXQgPSBjb250YWluZXIuZGF0YUZvcm1hdERlc2NyaXB0b3JbMF07XHJcbiAgICBkYXRhRm9ybWF0LmNvbG9yTW9kZWwgPSBrdHhwYXJzZS5LSFJfREZfTU9ERUxfUkdCU0RBO1xyXG4gICAgZGF0YUZvcm1hdC50cmFuc2ZlckZ1bmN0aW9uID0ga3R4cGFyc2UuS0hSX0RGX1RSQU5TRkVSX0xJTkVBUjtcclxuICAgIGRhdGFGb3JtYXQuYnl0ZXNQbGFuZVswXSA9IHBpeGVsU2l6ZTtcclxuXHJcbiAgICBkYXRhRm9ybWF0LnNhbXBsZXMgPSBbMCwgMSwgMiwgM10ubWFwKChpKSA9PiAoe1xyXG4gICAgICAgIGNoYW5uZWxUeXBlOiBbMTkyLCAxOTMsIDE5NCwgMjA3XVtpXSxcclxuICAgICAgICBzYW1wbGVQb3NpdGlvbjogWzAsIDAsIDAsIDBdLFxyXG4gICAgICAgIGJpdExlbmd0aDogY29udGFpbmVyLnR5cGVTaXplICogOCAtIDEsXHJcbiAgICAgICAgYml0T2Zmc2V0OiBjb250YWluZXIudHlwZVNpemUgKiA4ICogaSxcclxuICAgICAgICBzYW1wbGVMb3dlcjogLTEwODIxMzA0MzIsXHJcbiAgICAgICAgc2FtcGxlVXBwZXI6IDEwNjUzNTMyMTYsXHJcbiAgICB9KSk7XHJcblxyXG4gICAgaWYgKHRleHR1cmUuZGltZW5zaW9uID09PSAnM2QnKSB7XHJcbiAgICAgICAgY29udGFpbmVyLmZhY2VDb3VudCA9IDE7XHJcbiAgICAgICAgY29udGFpbmVyLnBpeGVsRGVwdGggPSB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycztcclxuICAgIH0gZWxzZSBpZiAoY3ViZSkge1xyXG4gICAgICAgIGNvbnN0IGN1YmVMYXllcnMgPSB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycyAvIDY7XHJcbiAgICAgICAgY29udGFpbmVyLmxheWVyQ291bnQgPSBjdWJlTGF5ZXJzID09PSAxID8gMCA6IGN1YmVMYXllcnM7XHJcbiAgICAgICAgY29udGFpbmVyLmZhY2VDb3VudCA9IDY7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnRhaW5lci5sYXllckNvdW50ID0gdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnM7XHJcbiAgICAgICAgY29udGFpbmVyLmZhY2VDb3VudCA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0b3JhZ2VCdWZmZXI6IEdQVUJ1ZmZlciB8IHVuZGVmaW5lZDtcclxuICAgIGxldCBpbWFnZURhdGE6IFVpbnQ4QXJyYXk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlLm1pcExldmVsQ291bnQ7IGkgKz0gMSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXHJcbiAgICAgICAgKHsgaW1hZ2VEYXRhLCBzdG9yYWdlQnVmZmVyIH0gPSBhd2FpdCB0ZXh0dXJlVG9BcnJheUJ1ZmZlcih7XHJcbiAgICAgICAgICAgIG1pcExldmVsOiBpLFxyXG4gICAgICAgICAgICByZXR1cm5CdWZmZXI6IHRydWUsXHJcbiAgICAgICAgICAgIGRldmljZSxcclxuICAgICAgICAgICAgdGV4dHVyZSxcclxuICAgICAgICAgICAgc3RvcmFnZUJ1ZmZlcixcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lci5sZXZlbHMucHVzaCh7XHJcbiAgICAgICAgICAgIGxldmVsRGF0YTogaW1hZ2VEYXRhLFxyXG4gICAgICAgICAgICB1bmNvbXByZXNzZWRCeXRlTGVuZ3RoOiBpbWFnZURhdGEuYnl0ZUxlbmd0aCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ga3R4cGFyc2Uud3JpdGUoY29udGFpbmVyKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5752\n")},8862:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  y: () => (/* binding */ parseHDR)\n});\n\n// UNUSED EXPORTS: imageToTexture\n\n;// ./src/utils/data-conversion.ts\nconst { baseTable, shiftTable } = (() => {\n    const baseTable = new Uint32Array(256);\n    const shiftTable = new Uint32Array(256);\n    for (let i = 0; i < 255; ++i) {\n        const e = i - 127;\n        if (e < -27) { // very small number (0, -0)\n            baseTable[i] = 0x0000;\n            shiftTable[i] = 24;\n        }\n        else if (e < -14) { // small number (denorm)\n            baseTable[i] = 0x0400 >> (-e - 14);\n            shiftTable[i] = -e - 1;\n        }\n        else if (e <= 15) { // normal number\n            baseTable[i] = (e + 15) << 10;\n            shiftTable[i] = 13;\n        }\n        else { // e < 128, large number (Infinity, -Infinity)\n            baseTable[i] = 0x7c00;\n            shiftTable[i] = 24;\n        }\n    }\n    // e == 128, stay (NaN, Infinity, -Infinity)\n    baseTable[255] = 0x7c00;\n    shiftTable[255] = 13;\n    return { baseTable, shiftTable };\n})();\nconst conversionBuffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(conversionBuffer);\nconst uintView = new Uint32Array(conversionBuffer);\nfunction toFloat16Bytes(val) {\n    floatView[0] = val;\n    const f = uintView[0];\n    const e = (f >> 23) & 0x1ff;\n    const idx = e & 0xff;\n    return baseTable[idx] + ((f & 0x007fffff) >> shiftTable[idx]) + ((e & 0x100) << 7);\n}\n\n// EXTERNAL MODULE: ./src/utils/texture-processing.ts\nvar texture_processing = __webpack_require__(9629);\n;// ./src/utils/texture-importing.ts\n\n\nasync function imageToTexture({ device, data, mimeType, usage = GPUTextureUsage.TEXTURE_BINDING, mips = true, format = 'rgba8unorm', colorSpace = 'srgb', label = '', srgbToLinear, }) {\n    let bitmap;\n    if (data instanceof ImageBitmap) {\n        bitmap = data;\n    }\n    else {\n        const blob = (data instanceof Blob || data instanceof File)\n            ? data\n            : new Blob([data], { type: mimeType });\n        bitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n    }\n    const size = { width: bitmap.width, height: bitmap.height };\n    const texture = device.createTexture({\n        label,\n        format,\n        size: size,\n        usage: usage | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: mips ? 1 + (Math.log2(Math.max(bitmap.width, bitmap.height)) | 0) : 1,\n    });\n    device.queue.copyExternalImageToTexture({ source: bitmap }, { texture, colorSpace }, size);\n    if (srgbToLinear)\n        srgbTextureToLinear(device, texture);\n    if (mips)\n        void generateMips(device, texture);\n    return texture;\n}\nfunction parseHDR(inData) {\n    const decoder = new TextDecoder();\n    const buffer = inData instanceof Uint8Array ? inData : new Uint8Array(inData);\n    let pos = 0;\n    const getLine = (lineLimit = 1024) => {\n        const limit = Math.min(buffer.length, lineLimit + pos);\n        const sub = buffer.subarray(pos, limit);\n        const end = sub.indexOf(0x0A) + 1;\n        pos += end;\n        return end === 0 ? undefined : decoder.decode(sub.subarray(0, end));\n    };\n    const importError = (msg) => new Error('HDR Import Error: ' + msg);\n    // #region Read Header\n    const magicTokenRegex = /^#\\?(\\S+)/;\n    const magicTokenLine = getLine();\n    if (magicTokenLine == null)\n        throw importError('no header found');\n    if (!magicTokenRegex.test(magicTokenLine))\n        throw importError('bad initial token');\n    const headerRegs = [\n        /FORMAT=(?<format>\\S+)/, // format\n        /-Y\\s+(?<Y>\\d+)\\s+\\+X\\s+(?<X>\\d+)/, // size\n        /EXPOSURE\\s*=\\s*(?<exposure>\\d+(\\.\\d+)?)/, // exposure\n        /GAMMA\\s*=\\s*(?<gamma>\\d+(\\.\\d+)?)/, // gamma\n    ];\n    const headerReg = new RegExp(`^\\\\s*(${headerRegs.map(({ source }) => `(${source})`).join('|')})\\\\s*$`);\n    let noFormat = true;\n    let gamma = 1; /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n    let exposure = 1; /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n    let width = undefined;\n    let height = undefined;\n    for (let line = getLine(); line != null; line = width == null ? getLine() : undefined) {\n        const groups = line.match(headerReg)?.groups;\n        if (groups == null)\n            continue;\n        if (groups.format != null) {\n            noFormat = false;\n        }\n        else if (groups.X != null && groups.Y != null) {\n            width = parseInt(groups.X);\n            height = parseInt(groups.Y);\n        }\n        else if (groups.gamma != null) {\n            gamma = parseFloat(groups.gamma);\n        }\n        else if (groups.exposure != null) {\n            exposure = parseFloat(groups.exposure);\n        }\n    }\n    if (noFormat)\n        throw importError('missing format specifier');\n    if (width == null || height == null)\n        throw importError('missing image size specifier');\n    // #endregion\n    // #region Read Scanline Data\n    let rawData;\n    const unencodable = width < 8 || width > 0x7fff;\n    const flatData = buffer[pos] !== 2 || buffer[pos + 1] !== 2 || (buffer[pos + 2] & 0x80) !== 0;\n    if (unencodable || flatData) {\n        rawData = buffer.subarray(pos);\n    }\n    else {\n        rawData = new Uint8Array(width * height * 4);\n        const end = 4 * width;\n        const scanline_buffer = new Uint8Array(end);\n        const len = buffer.byteLength;\n        for (let k = 0, offset = 0; k < height && pos < len; k++) {\n            if (pos + 4 > len)\n                throw importError('file ended durning scanline');\n            if ((2 != buffer[pos++]) || (2 != buffer[pos++]) || (((buffer[pos++] << 8) | buffer[pos++]) != width))\n                throw importError('bad rgbe scanline format');\n            let count;\n            for (let ptr = 0; ptr < end && pos < len; ptr += count) {\n                count = buffer[pos++];\n                const isEncodedRun = count > 128;\n                if (isEncodedRun)\n                    count -= 128;\n                if (count == 0 || ptr + count > end)\n                    throw importError('bad scanline data');\n                if (isEncodedRun) {\n                    scanline_buffer.fill(buffer[pos], ptr, ptr + count);\n                    pos += 1;\n                }\n                else {\n                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                    pos += count;\n                }\n            }\n            for (let i = 0; i < width; i++)\n                for (let j = 0; j < end; j += width)\n                    rawData[offset++] = scanline_buffer[i + j];\n        }\n    }\n    // #endregion\n    // #region Convert to Float16\n    const data = new Uint16Array(rawData.length);\n    const float16One = toFloat16Bytes(1);\n    for (let i = 0; i < width * height * 4; i += 4) {\n        const raw_e = rawData[i + 3];\n        const scale = Math.pow(2.0, raw_e - 128.0) / 255.0;\n        for (let j = 0; j < 3; j += 1) {\n            data[i + j] = toFloat16Bytes(Math.min(rawData[i + j] * scale, 65504));\n        }\n        data[i + 3] = float16One;\n    }\n    // #endregion\n    return { data, width, height, gamma, exposure };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxDQUFDO0lBQzdDLE1BQU0sVUFBVSxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVyQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxHQUFHLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQzdDLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDN0IsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUVuRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUM1QixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDMUUsQ0FBQztRQUNELElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO0lBQzdCLENBQUM7SUFDRCxhQUFhO0lBRWIsT0FBTyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsQ0FBQztBQUNwRCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3V0aWxzL2RhdGEtY29udmVyc2lvbi50cz82MGMxIiwid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy91dGlscy90ZXh0dXJlLWltcG9ydGluZy50cz80MjUyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgYmFzZVRhYmxlLCBzaGlmdFRhYmxlIH0gPSAoKCkgPT4ge1xuICAgIGNvbnN0IGJhc2VUYWJsZSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGNvbnN0IHNoaWZ0VGFibGUgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU1OyArK2kpIHtcbiAgICAgICAgY29uc3QgZSA9IGkgLSAxMjc7XG4gICAgICAgIGlmIChlIDwgLTI3KSB7IC8vIHZlcnkgc21hbGwgbnVtYmVyICgwLCAtMClcbiAgICAgICAgICAgIGJhc2VUYWJsZVtpXSA9IDB4MDAwMDtcbiAgICAgICAgICAgIHNoaWZ0VGFibGVbaV0gPSAyNDtcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgLTE0KSB7IC8vIHNtYWxsIG51bWJlciAoZGVub3JtKVxuICAgICAgICAgICAgYmFzZVRhYmxlW2ldID0gMHgwNDAwID4+ICgtZSAtIDE0KTtcbiAgICAgICAgICAgIHNoaWZ0VGFibGVbaV0gPSAtZSAtIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoZSA8PSAxNSkgeyAvLyBub3JtYWwgbnVtYmVyXG4gICAgICAgICAgICBiYXNlVGFibGVbaV0gPSAoZSArIDE1KSA8PCAxMDtcbiAgICAgICAgICAgIHNoaWZ0VGFibGVbaV0gPSAxMztcbiAgICAgICAgfSBlbHNlIHsgLy8gZSA8IDEyOCwgbGFyZ2UgbnVtYmVyIChJbmZpbml0eSwgLUluZmluaXR5KVxuICAgICAgICAgICAgYmFzZVRhYmxlW2ldID0gMHg3YzAwO1xuICAgICAgICAgICAgc2hpZnRUYWJsZVtpXSA9IDI0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZSA9PSAxMjgsIHN0YXkgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSlcbiAgICBiYXNlVGFibGVbMjU1XSA9IDB4N2MwMDtcbiAgICBzaGlmdFRhYmxlWzI1NV0gPSAxMztcblxuICAgIHJldHVybiB7IGJhc2VUYWJsZSwgc2hpZnRUYWJsZSB9O1xufSkoKTtcblxuY29uc3QgY29udmVyc2lvbkJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbmNvbnN0IGZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoY29udmVyc2lvbkJ1ZmZlcik7XG5jb25zdCB1aW50VmlldyA9IG5ldyBVaW50MzJBcnJheShjb252ZXJzaW9uQnVmZmVyKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvRmxvYXQxNkJ5dGVzKHZhbDogbnVtYmVyKSB7XG4gICAgZmxvYXRWaWV3WzBdID0gdmFsO1xuICAgIGNvbnN0IGYgPSB1aW50Vmlld1swXTtcbiAgICBjb25zdCBlID0gKGYgPj4gMjMpICYgMHgxZmY7XG4gICAgY29uc3QgaWR4ID0gZSAmIDB4ZmY7XG4gICAgcmV0dXJuIGJhc2VUYWJsZVtpZHhdICsgKChmICYgMHgwMDdmZmZmZikgPj4gc2hpZnRUYWJsZVtpZHhdKSArICgoZSAmIDB4MTAwKSA8PCA3KTtcbn1cbiIsImltcG9ydCB7IHRvRmxvYXQxNkJ5dGVzIH0gZnJvbSAnLi9kYXRhLWNvbnZlcnNpb24nO1xuaW1wb3J0IHsgc3JnYlRleHR1cmVUb0xpbmVhciwgZ2VuZXJhdGVNaXBzIH0gZnJvbSAnLi90ZXh0dXJlLXByb2Nlc3NpbmcnO1xuXG5leHBvcnQgdHlwZSBpbWFnZVRvVGV4dHVyZURlc2NyaXB0b3IgPSB7XG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXG4gICAgZGF0YTogVWludDhBcnJheSB8IEJsb2IgfCBGaWxlIHwgSW1hZ2VCaXRtYXAsXG4gICAgbWltZVR5cGU/OiBzdHJpbmcsXG4gICAgbGFiZWw/OiBzdHJpbmcsXG4gICAgdXNhZ2U/OiBudW1iZXIsXG4gICAgZm9ybWF0PzogR1BVVGV4dHVyZUZvcm1hdCxcbiAgICBtaXBzPzogYm9vbGVhbixcbiAgICBzcmdiVG9MaW5lYXI/OiBib29sZWFuLFxuICAgIGNvbG9yU3BhY2U/OiBQcmVkZWZpbmVkQ29sb3JTcGFjZSxcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbWFnZVRvVGV4dHVyZSh7XG4gICAgZGV2aWNlLFxuICAgIGRhdGEsXG4gICAgbWltZVR5cGUsXG4gICAgdXNhZ2UgPSBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HLFxuICAgIG1pcHMgPSB0cnVlLFxuICAgIGZvcm1hdCA9ICdyZ2JhOHVub3JtJyxcbiAgICBjb2xvclNwYWNlID0gJ3NyZ2InLFxuICAgIGxhYmVsID0gJycsXG4gICAgc3JnYlRvTGluZWFyLFxufTogaW1hZ2VUb1RleHR1cmVEZXNjcmlwdG9yKSB7XG4gICAgbGV0IGJpdG1hcDogSW1hZ2VCaXRtYXA7XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG4gICAgICAgIGJpdG1hcCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmxvYiA9IChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBkYXRhIGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgICAgID8gZGF0YVxuICAgICAgICAgICAgOiBuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogbWltZVR5cGUgfSk7XG4gICAgICAgIGJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGJsb2IsIHsgY29sb3JTcGFjZUNvbnZlcnNpb246ICdub25lJyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplID0geyB3aWR0aDogYml0bWFwLndpZHRoLCBoZWlnaHQ6IGJpdG1hcC5oZWlnaHQgfTtcblxuICAgIGNvbnN0IHRleHR1cmUgPSBkZXZpY2UuY3JlYXRlVGV4dHVyZSh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHVzYWdlOiB1c2FnZSB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQyB8IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCxcbiAgICAgICAgbWlwTGV2ZWxDb3VudDogbWlwcyA/IDEgKyAoTWF0aC5sb2cyKE1hdGgubWF4KGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCkpIHwgMCkgOiAxLFxuICAgIH0pO1xuXG4gICAgZGV2aWNlLnF1ZXVlLmNvcHlFeHRlcm5hbEltYWdlVG9UZXh0dXJlKFxuICAgICAgICB7IHNvdXJjZTogYml0bWFwIH0sXG4gICAgICAgIHsgdGV4dHVyZSwgY29sb3JTcGFjZSB9LFxuICAgICAgICBzaXplLFxuICAgICk7XG5cbiAgICBpZiAoc3JnYlRvTGluZWFyKSBzcmdiVGV4dHVyZVRvTGluZWFyKGRldmljZSwgdGV4dHVyZSk7XG4gICAgaWYgKG1pcHMpIHZvaWQgZ2VuZXJhdGVNaXBzKGRldmljZSwgdGV4dHVyZSk7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSERSKGluRGF0YTogVWludDhBcnJheSB8IEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGluRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBpbkRhdGEgOiBuZXcgVWludDhBcnJheShpbkRhdGEpO1xuICAgIGxldCBwb3MgPSAwO1xuXG4gICAgY29uc3QgZ2V0TGluZSA9IChsaW5lTGltaXQgPSAxMDI0KSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5taW4oYnVmZmVyLmxlbmd0aCwgbGluZUxpbWl0ICsgcG9zKTtcbiAgICAgICAgY29uc3Qgc3ViID0gYnVmZmVyLnN1YmFycmF5KHBvcywgbGltaXQpO1xuICAgICAgICBjb25zdCBlbmQgPSBzdWIuaW5kZXhPZigweDBBKSArIDE7XG4gICAgICAgIHBvcyArPSBlbmQ7XG4gICAgICAgIHJldHVybiBlbmQgPT09IDAgPyB1bmRlZmluZWQgOiBkZWNvZGVyLmRlY29kZShzdWIuc3ViYXJyYXkoMCwgZW5kKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGltcG9ydEVycm9yID0gKG1zZzogc3RyaW5nKSA9PiBuZXcgRXJyb3IoJ0hEUiBJbXBvcnQgRXJyb3I6ICcgKyBtc2cpO1xuXG4gICAgLy8gI3JlZ2lvbiBSZWFkIEhlYWRlclxuICAgIGNvbnN0IG1hZ2ljVG9rZW5SZWdleCA9IC9eI1xcPyhcXFMrKS87XG4gICAgY29uc3QgbWFnaWNUb2tlbkxpbmUgPSBnZXRMaW5lKCk7XG5cbiAgICBpZiAobWFnaWNUb2tlbkxpbmUgPT0gbnVsbCkgdGhyb3cgaW1wb3J0RXJyb3IoJ25vIGhlYWRlciBmb3VuZCcpO1xuICAgIGlmICghbWFnaWNUb2tlblJlZ2V4LnRlc3QobWFnaWNUb2tlbkxpbmUpKSB0aHJvdyBpbXBvcnRFcnJvcignYmFkIGluaXRpYWwgdG9rZW4nKTtcblxuICAgIGNvbnN0IGhlYWRlclJlZ3MgPSBbXG4gICAgICAgIC9GT1JNQVQ9KD88Zm9ybWF0PlxcUyspLywgLy8gZm9ybWF0XG4gICAgICAgIC8tWVxccysoPzxZPlxcZCspXFxzK1xcK1hcXHMrKD88WD5cXGQrKS8sIC8vIHNpemVcbiAgICAgICAgL0VYUE9TVVJFXFxzKj1cXHMqKD88ZXhwb3N1cmU+XFxkKyhcXC5cXGQrKT8pLywgLy8gZXhwb3N1cmVcbiAgICAgICAgL0dBTU1BXFxzKj1cXHMqKD88Z2FtbWE+XFxkKyhcXC5cXGQrKT8pLywgLy8gZ2FtbWFcbiAgICBdO1xuXG4gICAgY29uc3QgaGVhZGVyUmVnID0gbmV3IFJlZ0V4cChgXlxcXFxzKigke1xuICAgICAgICBoZWFkZXJSZWdzLm1hcCgoeyBzb3VyY2UgfSkgPT4gYCgke3NvdXJjZX0pYCkuam9pbignfCcpXG4gICAgfSlcXFxccyokYCk7XG5cbiAgICBsZXQgbm9Gb3JtYXQgPSB0cnVlO1xuICAgIGxldCBnYW1tYSA9IDE7IC8qIGEgdmFsdWUgb2YgMS4wIGluIGFuIGltYWdlIGNvcnJlc3BvbmRzIHRvIDxleHBvc3VyZT4gd2F0dHMvc3RlcmFkaWFuL21eMi4gZGVmYXVsdHMgdG8gMS4wICovXG4gICAgbGV0IGV4cG9zdXJlID0gMTsgLyogaW1hZ2UgaGFzIGFscmVhZHkgYmVlbiBnYW1tYSBjb3JyZWN0ZWQgd2l0aCBnaXZlbiBnYW1tYS4gZGVmYXVsdHMgdG8gMS4wIChubyBjb3JyZWN0aW9uKSAqL1xuICAgIGxldCB3aWR0aDogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgIGZvciAobGV0IGxpbmUgPSBnZXRMaW5lKCk7IGxpbmUgIT0gbnVsbDsgbGluZSA9IHdpZHRoID09IG51bGwgPyBnZXRMaW5lKCkgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gbGluZS5tYXRjaChoZWFkZXJSZWcpPy5ncm91cHMgYXMgUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGdyb3VwcyA9PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoZ3JvdXBzLmZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBub0Zvcm1hdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3Vwcy5YICE9IG51bGwgJiYgZ3JvdXBzLlkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludChncm91cHMuWCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBwYXJzZUludChncm91cHMuWSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBzLmdhbW1hICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdhbW1hID0gcGFyc2VGbG9hdChncm91cHMuZ2FtbWEpO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3Vwcy5leHBvc3VyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHBvc3VyZSA9IHBhcnNlRmxvYXQoZ3JvdXBzLmV4cG9zdXJlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub0Zvcm1hdCkgdGhyb3cgaW1wb3J0RXJyb3IoJ21pc3NpbmcgZm9ybWF0IHNwZWNpZmllcicpO1xuICAgIGlmICh3aWR0aCA9PSBudWxsIHx8IGhlaWdodCA9PSBudWxsKSB0aHJvdyBpbXBvcnRFcnJvcignbWlzc2luZyBpbWFnZSBzaXplIHNwZWNpZmllcicpO1xuICAgIC8vICNlbmRyZWdpb25cblxuICAgIC8vICNyZWdpb24gUmVhZCBTY2FubGluZSBEYXRhXG4gICAgbGV0IHJhd0RhdGE6IFVpbnQ4QXJyYXk7XG4gICAgY29uc3QgdW5lbmNvZGFibGUgPSB3aWR0aCA8IDggfHwgd2lkdGggPiAweDdmZmY7XG4gICAgY29uc3QgZmxhdERhdGEgPSBidWZmZXJbcG9zXSAhPT0gMiB8fCBidWZmZXJbcG9zICsgMV0gIT09IDIgfHwgKGJ1ZmZlcltwb3MgKyAyXSAmIDB4ODApICE9PSAwO1xuXG4gICAgaWYgKHVuZW5jb2RhYmxlIHx8IGZsYXREYXRhKSB7XG4gICAgICAgIHJhd0RhdGEgPSBidWZmZXIuc3ViYXJyYXkocG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByYXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgY29uc3QgZW5kID0gNCAqIHdpZHRoO1xuICAgICAgICBjb25zdCBzY2FubGluZV9idWZmZXIgPSBuZXcgVWludDhBcnJheShlbmQpO1xuICAgICAgICBjb25zdCBsZW4gPSBidWZmZXIuYnl0ZUxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBrID0gMCwgb2Zmc2V0ID0gMDsgayA8IGhlaWdodCAmJiBwb3MgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgaWYgKHBvcyArIDQgPiBsZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW1wb3J0RXJyb3IoJ2ZpbGUgZW5kZWQgZHVybmluZyBzY2FubGluZScpO1xuXG4gICAgICAgICAgICBpZiAoKDIgIT0gYnVmZmVyW3BvcysrXSkgfHwgKDIgIT0gYnVmZmVyW3BvcysrXSkgfHwgKCgoYnVmZmVyW3BvcysrXSA8PCA4KSB8IGJ1ZmZlcltwb3MrK10pICE9IHdpZHRoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBpbXBvcnRFcnJvcignYmFkIHJnYmUgc2NhbmxpbmUgZm9ybWF0Jyk7XG5cbiAgICAgICAgICAgIGxldCBjb3VudDtcbiAgICAgICAgICAgIGZvciAobGV0IHB0ciA9IDA7IHB0ciA8IGVuZCAmJiBwb3MgPCBsZW47IHB0ciArPSBjb3VudCkge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gYnVmZmVyW3BvcysrXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0VuY29kZWRSdW4gPSBjb3VudCA+IDEyODtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbmNvZGVkUnVuKSBjb3VudCAtPSAxMjg7XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT0gMCB8fCBwdHIgKyBjb3VudCA+IGVuZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaW1wb3J0RXJyb3IoJ2JhZCBzY2FubGluZSBkYXRhJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbmNvZGVkUnVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5saW5lX2J1ZmZlci5maWxsKGJ1ZmZlcltwb3NdLCBwdHIsIHB0ciArIGNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbmxpbmVfYnVmZmVyLnNldChidWZmZXIuc3ViYXJyYXkocG9zLCBwb3MgKyBjb3VudCksIHB0cik7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVuZDsgaiArPSB3aWR0aClcbiAgICAgICAgICAgICAgICAgICAgcmF3RGF0YVtvZmZzZXQrK10gPSBzY2FubGluZV9idWZmZXJbaSArIGpdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cblxuICAgIC8vICNyZWdpb24gQ29udmVydCB0byBGbG9hdDE2XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50MTZBcnJheShyYXdEYXRhLmxlbmd0aCk7XG4gICAgY29uc3QgZmxvYXQxNk9uZSA9IHRvRmxvYXQxNkJ5dGVzKDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aCAqIGhlaWdodCAqIDQ7IGkgKz0gNCkge1xuICAgICAgICBjb25zdCByYXdfZSA9IHJhd0RhdGFbaSArIDNdO1xuICAgICAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIuMCwgcmF3X2UgLSAxMjguMCkgLyAyNTUuMDtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGogKz0gMSkge1xuICAgICAgICAgICAgZGF0YVtpICsgal0gPSB0b0Zsb2F0MTZCeXRlcyhNYXRoLm1pbihyYXdEYXRhW2kgKyBqXSAqIHNjYWxlLCA2NTUwNCkpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbaSArIDNdID0gZmxvYXQxNk9uZTtcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuXG4gICAgcmV0dXJuIHsgZGF0YSwgd2lkdGgsIGhlaWdodCwgZ2FtbWEsIGV4cG9zdXJlIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8862\n")},9629:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   l3: () => (/* binding */ equirectangularToCubemap)\n/* harmony export */ });\n/* unused harmony exports generateMips, srgbTextureToLinear */\n/* harmony import */ var _shaders_blit_vert_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(157);\n/* harmony import */ var _shaders_cubemap_sampling_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6097);\n/* harmony import */ var _data_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5752);\n/* harmony import */ var _general__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4742);\n\n\n\n\nasync function equirectangularToCubemap(device, { data, width, height, gamma = 1, exposure = 1 }, outputDescriptor) {\n    const code = /* wgsl */ `\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${_shaders_blit_vert_shader__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A}\n        ${_shaders_cubemap_sampling_shader__WEBPACK_IMPORTED_MODULE_2__/* .toWorldDir */ .V}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;\n    let FLIP_Y = 0;\n    let equirectangular;\n    if (data instanceof GPUTexture) {\n        equirectangular = data;\n    }\n    else {\n        FLIP_Y = 1;\n        equirectangular = device.createTexture({\n            label: `${outputDescriptor.label} equirectangular`,\n            dimension: '2d',\n            format: 'rgba16float',\n            size: { width, height },\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        });\n        device.queue.writeTexture({ texture: equirectangular, mipLevel: 0 }, data, { bytesPerRow: width * 2 * 4 }, { width, height, depthOrArrayLayers: 1 });\n        await device.queue.onSubmittedWorkDone();\n    }\n    const faceSize = equirectangular.height >> 1;\n    const cubemapDescriptor = outputDescriptor;\n    cubemapDescriptor.mipLevelCount ??= Math.log2(faceSize) | 0;\n    cubemapDescriptor.size = { width: faceSize, height: faceSize, depthOrArrayLayers: 6 };\n    cubemapDescriptor.dimension = '2d';\n    cubemapDescriptor.usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    const cubemap = device.createTexture(cubemapDescriptor);\n    const label = (0,_general__WEBPACK_IMPORTED_MODULE_3__/* .padTemplate */ .OY) `hdr copy${outputDescriptor.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 2,\n                buffer: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n    const module = device.createShaderModule({ label, code });\n    const sampler = device.createSampler({ label, minFilter: 'linear', magFilter: 'linear' });\n    const params = new Uint32Array(1);\n    const paramBuffer = (0,_data_copy__WEBPACK_IMPORTED_MODULE_0__/* .createAndCopyBuffer */ .Lr)(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device, label);\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            { binding: 0, resource: equirectangular.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: paramBuffer } },\n        ],\n    });\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: { module },\n        fragment: {\n            module,\n            targets: [{ format: cubemap.format }],\n            constants: {\n                GAMMA: gamma,\n                EXPOSURE: exposure,\n                FLIP_Y,\n            },\n        },\n    });\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n        const view = cubemap.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n            mipLevelCount: 1,\n        });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [{\n                    view,\n                    loadOp: 'clear',\n                    storeOp: 'store',\n                }],\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n    return cubemap;\n}\nasync function generateMips(device, texture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${blit}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `;\n    const label = padTemplate `mip generation${texture.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d', sampleType: 'float' },\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n    const colorAttachment = {\n        view: undefined,\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n    colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: 0 });\n    await device.queue.onSubmittedWorkDone();\n    for (let i = 1; i < texture.mipLevelCount; i += 1) {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: colorAttachment.view,\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n        colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: i });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [colorAttachment],\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n}\nfunction srgbTextureToLinear(device, texture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${blit}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `;\n    const label = padTemplate `srgb to linear${texture.label}`;\n    const size = { width: texture.width, height: texture.height };\n    const tempTexture = device.createTexture({\n        format: texture.format,\n        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        size,\n    });\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code: code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: tempTexture.createView(),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n        ],\n    });\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToTexture({ texture }, { texture: tempTexture }, size);\n    const pass = encoder.beginRenderPass({\n        label,\n        colorAttachments: [{\n                view: texture.createView({ mipLevelCount: 1, baseMipLevel: 0 }),\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n    });\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindgroup);\n    pass.draw(3);\n    pass.end();\n    device.queue.submit([encoder.finish()]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LG9CQUFvQixDQUN4QixFQUFFLE9BQU8sRUFBRSxFQUNYLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxFQUN4QixJQUFJLENBQ1AsQ0FBQztJQUVGLE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUM7UUFDakMsS0FBSztRQUNMLGdCQUFnQixFQUFFLENBQUM7Z0JBQ2YsSUFBSSxFQUFFLE9BQU8sQ0FBQyxVQUFVLENBQUMsRUFBRSxhQUFhLEVBQUUsQ0FBQyxFQUFFLFlBQVksRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDL0QsTUFBTSxFQUFFLE9BQU87Z0JBQ2YsT0FBTyxFQUFFLE9BQU87YUFDbkIsQ0FBQztLQUNMLENBQUMsQ0FBQztJQUVILElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDM0IsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNiLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUVYLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM1QyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3V0aWxzL3RleHR1cmUtcHJvY2Vzc2luZy50cz83NjQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBibGl0IGZyb20gJy4uL3NoYWRlcnMvYmxpdC12ZXJ0LnNoYWRlcic7XG5pbXBvcnQgeyB0b1dvcmxkRGlyIH0gZnJvbSAnLi4vc2hhZGVycy9jdWJlbWFwLXNhbXBsaW5nLnNoYWRlcic7XG5pbXBvcnQgeyBjcmVhdGVBbmRDb3B5QnVmZmVyIH0gZnJvbSAnLi9kYXRhLWNvcHknO1xuaW1wb3J0IHsgcGFkVGVtcGxhdGUgfSBmcm9tICcuL2dlbmVyYWwnO1xuXG50eXBlIEVxdWlyZWN0YW5ndWxhckRlc2NyaXB0b3IgPSB7XG4gICAgZGF0YTogU2hhcmVkQXJyYXlCdWZmZXIgfCBCdWZmZXJTb3VyY2UgfCBHUFVUZXh0dXJlLFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICAgZ2FtbWE/OiBudW1iZXIsXG4gICAgZXhwb3N1cmU/OiBudW1iZXIsXG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXF1aXJlY3Rhbmd1bGFyVG9DdWJlbWFwKFxuICAgIGRldmljZTogR1BVRGV2aWNlLFxuICAgIHsgZGF0YSwgd2lkdGgsIGhlaWdodCwgZ2FtbWEgPSAxLCBleHBvc3VyZSA9IDEgfTogRXF1aXJlY3Rhbmd1bGFyRGVzY3JpcHRvcixcbiAgICBvdXRwdXREZXNjcmlwdG9yOiBPbWl0PEdQVVRleHR1cmVEZXNjcmlwdG9yLCAnZGltZW5zaW9uJyB8ICdzaXplJz4sXG4pIHtcbiAgICBjb25zdCBjb2RlID0gLyogd2dzbCAqLyBgXG4gICAgICAgIG92ZXJyaWRlIEVYUE9TVVJFOiBmMzIgPSAxLjA7XG4gICAgICAgIG92ZXJyaWRlIEdBTU1BOiBmMzIgPSAxLjA7XG4gICAgICAgIG92ZXJyaWRlIEZMSVBfWTogYm9vbCA9IGZhbHNlO1xuXG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXIgZXF1aXJlY3Rhbmd1bGFyTWFwOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXIgbWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjx1bmlmb3JtPiBmYWNlOiB1MzI7XG5cbiAgICAgICAgZm4gc2FtcGxlU3BoZXJpY2FsTWFwKHY6IHZlYzNmKSAtPiB2ZWMyZiB7XG4gICAgICAgICAgICBjb25zdCBpbnZBdGFuID0gdmVjMigwLjE1OTEsIDAuMzE4Myk7XG5cbiAgICAgICAgICAgIHZhciB1diA9IHZlYzIoYXRhbjIodi56LCB2LngpLCBhc2luKHYueSkpO1xuICAgICAgICAgICAgdXYgKj0gaW52QXRhbjtcbiAgICAgICAgICAgIHV2ICs9IDAuNTtcbiAgICAgICAgICAgIHJldHVybiB1djtcbiAgICAgICAgfVxuIFxuICAgICAgICAke2JsaXR9XG4gICAgICAgICR7dG9Xb3JsZERpcn1cblxuICAgICAgICBAZnJhZ21lbnRcbiAgICAgICAgZm4gZnMoQGxvY2F0aW9uKDApIHV2OiB2ZWMyZikgLT4gQGxvY2F0aW9uKDApIHZlYzRmIHtcbiAgICAgICAgICAgIHZhciBkaXIgPSB0b1dvcmxkRGlyRjMyKHV2LCBmYWNlKTtcbiAgICAgICAgICAgIGRpciA9IHZlYzMoZGlyLnosIGRpci55LCAtZGlyLngpO1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gc2FtcGxlU3BoZXJpY2FsTWFwKGRpcik7XG4gICAgICAgICAgICBpZiAoRkxJUF9ZKSB7IGNvb3JkLnkgPSAxIC0gY29vcmQueTsgfVxuXG4gICAgICAgICAgICB2YXIgY29sb3IgPSB0ZXh0dXJlU2FtcGxlKGVxdWlyZWN0YW5ndWxhck1hcCwgbWFwU2FtcGxlciwgY29vcmQpLnJnYjtcbiAgICAgICAgICAgIGlmIChHQU1NQSAhPSAxLjApIHsgY29sb3IgPSBwb3coY29sb3IsIHZlYzMoMS4wIC8gR0FNTUEpKTsgfVxuICAgICAgICAgICAgaWYgKEVYUE9TVVJFICE9IDEuMCkgeyBjb2xvciAvPSBFWFBPU1VSRTsgfVxuICAgICAgICAgICAgcmV0dXJuIHZlYzQoY29sb3IsIDEuMCk7XG4gICAgICAgIH1cbiAgICBgO1xuXG4gICAgbGV0IEZMSVBfWSA9IDA7XG4gICAgbGV0IGVxdWlyZWN0YW5ndWxhcjogR1BVVGV4dHVyZTtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEdQVVRleHR1cmUpIHtcbiAgICAgICAgZXF1aXJlY3Rhbmd1bGFyID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBGTElQX1kgPSAxO1xuICAgICAgICBlcXVpcmVjdGFuZ3VsYXIgPSBkZXZpY2UuY3JlYXRlVGV4dHVyZSh7XG4gICAgICAgICAgICBsYWJlbDogYCR7b3V0cHV0RGVzY3JpcHRvci5sYWJlbH0gZXF1aXJlY3Rhbmd1bGFyYCxcbiAgICAgICAgICAgIGRpbWVuc2lvbjogJzJkJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ3JnYmExNmZsb2F0JyxcbiAgICAgICAgICAgIHNpemU6IHsgd2lkdGgsIGhlaWdodCB9LFxuICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCB8IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRldmljZS5xdWV1ZS53cml0ZVRleHR1cmUoXG4gICAgICAgICAgICB7IHRleHR1cmU6IGVxdWlyZWN0YW5ndWxhciwgbWlwTGV2ZWw6IDAgfSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB7IGJ5dGVzUGVyUm93OiB3aWR0aCAqIDIgKiA0IH0sXG4gICAgICAgICAgICB7IHdpZHRoLCBoZWlnaHQsIGRlcHRoT3JBcnJheUxheWVyczogMSB9LFxuICAgICAgICApO1xuICAgICAgICBhd2FpdCBkZXZpY2UucXVldWUub25TdWJtaXR0ZWRXb3JrRG9uZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGZhY2VTaXplID0gZXF1aXJlY3Rhbmd1bGFyLmhlaWdodCA+PiAxO1xuICAgIGNvbnN0IGN1YmVtYXBEZXNjcmlwdG9yID0gb3V0cHV0RGVzY3JpcHRvciBhcyBHUFVUZXh0dXJlRGVzY3JpcHRvcjtcbiAgICBjdWJlbWFwRGVzY3JpcHRvci5taXBMZXZlbENvdW50ID8/PSBNYXRoLmxvZzIoZmFjZVNpemUpIHwgMDtcbiAgICBjdWJlbWFwRGVzY3JpcHRvci5zaXplID0geyB3aWR0aDogZmFjZVNpemUsIGhlaWdodDogZmFjZVNpemUsIGRlcHRoT3JBcnJheUxheWVyczogNiB9O1xuICAgIGN1YmVtYXBEZXNjcmlwdG9yLmRpbWVuc2lvbiA9ICcyZCc7XG4gICAgY3ViZW1hcERlc2NyaXB0b3IudXNhZ2UgfD0gR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UO1xuICAgIGNvbnN0IGN1YmVtYXAgPSBkZXZpY2UuY3JlYXRlVGV4dHVyZShjdWJlbWFwRGVzY3JpcHRvcik7XG5cbiAgICBjb25zdCBsYWJlbCA9IHBhZFRlbXBsYXRlYGhkciBjb3B5JHtvdXRwdXREZXNjcmlwdG9yLmxhYmVsfWA7XG4gICAgY29uc3QgYmluZGdyb3VwTGF5b3V0ID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiB7fSxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMSxcbiAgICAgICAgICAgICAgICBzYW1wbGVyOiB7fSxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMixcbiAgICAgICAgICAgICAgICBidWZmZXI6IHt9LFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoeyBsYWJlbCwgY29kZSB9KTtcbiAgICBjb25zdCBzYW1wbGVyID0gZGV2aWNlLmNyZWF0ZVNhbXBsZXIoeyBsYWJlbCwgbWluRmlsdGVyOiAnbGluZWFyJywgbWFnRmlsdGVyOiAnbGluZWFyJyB9KTtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVWludDMyQXJyYXkoMSk7XG4gICAgY29uc3QgcGFyYW1CdWZmZXIgPSBjcmVhdGVBbmRDb3B5QnVmZmVyKHBhcmFtcywgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfCBHUFVCdWZmZXJVc2FnZS5VTklGT1JNLCBkZXZpY2UsIGxhYmVsKTtcblxuICAgIGNvbnN0IGJpbmRncm91cCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgbGF5b3V0OiBiaW5kZ3JvdXBMYXlvdXQsXG4gICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgIHsgYmluZGluZzogMCwgcmVzb3VyY2U6IGVxdWlyZWN0YW5ndWxhci5jcmVhdGVWaWV3KCkgfSxcbiAgICAgICAgICAgIHsgYmluZGluZzogMSwgcmVzb3VyY2U6IHNhbXBsZXIgfSxcbiAgICAgICAgICAgIHsgYmluZGluZzogMiwgcmVzb3VyY2U6IHsgYnVmZmVyOiBwYXJhbUJ1ZmZlciB9IH0sXG4gICAgICAgIF0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBwaXBlbGluZUxheW91dCA9IGRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBiaW5kR3JvdXBMYXlvdXRzOiBbYmluZGdyb3VwTGF5b3V0XSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGxheW91dDogcGlwZWxpbmVMYXlvdXQsXG4gICAgICAgIHZlcnRleDogeyBtb2R1bGUgfSxcbiAgICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgICAgIG1vZHVsZSxcbiAgICAgICAgICAgIHRhcmdldHM6IFt7IGZvcm1hdDogY3ViZW1hcC5mb3JtYXQgfV0sXG4gICAgICAgICAgICBjb25zdGFudHM6IHtcbiAgICAgICAgICAgICAgICBHQU1NQTogZ2FtbWEsXG4gICAgICAgICAgICAgICAgRVhQT1NVUkU6IGV4cG9zdXJlLFxuICAgICAgICAgICAgICAgIEZMSVBfWSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkgKz0gMSkge1xuICAgICAgICBwYXJhbXNbMF0gPSBpO1xuICAgICAgICBkZXZpY2UucXVldWUud3JpdGVCdWZmZXIocGFyYW1CdWZmZXIsIDAsIHBhcmFtcywgMCwgMSk7XG5cbiAgICAgICAgY29uc3QgdmlldyA9IGN1YmVtYXAuY3JlYXRlVmlldyh7XG4gICAgICAgICAgICBkaW1lbnNpb246ICcyZCcsXG4gICAgICAgICAgICBhcnJheUxheWVyQ291bnQ6IDEsXG4gICAgICAgICAgICBiYXNlQXJyYXlMYXllcjogaSxcbiAgICAgICAgICAgIG1pcExldmVsQ291bnQ6IDEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICAgICAgY29uc3QgcGFzcyA9IGVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKHtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW3tcbiAgICAgICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgICAgIGxvYWRPcDogJ2NsZWFyJyxcbiAgICAgICAgICAgICAgICBzdG9yZU9wOiAnc3RvcmUnLFxuICAgICAgICAgICAgfV0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBhc3Muc2V0UGlwZWxpbmUocGlwZWxpbmUpO1xuICAgICAgICBwYXNzLnNldEJpbmRHcm91cCgwLCBiaW5kZ3JvdXApO1xuICAgICAgICBwYXNzLmRyYXcoMyk7XG4gICAgICAgIHBhc3MuZW5kKCk7XG4gICAgICAgIGRldmljZS5xdWV1ZS5zdWJtaXQoW2VuY29kZXIuZmluaXNoKCldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3ViZW1hcDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU1pcHMoZGV2aWNlOiBHUFVEZXZpY2UsIHRleHR1cmU6IEdQVVRleHR1cmUpIHtcbiAgICBjb25zdCBjb2RlID0gLyogd2dzbCAqLyBgXG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXIgaW1hZ2U6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciBtaXBTYW1wbGVyOiBzYW1wbGVyO1xuXG4gICAgICAgICR7YmxpdH1cblxuICAgICAgICBAZnJhZ21lbnRcbiAgICAgICAgZm4gZnMoQGxvY2F0aW9uKDApIHV2OiB2ZWMyZikgLT4gQGxvY2F0aW9uKDApIHZlYzRmIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlU2FtcGxlKGltYWdlLCBtaXBTYW1wbGVyLCB1dik7XG4gICAgICAgIH1cbiAgICBgO1xuXG4gICAgY29uc3QgbGFiZWwgPSBwYWRUZW1wbGF0ZWBtaXAgZ2VuZXJhdGlvbiR7dGV4dHVyZS5sYWJlbH1gO1xuXG4gICAgY29uc3QgYmluZGdyb3VwTGF5b3V0ID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiB7IHZpZXdEaW1lbnNpb246ICcyZCcsIHNhbXBsZVR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMSxcbiAgICAgICAgICAgICAgICBzYW1wbGVyOiB7fSxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBjb2xvckF0dGFjaG1lbnQgPSB7XG4gICAgICAgIHZpZXc6IHVuZGVmaW5lZCBhcyBHUFVUZXh0dXJlVmlldyB8IHVuZGVmaW5lZCxcbiAgICAgICAgbG9hZE9wOiAnY2xlYXInLFxuICAgICAgICBzdG9yZU9wOiAnc3RvcmUnLFxuICAgIH07XG5cbiAgICBjb25zdCBzYW1wbGVyID0gZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe1xuICAgICAgICBtaW5GaWx0ZXI6ICdsaW5lYXInLFxuICAgICAgICBtYWdGaWx0ZXI6ICdsaW5lYXInLFxuICAgIH0pO1xuICAgIGNvbnN0IG1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoeyBsYWJlbCwgY29kZSB9KTtcbiAgICBjb25zdCBwaXBlbGluZUxheW91dCA9IGRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCh7IGxhYmVsLCBiaW5kR3JvdXBMYXlvdXRzOiBbYmluZGdyb3VwTGF5b3V0XSB9KTtcblxuICAgIGNvbnN0IHBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGxheW91dDogcGlwZWxpbmVMYXlvdXQsXG4gICAgICAgIHZlcnRleDoge1xuICAgICAgICAgICAgZW50cnlQb2ludDogJ3ZzJyxcbiAgICAgICAgICAgIG1vZHVsZSxcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgICAgIGVudHJ5UG9pbnQ6ICdmcycsXG4gICAgICAgICAgICB0YXJnZXRzOiBbeyBmb3JtYXQ6IHRleHR1cmUuZm9ybWF0IH1dLFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29sb3JBdHRhY2htZW50LnZpZXcgPSB0ZXh0dXJlLmNyZWF0ZVZpZXcoeyBtaXBMZXZlbENvdW50OiAxLCBiYXNlTWlwTGV2ZWw6IDAgfSk7XG4gICAgYXdhaXQgZGV2aWNlLnF1ZXVlLm9uU3VibWl0dGVkV29ya0RvbmUoKTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGV4dHVyZS5taXBMZXZlbENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYmluZGdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIGxheW91dDogYmluZGdyb3VwTGF5b3V0LFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IGNvbG9yQXR0YWNobWVudC52aWV3LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogc2FtcGxlcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29sb3JBdHRhY2htZW50LnZpZXcgPSB0ZXh0dXJlLmNyZWF0ZVZpZXcoeyBtaXBMZXZlbENvdW50OiAxLCBiYXNlTWlwTGV2ZWw6IGkgfSk7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICAgICAgY29uc3QgcGFzcyA9IGVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKHtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW2NvbG9yQXR0YWNobWVudCBhcyBHUFVSZW5kZXJQYXNzQ29sb3JBdHRhY2htZW50XSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGFzcy5zZXRQaXBlbGluZShwaXBlbGluZSk7XG4gICAgICAgIHBhc3Muc2V0QmluZEdyb3VwKDAsIGJpbmRncm91cCk7XG4gICAgICAgIHBhc3MuZHJhdygzKTtcbiAgICAgICAgcGFzcy5lbmQoKTtcblxuICAgICAgICBkZXZpY2UucXVldWUuc3VibWl0KFtlbmNvZGVyLmZpbmlzaCgpXSk7XG4gICAgICAgIGF3YWl0IGRldmljZS5xdWV1ZS5vblN1Ym1pdHRlZFdvcmtEb25lKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3JnYlRleHR1cmVUb0xpbmVhcihkZXZpY2U6IEdQVURldmljZSwgdGV4dHVyZTogR1BVVGV4dHVyZSkge1xuICAgIGNvbnN0IGNvZGUgPSAvKiB3Z3NsICovIGBcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhciBpbWFnZTogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIGltYWdlU2FtcGxlcjogc2FtcGxlcjtcblxuICAgICAgICAke2JsaXR9XG5cbiAgICAgICAgZm4gc1JHQlRvTGluZWFyKGNvbG9yOiB2ZWMzZikgLT4gdmVjM2Yge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdCggXG4gICAgICAgICAgICAgICAgcG93KGNvbG9yICogMC45NDc4NjcyOTg2ICsgMC4wNTIxMzI3MDE0LCB2ZWMzKDIuNCkpLCBcbiAgICAgICAgICAgICAgICBjb2xvciAqIDAuMDc3Mzk5MzgwOCwgXG4gICAgICAgICAgICAgICAgY29sb3IgPD0gdmVjMygwLjA0MDQ1KSwgXG4gICAgICAgICAgICApO1xuICAgICAgICB9ICBcblxuICAgICAgICBAZnJhZ21lbnRcbiAgICAgICAgZm4gZnMoQGxvY2F0aW9uKDApIHV2OiB2ZWMyZikgLT4gQGxvY2F0aW9uKDApIHZlYzRmICB7XG4gICAgICAgICAgICBsZXQgc2FtcGxlID0gdGV4dHVyZVNhbXBsZShpbWFnZSwgaW1hZ2VTYW1wbGVyLCB1dik7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBzUkdCVG9MaW5lYXIoc2FtcGxlLnJnYik7XG4gICAgICAgICAgICByZXR1cm4gdmVjNChjb2xvciwgc2FtcGxlLmEpO1xuICAgICAgICB9XG4gICAgYDtcblxuICAgIGNvbnN0IGxhYmVsID0gcGFkVGVtcGxhdGVgc3JnYiB0byBsaW5lYXIke3RleHR1cmUubGFiZWx9YDtcblxuICAgIGNvbnN0IHNpemUgPSB7IHdpZHRoOiB0ZXh0dXJlLndpZHRoLCBoZWlnaHQ6IHRleHR1cmUuaGVpZ2h0IH07XG5cbiAgICBjb25zdCB0ZW1wVGV4dHVyZSA9IGRldmljZS5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgZm9ybWF0OiB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCB8IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcsXG4gICAgICAgIHNpemUsXG4gICAgfSk7XG5cbiAgICBjb25zdCBiaW5kZ3JvdXBMYXlvdXQgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHt9LFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgIHNhbXBsZXI6IHt9LFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHNhbXBsZXIgPSBkZXZpY2UuY3JlYXRlU2FtcGxlcih7XG4gICAgICAgIG1pbkZpbHRlcjogJ2xpbmVhcicsXG4gICAgICAgIG1hZ0ZpbHRlcjogJ2xpbmVhcicsXG4gICAgfSk7XG5cbiAgICBjb25zdCBtb2R1bGUgPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHsgbGFiZWwsIGNvZGU6IGNvZGUgfSk7XG4gICAgY29uc3QgcGlwZWxpbmVMYXlvdXQgPSBkZXZpY2UuY3JlYXRlUGlwZWxpbmVMYXlvdXQoeyBsYWJlbCwgYmluZEdyb3VwTGF5b3V0czogW2JpbmRncm91cExheW91dF0gfSk7XG5cbiAgICBjb25zdCBwaXBlbGluZSA9IGRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZSh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBsYXlvdXQ6IHBpcGVsaW5lTGF5b3V0LFxuICAgICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgICAgIGVudHJ5UG9pbnQ6ICd2cycsXG4gICAgICAgICAgICBtb2R1bGUsXG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgICAgICBlbnRyeVBvaW50OiAnZnMnLFxuICAgICAgICAgICAgdGFyZ2V0czogW3sgZm9ybWF0OiB0ZXh0dXJlLmZvcm1hdCB9XSxcbiAgICAgICAgICAgIG1vZHVsZSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGJpbmRncm91cCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgbGF5b3V0OiBiaW5kZ3JvdXBMYXlvdXQsXG4gICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgIHJlc291cmNlOiB0ZW1wVGV4dHVyZS5jcmVhdGVWaWV3KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IHNhbXBsZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0pO1xuXG4gICAgY29uc3QgZW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgIGVuY29kZXIuY29weVRleHR1cmVUb1RleHR1cmUoXG4gICAgICAgIHsgdGV4dHVyZSB9LFxuICAgICAgICB7IHRleHR1cmU6IHRlbXBUZXh0dXJlIH0sXG4gICAgICAgIHNpemUsXG4gICAgKTtcblxuICAgIGNvbnN0IHBhc3MgPSBlbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBjb2xvckF0dGFjaG1lbnRzOiBbe1xuICAgICAgICAgICAgdmlldzogdGV4dHVyZS5jcmVhdGVWaWV3KHsgbWlwTGV2ZWxDb3VudDogMSwgYmFzZU1pcExldmVsOiAwIH0pLFxuICAgICAgICAgICAgbG9hZE9wOiAnY2xlYXInLFxuICAgICAgICAgICAgc3RvcmVPcDogJ3N0b3JlJyxcbiAgICAgICAgfV0sXG4gICAgfSk7XG5cbiAgICBwYXNzLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcbiAgICBwYXNzLnNldEJpbmRHcm91cCgwLCBiaW5kZ3JvdXApO1xuICAgIHBhc3MuZHJhdygzKTtcbiAgICBwYXNzLmVuZCgpO1xuXG4gICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZW5jb2Rlci5maW5pc2goKV0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9629\n")}}]);