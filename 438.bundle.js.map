{"version":3,"file":"438.bundle.js","mappings":"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","sources":["webpack://cbunt-portfolio/./src/rendering/global-uniforms.ts","webpack://cbunt-portfolio/./src/rendering/tonemap-pass.ts","webpack://cbunt-portfolio/./src/rendering/skybox-pass.ts","webpack://cbunt-portfolio/./src/rendering/gbuffer.ts","webpack://cbunt-portfolio/./src/shaders/brdfs.shader.ts","webpack://cbunt-portfolio/./src/rendering/ibl-textures/create-bfrd-lut.ts","webpack://cbunt-portfolio/./src/rendering/ibl-textures/create-irradiance-texture.ts","webpack://cbunt-portfolio/./src/rendering/ibl-textures/create-radiance-texture.ts","webpack://cbunt-portfolio/./src/rendering/deferred-pass.ts","webpack://cbunt-portfolio/./src/rendering/renderer.ts","webpack://cbunt-portfolio/./src/shaders/blit-vert.shader.ts","webpack://cbunt-portfolio/./src/shaders/cubemap-sampling.shader.ts","webpack://cbunt-portfolio/./src/utils/data-copy.ts"],"sourcesContent":["import Camera from './camera/camera';\r\n\r\nconst label = 'global uniforms';\r\n\r\nexport default class GlobalUniforms {\r\n    static readonly code = (group: number) => /* wgsl */`\r\n        struct GlobalUniforms {\r\n            worldToView: mat4x4f,\r\n            viewToClip: mat4x4f,\r\n            worldToClip: mat4x4f,\r\n            inverseWorldToView: mat4x4f,\r\n            inverseViewToClip: mat4x4f,\r\n            inverseWorldToClip: mat4x4f,\r\n        }\r\n\r\n        @group(${group}) @binding(0) var<uniform> globals: GlobalUniforms;\r\n    `;\r\n\r\n    static readonly bufferSize = Camera.bufferLength;\r\n\r\n    static readonly layoutDescriptor: GPUBindGroupLayoutDescriptor = {\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                buffer: { minBindingSize: GlobalUniforms.bufferSize },\r\n                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\r\n            },\r\n        ],\r\n    };\r\n\r\n    static readonly bufferDescriptor: GPUBufferDescriptor = {\r\n        label,\r\n        size: GlobalUniforms.bufferSize,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    };\r\n\r\n    deviceBuffer: GPUBuffer;\r\n    bindGroupLayout: GPUBindGroupLayout;\r\n    bindGroupDescriptor!: GPUBindGroupDescriptor;\r\n    bindgroup!: GPUBindGroup;\r\n\r\n    constructor(device: GPUDevice) {\r\n        this.deviceBuffer = device.createBuffer(GlobalUniforms.bufferDescriptor);\r\n        this.bindGroupLayout = device.createBindGroupLayout(GlobalUniforms.layoutDescriptor);\r\n\r\n        this.bindGroupDescriptor = {\r\n            label,\r\n            layout: this.bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.deviceBuffer,\r\n                        offset: 0,\r\n                        size: GlobalUniforms.bufferSize,\r\n                    },\r\n                },\r\n            ],\r\n        };\r\n\r\n        this.bindgroup = device.createBindGroup(this.bindGroupDescriptor);\r\n    }\r\n\r\n    updateDeviceBuffer(queue: GPUQueue, camera: Camera) {\r\n        camera.cacheView();\r\n        queue.writeBuffer(this.deviceBuffer, 0, camera.buffer);\r\n    }\r\n}\r\n","import blit from '../shaders/blit-vert.shader';\r\n\r\nconst label = 'tonemap pass';\r\n\r\nexport default class TonemapPass {\r\n    static readonly code = /* wgsl */`\r\n        @group(0) @binding(0) var colorTexture: texture_2d<f32>;\r\n\r\n        ${blit}\r\n\r\n        fn fitRRTAndODT(color: vec3f) -> vec3f {\r\n            let a = color * (color + 0.0245786) - 0.000090537;\r\n            let b = color * (0.983729 * color + 0.4329510) + 0.238081;\r\n            return a / b;\r\n        }\r\n\r\n        fn aces_tone_map(hdr: vec3f) -> vec3f {\r\n            const inputMat = mat3x3(\r\n                0.59719, 0.07600, 0.02840,\r\n                0.35458, 0.90834, 0.13383,\r\n                0.04823, 0.01566, 0.83777,\r\n            );\r\n            const outputMat = mat3x3(\r\n                1.60475, -0.10208, -0.00327,\r\n                -0.53108, 1.10813, -0.07276,\r\n                -0.07367, -0.00605, 1.07602,\r\n            );\r\n            const boost = 1.0 / 0.6;\r\n\r\n            var color = hdr * boost;\r\n            color = inputMat * color;\r\n            color = fitRRTAndODT(color);\r\n            color = outputMat * color;\r\n            return saturate(color);\r\n        }\r\n\r\n        fn linear_to_srgb(color: vec3f) -> vec3f {\r\n            return pow(color, vec3(1.0/2.2));\r\n        }\r\n\r\n        @fragment\r\n        fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {\r\n            let uv = vec2<i32>(floor(pos.xy));\r\n\r\n            var color = textureLoad(colorTexture, uv, 0).rgb;\r\n            color = aces_tone_map(color);\r\n            color = linear_to_srgb(color);\r\n            return vec4f(color, 1.0);\r\n        }\r\n    `;\r\n\r\n    static readonly bindGroupLayoutDescriptor: GPUBindGroupLayoutDescriptor = {\r\n        label,\r\n        entries: [{\r\n            binding: 0,\r\n            texture: { sampleType: 'float', viewDimension: '2d' },\r\n            visibility: GPUShaderStage.FRAGMENT,\r\n        }],\r\n    };\r\n\r\n    colorAttachment: GPURenderPassColorAttachment = {\r\n        loadOp: 'load',\r\n        storeOp: 'store',\r\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n        view: undefined!,\r\n    };\r\n\r\n    passDescriptor: GPURenderPassDescriptor = {\r\n        label,\r\n        colorAttachments: [this.colorAttachment],\r\n    };\r\n\r\n    pipeline: GPURenderPipeline;\r\n    pipelineDescriptor: GPURenderPipelineDescriptor;\r\n\r\n    renderTarget: GPUColorTargetState;\r\n    bindgroupLayout: GPUBindGroupLayout;\r\n    bindgroup?: GPUBindGroup;\r\n\r\n    constructor(\r\n        public device: GPUDevice,\r\n        format: GPUTextureFormat,\r\n    ) {\r\n        this.renderTarget = { format };\r\n        this.bindgroupLayout = device.createBindGroupLayout(TonemapPass.bindGroupLayoutDescriptor);\r\n        const module = device.createShaderModule({ label, code: TonemapPass.code });\r\n\r\n        this.pipelineDescriptor = {\r\n            label,\r\n            layout: device.createPipelineLayout({\r\n                label,\r\n                bindGroupLayouts: [this.bindgroupLayout],\r\n            }),\r\n            vertex: {\r\n                module,\r\n                entryPoint: 'vs',\r\n            },\r\n            fragment: {\r\n                module,\r\n                entryPoint: 'fs',\r\n                targets: [this.renderTarget],\r\n            },\r\n        };\r\n\r\n        this.pipeline = device.createRenderPipeline(this.pipelineDescriptor);\r\n    }\r\n\r\n    updateInput(input: GPUTextureView) {\r\n        this.bindgroup = this.device.createBindGroup({\r\n            label,\r\n            layout: this.bindgroupLayout,\r\n            entries: [{\r\n                binding: 0,\r\n                resource: input,\r\n            }],\r\n        });\r\n    }\r\n\r\n    render(encoder: GPUCommandEncoder, output: GPUTexture) {\r\n        if (this.bindgroup == null) return;\r\n\r\n        if (this.renderTarget.format !== output.format) {\r\n            this.renderTarget.format = output.format;\r\n            this.pipeline = this.device.createRenderPipeline(this.pipelineDescriptor);\r\n        }\r\n\r\n        this.colorAttachment.view = output.createView({ dimension: '2d' });\r\n\r\n        const pass = encoder.beginRenderPass(this.passDescriptor);\r\n        pass.setPipeline(this.pipeline);\r\n        pass.setBindGroup(0, this.bindgroup);\r\n        pass.draw(3);\r\n        pass.end();\r\n    }\r\n}\r\n","import GlobalUniforms from './global-uniforms';\n\nconst label = 'skybox pass';\n\nexport default class SkyboxPass {\n    static readonly code = /* wgsl */`\n        ${GlobalUniforms.code(0)}\n\n        struct SkyboxUniforms {\n            mipBias: f32,\n        };\n\n        @group(1) @binding(0) var environmentTexture: texture_cube<f32>;\n        @group(1) @binding(1) var depthTexture: texture_depth_2d;\n        @group(1) @binding(2) var environmentSampler: sampler;\n        @group(1) @binding(3) var<uniform> skyboxUniforms: SkyboxUniforms;\n\n        struct Varyings {\n            @builtin(position) position: vec4f,\n            @location(0) pos: vec4f,\n            @location(1) mipBias: f32,\n        };\n    \n        @vertex \n        fn vs(@builtin(vertex_index) vNdx: u32) -> Varyings {\n            const pos = array(\n                vec2(-1.0,  3.0),\n                vec2(-1.0, -1.0),\n                vec2( 3.0, -1.0),\n            );\n    \n            var vsOut: Varyings;\n            vsOut.position = vec4(pos[vNdx], 0.0, 1.0);\n    \n            // Ignores the camera's translation without needing a separate rotation matrix.\n            vsOut.pos = globals.inverseViewToClip * vsOut.position;\n            let w = vsOut.pos.w;\n            vsOut.pos.w = 0.0;\n            vsOut.pos = globals.inverseWorldToView * vsOut.pos;\n            vsOut.pos.w = w;\n\n            vsOut.mipBias = clamp(skyboxUniforms.mipBias, 0, f32(textureNumLevels(environmentTexture)));\n            return vsOut;\n        }\n\n        @fragment\n        fn fs(in: Varyings) -> @location(0) vec4f {\n            let dimensions = textureDimensions(depthTexture);\n            let uv = min(vec2<u32>(floor(in.position.xy)), dimensions - 1);\n            let depth = textureLoad(depthTexture, uv, 0);\n            if (depth < 1.0) { discard; }\n\n            let t = normalize(in.pos.xyz / in.pos.w);\n            let color = textureSampleLevel(environmentTexture, environmentSampler, t, in.mipBias).rgb;\n            return vec4(color, 1.0);\n        }\n    `;\n\n    bindgroupLayout: GPUBindGroupLayout;\n    pipelineLayout: GPUPipelineLayout;\n    shader: GPUShaderModule;\n\n    linearSampler: GPUSampler;\n    nearestSampler: GPUSampler;\n    textureBindgroup?: GPUBindGroup;\n\n    uniformBuffer: GPUBuffer;\n    uniformArray = new Float32Array(8);\n\n    pipeline?: GPURenderPipeline;\n\n    #skyTexture?: GPUTextureView;\n    #depthTexture?: GPUTextureView;\n    #targetFormat!: GPUTextureFormat;\n    #useNearestSample = false;\n\n    get mipLevel() { return this.uniformArray[0]; }\n    set mipLevel(val: number) {\n        if (val === this.uniformArray[0]) return;\n        this.uniformArray[0] = val;\n        this.device.queue.writeBuffer(this.uniformBuffer, 0, this.uniformArray, 0, 1);\n    }\n\n    get useNearestSample() { return this.#useNearestSample; }\n    set useNearestSample(val: boolean) {\n        if (val === this.#useNearestSample) return;\n        this.#useNearestSample = val;\n        this.#updateBindgroup();\n    }\n\n    get targetFormat() { return this.#targetFormat; }\n    set targetFormat(format: GPUTextureFormat) {\n        if (format === this.#targetFormat) return;\n        this.#targetFormat = format;\n\n        this.pipeline = this.device.createRenderPipeline({\n            label,\n            layout: this.pipelineLayout,\n            vertex: {\n                entryPoint: 'vs',\n                module: this.shader,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                targets: [{ format }],\n                module: this.shader,\n            },\n        });\n    }\n\n    set skyTexture(skybox: GPUTextureView) {\n        if (skybox === this.#skyTexture) return;\n        this.#skyTexture = skybox;\n        this.#updateBindgroup();\n    }\n\n    set depthTexture(depthTexture: GPUTextureView) {\n        if (depthTexture === this.#depthTexture) return;\n        this.#depthTexture = depthTexture;\n        this.#updateBindgroup();\n    }\n\n    target: GPURenderPassColorAttachment = {\n        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        loadOp: 'clear',\n        storeOp: 'store',\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        view: undefined!,\n    };\n\n    readonly passDescriptor: GPURenderPassDescriptor = { colorAttachments: [this.target] };\n\n    constructor(\n        public device: GPUDevice,\n        public globals: GlobalUniforms,\n        targetFormat: GPUTextureFormat,\n        skybox?: GPUTextureView,\n    ) {\n        this.bindgroupLayout = device.createBindGroupLayout({\n            label,\n            entries: [\n                {\n                    binding: 0,\n                    texture: { viewDimension: 'cube' },\n                    visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n                },\n                {\n                    binding: 1,\n                    texture: {\n                        viewDimension: '2d',\n                        sampleType: 'depth',\n                    },\n                    visibility: GPUShaderStage.FRAGMENT,\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: { type: 'uniform' },\n                },\n            ],\n        });\n\n        this.linearSampler = device.createSampler({\n            minFilter: 'linear',\n            magFilter: 'linear',\n            mipmapFilter: 'linear',\n        });\n\n        this.nearestSampler = device.createSampler({\n            minFilter: 'nearest',\n            magFilter: 'nearest',\n            mipmapFilter: 'nearest',\n        });\n\n        this.shader = device.createShaderModule({\n            code: SkyboxPass.code,\n            label,\n        });\n\n        this.pipelineLayout = device.createPipelineLayout({\n            label,\n            bindGroupLayouts: [\n                globals.bindGroupLayout,\n                this.bindgroupLayout,\n            ],\n        });\n\n        this.uniformBuffer = device.createBuffer({\n            label,\n            size: 32,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        });\n\n        this.targetFormat = targetFormat;\n        if (skybox != null) this.skyTexture = skybox;\n    }\n\n    render(pass: GPURenderPassEncoder) {\n        if (this.textureBindgroup == null || this.pipeline == null) return false;\n        pass.setPipeline(this.pipeline);\n        pass.setBindGroup(0, this.globals.bindgroup);\n        pass.setBindGroup(1, this.textureBindgroup);\n        pass.draw(3);\n        return true;\n    }\n\n    #updateBindgroup() {\n        if (this.#skyTexture == null || this.#depthTexture == null) return;\n\n        this.textureBindgroup = this.device.createBindGroup({\n            label,\n            layout: this.bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: this.#skyTexture,\n                },\n                {\n                    binding: 1,\n                    resource: this.#depthTexture,\n                },\n                {\n                    binding: 2,\n                    resource: this.useNearestSample\n                        ? this.nearestSampler\n                        : this.linearSampler,\n                },\n                {\n                    binding: 3,\n                    resource: { buffer: this.uniformBuffer },\n                },\n            ],\n        });\n    }\n}\n","type TextureData = {\n    format: GPUTextureFormat,\n    name: string,\n    clearValue?: GPUColor,\n    texture?: GPUTexture,\n    view?: GPUTextureView,\n};\n\nexport const enum GBufferGroupIndices {\n    Normal = 0,\n    Albedo,\n    Emission,\n    MetallicRoughness,\n    Depth,\n}\n\nexport default class GBuffer {\n    static readonly code = (group: number) => /* wgsl */`\n        @group(${group}) @binding(${GBufferGroupIndices.Normal}) \n        var gBufferNormal: texture_2d<f32>;\n        \n        @group(${group}) @binding(${GBufferGroupIndices.Albedo}) \n        var gBufferAlbedo: texture_2d<f32>;\n        \n        @group(${group}) @binding(${GBufferGroupIndices.Emission}) \n        var gBufferEmission: texture_2d<f32>;\n\n        @group(${group}) @binding(${GBufferGroupIndices.MetallicRoughness}) \n        var gBufferMetallicRoughness: texture_2d<f32>;\n        \n        @group(${group}) @binding(${GBufferGroupIndices.Depth})  \n        var gBufferDepth: texture_depth_2d;\n    `;\n\n    static readonly layoutDescription: GPUBindGroupLayoutDescriptor = {\n        label: 'gbuffer bind group layout',\n        entries: [\n            {\n                binding: GBufferGroupIndices.Normal,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { sampleType: 'unfilterable-float' },\n            },\n            {\n                binding: GBufferGroupIndices.Albedo,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { sampleType: 'float' },\n            },\n            {\n                binding: GBufferGroupIndices.Emission,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { sampleType: 'float' },\n            },\n            {\n                binding: GBufferGroupIndices.MetallicRoughness,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { sampleType: 'unfilterable-float' },\n            },\n            {\n                binding: GBufferGroupIndices.Depth,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { sampleType: 'depth' },\n            },\n        ],\n    };\n\n    normal = this.createTexture({\n        format: 'rgba16float',\n        name: 'normal',\n        clearValue: { r: 0, g: 0, b: 1, a: 1 },\n    });\n\n    albedo = this.createTexture({\n        format: 'rgba8unorm',\n        name: 'albedo',\n        clearValue: { r: 0, g: 0, b: 0, a: 1 },\n    });\n\n    emission = this.createTexture({\n        format: 'rgba16float',\n        name: 'emission',\n        clearValue: { r: 0, g: 0, b: 0, a: 1 },\n    });\n\n    metallicRoughness = this.createTexture({\n        format: 'rg8unorm',\n        name: 'metallic roughness',\n        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n    });\n\n    depth = this.createTexture({\n        format: 'depth32float',\n        name: 'depth',\n    });\n\n    textures = [\n        this.normal,\n        this.albedo,\n        this.emission,\n        this.metallicRoughness,\n        this.depth,\n    ];\n\n    targets = this.textures.slice(0, -1).map(({ format }) => ({ format }));\n\n    bindGroupLayout = this.device.createBindGroupLayout(GBuffer.layoutDescription);\n    bindgroup = this.updateBindgroup();\n    passDescriptor = this.updatePassDescriptor();\n\n    get size() { return this._size; }\n    set size(value: GPUExtent3D) {\n        this._size = value;\n\n        this.textures.forEach((tex) => { this.createTexture(tex); });\n        this.bindgroup = this.updateBindgroup();\n        this.passDescriptor = this.updatePassDescriptor();\n    }\n\n    constructor(\n        public readonly device: GPUDevice,\n        private _size: GPUExtent3D,\n    ) { }\n\n    updateBindgroup() {\n        const entries = this.textures.map(({ view }, idx) => ({\n            binding: idx,\n            resource: view,\n        }));\n\n        return this.device.createBindGroup({\n            label: 'gbuffer bind group',\n            layout: this.bindGroupLayout,\n            entries,\n        });\n    }\n\n    updatePassDescriptor() {\n        const colorAttachments = this.textures.slice(0, -1).map(({ view, clearValue }) => ({\n            view: view,\n            clearValue: clearValue,\n            loadOp: 'clear',\n            storeOp: 'store',\n        }));\n\n        return {\n            label: 'forward pass encoder',\n            colorAttachments,\n            depthStencilAttachment: {\n                view: this.depth.view,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n                depthClearValue: 1.0,\n            },\n        } as GPURenderPassDescriptor;\n    }\n\n    createTexture(tex: TextureData) {\n        const label = `gbuffer ${tex.name}`;\n        tex.texture = this.device.createTexture({\n            label,\n            size: this._size,\n            format: tex.format,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n        });\n        tex.view = tex.texture.createView({ label });\n        return tex as TextureData & Required<Pick<TextureData, 'texture' | 'view'>>;\n    }\n}\n","export default /* wgsl */`\n    fn hammersley(i: u32, N: u32) -> vec2f {\n        var bits = (i << 16u) | (i >> 16u);\n        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n        let rdi = f32(bits) * 2.3283064365386963e-10; // / 0x100000000\n        return vec2(f32(i) / f32(N), rdi);\n    }\n\n    fn tangentSampleGGX(N: vec3f, Xi: vec2f, a2: f32) -> vec3f {\n        const PI = 3.14159265359;\n\n        let phi = 2.0 * PI * Xi.x;\n        let cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));\n        let sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n        \n        var H: vec3f;\n        H.x = cos(phi) * sinTheta;\n        H.y = sin(phi) * sinTheta;\n        H.z = cosTheta;\n\n        let up = select(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), abs(N.z) >= 0.999);\n        let T = normalize(cross(up, N));\n        let B = cross(N, T);\n\n        let S = T * H.x + B * H.y + N * H.z;\n        return normalize(S);\n    }\n\n    fn vPartLambda(NoV: f32, a2: f32) -> f32 {\n        return sqrt(NoV * NoV * (1.0 - a2) + a2);\n    }\n\n    fn vCorrelatedGGX(NoV: f32, NoL: f32, a2: f32) -> f32 {\n        let GGXV = NoL * vPartLambda(NoV, a2);\n        let GGXL = NoV * vPartLambda(NoL, a2);\n        return 0.5 / (GGXV + GGXL);\n    }\n\n    fn dS2GGX(NoH: f32, a2: f32) -> f32 {\n        let s = (a2 - 1.0) * NoH * NoH + 1.0;\n        return s * s;\n    }\n\n    fn dGGX(NoH: f32, a2: f32) -> f32 {\n        const invPI = 1.0 / 3.14159265359;\n\n        let s2 = dS2GGX(NoH, a2);\n        return invPI * select(1, a2 / s2, a2 != s2);\n    }\n`;\n","import brdfs from '../../shaders/brdfs.shader';\nimport blit from '../../shaders/blit-vert.shader';\n\nconst code = /* wgsl */ `\noverride SAMPLE_COUNT: u32 = 1024u;\n\n${blit}\n${brdfs}\n\n@fragment\nfn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n    let NoV = uv.x;\n    let roughness = uv.y;\n    let alpha = roughness * roughness;\n    let a2 = alpha * alpha;\n    let V = vec3(sqrt(1.0 - NoV * NoV), NoV, 0.0);\n    let N = vec3(0.0, 1.0, 0.0);\n\n    var brdf = vec2(0.0);\n\n    for (var i = 0u; i < SAMPLE_COUNT; i++) {\n        let Xi = hammersley(i, SAMPLE_COUNT);\n        let H = tangentSampleGGX(N, Xi, a2);\n        let L = normalize(2.0 * dot(V, H) * H - V);\n\n        let NoL = saturate(L.y);\n        let NoH = saturate(H.y);\n        let VoH = saturate(dot(V, H));\n\n        if (NoL > 0.0) {\n            let pdf = vCorrelatedGGX(NoV, NoL, a2) * VoH * NoL / NoH;\n            let Fc = pow(1.0 - VoH, 5.0);\n            brdf += vec2(1.0 - Fc, Fc) * pdf;\n        }\n    }\n\n    return vec4f(brdf * 4.0 / f32(SAMPLE_COUNT), 0.0, 1.0);\n}\n`;\n\nexport type BfrdLutDescriptor = {\n    device: GPUDevice,\n    label?: string,\n    width?: number,\n    height?: number,\n    format?: GPUTextureFormat,\n    sampleCount?: number,\n};\n\nexport function createBfrdLut({\n    device,\n    label,\n    sampleCount,\n    width = 1024,\n    height = 1024,\n    format = 'rg32float',\n}: BfrdLutDescriptor) {\n    const bfrdLut = device.createTexture({\n        label,\n        format,\n        dimension: '2d',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n        size: { width, height },\n    });\n\n    const module = device.createShaderModule({ label: 'bfrdLut shader', code });\n\n    const pipeline = device.createRenderPipeline({\n        label: 'bfrd lut pipeline',\n        layout: 'auto',\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format }],\n            constants: sampleCount ? { SAMPLE_COUNT: sampleCount } : undefined,\n            module,\n        },\n    });\n\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n        label: 'brdf lut render pass',\n        colorAttachments: [{\n            view: bfrdLut.createView(),\n            loadOp: 'clear',\n            storeOp: 'store',\n        }],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n\n    return bfrdLut;\n}\n","import { toWorldDir } from '../../shaders/cubemap-sampling.shader';\nimport brdfs from '../../shaders/brdfs.shader';\nimport blit from '../../shaders/blit-vert.shader';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\n\nconst code = /* wgsl */`\n    const PI = 3.14159265359;\n\n    override SAMPLES: u32 = 2048u;\n\n    struct Params {\n        face: u32,\n        size: u32,\n    }\n\n    @group(0) @binding(0) var environment: texture_cube<f32>;\n    @group(0) @binding(1) var environmentSampler: sampler;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    ${toWorldDir}\n    ${brdfs}\n    ${blit}\n\n    @fragment\n    fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {\n        let coord = vec3u(vec2u(floor(pos.xy)), params.face);\n        let size = f32(textureDimensions(environment).x);\n        let lodFactor = 6.0 * size * size / f32(SAMPLES);\n\n        let N = toWorldDir(coord, params.size);\n        let right = normalize(cross(vec3(0.0, 1.0, 0.0), N));\n        let up = normalize(cross(N, right));\n        let TBN = mat3x3(right, up, N);\n        \n        var irradiance = vec3(0.0);\n        var samples = 0.0;\n\n        for (var i = 0u; i < SAMPLES; i += 1) {\n            let xi = hammersley(i, SAMPLES);\n            let cosTheta = sqrt(1.0 - xi.y);\n            let sinTheta = sqrt(xi.y);\n            let phi = 2.0 * PI * xi.x;\n            let invPdf = PI / cosTheta;\n            let localDir = normalize(vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta));\n            let worldDir = TBN * localDir;\n            let lod = 0.5 * log2(lodFactor * invPdf);\n            irradiance += textureSampleLevel(environment, environmentSampler, worldDir, lod).rgb;\n        }\n\n        return vec4(irradiance / f32(SAMPLES), 1.0);\n    }\n`;\n\nexport type IrradianceTextureDescriptor = {\n    device: GPUDevice,\n    texture: GPUTexture,\n    label?: string,\n    usage?: GPUTextureUsageFlags,\n    samples?: number,\n    outputWidth?: number,\n    outputFormat?: GPUTextureFormat,\n    outputTexture?: GPUTexture,\n};\n\nexport default function createIrradianceTexture({\n    device,\n    texture,\n    label = 'irradiance',\n    usage = 0,\n    samples = 2048,\n    outputWidth,\n    outputFormat,\n    outputTexture,\n}: IrradianceTextureDescriptor) {\n    const format = outputTexture?.format ?? outputFormat ?? texture.format;\n    const width = outputTexture?.width ?? outputWidth ?? 64;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { viewDimension: 'cube' },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.FRAGMENT,\n                sampler: {},\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.FRAGMENT,\n                buffer: { type: 'uniform' },\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({ minFilter: 'linear', magFilter: 'linear', mipmapFilter: 'linear' });\n\n    const irradianceTexture = outputTexture?.depthOrArrayLayers === 6\n        ? outputTexture\n        : device.createTexture({\n            label,\n            format,\n            dimension: '2d',\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | usage,\n            size: { width, height: width, depthOrArrayLayers: 6 },\n        });\n\n    const params = new Uint32Array([0, irradianceTexture.width]);\n    const paramBuffer = createAndCopyBuffer(\n        params,\n        GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        device,\n    );\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: texture.createView({ dimension: 'cube' }),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n            {\n                binding: 2,\n                resource: { buffer: paramBuffer },\n            },\n        ],\n    });\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const module = device.createShaderModule({ label, code });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            module,\n            entryPoint: 'vs',\n        },\n        fragment: {\n            entryPoint: 'fs',\n            constants: {\n                SAMPLES: samples,\n            },\n            module,\n            targets: [{ format }],\n        },\n    });\n\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n\n        const view = irradianceTexture.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            colorAttachments: [{\n                view,\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n\n    return irradianceTexture;\n}\n","import { toWorldDir } from '../../shaders/cubemap-sampling.shader';\nimport brdfs from '../../shaders/brdfs.shader';\nimport blit from '../../shaders/blit-vert.shader';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\n\nconst code = /* wgsl */`\n    override SAMPLES: u32 = 1024u;\n\n    const PI = 3.14159265359;\n    const invPI = 1.0 / PI;\n\n    struct Params {\n        face: u32,\n        mipSize: u32,\n        invOmegaP: f32,\n        a2: f32,\n    }\n\n    @group(0) @binding(0) var environment: texture_cube<f32>;\n    @group(0) @binding(1) var environmentSampler: sampler;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    ${toWorldDir}\n    ${brdfs}\n    ${blit}\n\n    @fragment\n    fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n        let N = toWorldDirF32(uv, params.face);\n\n        var radiance = vec3(0.0);\n        var totalWeight = 0.0;\n        \n        for (var i = 0u; i < SAMPLES; i += 1) {\n            let Xi = hammersley(i, SAMPLES);\n            let H = tangentSampleGGX(N, Xi, params.a2);\n            let HoV = saturate(dot(H, N));\n            let L = normalize(2.0 * HoV * H - N);\n            let NoL = saturate(dot(N, L));\n\n            if (NoL <= 0.0) { continue; }\n\n            let pdf = dGGX(HoV, params.a2) / 4.0 + 0.001;\n            let omegaS = 1.0 / (f32(SAMPLES) * pdf);\n            let mipLevel = 0.5 * log2(omegaS * params.invOmegaP) + params.a2;\n\n            radiance += textureSampleLevel(environment, environmentSampler, L, mipLevel).rgb * NoL;\n            totalWeight += NoL;\n        }\n    \n        return vec4(radiance / totalWeight, 1.0);\n    }\n`;\n\nexport type IrradianceTextureDescriptor = {\n    device: GPUDevice,\n    texture: GPUTexture,\n    label?: string,\n    usage?: GPUTextureUsageFlags,\n    targetFormat?: GPUTextureFormat,\n    outputTexture?: GPUTexture,\n    outputWidth?: number,\n    samples?: number,\n    inPlaceMips?: boolean,\n};\n\nexport default function createRadianceTexture({\n    device,\n    texture,\n    targetFormat,\n    usage = 0,\n    label = 'radiance',\n    samples = 1024,\n    outputWidth,\n    outputTexture,\n}: IrradianceTextureDescriptor) {\n    const format = outputTexture?.format ?? targetFormat ?? texture.format;\n    const width = outputTexture?.width ?? outputWidth ?? texture.width;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { viewDimension: 'cube' },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.FRAGMENT,\n                sampler: {},\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.FRAGMENT,\n                buffer: { type: 'uniform' },\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({ minFilter: 'linear', magFilter: 'linear', mipmapFilter: 'linear' });\n    const paramArrayBuffer = new ArrayBuffer(4 * 4);\n    const uintParams = new Uint32Array(paramArrayBuffer, 0, 2);\n    const floatParams = new Float32Array(paramArrayBuffer, 2 * 4, 2);\n\n    const paramBuffer = createAndCopyBuffer(\n        paramArrayBuffer,\n        GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        device,\n    );\n\n    const radianceTexture = outputTexture?.depthOrArrayLayers === 6\n        ? outputTexture\n        : device.createTexture({\n            label,\n            format,\n            dimension: '2d',\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST | usage,\n            size: { width, height: width, depthOrArrayLayers: 6 },\n            mipLevelCount: Math.max((Math.log2(width) | 0) - 2, 1),\n        });\n\n    const copyEncoder = device.createCommandEncoder({\n        label: `${label} copy encoder`,\n    });\n\n    copyEncoder.copyTextureToTexture(\n        { texture, mipLevel: 0 },\n        { texture: radianceTexture, mipLevel: 0 },\n        { width, height: width, depthOrArrayLayers: 6 },\n    );\n    device.queue.submit([copyEncoder.finish()]);\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const module = device.createShaderModule({ label, code });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            module,\n            entryPoint: 'vs',\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: radianceTexture.format }],\n            constants: {\n                SAMPLES: samples,\n            },\n            module,\n        },\n    });\n\n    floatParams[0] = (6 * texture.width * texture.width) / (4 * Math.PI);\n\n    void Promise.resolve().then(async () => {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: texture.createView({ dimension: 'cube' }),\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n                {\n                    binding: 2,\n                    resource: { buffer: paramBuffer },\n                },\n            ],\n        });\n\n        for (let mip = 1; mip < radianceTexture.mipLevelCount; mip += 1) {\n            const roughness = mip / (radianceTexture.mipLevelCount - 1);\n            floatParams[1] = roughness ** 4;\n            uintParams[1] = (radianceTexture.width >> mip) | 0;\n\n            for (let face = 0; face < 6; face += 1) {\n                await device.queue.onSubmittedWorkDone();\n                uintParams[0] = face;\n                device.queue.writeBuffer(paramBuffer, 0, paramArrayBuffer);\n\n                const view = radianceTexture.createView({\n                    dimension: '2d',\n                    arrayLayerCount: 1,\n                    baseArrayLayer: face,\n                    mipLevelCount: 1,\n                    baseMipLevel: mip,\n                });\n\n                const encoder = device.createCommandEncoder();\n                const pass = encoder.beginRenderPass({\n                    colorAttachments: [{\n                        view,\n                        loadOp: 'clear',\n                        storeOp: 'store',\n                    }],\n                });\n\n                pass.setPipeline(pipeline);\n                pass.setBindGroup(0, bindgroup);\n                pass.draw(3);\n                pass.end();\n                device.queue.submit([encoder.finish()]);\n            }\n        }\n    });\n\n    return radianceTexture;\n}\n","import GBuffer from './gbuffer';\nimport brdfs from '../shaders/brdfs.shader';\nimport blit from '../shaders/blit-vert.shader';\nimport GlobalUniforms from './global-uniforms';\nimport { createBfrdLut } from './ibl-textures/create-bfrd-lut';\nimport createIrradianceTexture from './ibl-textures/create-irradiance-texture';\nimport createRadianceTexture from './ibl-textures/create-radiance-texture';\n\nexport default class DeferredPass {\n    static readonly code = /* wgsl */`\n        ${GlobalUniforms.code(0)}\n        ${GBuffer.code(1)}\n\n        @group(2) @binding(0) var radianceTexture: texture_cube<f32>;\n        @group(2) @binding(1) var irradianceTexture: texture_cube<f32>;\n        @group(2) @binding(2) var brdfTexture: texture_2d<f32>;\n        @group(2) @binding(3) var generalSampler: sampler;\n\n        ${brdfs}\n        ${blit}\n\n        @fragment\n        fn fs(@builtin(position) pos: vec4f, @location(0) uv: vec2f) -> @location(0) vec4f {\n            let uvi = vec2<u32>(pos.xy);\n            let depth = textureLoad(gBufferDepth, uvi, 0);\n\n            if (depth >= 1.0) { discard; }\n\n            let uvClip = vec2(uv.x * 2.0 - 1.0, 1.0 - uv.y * 2.0);\n            let clipPos = vec4(uvClip, depth, 1.0);\n            let viewPos = globals.inverseViewToClip * clipPos;\n            let worldDir = globals.inverseWorldToView * vec4(viewPos.xyz / viewPos.w, 0.0);\n            let view = -normalize(worldDir.xyz);\n\n            let normal = textureLoad(gBufferNormal, uvi, 0).rgb;\n            let albedo = textureLoad(gBufferAlbedo, uvi, 0).rgb;\n            let emission = textureLoad(gBufferEmission, uvi, 0).rgb;\n            let metallicRoughnessSample = textureLoad(gBufferMetallicRoughness, uvi, 0);\n            let metallic = metallicRoughnessSample.r;\n            let roughness = metallicRoughnessSample.g;\n            let alpha = roughness * roughness;\n            let a2 = alpha * alpha;\n\n            let NoV = saturate(dot(normal, view));\n            let F0 = mix(vec3f(0.04), albedo, metallic);\n            let R = reflect(-view, normal);\n\n            let level = roughness * f32(textureNumLevels(radianceTexture) - 1u);\n            let radiance = textureSampleLevel(radianceTexture, generalSampler, R, level).rgb;\n            let irradiance = textureSample(irradianceTexture, generalSampler, normal).rgb;\n            let brdf = textureSample(brdfTexture, generalSampler, saturate(vec2f(NoV, roughness))).xy;\n\n            // Roughness dependent fresnel\n            let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n            let kS = F0 + Fr * pow(1.0 - NoV, 5.0);\n            let FssEss = kS * brdf.x + brdf.y;\n\n            // Multiple scattering, originally proposed by Fdez-Aguera\n            // and here adapted from https://bruop.github.io/ibl\n            let Ems = 1.0 - (brdf.x + brdf.y);\n            let Favg = F0 + (1.0 - F0) / 21.0;\n            let FmsEms = Ems * FssEss * Favg / (1.0 - Favg * Ems);\n            let kD = albedo * (1.0 - 0.04) * (1.0 - metallic) * (1.0 - FssEss + FmsEms);\n\n            let specular = FssEss * radiance;\n            let diffuse = (FmsEms + kD) * irradiance;\n            let ambient = specular + diffuse + emission;\n\n            return vec4f(ambient, 1.0);\n        }\n    `;\n\n    target: GPURenderPassColorAttachment = {\n        view: undefined!, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        clearValue: { r: 0, g: 0, b: 0, a: 1 },\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n\n    bfrdLut = createBfrdLut({ device: this.device });\n    bfrdLutView = this.bfrdLut.createView();\n\n    irradianceTexture?: GPUTexture;\n    irradianceView?: GPUTextureView;\n    radianceTexture?: GPUTexture;\n    radianceView?: GPUTextureView;\n    bindgroup?: GPUBindGroup;\n\n    sampler: GPUSampler;\n    pipeline: GPURenderPipeline;\n    bindgroupLayout: GPUBindGroupLayout;\n\n    readonly passDescriptor: GPURenderPassDescriptor = { colorAttachments: [this.target] };\n\n    set skybox(texture: GPUTexture) {\n        this.irradianceTexture = createIrradianceTexture({\n            texture,\n            device: this.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        this.radianceTexture = createRadianceTexture({\n            texture,\n            device: this.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        this.irradianceView = this.irradianceTexture.createView({ dimension: 'cube' });\n        this.radianceView = this.radianceTexture.createView({ dimension: 'cube' });\n\n        this.bindgroup = this.device.createBindGroup({\n            layout: this.bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: this.radianceView,\n                },\n                {\n                    binding: 1,\n                    resource: this.irradianceView,\n                },\n                {\n                    binding: 2,\n                    resource: this.bfrdLutView,\n                },\n                {\n                    binding: 3,\n                    resource: this.sampler,\n                },\n            ],\n        });\n    }\n\n    constructor(public device: GPUDevice, public globals: GlobalUniforms, public gbuffer: GBuffer, format: GPUTextureFormat, skybox?: GPUTexture) {\n        this.sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear', mipmapFilter: 'linear' });\n\n        if (skybox != null) this.skybox = skybox;\n\n        this.bindgroupLayout = device.createBindGroupLayout({\n            label: 'deferred pass',\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: { viewDimension: 'cube' },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: { viewDimension: 'cube' },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: { viewDimension: '2d' },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n            ],\n        });\n\n        const layout = device.createPipelineLayout({\n            label: 'deferred pass bindgroup layout',\n            bindGroupLayouts: [\n                this.globals.bindGroupLayout,\n                this.gbuffer.bindGroupLayout,\n                this.bindgroupLayout,\n            ],\n        });\n\n        const module = device.createShaderModule({ code: DeferredPass.code, label: 'deferred pass shader' });\n\n        this.pipeline = device.createRenderPipeline({\n            layout,\n            vertex: {\n                entryPoint: 'vs',\n                module,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                targets: [{ format }],\n                module,\n            },\n        });\n    }\n\n    render(pass: GPURenderPassEncoder) {\n        if (this.bindgroup == null) return;\n        pass.setPipeline(this.pipeline);\n        pass.setBindGroup(0, this.globals.bindgroup);\n        pass.setBindGroup(1, this.gbuffer.bindgroup);\n        pass.setBindGroup(2, this.bindgroup);\n        pass.draw(3);\n    }\n}\n","import Camera from './camera/camera';\nimport GlobalUniforms from './global-uniforms';\nimport TonemapPass from './tonemap-pass';\nimport SkyboxPass from './skybox-pass';\nimport GBuffer from './gbuffer';\nimport DeferredPass from './deferred-pass';\n\nimport { binaryInsert, debounce } from '../utils/general';\n\nexport type ForwardPassParams = {\n    encoder: GPUCommandEncoder,\n    globals: GlobalUniforms,\n    gbuffer: GBuffer,\n};\n\nexport type ForwardPass = {\n    render: (params: ForwardPassParams) => void,\n    priority: number,\n};\n\nexport default class Renderer {\n    static readonly requiredFeatures: GPUFeatureName[] = ['float32-filterable'];\n    static readonly outputFormat: GPUTextureFormat = navigator.gpu.getPreferredCanvasFormat();\n    static readonly postProcessFormat: GPUTextureFormat = 'rgba32float';\n\n    colorAttachment: GPURenderPassColorAttachment = {\n        clearValue: { r: 0, g: 0, b: 0, a: 1 },\n        loadOp: 'clear',\n        storeOp: 'store',\n        view: undefined!, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    };\n\n    passDescriptor: GPURenderPassDescriptor = { colorAttachments: [this.colorAttachment] };\n\n    context: GPUCanvasContext;\n    camera: Camera;\n    globals: GlobalUniforms;\n    gbuffer: GBuffer;\n\n    forwardPasses: ForwardPass[] = [];\n    deferredPass: DeferredPass;\n    skyboxPass: SkyboxPass;\n    tonemapPass: TonemapPass;\n\n    postprocessTarget!: GPUTexture;\n\n    set skybox(texture: GPUTexture) {\n        this.deferredPass.skybox = texture;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.skyboxPass.skyTexture = this.deferredPass.radianceView!;\n    }\n\n    constructor(\n        public readonly canvas: HTMLCanvasElement,\n        public readonly device: GPUDevice,\n    ) {\n        const size = { width: this.canvas.width, height: this.canvas.height };\n        this.camera = new Camera(size);\n        this.globals = new GlobalUniforms(this.device);\n        this.gbuffer = new GBuffer(device, size);\n        this.deferredPass = new DeferredPass(device, this.globals, this.gbuffer, Renderer.postProcessFormat);\n\n        this.skyboxPass = new SkyboxPass(\n            this.device,\n            this.globals,\n            Renderer.postProcessFormat,\n        );\n        this.tonemapPass = new TonemapPass(this.device, Renderer.outputFormat);\n\n        const context = this.canvas.getContext('webgpu');\n        if (context == null) throw new Error('renderer -- given canvas already initialized to non-webgpu context');\n\n        this.context = context as unknown as GPUCanvasContext;\n\n        this.context.configure({\n            device: this.device,\n            format: Renderer.outputFormat,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            alphaMode: 'opaque',\n            colorSpace: 'srgb',\n        });\n\n        this.updateBackings(size);\n        this.#createResizeObserver();\n    }\n\n    static async CreateInitialized(canvas: HTMLCanvasElement): Promise<Renderer> {\n        const adapter = await navigator.gpu.requestAdapter();\n        if (adapter == null) {\n            throw new Error('Could not initialize GPU.');\n        }\n\n        const {\n            maxComputeWorkgroupSizeX,\n            maxComputeWorkgroupsPerDimension,\n            maxComputeInvocationsPerWorkgroup,\n        } = adapter.limits;\n\n        const device = await adapter.requestDevice({\n            label: 'main logical device',\n            requiredFeatures: Renderer.requiredFeatures,\n            requiredLimits: {\n                maxComputeWorkgroupSizeX,\n                maxComputeWorkgroupsPerDimension,\n                maxComputeInvocationsPerWorkgroup,\n            },\n        });\n\n        return new Renderer(canvas, device);\n    }\n\n    updateBackings(size: { width: number, height: number }) {\n        this.camera.updateParams(size);\n        this.postprocessTarget = this.device.createTexture({\n            dimension: '2d',\n            format: Renderer.postProcessFormat,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n            size,\n        });\n\n        this.colorAttachment.view = this.postprocessTarget.createView();\n        this.tonemapPass.updateInput(this.colorAttachment.view);\n        this.gbuffer.size = size;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.skyboxPass.depthTexture = this.gbuffer.depth.view!;\n    }\n\n    #createResizeObserver() {\n        const resizeCanvas = debounce((rawWidth: number, rawHeight: number) => {\n            const width = Math.max(1, Math.min(rawWidth | 0, this.device.limits.maxTextureDimension2D));\n            const height = Math.max(1, Math.min(rawHeight | 0, this.device.limits.maxTextureDimension2D));\n            const dimensions = { width, height };\n            this.canvas.width = width;\n            this.canvas.height = height;\n            this.updateBackings(dimensions);\n        }, 20);\n\n        try {\n            const observer = new ResizeObserver((entries) => {\n                const [{ inlineSize, blockSize }] = entries[entries.length - 1].devicePixelContentBoxSize;\n                resizeCanvas(inlineSize, blockSize);\n            });\n            observer.observe(this.canvas, { box: 'device-pixel-content-box' });\n        } catch {\n            // Safari doesn't support device-pixel-content-box, so it would fail into this.\n            const observer = new ResizeObserver((entries) => {\n                const [{ inlineSize, blockSize }] = entries[entries.length - 1].contentBoxSize;\n                resizeCanvas(inlineSize * devicePixelRatio, blockSize * devicePixelRatio);\n            });\n            observer.observe(this.canvas, { box: 'content-box' });\n        }\n    }\n\n    addForwardPass(forwardPass: ForwardPass) {\n        binaryInsert(this.forwardPasses, forwardPass, (a, b) => a.priority - b.priority);\n    }\n\n    render = () => {\n        requestAnimationFrame(this.render);\n\n        this.globals.updateDeviceBuffer(this.device.queue, this.camera);\n\n        const encoder = this.device.createCommandEncoder({ label: 'main render encoder' });\n        const forwardPassParams = { encoder, globals: this.globals, gbuffer: this.gbuffer };\n\n        for (const forwardPass of this.forwardPasses) {\n            forwardPass.render(forwardPassParams);\n        }\n\n        const pass = encoder.beginRenderPass(this.passDescriptor);\n        this.deferredPass.render(pass);\n        this.skyboxPass.render(pass);\n        pass.end();\n\n        this.tonemapPass.render(encoder, this.context.getCurrentTexture());\n\n        this.device.queue.submit([encoder.finish()]);\n    };\n}\n","export default /* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`;\r\n","export const toWorldDir: string = /* wgsl */`\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nexport const cubemapSampleConversions: string = /* wgsl */`\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n","import * as ktxparse from 'ktx-parse';\r\n\r\nimport { VkFormatToWebGPU, TextureFormatToSize, TextureFormatToChannelSize, WebGPUToVkFormat } from '../rendering/constants';\r\nimport { padTemplate } from './general';\r\n\r\nexport function createAndCopyBuffer(\r\n    arr: ArrayBuffer | TypedArrayLike,\r\n    usage: GPUFlagsConstant,\r\n    device: GPUDevice,\r\n    label?: string,\r\n    alignment = 4,\r\n): GPUBuffer {\r\n    const pad = alignment - 1;\r\n    const buffer = device.createBuffer({\r\n        label,\r\n        usage,\r\n        size: (arr.byteLength + pad) & ~pad,\r\n        mappedAtCreation: true,\r\n    } as GPUBufferDescriptor);\r\n\r\n    const writeArray = new Uint8Array(buffer.getMappedRange());\r\n    const readArray = arr instanceof ArrayBuffer\r\n        ? new Uint8Array(arr)\r\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n\r\n    writeArray.set(readArray);\r\n    buffer.unmap();\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function createAndCopyCubemap(\r\n    device: GPUDevice,\r\n    data: ArrayBuffer,\r\n    format: GPUTextureFormat,\r\n    usage: number,\r\n    label?: string,\r\n) {\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\r\n    }\r\n\r\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\r\n    const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n    const texture = device.createTexture({\r\n        usage: usage | GPUTextureUsage.COPY_DST,\r\n        label,\r\n        format,\r\n        size,\r\n    });\r\n\r\n    device.queue.writeTexture(\r\n        { texture },\r\n        data,\r\n        { bytesPerRow: width * pixelSize, rowsPerImage: width },\r\n        size,\r\n    );\r\n\r\n    return texture;\r\n}\r\n\r\nexport type KTXImportOptions = {\r\n    label?: string,\r\n    mipLevelCount?: number | 'max' | 'default',\r\n    textureUsage?: number,\r\n    validate?: boolean,\r\n};\r\n\r\nexport function ktx2ToTexture(\r\n    buffer: ArrayBuffer,\r\n    device: GPUDevice,\r\n    options?: KTXImportOptions,\r\n) {\r\n    const arr = new Uint8Array(buffer);\r\n    const ktx = ktxparse.read(arr);\r\n    const format = VkFormatToWebGPU[ktx.vkFormat];\r\n\r\n    if (format == null) {\r\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not covert to webgpu`);\r\n    }\r\n\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not get pixel byte size`);\r\n    }\r\n\r\n    const size = {\r\n        width: ktx.pixelWidth,\r\n        height: ktx.pixelHeight,\r\n        depthOrArrayLayers: ktx.faceCount,\r\n    };\r\n\r\n    const maxMipCount = Math.ceil(Math.log2(Math.max(size.width, size.height))) + 1;\r\n    let mipLevelCount = ktx.levels.length;\r\n    if (options?.mipLevelCount === 'max') {\r\n        mipLevelCount = maxMipCount;\r\n    } else if (typeof options?.mipLevelCount === 'number') {\r\n        mipLevelCount = Math.min(maxMipCount, options.mipLevelCount);\r\n    }\r\n\r\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\r\n    if (options?.textureUsage) usage |= options.textureUsage;\r\n\r\n    const texture = device.createTexture({\r\n        label: options?.label,\r\n        size,\r\n        mipLevelCount,\r\n        format,\r\n        usage,\r\n    });\r\n\r\n    const mipCopies = Math.min(ktx.levels.length, mipLevelCount) - 1;\r\n\r\n    for (let mipLevel = mipCopies; mipLevel >= 0; mipLevel -= 1) {\r\n        const width = size.width >> mipLevel;\r\n        const height = size.height >> mipLevel;\r\n        const { levelData } = ktx.levels[mipLevel];\r\n\r\n        const rawBytesPerRow = width * pixelSize;\r\n        const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n        const rowsPerImage = height;\r\n        const bytesPerImage = rowsPerImage * bytesPerRow;\r\n\r\n        let imageData = levelData;\r\n        if (bytesPerRow > rawBytesPerRow) {\r\n            imageData = new Uint8Array(bytesPerImage * texture.depthOrArrayLayers);\r\n\r\n            for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n                for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                    imageData[w + h * bytesPerRow] = levelData[w + h * rawBytesPerRow];\r\n                }\r\n            }\r\n        }\r\n\r\n        const layerBatch = Math.min(\r\n            Math.floor(device.limits.maxBufferSize / bytesPerImage),\r\n            ktx.faceCount,\r\n        );\r\n        const layerCount = Math.ceil(ktx.faceCount / layerBatch);\r\n\r\n        for (let l = 0; l < layerCount; l += 1) {\r\n            const offset = l * layerBatch;\r\n            const count = Math.min(layerBatch, ktx.faceCount - offset);\r\n\r\n            const data = layerCount > 1\r\n                ? imageData.subarray(offset * bytesPerImage, (offset + count) * bytesPerImage)\r\n                : imageData;\r\n\r\n            device.queue.writeTexture(\r\n                { mipLevel, texture, origin: [0, 0, offset] },\r\n                data,\r\n                { bytesPerRow, rowsPerImage },\r\n                [width, height, count],\r\n            );\r\n        }\r\n    }\r\n\r\n    return texture;\r\n}\r\n\r\nexport type TextureToArrayBufferOptions = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    mipLevel?: number,\r\n    resultBuffer?: Uint8Array,\r\n    storageBuffer?: GPUBuffer,\r\n    returnBuffer?: boolean,\r\n    description?: string,\r\n};\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer?: false },\r\n): Promise<{ imageData: Uint8Array }>;\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer: true },\r\n): Promise<{ imageData: Uint8Array, storageBuffer: GPUBuffer }>;\r\n\r\nexport async function textureToArrayBuffer({\r\n    device,\r\n    texture,\r\n    mipLevel = 0,\r\n    returnBuffer,\r\n    storageBuffer,\r\n    resultBuffer,\r\n    description,\r\n}: TextureToArrayBufferOptions) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const fullDescription = padTemplate`[textureToKTX${description ?? ''}${texture.label}] --`;\r\n\r\n    if (pixelSize == null) {\r\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\r\n    }\r\n\r\n    const width = texture.width >> mipLevel;\r\n    const height = texture.height >> mipLevel;\r\n    const rawBytesPerRow = width * pixelSize;\r\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n    const rowsPerImage = height;\r\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\r\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\r\n\r\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\r\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\r\n    }\r\n\r\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\r\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\r\n    }\r\n\r\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\r\n\r\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\r\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\r\n    }\r\n\r\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\r\n    const storage = storageBuffer ?? device.createBuffer({\r\n        label: `${fullDescription} storage buffer`,\r\n        size: byteSize,\r\n        usage: requiredUsage,\r\n    });\r\n\r\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\r\n    encoder.copyTextureToBuffer(\r\n        { texture, mipLevel },\r\n        { buffer: storage, rowsPerImage, bytesPerRow },\r\n        { width, height, depthOrArrayLayers: texture.depthOrArrayLayers },\r\n    );\r\n    device.queue.submit([encoder.finish()]);\r\n\r\n    await Promise.all([\r\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\r\n        device.queue.onSubmittedWorkDone(),\r\n    ]);\r\n\r\n    const mapped = storage.getMappedRange(0, byteSize);\r\n    imageData.set(new Uint8Array(mapped));\r\n    storage.unmap();\r\n\r\n    if (bytesPerRow > rawBytesPerRow) {\r\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\r\n            }\r\n        }\r\n        imageData = imageData.slice(0, resultSize);\r\n    }\r\n\r\n    return {\r\n        imageData,\r\n        storageBuffer: returnBuffer ? storage : undefined,\r\n    };\r\n}\r\n\r\nexport async function textureToKTX(device: GPUDevice, texture: GPUTexture, cube = false) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const typeSize = TextureFormatToChannelSize[texture.format];\r\n\r\n    if (pixelSize == null || typeSize == null) {\r\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\r\n    }\r\n\r\n    const container = new ktxparse.KTX2Container();\r\n    container.pixelWidth = texture.width;\r\n    container.pixelHeight = texture.height;\r\n    container.vkFormat = WebGPUToVkFormat[texture.format];\r\n    container.typeSize = typeSize;\r\n    delete container.keyValue.KTXswizzle;\r\n\r\n    const dataFormat = container.dataFormatDescriptor[0];\r\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\r\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\r\n    dataFormat.bytesPlane[0] = pixelSize;\r\n\r\n    dataFormat.samples = [0, 1, 2, 3].map((i) => ({\r\n        channelType: [192, 193, 194, 207][i],\r\n        samplePosition: [0, 0, 0, 0],\r\n        bitLength: container.typeSize * 8 - 1,\r\n        bitOffset: container.typeSize * 8 * i,\r\n        sampleLower: -1082130432,\r\n        sampleUpper: 1065353216,\r\n    }));\r\n\r\n    if (texture.dimension === '3d') {\r\n        container.faceCount = 1;\r\n        container.pixelDepth = texture.depthOrArrayLayers;\r\n    } else if (cube) {\r\n        const cubeLayers = texture.depthOrArrayLayers / 6;\r\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\r\n        container.faceCount = 6;\r\n    } else {\r\n        container.layerCount = texture.depthOrArrayLayers;\r\n        container.faceCount = 1;\r\n    }\r\n\r\n    let storageBuffer: GPUBuffer | undefined;\r\n    let imageData: Uint8Array;\r\n\r\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\r\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\r\n            mipLevel: i,\r\n            returnBuffer: true,\r\n            device,\r\n            texture,\r\n            storageBuffer,\r\n        }));\r\n\r\n        container.levels.push({\r\n            levelData: imageData,\r\n            uncompressedByteLength: imageData.byteLength,\r\n        });\r\n    }\r\n\r\n    return ktxparse.write(container);\r\n}\r\n"],"names":["label","GlobalUniforms","constructor","device","this","deviceBuffer","createBuffer","bufferDescriptor","bindGroupLayout","createBindGroupLayout","layoutDescriptor","bindGroupDescriptor","layout","entries","binding","resource","buffer","offset","size","bufferSize","bindgroup","createBindGroup","updateDeviceBuffer","queue","camera","cacheView","writeBuffer","code","group","bufferLength","minBindingSize","visibility","GPUShaderStage","VERTEX","FRAGMENT","usage","GPUBufferUsage","UNIFORM","COPY_DST","TonemapPass","format","colorAttachment","loadOp","storeOp","view","undefined","passDescriptor","colorAttachments","renderTarget","bindgroupLayout","bindGroupLayoutDescriptor","module","createShaderModule","pipelineDescriptor","createPipelineLayout","bindGroupLayouts","vertex","entryPoint","fragment","targets","pipeline","createRenderPipeline","updateInput","input","render","encoder","output","createView","dimension","pass","beginRenderPass","setPipeline","setBindGroup","draw","end","texture","sampleType","viewDimension","SkyboxPass","mipLevel","uniformArray","val","uniformBuffer","useNearestSample","targetFormat","pipelineLayout","shader","skyTexture","skybox","depthTexture","globals","Float32Array","target","clearValue","r","g","b","a","sampler","type","linearSampler","createSampler","minFilter","magFilter","mipmapFilter","nearestSampler","textureBindgroup","GBuffer","_size","value","textures","forEach","tex","createTexture","updateBindgroup","updatePassDescriptor","normal","name","albedo","emission","metallicRoughness","depth","slice","map","layoutDescription","idx","depthStencilAttachment","depthLoadOp","depthStoreOp","depthClearValue","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","DeferredPass","irradianceTexture","samples","outputWidth","outputFormat","outputTexture","width","depthOrArrayLayers","height","params","Uint32Array","paramBuffer","constants","SAMPLES","i","arrayLayerCount","baseArrayLayer","createCommandEncoder","submit","finish","createIrradianceTexture","radianceTexture","paramArrayBuffer","ArrayBuffer","uintParams","floatParams","mipLevelCount","Math","max","log2","copyEncoder","copyTextureToTexture","PI","Promise","resolve","then","async","mip","roughness","face","onSubmittedWorkDone","baseMipLevel","createRadianceTexture","irradianceView","radianceView","bfrdLutView","gbuffer","bfrdLut","sampleCount","SAMPLE_COUNT","createBfrdLut","Renderer","deferredPass","skyboxPass","canvas","forwardPasses","requestAnimationFrame","forwardPassParams","forwardPass","tonemapPass","context","getCurrentTexture","postProcessFormat","getContext","Error","configure","COPY_SRC","alphaMode","colorSpace","updateBackings","CreateInitialized","adapter","navigator","gpu","requestAdapter","maxComputeWorkgroupSizeX","maxComputeWorkgroupsPerDimension","maxComputeInvocationsPerWorkgroup","limits","requestDevice","requiredFeatures","requiredLimits","updateParams","postprocessTarget","addForwardPass","priority","resizeCanvas","rawWidth","rawHeight","min","maxTextureDimension2D","dimensions","ResizeObserver","inlineSize","blockSize","length","devicePixelContentBoxSize","observe","box","contentBoxSize","devicePixelRatio","getPreferredCanvasFormat","toWorldDir","cubemapSampleConversions","createAndCopyBuffer","arr","alignment","pad","byteLength","mappedAtCreation","writeArray","Uint8Array","getMappedRange","readArray","byteOffset","set","unmap","textureToArrayBuffer","returnBuffer","storageBuffer","resultBuffer","description","pixelSize","fullDescription","rawBytesPerRow","bytesPerRow","rowsPerImage","byteSize","resultSize","requiredUsage","MAP_READ","imageData","storage","copyTextureToBuffer","all","mapAsync","GPUMapMode","READ","mapped","h","w","textureToKTX","cube","typeSize","container","pixelWidth","pixelHeight","vkFormat","keyValue","KTXswizzle","dataFormat","dataFormatDescriptor","colorModel","transferFunction","bytesPlane","channelType","samplePosition","bitLength","bitOffset","sampleLower","sampleUpper","faceCount","pixelDepth","cubeLayers","layerCount","levels","push","levelData","uncompressedByteLength"],"sourceRoot":""}