"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[980],{992:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _camera_camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3048);\n\nconst label = 'global uniforms';\nclass GlobalUniforms {\n    constructor(device) {\n        this.deviceBuffer = device.createBuffer(GlobalUniforms.bufferDescriptor);\n        this.bindGroupLayout = device.createBindGroupLayout(GlobalUniforms.layoutDescriptor);\n        this.bindGroupDescriptor = {\n            label,\n            layout: this.bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.deviceBuffer,\n                        offset: 0,\n                        size: GlobalUniforms.bufferSize,\n                    },\n                },\n            ],\n        };\n        this.bindgroup = device.createBindGroup(this.bindGroupDescriptor);\n    }\n    updateDeviceBuffer(queue, camera) {\n        camera.cacheView();\n        queue.writeBuffer(this.deviceBuffer, 0, camera.buffer);\n    }\n}\nGlobalUniforms.code = (group) => /* wgsl */ `\r\n        struct GlobalUniforms {\r\n            worldToView: mat4x4f,\r\n            viewToClip: mat4x4f,\r\n            worldToClip: mat4x4f,\r\n            inverseWorldToView: mat4x4f,\r\n            inverseViewToClip: mat4x4f,\r\n            inverseWorldToClip: mat4x4f,\r\n        }\r\n\r\n        @group(${group}) @binding(0) var<uniform> globals: GlobalUniforms;\r\n    `;\nGlobalUniforms.bufferSize = _camera_camera__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A.bufferLength;\nGlobalUniforms.layoutDescriptor = {\n    label,\n    entries: [\n        {\n            binding: 0,\n            buffer: { minBindingSize: GlobalUniforms.bufferSize },\n            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n        },\n    ],\n};\nGlobalUniforms.bufferDescriptor = {\n    label,\n    size: GlobalUniforms.bufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GlobalUniforms);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBcUM7QUFFckMsTUFBTSxLQUFLLEdBQUcsaUJBQWlCLENBQUM7QUFFaEMsTUFBcUIsY0FBYztJQXNDL0IsWUFBWSxNQUFpQjtRQUN6QixJQUFJLENBQUMsWUFBWSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDekUsSUFBSSxDQUFDLGVBQWUsR0FBRyxNQUFNLENBQUMscUJBQXFCLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFckYsSUFBSSxDQUFDLG1CQUFtQixHQUFHO1lBQ3ZCLEtBQUs7WUFDTCxNQUFNLEVBQUUsSUFBSSxDQUFDLGVBQWU7WUFDNUIsT0FBTyxFQUFFO2dCQUNMO29CQUNJLE9BQU8sRUFBRSxDQUFDO29CQUNWLFFBQVEsRUFBRTt3QkFDTixNQUFNLEVBQUUsSUFBSSxDQUFDLFlBQVk7d0JBQ3pCLE1BQU0sRUFBRSxDQUFDO3dCQUNULElBQUksRUFBRSxjQUFjLENBQUMsVUFBVTtxQkFDbEM7aUJBQ0o7YUFDSjtTQUNKLENBQUM7UUFFRixJQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVELGtCQUFrQixDQUFDLEtBQWUsRUFBRSxNQUFjO1FBQzlDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNuQixLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzRCxDQUFDOztBQTlEZSxtQkFBSSxHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUUsQ0FBQyxVQUFVOzs7Ozs7Ozs7O2lCQVV2QyxLQUFLO0tBQ2pCLENBQUM7QUFFYyx5QkFBVSxHQUFHLCtEQUFNLENBQUMsWUFBWSxDQUFDO0FBRWpDLCtCQUFnQixHQUFpQztJQUM3RCxLQUFLO0lBQ0wsT0FBTyxFQUFFO1FBQ0w7WUFDSSxPQUFPLEVBQUUsQ0FBQztZQUNWLE1BQU0sRUFBRSxFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUMsVUFBVSxFQUFFO1lBQ3JELFVBQVUsRUFBRSxjQUFjLENBQUMsTUFBTSxHQUFHLGNBQWMsQ0FBQyxRQUFRO1NBQzlEO0tBQ0o7Q0FDSixDQUFDO0FBRWMsK0JBQWdCLEdBQXdCO0lBQ3BELEtBQUs7SUFDTCxJQUFJLEVBQUUsY0FBYyxDQUFDLFVBQVU7SUFDL0IsS0FBSyxFQUFFLGNBQWMsQ0FBQyxPQUFPLEdBQUcsY0FBYyxDQUFDLFFBQVE7Q0FDMUQsQ0FBQztpRUEvQmUsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy9yZW5kZXJpbmcvZ2xvYmFsLXVuaWZvcm1zLnRzPzZlNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhbWVyYSBmcm9tICcuL2NhbWVyYS9jYW1lcmEnO1xyXG5cclxuY29uc3QgbGFiZWwgPSAnZ2xvYmFsIHVuaWZvcm1zJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdsb2JhbFVuaWZvcm1zIHtcclxuICAgIHN0YXRpYyByZWFkb25seSBjb2RlID0gKGdyb3VwOiBudW1iZXIpID0+IC8qIHdnc2wgKi9gXHJcbiAgICAgICAgc3RydWN0IEdsb2JhbFVuaWZvcm1zIHtcclxuICAgICAgICAgICAgd29ybGRUb1ZpZXc6IG1hdDR4NGYsXHJcbiAgICAgICAgICAgIHZpZXdUb0NsaXA6IG1hdDR4NGYsXHJcbiAgICAgICAgICAgIHdvcmxkVG9DbGlwOiBtYXQ0eDRmLFxyXG4gICAgICAgICAgICBpbnZlcnNlV29ybGRUb1ZpZXc6IG1hdDR4NGYsXHJcbiAgICAgICAgICAgIGludmVyc2VWaWV3VG9DbGlwOiBtYXQ0eDRmLFxyXG4gICAgICAgICAgICBpbnZlcnNlV29ybGRUb0NsaXA6IG1hdDR4NGYsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBAZ3JvdXAoJHtncm91cH0pIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnbG9iYWxzOiBHbG9iYWxVbmlmb3JtcztcclxuICAgIGA7XHJcblxyXG4gICAgc3RhdGljIHJlYWRvbmx5IGJ1ZmZlclNpemUgPSBDYW1lcmEuYnVmZmVyTGVuZ3RoO1xyXG5cclxuICAgIHN0YXRpYyByZWFkb25seSBsYXlvdXREZXNjcmlwdG9yOiBHUFVCaW5kR3JvdXBMYXlvdXREZXNjcmlwdG9yID0ge1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGVudHJpZXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmluZGluZzogMCxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcjogeyBtaW5CaW5kaW5nU2l6ZTogR2xvYmFsVW5pZm9ybXMuYnVmZmVyU2l6ZSB9LFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuVkVSVEVYIHwgR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIHJlYWRvbmx5IGJ1ZmZlckRlc2NyaXB0b3I6IEdQVUJ1ZmZlckRlc2NyaXB0b3IgPSB7XHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgc2l6ZTogR2xvYmFsVW5pZm9ybXMuYnVmZmVyU2l6ZSxcclxuICAgICAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULFxyXG4gICAgfTtcclxuXHJcbiAgICBkZXZpY2VCdWZmZXI6IEdQVUJ1ZmZlcjtcclxuICAgIGJpbmRHcm91cExheW91dDogR1BVQmluZEdyb3VwTGF5b3V0O1xyXG4gICAgYmluZEdyb3VwRGVzY3JpcHRvciE6IEdQVUJpbmRHcm91cERlc2NyaXB0b3I7XHJcbiAgICBiaW5kZ3JvdXAhOiBHUFVCaW5kR3JvdXA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZGV2aWNlOiBHUFVEZXZpY2UpIHtcclxuICAgICAgICB0aGlzLmRldmljZUJ1ZmZlciA9IGRldmljZS5jcmVhdGVCdWZmZXIoR2xvYmFsVW5pZm9ybXMuYnVmZmVyRGVzY3JpcHRvcik7XHJcbiAgICAgICAgdGhpcy5iaW5kR3JvdXBMYXlvdXQgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KEdsb2JhbFVuaWZvcm1zLmxheW91dERlc2NyaXB0b3IpO1xyXG5cclxuICAgICAgICB0aGlzLmJpbmRHcm91cERlc2NyaXB0b3IgPSB7XHJcbiAgICAgICAgICAgIGxhYmVsLFxyXG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMuYmluZEdyb3VwTGF5b3V0LFxyXG4gICAgICAgICAgICBlbnRyaWVzOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMCxcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHRoaXMuZGV2aWNlQnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IEdsb2JhbFVuaWZvcm1zLmJ1ZmZlclNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kZ3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHRoaXMuYmluZEdyb3VwRGVzY3JpcHRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRGV2aWNlQnVmZmVyKHF1ZXVlOiBHUFVRdWV1ZSwgY2FtZXJhOiBDYW1lcmEpIHtcclxuICAgICAgICBjYW1lcmEuY2FjaGVWaWV3KCk7XHJcbiAgICAgICAgcXVldWUud3JpdGVCdWZmZXIodGhpcy5kZXZpY2VCdWZmZXIsIDAsIGNhbWVyYS5idWZmZXIpO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///992\n")},3980:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ renderer)\n});\n\n// EXTERNAL MODULE: ./src/rendering/camera/camera.ts\nvar camera = __webpack_require__(3048);\n// EXTERNAL MODULE: ./src/rendering/global-uniforms.ts\nvar global_uniforms = __webpack_require__(992);\n// EXTERNAL MODULE: ./src/shaders/blit-vert.shader.ts\nvar blit_vert_shader = __webpack_require__(157);\n;// ./src/rendering/tonemap-pass.ts\n\nconst label = 'tonemap pass';\nclass TonemapPass {\n    constructor(device, format) {\n        this.device = device;\n        this.colorAttachment = {\n            loadOp: 'load',\n            storeOp: 'store',\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            view: undefined,\n        };\n        this.passDescriptor = {\n            label,\n            colorAttachments: [this.colorAttachment],\n        };\n        this.renderTarget = { format };\n        this.bindgroupLayout = device.createBindGroupLayout(TonemapPass.bindGroupLayoutDescriptor);\n        const module = device.createShaderModule({ label, code: TonemapPass.code });\n        this.pipelineDescriptor = {\n            label,\n            layout: device.createPipelineLayout({\n                label,\n                bindGroupLayouts: [this.bindgroupLayout],\n            }),\n            vertex: {\n                module,\n                entryPoint: 'vs',\n            },\n            fragment: {\n                module,\n                entryPoint: 'fs',\n                targets: [this.renderTarget],\n            },\n        };\n        this.pipeline = device.createRenderPipeline(this.pipelineDescriptor);\n    }\n    updateInput(input) {\n        this.bindgroup = this.device.createBindGroup({\n            label,\n            layout: this.bindgroupLayout,\n            entries: [{\n                    binding: 0,\n                    resource: input,\n                }],\n        });\n    }\n    render(encoder, output) {\n        if (this.bindgroup == null)\n            return;\n        if (this.renderTarget.format !== output.format) {\n            this.renderTarget.format = output.format;\n            this.pipeline = this.device.createRenderPipeline(this.pipelineDescriptor);\n        }\n        this.colorAttachment.view = output.createView({ dimension: '2d' });\n        const pass = encoder.beginRenderPass(this.passDescriptor);\n        pass.setPipeline(this.pipeline);\n        pass.setBindGroup(0, this.bindgroup);\n        pass.draw(3);\n        pass.end();\n    }\n}\nTonemapPass.code = `\r\n        @group(0) @binding(0) var colorTexture: texture_2d<f32>;\r\n\r\n        ${blit_vert_shader/* default */.A}\r\n\r\n        fn fitRRTAndODT(color: vec3f) -> vec3f {\r\n            let a = color * (color + 0.0245786) - 0.000090537;\r\n            let b = color * (0.983729 * color + 0.4329510) + 0.238081;\r\n            return a / b;\r\n        }\r\n\r\n        fn aces_tone_map(hdr: vec3f) -> vec3f {\r\n            const inputMat = mat3x3(\r\n                0.59719, 0.07600, 0.02840,\r\n                0.35458, 0.90834, 0.13383,\r\n                0.04823, 0.01566, 0.83777,\r\n            );\r\n            const outputMat = mat3x3(\r\n                1.60475, -0.10208, -0.00327,\r\n                -0.53108, 1.10813, -0.07276,\r\n                -0.07367, -0.00605, 1.07602,\r\n            );\r\n            const boost = 1.0 / 0.6;\r\n\r\n            var color = hdr * boost;\r\n            color = inputMat * color;\r\n            color = fitRRTAndODT(color);\r\n            color = outputMat * color;\r\n            return saturate(color);\r\n        }\r\n\r\n        fn linear_to_srgb(color: vec3f) -> vec3f {\r\n            return pow(color, vec3(1.0/2.2));\r\n        }\r\n\r\n        @fragment\r\n        fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {\r\n            let uv = vec2<i32>(floor(pos.xy));\r\n\r\n            var color = textureLoad(colorTexture, uv, 0).rgb;\r\n            color = aces_tone_map(color);\r\n            color = linear_to_srgb(color);\r\n            return vec4f(color, 1.0);\r\n        }\r\n    `;\nTonemapPass.bindGroupLayoutDescriptor = {\n    label,\n    entries: [{\n            binding: 0,\n            texture: { sampleType: 'float', viewDimension: '2d' },\n            visibility: GPUShaderStage.FRAGMENT,\n        }],\n};\n/* harmony default export */ const tonemap_pass = (TonemapPass);\n\n;// ./src/rendering/skybox-pass.ts\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _SkyboxPass_instances, _SkyboxPass_skyTexture, _SkyboxPass_depthTexture, _SkyboxPass_targetFormat, _SkyboxPass_useNearestSample, _SkyboxPass_updateBindgroup;\n\nconst skybox_pass_label = 'skybox pass';\nclass SkyboxPass {\n    get mipLevel() { return this.uniformArray[0]; }\n    set mipLevel(val) {\n        if (val === this.uniformArray[0])\n            return;\n        this.uniformArray[0] = val;\n        this.device.queue.writeBuffer(this.uniformBuffer, 0, this.uniformArray, 0, 1);\n    }\n    get useNearestSample() { return __classPrivateFieldGet(this, _SkyboxPass_useNearestSample, \"f\"); }\n    set useNearestSample(val) {\n        if (val === __classPrivateFieldGet(this, _SkyboxPass_useNearestSample, \"f\"))\n            return;\n        __classPrivateFieldSet(this, _SkyboxPass_useNearestSample, val, \"f\");\n        __classPrivateFieldGet(this, _SkyboxPass_instances, \"m\", _SkyboxPass_updateBindgroup).call(this);\n    }\n    get targetFormat() { return __classPrivateFieldGet(this, _SkyboxPass_targetFormat, \"f\"); }\n    set targetFormat(format) {\n        if (format === __classPrivateFieldGet(this, _SkyboxPass_targetFormat, \"f\"))\n            return;\n        __classPrivateFieldSet(this, _SkyboxPass_targetFormat, format, \"f\");\n        this.pipeline = this.device.createRenderPipeline({\n            label: skybox_pass_label,\n            layout: this.pipelineLayout,\n            vertex: {\n                entryPoint: 'vs',\n                module: this.shader,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                targets: [{ format }],\n                module: this.shader,\n            },\n        });\n    }\n    set skyTexture(skybox) {\n        if (skybox === __classPrivateFieldGet(this, _SkyboxPass_skyTexture, \"f\"))\n            return;\n        __classPrivateFieldSet(this, _SkyboxPass_skyTexture, skybox, \"f\");\n        __classPrivateFieldGet(this, _SkyboxPass_instances, \"m\", _SkyboxPass_updateBindgroup).call(this);\n    }\n    set depthTexture(depthTexture) {\n        if (depthTexture === __classPrivateFieldGet(this, _SkyboxPass_depthTexture, \"f\"))\n            return;\n        __classPrivateFieldSet(this, _SkyboxPass_depthTexture, depthTexture, \"f\");\n        __classPrivateFieldGet(this, _SkyboxPass_instances, \"m\", _SkyboxPass_updateBindgroup).call(this);\n    }\n    constructor(device, globals, targetFormat, skybox) {\n        _SkyboxPass_instances.add(this);\n        this.device = device;\n        this.globals = globals;\n        this.uniformArray = new Float32Array(8);\n        _SkyboxPass_skyTexture.set(this, void 0);\n        _SkyboxPass_depthTexture.set(this, void 0);\n        _SkyboxPass_targetFormat.set(this, void 0);\n        _SkyboxPass_useNearestSample.set(this, false);\n        this.target = {\n            clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n            loadOp: 'clear',\n            storeOp: 'store',\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            view: undefined,\n        };\n        this.passDescriptor = { colorAttachments: [this.target] };\n        this.bindgroupLayout = device.createBindGroupLayout({\n            label: skybox_pass_label,\n            entries: [\n                {\n                    binding: 0,\n                    texture: { viewDimension: 'cube' },\n                    visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n                },\n                {\n                    binding: 1,\n                    texture: {\n                        viewDimension: '2d',\n                        sampleType: 'depth',\n                    },\n                    visibility: GPUShaderStage.FRAGMENT,\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: { type: 'uniform' },\n                },\n            ],\n        });\n        this.linearSampler = device.createSampler({\n            minFilter: 'linear',\n            magFilter: 'linear',\n            mipmapFilter: 'linear',\n        });\n        this.nearestSampler = device.createSampler({\n            minFilter: 'nearest',\n            magFilter: 'nearest',\n            mipmapFilter: 'nearest',\n        });\n        this.shader = device.createShaderModule({\n            code: SkyboxPass.code,\n            label: skybox_pass_label,\n        });\n        this.pipelineLayout = device.createPipelineLayout({\n            label: skybox_pass_label,\n            bindGroupLayouts: [\n                globals.bindGroupLayout,\n                this.bindgroupLayout,\n            ],\n        });\n        this.uniformBuffer = device.createBuffer({\n            label: skybox_pass_label,\n            size: 32,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        });\n        this.targetFormat = targetFormat;\n        if (skybox != null)\n            this.skyTexture = skybox;\n    }\n    render(pass) {\n        if (this.textureBindgroup == null || this.pipeline == null)\n            return false;\n        pass.setPipeline(this.pipeline);\n        pass.setBindGroup(0, this.globals.bindgroup);\n        pass.setBindGroup(1, this.textureBindgroup);\n        pass.draw(3);\n        return true;\n    }\n}\n_SkyboxPass_skyTexture = new WeakMap(), _SkyboxPass_depthTexture = new WeakMap(), _SkyboxPass_targetFormat = new WeakMap(), _SkyboxPass_useNearestSample = new WeakMap(), _SkyboxPass_instances = new WeakSet(), _SkyboxPass_updateBindgroup = function _SkyboxPass_updateBindgroup() {\n    if (__classPrivateFieldGet(this, _SkyboxPass_skyTexture, \"f\") == null || __classPrivateFieldGet(this, _SkyboxPass_depthTexture, \"f\") == null)\n        return;\n    this.textureBindgroup = this.device.createBindGroup({\n        label: skybox_pass_label,\n        layout: this.bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: __classPrivateFieldGet(this, _SkyboxPass_skyTexture, \"f\"),\n            },\n            {\n                binding: 1,\n                resource: __classPrivateFieldGet(this, _SkyboxPass_depthTexture, \"f\"),\n            },\n            {\n                binding: 2,\n                resource: this.useNearestSample\n                    ? this.nearestSampler\n                    : this.linearSampler,\n            },\n            {\n                binding: 3,\n                resource: { buffer: this.uniformBuffer },\n            },\n        ],\n    });\n};\nSkyboxPass.code = `\r\n        ${global_uniforms/* default */.A.code(0)}\r\n\r\n        struct SkyboxUniforms {\r\n            mipBias: f32,\r\n        };\r\n\r\n        @group(1) @binding(0) var environmentTexture: texture_cube<f32>;\r\n        @group(1) @binding(1) var depthTexture: texture_depth_2d;\r\n        @group(1) @binding(2) var environmentSampler: sampler;\r\n        @group(1) @binding(3) var<uniform> skyboxUniforms: SkyboxUniforms;\r\n\r\n        struct Varyings {\r\n            @builtin(position) position: vec4f,\r\n            @location(0) pos: vec4f,\r\n            @location(1) mipBias: f32,\r\n        };\r\n    \r\n        @vertex \r\n        fn vs(@builtin(vertex_index) vNdx: u32) -> Varyings {\r\n            const pos = array(\r\n                vec2(-1.0,  3.0),\r\n                vec2(-1.0, -1.0),\r\n                vec2( 3.0, -1.0),\r\n            );\r\n    \r\n            var vsOut: Varyings;\r\n            vsOut.position = vec4(pos[vNdx], 0.0, 1.0);\r\n    \r\n            // Ignores the camera's translation without needing a separate rotation matrix.\r\n            vsOut.pos = globals.inverseViewToClip * vsOut.position;\r\n            let w = vsOut.pos.w;\r\n            vsOut.pos.w = 0.0;\r\n            vsOut.pos = globals.inverseWorldToView * vsOut.pos;\r\n            vsOut.pos.w = w;\r\n\r\n            vsOut.mipBias = clamp(skyboxUniforms.mipBias, 0, f32(textureNumLevels(environmentTexture)));\r\n            return vsOut;\r\n        }\r\n\r\n        @fragment\r\n        fn fs(in: Varyings) -> @location(0) vec4f {\r\n            let dimensions = textureDimensions(depthTexture);\r\n            let uv = min(vec2<u32>(floor(in.position.xy)), dimensions - 1);\r\n            let depth = textureLoad(depthTexture, uv, 0);\r\n            if (depth < 1.0) { discard; }\r\n\r\n            let t = normalize(in.pos.xyz / in.pos.w);\r\n            let color = textureSampleLevel(environmentTexture, environmentSampler, t, in.mipBias).rgb;\r\n            return vec4(color, 1.0);\r\n        }\r\n    `;\n/* harmony default export */ const skybox_pass = (SkyboxPass);\n\n;// ./src/rendering/gbuffer.ts\nclass GBuffer {\n    get size() { return this._size; }\n    set size(value) {\n        this._size = value;\n        this.textures.forEach((tex) => { this.createTexture(tex); });\n        this.bindgroup = this.updateBindgroup();\n        this.passDescriptor = this.updatePassDescriptor();\n    }\n    constructor(device, _size) {\n        this.device = device;\n        this._size = _size;\n        this.normal = this.createTexture({\n            format: 'rgba16float',\n            name: 'normal',\n            clearValue: { r: 0, g: 0, b: 1, a: 1 },\n        });\n        this.albedo = this.createTexture({\n            format: 'rgba8unorm',\n            name: 'albedo',\n            clearValue: { r: 0, g: 0, b: 0, a: 1 },\n        });\n        this.emission = this.createTexture({\n            format: 'rgba16float',\n            name: 'emission',\n            clearValue: { r: 0, g: 0, b: 0, a: 1 },\n        });\n        this.metallicRoughness = this.createTexture({\n            format: 'rg8unorm',\n            name: 'metallic roughness',\n            clearValue: { r: 0, g: 0, b: 0, a: 0 },\n        });\n        this.depth = this.createTexture({\n            format: 'depth32float',\n            name: 'depth',\n        });\n        this.textures = [\n            this.normal,\n            this.albedo,\n            this.emission,\n            this.metallicRoughness,\n            this.depth,\n        ];\n        this.targets = this.textures.slice(0, -1).map(({ format }) => ({ format }));\n        this.bindGroupLayout = this.device.createBindGroupLayout(GBuffer.layoutDescription);\n        this.bindgroup = this.updateBindgroup();\n        this.passDescriptor = this.updatePassDescriptor();\n    }\n    updateBindgroup() {\n        const entries = this.textures.map(({ view }, idx) => ({\n            binding: idx,\n            resource: view, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        }));\n        return this.device.createBindGroup({\n            label: 'gbuffer bind group',\n            layout: this.bindGroupLayout,\n            entries,\n        });\n    }\n    updatePassDescriptor() {\n        const colorAttachments = this.textures.slice(0, -1).map(({ view, clearValue }) => ({\n            view: view, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            clearValue: clearValue, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            loadOp: 'clear',\n            storeOp: 'store',\n        }));\n        return {\n            label: 'forward pass encoder',\n            colorAttachments,\n            depthStencilAttachment: {\n                view: this.depth.view, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                depthClearValue: 1.0,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n            },\n        };\n    }\n    createTexture(tex) {\n        const label = `gbuffer ${tex.name}`;\n        tex.texture = this.device.createTexture({\n            label,\n            size: this._size,\n            format: tex.format,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n        });\n        tex.view = tex.texture.createView({ label });\n        return tex;\n    }\n}\nGBuffer.code = (group) => /* wgsl */ `\n        @group(${group}) @binding(${0 /* GBufferGroupIndices.Normal */}) \n        var gBufferNormal: texture_2d<f32>;\n        \n        @group(${group}) @binding(${1 /* GBufferGroupIndices.Albedo */}) \n        var gBufferAlbedo: texture_2d<f32>;\n        \n        @group(${group}) @binding(${2 /* GBufferGroupIndices.Emission */}) \n        var gBufferEmission: texture_2d<f32>;\n\n        @group(${group}) @binding(${3 /* GBufferGroupIndices.MetallicRoughness */}) \n        var gBufferMetallicRoughness: texture_2d<f32>;\n        \n        @group(${group}) @binding(${4 /* GBufferGroupIndices.Depth */})  \n        var gBufferDepth: texture_depth_2d;\n    `;\nGBuffer.layoutDescription = {\n    label: 'gbuffer bind group layout',\n    entries: [\n        {\n            binding: 0 /* GBufferGroupIndices.Normal */,\n            visibility: GPUShaderStage.FRAGMENT,\n            texture: { sampleType: 'unfilterable-float' },\n        },\n        {\n            binding: 1 /* GBufferGroupIndices.Albedo */,\n            visibility: GPUShaderStage.FRAGMENT,\n            texture: { sampleType: 'float' },\n        },\n        {\n            binding: 2 /* GBufferGroupIndices.Emission */,\n            visibility: GPUShaderStage.FRAGMENT,\n            texture: { sampleType: 'float' },\n        },\n        {\n            binding: 3 /* GBufferGroupIndices.MetallicRoughness */,\n            visibility: GPUShaderStage.FRAGMENT,\n            texture: { sampleType: 'unfilterable-float' },\n        },\n        {\n            binding: 4 /* GBufferGroupIndices.Depth */,\n            visibility: GPUShaderStage.FRAGMENT,\n            texture: { sampleType: 'depth' },\n        },\n    ],\n};\n/* harmony default export */ const gbuffer = (GBuffer);\n\n;// ./src/shaders/brdfs.shader.ts\n/* harmony default export */ const brdfs_shader = (/* wgsl */`\n    fn hammersley(i: u32, N: u32) -> vec2f {\n        var bits = (i << 16u) | (i >> 16u);\n        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n        let rdi = f32(bits) * 2.3283064365386963e-10; // / 0x100000000\n        return vec2(f32(i) / f32(N), rdi);\n    }\n\n    fn tangentSampleGGX(N: vec3f, Xi: vec2f, a2: f32) -> vec3f {\n        const PI = 3.14159265359;\n\n        let phi = 2.0 * PI * Xi.x;\n        let cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));\n        let sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n        \n        var H: vec3f;\n        H.x = cos(phi) * sinTheta;\n        H.y = sin(phi) * sinTheta;\n        H.z = cosTheta;\n\n        let up = select(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), abs(N.z) >= 0.999);\n        let T = normalize(cross(up, N));\n        let B = cross(N, T);\n\n        let S = T * H.x + B * H.y + N * H.z;\n        return normalize(S);\n    }\n\n    fn vPartLambda(NoV: f32, a2: f32) -> f32 {\n        return sqrt(NoV * NoV * (1.0 - a2) + a2);\n    }\n\n    fn vCorrelatedGGX(NoV: f32, NoL: f32, a2: f32) -> f32 {\n        let GGXV = NoL * vPartLambda(NoV, a2);\n        let GGXL = NoV * vPartLambda(NoL, a2);\n        return 0.5 / (GGXV + GGXL);\n    }\n\n    fn dS2GGX(NoH: f32, a2: f32) -> f32 {\n        let s = (a2 - 1.0) * NoH * NoH + 1.0;\n        return s * s;\n    }\n\n    fn dGGX(NoH: f32, a2: f32) -> f32 {\n        const invPI = 1.0 / 3.14159265359;\n\n        let s2 = dS2GGX(NoH, a2);\n        return invPI * select(1, a2 / s2, a2 != s2);\n    }\n`);\n\n;// ./src/rendering/ibl-textures/create-bfrd-lut.ts\n\n\nconst code = /* wgsl */ `\noverride SAMPLE_COUNT: u32 = 1024u;\n\n${blit_vert_shader/* default */.A}\n${brdfs_shader}\n\n@fragment\nfn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n    let NoV = uv.x;\n    let roughness = uv.y;\n    let alpha = roughness * roughness;\n    let a2 = alpha * alpha;\n    let V = vec3(sqrt(1.0 - NoV * NoV), NoV, 0.0);\n    let N = vec3(0.0, 1.0, 0.0);\n\n    var brdf = vec2(0.0);\n\n    for (var i = 0u; i < SAMPLE_COUNT; i++) {\n        let Xi = hammersley(i, SAMPLE_COUNT);\n        let H = tangentSampleGGX(N, Xi, a2);\n        let L = normalize(2.0 * dot(V, H) * H - V);\n\n        let NoL = saturate(L.y);\n        let NoH = saturate(H.y);\n        let VoH = saturate(dot(V, H));\n\n        if (NoL > 0.0) {\n            let pdf = vCorrelatedGGX(NoV, NoL, a2) * VoH * NoL / NoH;\n            let Fc = pow(1.0 - VoH, 5.0);\n            brdf += vec2(1.0 - Fc, Fc) * pdf;\n        }\n    }\n\n    return vec4f(brdf * 4.0 / f32(SAMPLE_COUNT), 0.0, 1.0);\n}\n`;\nfunction createBfrdLut({ device, label, sampleCount, width = 1024, height = 1024, format = 'rg32float', }) {\n    const bfrdLut = device.createTexture({\n        label,\n        format,\n        dimension: '2d',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n        size: { width, height },\n    });\n    const module = device.createShaderModule({ label: 'bfrdLut shader', code });\n    const pipeline = device.createRenderPipeline({\n        label: 'bfrd lut pipeline',\n        layout: 'auto',\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format }],\n            constants: sampleCount ? { SAMPLE_COUNT: sampleCount } : undefined,\n            module,\n        },\n    });\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n        label: 'brdf lut render pass',\n        colorAttachments: [{\n                view: bfrdLut.createView(),\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n    });\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.end();\n    device.queue.submit([encoder.finish()]);\n    return bfrdLut;\n}\n\n// EXTERNAL MODULE: ./src/shaders/cubemap-sampling.shader.ts\nvar cubemap_sampling_shader = __webpack_require__(6097);\n// EXTERNAL MODULE: ./src/utils/data-copy.ts\nvar data_copy = __webpack_require__(5752);\n;// ./src/rendering/ibl-textures/create-irradiance-texture.ts\n\n\n\n\nconst create_irradiance_texture_code = /* wgsl */ `\n    const PI = 3.14159265359;\n\n    override SAMPLES: u32 = 2048u;\n\n    struct Params {\n        face: u32,\n        size: u32,\n    }\n\n    @group(0) @binding(0) var environment: texture_cube<f32>;\n    @group(0) @binding(1) var environmentSampler: sampler;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    ${cubemap_sampling_shader/* toWorldDir */.V}\n    ${brdfs_shader}\n    ${blit_vert_shader/* default */.A}\n\n    @fragment\n    fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {\n        let coord = vec3u(vec2u(floor(pos.xy)), params.face);\n        let size = f32(textureDimensions(environment).x);\n        let lodFactor = 6.0 * size * size / f32(SAMPLES);\n\n        let N = toWorldDir(coord, params.size);\n        let right = normalize(cross(vec3(0.0, 1.0, 0.0), N));\n        let up = normalize(cross(N, right));\n        let TBN = mat3x3(right, up, N);\n        \n        var irradiance = vec3(0.0);\n        var samples = 0.0;\n\n        for (var i = 0u; i < SAMPLES; i += 1) {\n            let xi = hammersley(i, SAMPLES);\n            let cosTheta = sqrt(1.0 - xi.y);\n            let sinTheta = sqrt(xi.y);\n            let phi = 2.0 * PI * xi.x;\n            let invPdf = PI / cosTheta;\n            let localDir = normalize(vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta));\n            let worldDir = TBN * localDir;\n            let lod = 0.5 * log2(lodFactor * invPdf);\n            irradiance += textureSampleLevel(environment, environmentSampler, worldDir, lod).rgb;\n        }\n\n        return vec4(irradiance / f32(SAMPLES), 1.0);\n    }\n`;\nfunction createIrradianceTexture({ device, texture, label = 'irradiance', usage = 0, samples = 2048, outputWidth, outputFormat, outputTexture, }) {\n    const format = outputTexture?.format ?? outputFormat ?? texture.format;\n    const width = outputTexture?.width ?? outputWidth ?? 64;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { viewDimension: 'cube' },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.FRAGMENT,\n                sampler: {},\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.FRAGMENT,\n                buffer: { type: 'uniform' },\n            },\n        ],\n    });\n    const sampler = device.createSampler({ minFilter: 'linear', magFilter: 'linear', mipmapFilter: 'linear' });\n    const irradianceTexture = outputTexture?.depthOrArrayLayers === 6\n        ? outputTexture\n        : device.createTexture({\n            label,\n            format,\n            dimension: '2d',\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | usage,\n            size: { width, height: width, depthOrArrayLayers: 6 },\n        });\n    const params = new Uint32Array([0, irradianceTexture.width]);\n    const paramBuffer = (0,data_copy/* createAndCopyBuffer */.Lr)(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device);\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: texture.createView({ dimension: 'cube' }),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n            {\n                binding: 2,\n                resource: { buffer: paramBuffer },\n            },\n        ],\n    });\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n    const module = device.createShaderModule({ label, code: create_irradiance_texture_code });\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            module,\n            entryPoint: 'vs',\n        },\n        fragment: {\n            entryPoint: 'fs',\n            constants: {\n                SAMPLES: samples,\n            },\n            module,\n            targets: [{ format }],\n        },\n    });\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n        const view = irradianceTexture.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n        });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            colorAttachments: [{\n                    view,\n                    loadOp: 'clear',\n                    storeOp: 'store',\n                }],\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n    return irradianceTexture;\n}\n\n;// ./src/rendering/ibl-textures/create-radiance-texture.ts\n\n\n\n\nconst create_radiance_texture_code = /* wgsl */ `\n    override SAMPLES: u32 = 1024u;\n\n    const PI = 3.14159265359;\n    const invPI = 1.0 / PI;\n\n    struct Params {\n        face: u32,\n        mipSize: u32,\n        invOmegaP: f32,\n        a2: f32,\n    }\n\n    @group(0) @binding(0) var environment: texture_cube<f32>;\n    @group(0) @binding(1) var environmentSampler: sampler;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    ${cubemap_sampling_shader/* toWorldDir */.V}\n    ${brdfs_shader}\n    ${blit_vert_shader/* default */.A}\n\n    @fragment\n    fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n        let N = toWorldDirF32(uv, params.face);\n\n        var radiance = vec3(0.0);\n        var totalWeight = 0.0;\n        \n        for (var i = 0u; i < SAMPLES; i += 1) {\n            let Xi = hammersley(i, SAMPLES);\n            let H = tangentSampleGGX(N, Xi, params.a2);\n            let HoV = saturate(dot(H, N));\n            let L = normalize(2.0 * HoV * H - N);\n            let NoL = saturate(dot(N, L));\n\n            if (NoL <= 0.0) { continue; }\n\n            let pdf = dGGX(HoV, params.a2) / 4.0 + 0.001;\n            let omegaS = 1.0 / (f32(SAMPLES) * pdf);\n            let mipLevel = 0.5 * log2(omegaS * params.invOmegaP) + params.a2;\n\n            radiance += textureSampleLevel(environment, environmentSampler, L, mipLevel).rgb * NoL;\n            totalWeight += NoL;\n        }\n    \n        return vec4(radiance / totalWeight, 1.0);\n    }\n`;\nfunction createRadianceTexture({ device, texture, targetFormat, usage = 0, label = 'radiance', samples = 1024, outputWidth, outputTexture, }) {\n    const format = outputTexture?.format ?? targetFormat ?? texture.format;\n    const width = outputTexture?.width ?? outputWidth ?? texture.width;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { viewDimension: 'cube' },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.FRAGMENT,\n                sampler: {},\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.FRAGMENT,\n                buffer: { type: 'uniform' },\n            },\n        ],\n    });\n    const sampler = device.createSampler({ minFilter: 'linear', magFilter: 'linear', mipmapFilter: 'linear' });\n    const paramArrayBuffer = new ArrayBuffer(4 * 4);\n    const uintParams = new Uint32Array(paramArrayBuffer, 0, 2);\n    const floatParams = new Float32Array(paramArrayBuffer, 2 * 4, 2);\n    const paramBuffer = (0,data_copy/* createAndCopyBuffer */.Lr)(paramArrayBuffer, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device);\n    const radianceTexture = outputTexture?.depthOrArrayLayers === 6\n        ? outputTexture\n        : device.createTexture({\n            label,\n            format,\n            dimension: '2d',\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST | usage,\n            size: { width, height: width, depthOrArrayLayers: 6 },\n            mipLevelCount: Math.max((Math.log2(width) | 0) - 2, 1),\n        });\n    const copyEncoder = device.createCommandEncoder({\n        label: `${label} copy encoder`,\n    });\n    copyEncoder.copyTextureToTexture({ texture, mipLevel: 0 }, { texture: radianceTexture, mipLevel: 0 }, { width, height: width, depthOrArrayLayers: 6 });\n    device.queue.submit([copyEncoder.finish()]);\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n    const module = device.createShaderModule({ label, code: create_radiance_texture_code });\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            module,\n            entryPoint: 'vs',\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: radianceTexture.format }],\n            constants: {\n                SAMPLES: samples,\n            },\n            module,\n        },\n    });\n    floatParams[0] = (6 * texture.width * texture.width) / (4 * Math.PI);\n    void Promise.resolve().then(async () => {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: texture.createView({ dimension: 'cube' }),\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n                {\n                    binding: 2,\n                    resource: { buffer: paramBuffer },\n                },\n            ],\n        });\n        for (let mip = 1; mip < radianceTexture.mipLevelCount; mip += 1) {\n            const roughness = mip / (radianceTexture.mipLevelCount - 1);\n            floatParams[1] = roughness ** 4;\n            uintParams[1] = (radianceTexture.width >> mip) | 0;\n            for (let face = 0; face < 6; face += 1) {\n                await device.queue.onSubmittedWorkDone();\n                uintParams[0] = face;\n                device.queue.writeBuffer(paramBuffer, 0, paramArrayBuffer);\n                const view = radianceTexture.createView({\n                    dimension: '2d',\n                    arrayLayerCount: 1,\n                    baseArrayLayer: face,\n                    mipLevelCount: 1,\n                    baseMipLevel: mip,\n                });\n                const encoder = device.createCommandEncoder();\n                const pass = encoder.beginRenderPass({\n                    colorAttachments: [{\n                            view,\n                            loadOp: 'clear',\n                            storeOp: 'store',\n                        }],\n                });\n                pass.setPipeline(pipeline);\n                pass.setBindGroup(0, bindgroup);\n                pass.draw(3);\n                pass.end();\n                device.queue.submit([encoder.finish()]);\n            }\n        }\n    });\n    return radianceTexture;\n}\n\n;// ./src/rendering/deferred-pass.ts\n\n\n\n\n\n\n\nclass DeferredPass {\n    set skybox(texture) {\n        this.irradianceTexture = createIrradianceTexture({\n            texture,\n            device: this.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING,\n        });\n        this.radianceTexture = createRadianceTexture({\n            texture,\n            device: this.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING,\n        });\n        this.irradianceView = this.irradianceTexture.createView({ dimension: 'cube' });\n        this.radianceView = this.radianceTexture.createView({ dimension: 'cube' });\n        this.bindgroup = this.device.createBindGroup({\n            layout: this.bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: this.radianceView,\n                },\n                {\n                    binding: 1,\n                    resource: this.irradianceView,\n                },\n                {\n                    binding: 2,\n                    resource: this.bfrdLutView,\n                },\n                {\n                    binding: 3,\n                    resource: this.sampler,\n                },\n            ],\n        });\n    }\n    constructor(device, globals, gbuffer, format, skybox) {\n        this.device = device;\n        this.globals = globals;\n        this.gbuffer = gbuffer;\n        this.target = {\n            view: undefined, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            clearValue: { r: 0, g: 0, b: 0, a: 1 },\n            loadOp: 'clear',\n            storeOp: 'store',\n        };\n        this.bfrdLut = createBfrdLut({ device: this.device });\n        this.bfrdLutView = this.bfrdLut.createView();\n        this.passDescriptor = { colorAttachments: [this.target] };\n        this.sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear', mipmapFilter: 'linear' });\n        if (skybox != null)\n            this.skybox = skybox;\n        this.bindgroupLayout = device.createBindGroupLayout({\n            label: 'deferred pass',\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: { viewDimension: 'cube' },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: { viewDimension: 'cube' },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: { viewDimension: '2d' },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n            ],\n        });\n        const layout = device.createPipelineLayout({\n            label: 'deferred pass bindgroup layout',\n            bindGroupLayouts: [\n                this.globals.bindGroupLayout,\n                this.gbuffer.bindGroupLayout,\n                this.bindgroupLayout,\n            ],\n        });\n        const module = device.createShaderModule({ code: DeferredPass.code, label: 'deferred pass shader' });\n        this.pipeline = device.createRenderPipeline({\n            layout,\n            vertex: {\n                entryPoint: 'vs',\n                module,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                targets: [{ format }],\n                module,\n            },\n        });\n    }\n    render(pass) {\n        if (this.bindgroup == null)\n            return;\n        pass.setPipeline(this.pipeline);\n        pass.setBindGroup(0, this.globals.bindgroup);\n        pass.setBindGroup(1, this.gbuffer.bindgroup);\n        pass.setBindGroup(2, this.bindgroup);\n        pass.draw(3);\n    }\n}\nDeferredPass.code = `\n        ${global_uniforms/* default */.A.code(0)}\n        ${gbuffer.code(1)}\n\n        @group(2) @binding(0) var radianceTexture: texture_cube<f32>;\n        @group(2) @binding(1) var irradianceTexture: texture_cube<f32>;\n        @group(2) @binding(2) var brdfTexture: texture_2d<f32>;\n        @group(2) @binding(3) var generalSampler: sampler;\n\n        ${brdfs_shader}\n        ${blit_vert_shader/* default */.A}\n\n        @fragment\n        fn fs(@builtin(position) pos: vec4f, @location(0) uv: vec2f) -> @location(0) vec4f {\n            let uvi = vec2<u32>(pos.xy);\n            let depth = textureLoad(gBufferDepth, uvi, 0);\n\n            if (depth >= 1.0) { discard; }\n\n            let uvClip = vec2(uv.x * 2.0 - 1.0, 1.0 - uv.y * 2.0);\n            let clipPos = vec4(uvClip, depth, 1.0);\n            let viewPos = globals.inverseViewToClip * clipPos;\n            let worldDir = globals.inverseWorldToView * vec4(viewPos.xyz / viewPos.w, 0.0);\n            let view = -normalize(worldDir.xyz);\n\n            let normal = textureLoad(gBufferNormal, uvi, 0).rgb;\n            let albedo = textureLoad(gBufferAlbedo, uvi, 0).rgb;\n            let emission = textureLoad(gBufferEmission, uvi, 0).rgb;\n            let metallicRoughnessSample = textureLoad(gBufferMetallicRoughness, uvi, 0);\n            let metallic = metallicRoughnessSample.r;\n            let roughness = metallicRoughnessSample.g;\n            let alpha = roughness * roughness;\n            let a2 = alpha * alpha;\n\n            let NoV = saturate(dot(normal, view));\n            let F0 = mix(vec3f(0.04), albedo, metallic);\n            let R = reflect(-view, normal);\n\n            let level = roughness * f32(textureNumLevels(radianceTexture) - 1u);\n            let radiance = textureSampleLevel(radianceTexture, generalSampler, R, level).rgb;\n            let irradiance = textureSample(irradianceTexture, generalSampler, normal).rgb;\n            let brdf = textureSample(brdfTexture, generalSampler, saturate(vec2f(NoV, roughness))).xy;\n\n            // Roughness dependent fresnel\n            let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n            let kS = F0 + Fr * pow(1.0 - NoV, 5.0);\n            let FssEss = kS * brdf.x + brdf.y;\n\n            // Multiple scattering, originally proposed by Fdez-Aguera\n            // and here adapted from https://bruop.github.io/ibl\n            let Ems = 1.0 - (brdf.x + brdf.y);\n            let Favg = F0 + (1.0 - F0) / 21.0;\n            let FmsEms = Ems * FssEss * Favg / (1.0 - Favg * Ems);\n            let kD = albedo * (1.0 - 0.04) * (1.0 - metallic) * (1.0 - FssEss + FmsEms);\n\n            let specular = FssEss * radiance;\n            let diffuse = (FmsEms + kD) * irradiance;\n            let ambient = specular + diffuse + emission;\n\n            return vec4f(ambient, 1.0);\n        }\n    `;\n/* harmony default export */ const deferred_pass = (DeferredPass);\n\n// EXTERNAL MODULE: ./src/utils/general.ts\nvar general = __webpack_require__(4742);\n;// ./src/rendering/renderer.ts\nvar renderer_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Renderer_instances, _Renderer_createResizeObserver;\n\n\n\n\n\n\n\nclass Renderer {\n    set skybox(texture) {\n        this.deferredPass.skybox = texture;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.skyboxPass.skyTexture = this.deferredPass.radianceView;\n    }\n    constructor(canvas, device) {\n        _Renderer_instances.add(this);\n        this.canvas = canvas;\n        this.device = device;\n        this.colorAttachment = {\n            clearValue: { r: 0, g: 0, b: 0, a: 1 },\n            loadOp: 'clear',\n            storeOp: 'store',\n            view: undefined, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        };\n        this.passDescriptor = { colorAttachments: [this.colorAttachment] };\n        this.forwardPasses = [];\n        this.render = () => {\n            requestAnimationFrame(this.render);\n            this.globals.updateDeviceBuffer(this.device.queue, this.camera);\n            const encoder = this.device.createCommandEncoder({ label: 'main render encoder' });\n            const forwardPassParams = { encoder, globals: this.globals, gbuffer: this.gbuffer };\n            for (const forwardPass of this.forwardPasses) {\n                forwardPass.render(forwardPassParams);\n            }\n            const pass = encoder.beginRenderPass(this.passDescriptor);\n            this.deferredPass.render(pass);\n            this.skyboxPass.render(pass);\n            pass.end();\n            this.tonemapPass.render(encoder, this.context.getCurrentTexture());\n            this.device.queue.submit([encoder.finish()]);\n        };\n        const size = { width: this.canvas.width, height: this.canvas.height };\n        this.camera = new camera/* default */.A(size);\n        this.globals = new global_uniforms/* default */.A(this.device);\n        this.gbuffer = new gbuffer(device, size);\n        this.deferredPass = new deferred_pass(device, this.globals, this.gbuffer, Renderer.postProcessFormat);\n        this.skyboxPass = new skybox_pass(this.device, this.globals, Renderer.postProcessFormat);\n        this.tonemapPass = new tonemap_pass(this.device, Renderer.outputFormat);\n        const context = this.canvas.getContext('webgpu');\n        if (context == null)\n            throw new Error('renderer -- given canvas already initialized to non-webgpu context');\n        this.context = context;\n        this.context.configure({\n            device: this.device,\n            format: Renderer.outputFormat,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            alphaMode: 'opaque',\n            colorSpace: 'srgb',\n        });\n        this.updateBackings(size);\n        renderer_classPrivateFieldGet(this, _Renderer_instances, \"m\", _Renderer_createResizeObserver).call(this);\n    }\n    static async CreateInitialized(canvas) {\n        const adapter = await navigator.gpu.requestAdapter();\n        if (adapter == null) {\n            throw new Error('Could not initialize GPU.');\n        }\n        const { maxComputeWorkgroupSizeX, maxComputeWorkgroupsPerDimension, maxComputeInvocationsPerWorkgroup, } = adapter.limits;\n        const device = await adapter.requestDevice({\n            label: 'main logical device',\n            requiredFeatures: Renderer.requiredFeatures,\n            requiredLimits: {\n                maxComputeWorkgroupSizeX,\n                maxComputeWorkgroupsPerDimension,\n                maxComputeInvocationsPerWorkgroup,\n            },\n        });\n        return new Renderer(canvas, device);\n    }\n    updateBackings(size) {\n        this.camera.updateParams(size);\n        this.postprocessTarget = this.device.createTexture({\n            dimension: '2d',\n            format: Renderer.postProcessFormat,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n            size,\n        });\n        this.colorAttachment.view = this.postprocessTarget.createView();\n        this.tonemapPass.updateInput(this.colorAttachment.view);\n        this.gbuffer.size = size;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.skyboxPass.depthTexture = this.gbuffer.depth.view;\n    }\n    addForwardPass(forwardPass) {\n        (0,general/* binaryInsert */.nn)(this.forwardPasses, forwardPass, (a, b) => a.priority - b.priority);\n    }\n}\n_Renderer_instances = new WeakSet(), _Renderer_createResizeObserver = function _Renderer_createResizeObserver() {\n    const resizeCanvas = (0,general/* debounce */.sg)((rawWidth, rawHeight) => {\n        const width = Math.max(1, Math.min(rawWidth | 0, this.device.limits.maxTextureDimension2D));\n        const height = Math.max(1, Math.min(rawHeight | 0, this.device.limits.maxTextureDimension2D));\n        const dimensions = { width, height };\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.updateBackings(dimensions);\n    }, 20);\n    try {\n        const observer = new ResizeObserver((entries) => {\n            const [{ inlineSize, blockSize }] = entries[entries.length - 1].devicePixelContentBoxSize;\n            resizeCanvas(inlineSize, blockSize);\n        });\n        observer.observe(this.canvas, { box: 'device-pixel-content-box' });\n    }\n    catch {\n        // Safari doesn't support device-pixel-content-box, so it would fail into this.\n        const observer = new ResizeObserver((entries) => {\n            const [{ inlineSize, blockSize }] = entries[entries.length - 1].contentBoxSize;\n            resizeCanvas(inlineSize * devicePixelRatio, blockSize * devicePixelRatio);\n        });\n        observer.observe(this.canvas, { box: 'content-box' });\n    }\n};\nRenderer.requiredFeatures = ['float32-filterable'];\nRenderer.outputFormat = navigator.gpu.getPreferredCanvasFormat();\nRenderer.postProcessFormat = 'rgba32float';\n/* harmony default export */ const renderer = (Renderer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvcmVuZGVyaW5nL3RvbmVtYXAtcGFzcy50cz85YTUxIiwid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy9yZW5kZXJpbmcvc2t5Ym94LXBhc3MudHM/MmVlMyIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvcmVuZGVyaW5nL2didWZmZXIudHM/YjQ0NSIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvc2hhZGVycy9icmRmcy5zaGFkZXIudHM/MGJhNiIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvcmVuZGVyaW5nL2libC10ZXh0dXJlcy9jcmVhdGUtYmZyZC1sdXQudHM/MzMwMyIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvcmVuZGVyaW5nL2libC10ZXh0dXJlcy9jcmVhdGUtaXJyYWRpYW5jZS10ZXh0dXJlLnRzPzUzYmEiLCJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3JlbmRlcmluZy9pYmwtdGV4dHVyZXMvY3JlYXRlLXJhZGlhbmNlLXRleHR1cmUudHM/MGVkNiIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvcmVuZGVyaW5nL2RlZmVycmVkLXBhc3MudHM/ZmMyMiIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvcmVuZGVyaW5nL3JlbmRlcmVyLnRzPzJiOGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJsaXQgZnJvbSAnLi4vc2hhZGVycy9ibGl0LXZlcnQuc2hhZGVyJztcclxuXHJcbmNvbnN0IGxhYmVsID0gJ3RvbmVtYXAgcGFzcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb25lbWFwUGFzcyB7XHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgY29kZSA9IC8qIHdnc2wgKi9gXHJcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhciBjb2xvclRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcclxuXHJcbiAgICAgICAgJHtibGl0fVxyXG5cclxuICAgICAgICBmbiBmaXRSUlRBbmRPRFQoY29sb3I6IHZlYzNmKSAtPiB2ZWMzZiB7XHJcbiAgICAgICAgICAgIGxldCBhID0gY29sb3IgKiAoY29sb3IgKyAwLjAyNDU3ODYpIC0gMC4wMDAwOTA1Mzc7XHJcbiAgICAgICAgICAgIGxldCBiID0gY29sb3IgKiAoMC45ODM3MjkgKiBjb2xvciArIDAuNDMyOTUxMCkgKyAwLjIzODA4MTtcclxuICAgICAgICAgICAgcmV0dXJuIGEgLyBiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm4gYWNlc190b25lX21hcChoZHI6IHZlYzNmKSAtPiB2ZWMzZiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlucHV0TWF0ID0gbWF0M3gzKFxyXG4gICAgICAgICAgICAgICAgMC41OTcxOSwgMC4wNzYwMCwgMC4wMjg0MCxcclxuICAgICAgICAgICAgICAgIDAuMzU0NTgsIDAuOTA4MzQsIDAuMTMzODMsXHJcbiAgICAgICAgICAgICAgICAwLjA0ODIzLCAwLjAxNTY2LCAwLjgzNzc3LFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRwdXRNYXQgPSBtYXQzeDMoXHJcbiAgICAgICAgICAgICAgICAxLjYwNDc1LCAtMC4xMDIwOCwgLTAuMDAzMjcsXHJcbiAgICAgICAgICAgICAgICAtMC41MzEwOCwgMS4xMDgxMywgLTAuMDcyNzYsXHJcbiAgICAgICAgICAgICAgICAtMC4wNzM2NywgLTAuMDA2MDUsIDEuMDc2MDIsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvb3N0ID0gMS4wIC8gMC42O1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gaGRyICogYm9vc3Q7XHJcbiAgICAgICAgICAgIGNvbG9yID0gaW5wdXRNYXQgKiBjb2xvcjtcclxuICAgICAgICAgICAgY29sb3IgPSBmaXRSUlRBbmRPRFQoY29sb3IpO1xyXG4gICAgICAgICAgICBjb2xvciA9IG91dHB1dE1hdCAqIGNvbG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gc2F0dXJhdGUoY29sb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm4gbGluZWFyX3RvX3NyZ2IoY29sb3I6IHZlYzNmKSAtPiB2ZWMzZiB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3coY29sb3IsIHZlYzMoMS4wLzIuMikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQGZyYWdtZW50XHJcbiAgICAgICAgZm4gZnMoQGJ1aWx0aW4ocG9zaXRpb24pIHBvczogdmVjNGYpIC0+IEBsb2NhdGlvbigwKSB2ZWM0ZiB7XHJcbiAgICAgICAgICAgIGxldCB1diA9IHZlYzI8aTMyPihmbG9vcihwb3MueHkpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHRleHR1cmVMb2FkKGNvbG9yVGV4dHVyZSwgdXYsIDApLnJnYjtcclxuICAgICAgICAgICAgY29sb3IgPSBhY2VzX3RvbmVfbWFwKGNvbG9yKTtcclxuICAgICAgICAgICAgY29sb3IgPSBsaW5lYXJfdG9fc3JnYihjb2xvcik7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWM0Zihjb2xvciwgMS4wKTtcclxuICAgICAgICB9XHJcbiAgICBgO1xyXG5cclxuICAgIHN0YXRpYyByZWFkb25seSBiaW5kR3JvdXBMYXlvdXREZXNjcmlwdG9yOiBHUFVCaW5kR3JvdXBMYXlvdXREZXNjcmlwdG9yID0ge1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGVudHJpZXM6IFt7XHJcbiAgICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICAgIHRleHR1cmU6IHsgc2FtcGxlVHlwZTogJ2Zsb2F0Jywgdmlld0RpbWVuc2lvbjogJzJkJyB9LFxyXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcclxuICAgICAgICB9XSxcclxuICAgIH07XHJcblxyXG4gICAgY29sb3JBdHRhY2htZW50OiBHUFVSZW5kZXJQYXNzQ29sb3JBdHRhY2htZW50ID0ge1xyXG4gICAgICAgIGxvYWRPcDogJ2xvYWQnLFxyXG4gICAgICAgIHN0b3JlT3A6ICdzdG9yZScsXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgICAgICB2aWV3OiB1bmRlZmluZWQhLFxyXG4gICAgfTtcclxuXHJcbiAgICBwYXNzRGVzY3JpcHRvcjogR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3IgPSB7XHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgY29sb3JBdHRhY2htZW50czogW3RoaXMuY29sb3JBdHRhY2htZW50XSxcclxuICAgIH07XHJcblxyXG4gICAgcGlwZWxpbmU6IEdQVVJlbmRlclBpcGVsaW5lO1xyXG4gICAgcGlwZWxpbmVEZXNjcmlwdG9yOiBHUFVSZW5kZXJQaXBlbGluZURlc2NyaXB0b3I7XHJcblxyXG4gICAgcmVuZGVyVGFyZ2V0OiBHUFVDb2xvclRhcmdldFN0YXRlO1xyXG4gICAgYmluZGdyb3VwTGF5b3V0OiBHUFVCaW5kR3JvdXBMYXlvdXQ7XHJcbiAgICBiaW5kZ3JvdXA/OiBHUFVCaW5kR3JvdXA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHVibGljIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgICAgIGZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCxcclxuICAgICkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0geyBmb3JtYXQgfTtcclxuICAgICAgICB0aGlzLmJpbmRncm91cExheW91dCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoVG9uZW1hcFBhc3MuYmluZEdyb3VwTGF5b3V0RGVzY3JpcHRvcik7XHJcbiAgICAgICAgY29uc3QgbW9kdWxlID0gZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7IGxhYmVsLCBjb2RlOiBUb25lbWFwUGFzcy5jb2RlIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnBpcGVsaW5lRGVzY3JpcHRvciA9IHtcclxuICAgICAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgICAgIGxheW91dDogZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtcclxuICAgICAgICAgICAgICAgIGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgYmluZEdyb3VwTGF5b3V0czogW3RoaXMuYmluZGdyb3VwTGF5b3V0XSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHZlcnRleDoge1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlLFxyXG4gICAgICAgICAgICAgICAgZW50cnlQb2ludDogJ3ZzJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnJhZ21lbnQ6IHtcclxuICAgICAgICAgICAgICAgIG1vZHVsZSxcclxuICAgICAgICAgICAgICAgIGVudHJ5UG9pbnQ6ICdmcycsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiBbdGhpcy5yZW5kZXJUYXJnZXRdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMucGlwZWxpbmUgPSBkZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUodGhpcy5waXBlbGluZURlc2NyaXB0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUlucHV0KGlucHV0OiBHUFVUZXh0dXJlVmlldykge1xyXG4gICAgICAgIHRoaXMuYmluZGdyb3VwID0gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcclxuICAgICAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5iaW5kZ3JvdXBMYXlvdXQsXHJcbiAgICAgICAgICAgIGVudHJpZXM6IFt7XHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IGlucHV0LFxyXG4gICAgICAgICAgICB9XSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoZW5jb2RlcjogR1BVQ29tbWFuZEVuY29kZXIsIG91dHB1dDogR1BVVGV4dHVyZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmJpbmRncm91cCA9PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlclRhcmdldC5mb3JtYXQgIT09IG91dHB1dC5mb3JtYXQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQuZm9ybWF0ID0gb3V0cHV0LmZvcm1hdDtcclxuICAgICAgICAgICAgdGhpcy5waXBlbGluZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHRoaXMucGlwZWxpbmVEZXNjcmlwdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29sb3JBdHRhY2htZW50LnZpZXcgPSBvdXRwdXQuY3JlYXRlVmlldyh7IGRpbWVuc2lvbjogJzJkJyB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgcGFzcyA9IGVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKHRoaXMucGFzc0Rlc2NyaXB0b3IpO1xyXG4gICAgICAgIHBhc3Muc2V0UGlwZWxpbmUodGhpcy5waXBlbGluZSk7XHJcbiAgICAgICAgcGFzcy5zZXRCaW5kR3JvdXAoMCwgdGhpcy5iaW5kZ3JvdXApO1xyXG4gICAgICAgIHBhc3MuZHJhdygzKTtcclxuICAgICAgICBwYXNzLmVuZCgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBHbG9iYWxVbmlmb3JtcyBmcm9tICcuL2dsb2JhbC11bmlmb3Jtcyc7XHJcblxyXG5jb25zdCBsYWJlbCA9ICdza3lib3ggcGFzcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTa3lib3hQYXNzIHtcclxuICAgIHN0YXRpYyByZWFkb25seSBjb2RlID0gLyogd2dzbCAqL2BcclxuICAgICAgICAke0dsb2JhbFVuaWZvcm1zLmNvZGUoMCl9XHJcblxyXG4gICAgICAgIHN0cnVjdCBTa3lib3hVbmlmb3JtcyB7XHJcbiAgICAgICAgICAgIG1pcEJpYXM6IGYzMixcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyIGVudmlyb25tZW50VGV4dHVyZTogdGV4dHVyZV9jdWJlPGYzMj47XHJcbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKDEpIHZhciBkZXB0aFRleHR1cmU6IHRleHR1cmVfZGVwdGhfMmQ7XHJcbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKDIpIHZhciBlbnZpcm9ubWVudFNhbXBsZXI6IHNhbXBsZXI7XHJcbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKDMpIHZhcjx1bmlmb3JtPiBza3lib3hVbmlmb3JtczogU2t5Ym94VW5pZm9ybXM7XHJcblxyXG4gICAgICAgIHN0cnVjdCBWYXJ5aW5ncyB7XHJcbiAgICAgICAgICAgIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbjogdmVjNGYsXHJcbiAgICAgICAgICAgIEBsb2NhdGlvbigwKSBwb3M6IHZlYzRmLFxyXG4gICAgICAgICAgICBAbG9jYXRpb24oMSkgbWlwQmlhczogZjMyLFxyXG4gICAgICAgIH07XHJcbiAgICBcclxuICAgICAgICBAdmVydGV4IFxyXG4gICAgICAgIGZuIHZzKEBidWlsdGluKHZlcnRleF9pbmRleCkgdk5keDogdTMyKSAtPiBWYXJ5aW5ncyB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGFycmF5KFxyXG4gICAgICAgICAgICAgICAgdmVjMigtMS4wLCAgMy4wKSxcclxuICAgICAgICAgICAgICAgIHZlYzIoLTEuMCwgLTEuMCksXHJcbiAgICAgICAgICAgICAgICB2ZWMyKCAzLjAsIC0xLjApLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHZhciB2c091dDogVmFyeWluZ3M7XHJcbiAgICAgICAgICAgIHZzT3V0LnBvc2l0aW9uID0gdmVjNChwb3Nbdk5keF0sIDAuMCwgMS4wKTtcclxuICAgIFxyXG4gICAgICAgICAgICAvLyBJZ25vcmVzIHRoZSBjYW1lcmEncyB0cmFuc2xhdGlvbiB3aXRob3V0IG5lZWRpbmcgYSBzZXBhcmF0ZSByb3RhdGlvbiBtYXRyaXguXHJcbiAgICAgICAgICAgIHZzT3V0LnBvcyA9IGdsb2JhbHMuaW52ZXJzZVZpZXdUb0NsaXAgKiB2c091dC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgbGV0IHcgPSB2c091dC5wb3MudztcclxuICAgICAgICAgICAgdnNPdXQucG9zLncgPSAwLjA7XHJcbiAgICAgICAgICAgIHZzT3V0LnBvcyA9IGdsb2JhbHMuaW52ZXJzZVdvcmxkVG9WaWV3ICogdnNPdXQucG9zO1xyXG4gICAgICAgICAgICB2c091dC5wb3MudyA9IHc7XHJcblxyXG4gICAgICAgICAgICB2c091dC5taXBCaWFzID0gY2xhbXAoc2t5Ym94VW5pZm9ybXMubWlwQmlhcywgMCwgZjMyKHRleHR1cmVOdW1MZXZlbHMoZW52aXJvbm1lbnRUZXh0dXJlKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdnNPdXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBAZnJhZ21lbnRcclxuICAgICAgICBmbiBmcyhpbjogVmFyeWluZ3MpIC0+IEBsb2NhdGlvbigwKSB2ZWM0ZiB7XHJcbiAgICAgICAgICAgIGxldCBkaW1lbnNpb25zID0gdGV4dHVyZURpbWVuc2lvbnMoZGVwdGhUZXh0dXJlKTtcclxuICAgICAgICAgICAgbGV0IHV2ID0gbWluKHZlYzI8dTMyPihmbG9vcihpbi5wb3NpdGlvbi54eSkpLCBkaW1lbnNpb25zIC0gMSk7XHJcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IHRleHR1cmVMb2FkKGRlcHRoVGV4dHVyZSwgdXYsIDApO1xyXG4gICAgICAgICAgICBpZiAoZGVwdGggPCAxLjApIHsgZGlzY2FyZDsgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHQgPSBub3JtYWxpemUoaW4ucG9zLnh5eiAvIGluLnBvcy53KTtcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gdGV4dHVyZVNhbXBsZUxldmVsKGVudmlyb25tZW50VGV4dHVyZSwgZW52aXJvbm1lbnRTYW1wbGVyLCB0LCBpbi5taXBCaWFzKS5yZ2I7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWM0KGNvbG9yLCAxLjApO1xyXG4gICAgICAgIH1cclxuICAgIGA7XHJcblxyXG4gICAgYmluZGdyb3VwTGF5b3V0OiBHUFVCaW5kR3JvdXBMYXlvdXQ7XHJcbiAgICBwaXBlbGluZUxheW91dDogR1BVUGlwZWxpbmVMYXlvdXQ7XHJcbiAgICBzaGFkZXI6IEdQVVNoYWRlck1vZHVsZTtcclxuXHJcbiAgICBsaW5lYXJTYW1wbGVyOiBHUFVTYW1wbGVyO1xyXG4gICAgbmVhcmVzdFNhbXBsZXI6IEdQVVNhbXBsZXI7XHJcbiAgICB0ZXh0dXJlQmluZGdyb3VwPzogR1BVQmluZEdyb3VwO1xyXG5cclxuICAgIHVuaWZvcm1CdWZmZXI6IEdQVUJ1ZmZlcjtcclxuICAgIHVuaWZvcm1BcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XHJcblxyXG4gICAgcGlwZWxpbmU/OiBHUFVSZW5kZXJQaXBlbGluZTtcclxuXHJcbiAgICAjc2t5VGV4dHVyZT86IEdQVVRleHR1cmVWaWV3O1xyXG4gICAgI2RlcHRoVGV4dHVyZT86IEdQVVRleHR1cmVWaWV3O1xyXG4gICAgI3RhcmdldEZvcm1hdCE6IEdQVVRleHR1cmVGb3JtYXQ7XHJcbiAgICAjdXNlTmVhcmVzdFNhbXBsZSA9IGZhbHNlO1xyXG5cclxuICAgIGdldCBtaXBMZXZlbCgpIHsgcmV0dXJuIHRoaXMudW5pZm9ybUFycmF5WzBdOyB9XHJcbiAgICBzZXQgbWlwTGV2ZWwodmFsOiBudW1iZXIpIHtcclxuICAgICAgICBpZiAodmFsID09PSB0aGlzLnVuaWZvcm1BcnJheVswXSkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybUFycmF5WzBdID0gdmFsO1xyXG4gICAgICAgIHRoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKHRoaXMudW5pZm9ybUJ1ZmZlciwgMCwgdGhpcy51bmlmb3JtQXJyYXksIDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB1c2VOZWFyZXN0U2FtcGxlKCkgeyByZXR1cm4gdGhpcy4jdXNlTmVhcmVzdFNhbXBsZTsgfVxyXG4gICAgc2V0IHVzZU5lYXJlc3RTYW1wbGUodmFsOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKHZhbCA9PT0gdGhpcy4jdXNlTmVhcmVzdFNhbXBsZSkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuI3VzZU5lYXJlc3RTYW1wbGUgPSB2YWw7XHJcbiAgICAgICAgdGhpcy4jdXBkYXRlQmluZGdyb3VwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHRhcmdldEZvcm1hdCgpIHsgcmV0dXJuIHRoaXMuI3RhcmdldEZvcm1hdDsgfVxyXG4gICAgc2V0IHRhcmdldEZvcm1hdChmb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXQpIHtcclxuICAgICAgICBpZiAoZm9ybWF0ID09PSB0aGlzLiN0YXJnZXRGb3JtYXQpIHJldHVybjtcclxuICAgICAgICB0aGlzLiN0YXJnZXRGb3JtYXQgPSBmb3JtYXQ7XHJcblxyXG4gICAgICAgIHRoaXMucGlwZWxpbmUgPSB0aGlzLmRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZSh7XHJcbiAgICAgICAgICAgIGxhYmVsLFxyXG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMucGlwZWxpbmVMYXlvdXQsXHJcbiAgICAgICAgICAgIHZlcnRleDoge1xyXG4gICAgICAgICAgICAgICAgZW50cnlQb2ludDogJ3ZzJyxcclxuICAgICAgICAgICAgICAgIG1vZHVsZTogdGhpcy5zaGFkZXIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZyYWdtZW50OiB7XHJcbiAgICAgICAgICAgICAgICBlbnRyeVBvaW50OiAnZnMnLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0czogW3sgZm9ybWF0IH1dLFxyXG4gICAgICAgICAgICAgICAgbW9kdWxlOiB0aGlzLnNoYWRlcixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgc2t5VGV4dHVyZShza3lib3g6IEdQVVRleHR1cmVWaWV3KSB7XHJcbiAgICAgICAgaWYgKHNreWJveCA9PT0gdGhpcy4jc2t5VGV4dHVyZSkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuI3NreVRleHR1cmUgPSBza3lib3g7XHJcbiAgICAgICAgdGhpcy4jdXBkYXRlQmluZGdyb3VwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGRlcHRoVGV4dHVyZShkZXB0aFRleHR1cmU6IEdQVVRleHR1cmVWaWV3KSB7XHJcbiAgICAgICAgaWYgKGRlcHRoVGV4dHVyZSA9PT0gdGhpcy4jZGVwdGhUZXh0dXJlKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy4jZGVwdGhUZXh0dXJlID0gZGVwdGhUZXh0dXJlO1xyXG4gICAgICAgIHRoaXMuI3VwZGF0ZUJpbmRncm91cCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRhcmdldDogR1BVUmVuZGVyUGFzc0NvbG9yQXR0YWNobWVudCA9IHtcclxuICAgICAgICBjbGVhclZhbHVlOiB7IHI6IDAuMCwgZzogMC4wLCBiOiAwLjAsIGE6IDEuMCB9LFxyXG4gICAgICAgIGxvYWRPcDogJ2NsZWFyJyxcclxuICAgICAgICBzdG9yZU9wOiAnc3RvcmUnLFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXHJcbiAgICAgICAgdmlldzogdW5kZWZpbmVkISxcclxuICAgIH07XHJcblxyXG4gICAgcmVhZG9ubHkgcGFzc0Rlc2NyaXB0b3I6IEdQVVJlbmRlclBhc3NEZXNjcmlwdG9yID0geyBjb2xvckF0dGFjaG1lbnRzOiBbdGhpcy50YXJnZXRdIH07XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHVibGljIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgICAgIHB1YmxpYyBnbG9iYWxzOiBHbG9iYWxVbmlmb3JtcyxcclxuICAgICAgICB0YXJnZXRGb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXQsXHJcbiAgICAgICAgc2t5Ym94PzogR1BVVGV4dHVyZVZpZXcsXHJcbiAgICApIHtcclxuICAgICAgICB0aGlzLmJpbmRncm91cExheW91dCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoe1xyXG4gICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTogeyB2aWV3RGltZW5zaW9uOiAnY3ViZScgfSxcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCB8IEdQVVNoYWRlclN0YWdlLlZFUlRFWCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdEaW1lbnNpb246ICcyZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZVR5cGU6ICdkZXB0aCcsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMixcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcclxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyOiB7fSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMyxcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5WRVJURVgsXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB7IHR5cGU6ICd1bmlmb3JtJyB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5saW5lYXJTYW1wbGVyID0gZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe1xyXG4gICAgICAgICAgICBtaW5GaWx0ZXI6ICdsaW5lYXInLFxyXG4gICAgICAgICAgICBtYWdGaWx0ZXI6ICdsaW5lYXInLFxyXG4gICAgICAgICAgICBtaXBtYXBGaWx0ZXI6ICdsaW5lYXInLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLm5lYXJlc3RTYW1wbGVyID0gZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe1xyXG4gICAgICAgICAgICBtaW5GaWx0ZXI6ICduZWFyZXN0JyxcclxuICAgICAgICAgICAgbWFnRmlsdGVyOiAnbmVhcmVzdCcsXHJcbiAgICAgICAgICAgIG1pcG1hcEZpbHRlcjogJ25lYXJlc3QnLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlciA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe1xyXG4gICAgICAgICAgICBjb2RlOiBTa3lib3hQYXNzLmNvZGUsXHJcbiAgICAgICAgICAgIGxhYmVsLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnBpcGVsaW5lTGF5b3V0ID0gZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtcclxuICAgICAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgICAgIGJpbmRHcm91cExheW91dHM6IFtcclxuICAgICAgICAgICAgICAgIGdsb2JhbHMuYmluZEdyb3VwTGF5b3V0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kZ3JvdXBMYXlvdXQsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMudW5pZm9ybUJ1ZmZlciA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xyXG4gICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAgc2l6ZTogMzIsXHJcbiAgICAgICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0sXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMudGFyZ2V0Rm9ybWF0ID0gdGFyZ2V0Rm9ybWF0O1xyXG4gICAgICAgIGlmIChza3lib3ggIT0gbnVsbCkgdGhpcy5za3lUZXh0dXJlID0gc2t5Ym94O1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcihwYXNzOiBHUFVSZW5kZXJQYXNzRW5jb2Rlcikge1xyXG4gICAgICAgIGlmICh0aGlzLnRleHR1cmVCaW5kZ3JvdXAgPT0gbnVsbCB8fCB0aGlzLnBpcGVsaW5lID09IG51bGwpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBwYXNzLnNldFBpcGVsaW5lKHRoaXMucGlwZWxpbmUpO1xyXG4gICAgICAgIHBhc3Muc2V0QmluZEdyb3VwKDAsIHRoaXMuZ2xvYmFscy5iaW5kZ3JvdXApO1xyXG4gICAgICAgIHBhc3Muc2V0QmluZEdyb3VwKDEsIHRoaXMudGV4dHVyZUJpbmRncm91cCk7XHJcbiAgICAgICAgcGFzcy5kcmF3KDMpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgICN1cGRhdGVCaW5kZ3JvdXAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI3NreVRleHR1cmUgPT0gbnVsbCB8fCB0aGlzLiNkZXB0aFRleHR1cmUgPT0gbnVsbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmVCaW5kZ3JvdXAgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xyXG4gICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLmJpbmRncm91cExheW91dCxcclxuICAgICAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMuI3NreVRleHR1cmUsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMuI2RlcHRoVGV4dHVyZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMixcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogdGhpcy51c2VOZWFyZXN0U2FtcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5uZWFyZXN0U2FtcGxlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMubGluZWFyU2FtcGxlcixcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMyxcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogeyBidWZmZXI6IHRoaXMudW5pZm9ybUJ1ZmZlciB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iLCJ0eXBlIFRleHR1cmVEYXRhID0ge1xuICAgIGZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCxcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgY2xlYXJWYWx1ZT86IEdQVUNvbG9yLFxuICAgIHRleHR1cmU/OiBHUFVUZXh0dXJlLFxuICAgIHZpZXc/OiBHUFVUZXh0dXJlVmlldyxcbn07XG5cbmV4cG9ydCBjb25zdCBlbnVtIEdCdWZmZXJHcm91cEluZGljZXMge1xuICAgIE5vcm1hbCA9IDAsXG4gICAgQWxiZWRvLFxuICAgIEVtaXNzaW9uLFxuICAgIE1ldGFsbGljUm91Z2huZXNzLFxuICAgIERlcHRoLFxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHQnVmZmVyIHtcbiAgICBzdGF0aWMgcmVhZG9ubHkgY29kZSA9IChncm91cDogbnVtYmVyKSA9PiAvKiB3Z3NsICovYFxuICAgICAgICBAZ3JvdXAoJHtncm91cH0pIEBiaW5kaW5nKCR7R0J1ZmZlckdyb3VwSW5kaWNlcy5Ob3JtYWx9KSBcbiAgICAgICAgdmFyIGdCdWZmZXJOb3JtYWw6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgXG4gICAgICAgIEBncm91cCgke2dyb3VwfSkgQGJpbmRpbmcoJHtHQnVmZmVyR3JvdXBJbmRpY2VzLkFsYmVkb30pIFxuICAgICAgICB2YXIgZ0J1ZmZlckFsYmVkbzogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgICBcbiAgICAgICAgQGdyb3VwKCR7Z3JvdXB9KSBAYmluZGluZygke0dCdWZmZXJHcm91cEluZGljZXMuRW1pc3Npb259KSBcbiAgICAgICAgdmFyIGdCdWZmZXJFbWlzc2lvbjogdGV4dHVyZV8yZDxmMzI+O1xuXG4gICAgICAgIEBncm91cCgke2dyb3VwfSkgQGJpbmRpbmcoJHtHQnVmZmVyR3JvdXBJbmRpY2VzLk1ldGFsbGljUm91Z2huZXNzfSkgXG4gICAgICAgIHZhciBnQnVmZmVyTWV0YWxsaWNSb3VnaG5lc3M6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgXG4gICAgICAgIEBncm91cCgke2dyb3VwfSkgQGJpbmRpbmcoJHtHQnVmZmVyR3JvdXBJbmRpY2VzLkRlcHRofSkgIFxuICAgICAgICB2YXIgZ0J1ZmZlckRlcHRoOiB0ZXh0dXJlX2RlcHRoXzJkO1xuICAgIGA7XG5cbiAgICBzdGF0aWMgcmVhZG9ubHkgbGF5b3V0RGVzY3JpcHRpb246IEdQVUJpbmRHcm91cExheW91dERlc2NyaXB0b3IgPSB7XG4gICAgICAgIGxhYmVsOiAnZ2J1ZmZlciBiaW5kIGdyb3VwIGxheW91dCcsXG4gICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiBHQnVmZmVyR3JvdXBJbmRpY2VzLk5vcm1hbCxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiB7IHNhbXBsZVR5cGU6ICd1bmZpbHRlcmFibGUtZmxvYXQnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IEdCdWZmZXJHcm91cEluZGljZXMuQWxiZWRvLFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHsgc2FtcGxlVHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiBHQnVmZmVyR3JvdXBJbmRpY2VzLkVtaXNzaW9uLFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHsgc2FtcGxlVHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiBHQnVmZmVyR3JvdXBJbmRpY2VzLk1ldGFsbGljUm91Z2huZXNzLFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHsgc2FtcGxlVHlwZTogJ3VuZmlsdGVyYWJsZS1mbG9hdCcgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogR0J1ZmZlckdyb3VwSW5kaWNlcy5EZXB0aCxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiB7IHNhbXBsZVR5cGU6ICdkZXB0aCcgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfTtcblxuICAgIG5vcm1hbCA9IHRoaXMuY3JlYXRlVGV4dHVyZSh7XG4gICAgICAgIGZvcm1hdDogJ3JnYmExNmZsb2F0JyxcbiAgICAgICAgbmFtZTogJ25vcm1hbCcsXG4gICAgICAgIGNsZWFyVmFsdWU6IHsgcjogMCwgZzogMCwgYjogMSwgYTogMSB9LFxuICAgIH0pO1xuXG4gICAgYWxiZWRvID0gdGhpcy5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgZm9ybWF0OiAncmdiYTh1bm9ybScsXG4gICAgICAgIG5hbWU6ICdhbGJlZG8nLFxuICAgICAgICBjbGVhclZhbHVlOiB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDEgfSxcbiAgICB9KTtcblxuICAgIGVtaXNzaW9uID0gdGhpcy5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgZm9ybWF0OiAncmdiYTE2ZmxvYXQnLFxuICAgICAgICBuYW1lOiAnZW1pc3Npb24nLFxuICAgICAgICBjbGVhclZhbHVlOiB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDEgfSxcbiAgICB9KTtcblxuICAgIG1ldGFsbGljUm91Z2huZXNzID0gdGhpcy5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgZm9ybWF0OiAncmc4dW5vcm0nLFxuICAgICAgICBuYW1lOiAnbWV0YWxsaWMgcm91Z2huZXNzJyxcbiAgICAgICAgY2xlYXJWYWx1ZTogeyByOiAwLCBnOiAwLCBiOiAwLCBhOiAwIH0sXG4gICAgfSk7XG5cbiAgICBkZXB0aCA9IHRoaXMuY3JlYXRlVGV4dHVyZSh7XG4gICAgICAgIGZvcm1hdDogJ2RlcHRoMzJmbG9hdCcsXG4gICAgICAgIG5hbWU6ICdkZXB0aCcsXG4gICAgfSk7XG5cbiAgICB0ZXh0dXJlcyA9IFtcbiAgICAgICAgdGhpcy5ub3JtYWwsXG4gICAgICAgIHRoaXMuYWxiZWRvLFxuICAgICAgICB0aGlzLmVtaXNzaW9uLFxuICAgICAgICB0aGlzLm1ldGFsbGljUm91Z2huZXNzLFxuICAgICAgICB0aGlzLmRlcHRoLFxuICAgIF07XG5cbiAgICB0YXJnZXRzID0gdGhpcy50ZXh0dXJlcy5zbGljZSgwLCAtMSkubWFwKCh7IGZvcm1hdCB9KSA9PiAoeyBmb3JtYXQgfSkpO1xuXG4gICAgYmluZEdyb3VwTGF5b3V0ID0gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KEdCdWZmZXIubGF5b3V0RGVzY3JpcHRpb24pO1xuICAgIGJpbmRncm91cCA9IHRoaXMudXBkYXRlQmluZGdyb3VwKCk7XG4gICAgcGFzc0Rlc2NyaXB0b3IgPSB0aGlzLnVwZGF0ZVBhc3NEZXNjcmlwdG9yKCk7XG5cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuX3NpemU7IH1cbiAgICBzZXQgc2l6ZSh2YWx1ZTogR1BVRXh0ZW50M0QpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCgodGV4KSA9PiB7IHRoaXMuY3JlYXRlVGV4dHVyZSh0ZXgpOyB9KTtcbiAgICAgICAgdGhpcy5iaW5kZ3JvdXAgPSB0aGlzLnVwZGF0ZUJpbmRncm91cCgpO1xuICAgICAgICB0aGlzLnBhc3NEZXNjcmlwdG9yID0gdGhpcy51cGRhdGVQYXNzRGVzY3JpcHRvcigpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgZGV2aWNlOiBHUFVEZXZpY2UsXG4gICAgICAgIHByaXZhdGUgX3NpemU6IEdQVUV4dGVudDNELFxuICAgICkgeyB9XG5cbiAgICB1cGRhdGVCaW5kZ3JvdXAoKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSB0aGlzLnRleHR1cmVzLm1hcCgoeyB2aWV3IH0sIGlkeCkgPT4gKHtcbiAgICAgICAgICAgIGJpbmRpbmc6IGlkeCxcbiAgICAgICAgICAgIHJlc291cmNlOiB2aWV3LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICAgICAgbGFiZWw6ICdnYnVmZmVyIGJpbmQgZ3JvdXAnLFxuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLmJpbmRHcm91cExheW91dCxcbiAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZVBhc3NEZXNjcmlwdG9yKCkge1xuICAgICAgICBjb25zdCBjb2xvckF0dGFjaG1lbnRzID0gdGhpcy50ZXh0dXJlcy5zbGljZSgwLCAtMSkubWFwKCh7IHZpZXcsIGNsZWFyVmFsdWUgfSkgPT4gKHtcbiAgICAgICAgICAgIHZpZXc6IHZpZXcsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY2xlYXJWYWx1ZTogY2xlYXJWYWx1ZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBsb2FkT3A6ICdjbGVhcicsXG4gICAgICAgICAgICBzdG9yZU9wOiAnc3RvcmUnLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiAnZm9yd2FyZCBwYXNzIGVuY29kZXInLFxuICAgICAgICAgICAgY29sb3JBdHRhY2htZW50cyxcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQ6IHtcbiAgICAgICAgICAgICAgICB2aWV3OiB0aGlzLmRlcHRoLnZpZXcsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIGRlcHRoQ2xlYXJWYWx1ZTogMS4wLFxuICAgICAgICAgICAgICAgIGRlcHRoTG9hZE9wOiAnY2xlYXInLFxuICAgICAgICAgICAgICAgIGRlcHRoU3RvcmVPcDogJ3N0b3JlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0gYXMgR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3I7XG4gICAgfVxuXG4gICAgY3JlYXRlVGV4dHVyZSh0ZXg6IFRleHR1cmVEYXRhKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gYGdidWZmZXIgJHt0ZXgubmFtZX1gO1xuICAgICAgICB0ZXgudGV4dHVyZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBzaXplOiB0aGlzLl9zaXplLFxuICAgICAgICAgICAgZm9ybWF0OiB0ZXguZm9ybWF0LFxuICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCB8IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcsXG4gICAgICAgIH0pO1xuICAgICAgICB0ZXgudmlldyA9IHRleC50ZXh0dXJlLmNyZWF0ZVZpZXcoeyBsYWJlbCB9KTtcbiAgICAgICAgcmV0dXJuIHRleCBhcyBUZXh0dXJlRGF0YSAmIFJlcXVpcmVkPFBpY2s8VGV4dHVyZURhdGEsICd0ZXh0dXJlJyB8ICd2aWV3Jz4+O1xuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IC8qIHdnc2wgKi9gXG4gICAgZm4gaGFtbWVyc2xleShpOiB1MzIsIE46IHUzMikgLT4gdmVjMmYge1xuICAgICAgICB2YXIgYml0cyA9IChpIDw8IDE2dSkgfCAoaSA+PiAxNnUpO1xuICAgICAgICBiaXRzID0gKChiaXRzICYgMHg1NTU1NTU1NXUpIDw8IDF1KSB8ICgoYml0cyAmIDB4QUFBQUFBQUF1KSA+PiAxdSk7XG4gICAgICAgIGJpdHMgPSAoKGJpdHMgJiAweDMzMzMzMzMzdSkgPDwgMnUpIHwgKChiaXRzICYgMHhDQ0NDQ0NDQ3UpID4+IDJ1KTtcbiAgICAgICAgYml0cyA9ICgoYml0cyAmIDB4MEYwRjBGMEZ1KSA8PCA0dSkgfCAoKGJpdHMgJiAweEYwRjBGMEYwdSkgPj4gNHUpO1xuICAgICAgICBiaXRzID0gKChiaXRzICYgMHgwMEZGMDBGRnUpIDw8IDh1KSB8ICgoYml0cyAmIDB4RkYwMEZGMDB1KSA+PiA4dSk7XG4gICAgICAgIGxldCByZGkgPSBmMzIoYml0cykgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAvIDB4MTAwMDAwMDAwXG4gICAgICAgIHJldHVybiB2ZWMyKGYzMihpKSAvIGYzMihOKSwgcmRpKTtcbiAgICB9XG5cbiAgICBmbiB0YW5nZW50U2FtcGxlR0dYKE46IHZlYzNmLCBYaTogdmVjMmYsIGEyOiBmMzIpIC0+IHZlYzNmIHtcbiAgICAgICAgY29uc3QgUEkgPSAzLjE0MTU5MjY1MzU5O1xuXG4gICAgICAgIGxldCBwaGkgPSAyLjAgKiBQSSAqIFhpLng7XG4gICAgICAgIGxldCBjb3NUaGV0YSA9IHNxcnQoKDEuMCAtIFhpLnkpIC8gKDEuMCArIChhMiAtIDEuMCkgKiBYaS55KSk7XG4gICAgICAgIGxldCBzaW5UaGV0YSA9IHNxcnQoMS4wIC0gY29zVGhldGEgKiBjb3NUaGV0YSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgSDogdmVjM2Y7XG4gICAgICAgIEgueCA9IGNvcyhwaGkpICogc2luVGhldGE7XG4gICAgICAgIEgueSA9IHNpbihwaGkpICogc2luVGhldGE7XG4gICAgICAgIEgueiA9IGNvc1RoZXRhO1xuXG4gICAgICAgIGxldCB1cCA9IHNlbGVjdCh2ZWMzKDAuMCwgMC4wLCAxLjApLCB2ZWMzKDEuMCwgMC4wLCAwLjApLCBhYnMoTi56KSA+PSAwLjk5OSk7XG4gICAgICAgIGxldCBUID0gbm9ybWFsaXplKGNyb3NzKHVwLCBOKSk7XG4gICAgICAgIGxldCBCID0gY3Jvc3MoTiwgVCk7XG5cbiAgICAgICAgbGV0IFMgPSBUICogSC54ICsgQiAqIEgueSArIE4gKiBILno7XG4gICAgICAgIHJldHVybiBub3JtYWxpemUoUyk7XG4gICAgfVxuXG4gICAgZm4gdlBhcnRMYW1iZGEoTm9WOiBmMzIsIGEyOiBmMzIpIC0+IGYzMiB7XG4gICAgICAgIHJldHVybiBzcXJ0KE5vViAqIE5vViAqICgxLjAgLSBhMikgKyBhMik7XG4gICAgfVxuXG4gICAgZm4gdkNvcnJlbGF0ZWRHR1goTm9WOiBmMzIsIE5vTDogZjMyLCBhMjogZjMyKSAtPiBmMzIge1xuICAgICAgICBsZXQgR0dYViA9IE5vTCAqIHZQYXJ0TGFtYmRhKE5vViwgYTIpO1xuICAgICAgICBsZXQgR0dYTCA9IE5vViAqIHZQYXJ0TGFtYmRhKE5vTCwgYTIpO1xuICAgICAgICByZXR1cm4gMC41IC8gKEdHWFYgKyBHR1hMKTtcbiAgICB9XG5cbiAgICBmbiBkUzJHR1goTm9IOiBmMzIsIGEyOiBmMzIpIC0+IGYzMiB7XG4gICAgICAgIGxldCBzID0gKGEyIC0gMS4wKSAqIE5vSCAqIE5vSCArIDEuMDtcbiAgICAgICAgcmV0dXJuIHMgKiBzO1xuICAgIH1cblxuICAgIGZuIGRHR1goTm9IOiBmMzIsIGEyOiBmMzIpIC0+IGYzMiB7XG4gICAgICAgIGNvbnN0IGludlBJID0gMS4wIC8gMy4xNDE1OTI2NTM1OTtcblxuICAgICAgICBsZXQgczIgPSBkUzJHR1goTm9ILCBhMik7XG4gICAgICAgIHJldHVybiBpbnZQSSAqIHNlbGVjdCgxLCBhMiAvIHMyLCBhMiAhPSBzMik7XG4gICAgfVxuYDtcbiIsImltcG9ydCBicmRmcyBmcm9tICcuLi8uLi9zaGFkZXJzL2JyZGZzLnNoYWRlcic7XG5pbXBvcnQgYmxpdCBmcm9tICcuLi8uLi9zaGFkZXJzL2JsaXQtdmVydC5zaGFkZXInO1xuXG5jb25zdCBjb2RlID0gLyogd2dzbCAqLyBgXG5vdmVycmlkZSBTQU1QTEVfQ09VTlQ6IHUzMiA9IDEwMjR1O1xuXG4ke2JsaXR9XG4ke2JyZGZzfVxuXG5AZnJhZ21lbnRcbmZuIGZzKEBsb2NhdGlvbigwKSB1djogdmVjMmYpIC0+IEBsb2NhdGlvbigwKSB2ZWM0ZiAge1xuICAgIGxldCBOb1YgPSB1di54O1xuICAgIGxldCByb3VnaG5lc3MgPSB1di55O1xuICAgIGxldCBhbHBoYSA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcbiAgICBsZXQgYTIgPSBhbHBoYSAqIGFscGhhO1xuICAgIGxldCBWID0gdmVjMyhzcXJ0KDEuMCAtIE5vViAqIE5vViksIE5vViwgMC4wKTtcbiAgICBsZXQgTiA9IHZlYzMoMC4wLCAxLjAsIDAuMCk7XG5cbiAgICB2YXIgYnJkZiA9IHZlYzIoMC4wKTtcblxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8IFNBTVBMRV9DT1VOVDsgaSsrKSB7XG4gICAgICAgIGxldCBYaSA9IGhhbW1lcnNsZXkoaSwgU0FNUExFX0NPVU5UKTtcbiAgICAgICAgbGV0IEggPSB0YW5nZW50U2FtcGxlR0dYKE4sIFhpLCBhMik7XG4gICAgICAgIGxldCBMID0gbm9ybWFsaXplKDIuMCAqIGRvdChWLCBIKSAqIEggLSBWKTtcblxuICAgICAgICBsZXQgTm9MID0gc2F0dXJhdGUoTC55KTtcbiAgICAgICAgbGV0IE5vSCA9IHNhdHVyYXRlKEgueSk7XG4gICAgICAgIGxldCBWb0ggPSBzYXR1cmF0ZShkb3QoViwgSCkpO1xuXG4gICAgICAgIGlmIChOb0wgPiAwLjApIHtcbiAgICAgICAgICAgIGxldCBwZGYgPSB2Q29ycmVsYXRlZEdHWChOb1YsIE5vTCwgYTIpICogVm9IICogTm9MIC8gTm9IO1xuICAgICAgICAgICAgbGV0IEZjID0gcG93KDEuMCAtIFZvSCwgNS4wKTtcbiAgICAgICAgICAgIGJyZGYgKz0gdmVjMigxLjAgLSBGYywgRmMpICogcGRmO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZlYzRmKGJyZGYgKiA0LjAgLyBmMzIoU0FNUExFX0NPVU5UKSwgMC4wLCAxLjApO1xufVxuYDtcblxuZXhwb3J0IHR5cGUgQmZyZEx1dERlc2NyaXB0b3IgPSB7XG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXG4gICAgbGFiZWw/OiBzdHJpbmcsXG4gICAgd2lkdGg/OiBudW1iZXIsXG4gICAgaGVpZ2h0PzogbnVtYmVyLFxuICAgIGZvcm1hdD86IEdQVVRleHR1cmVGb3JtYXQsXG4gICAgc2FtcGxlQ291bnQ/OiBudW1iZXIsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmZyZEx1dCh7XG4gICAgZGV2aWNlLFxuICAgIGxhYmVsLFxuICAgIHNhbXBsZUNvdW50LFxuICAgIHdpZHRoID0gMTAyNCxcbiAgICBoZWlnaHQgPSAxMDI0LFxuICAgIGZvcm1hdCA9ICdyZzMyZmxvYXQnLFxufTogQmZyZEx1dERlc2NyaXB0b3IpIHtcbiAgICBjb25zdCBiZnJkTHV0ID0gZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICBkaW1lbnNpb246ICcyZCcsXG4gICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQgfCBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HLFxuICAgICAgICBzaXplOiB7IHdpZHRoLCBoZWlnaHQgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoeyBsYWJlbDogJ2JmcmRMdXQgc2hhZGVyJywgY29kZSB9KTtcblxuICAgIGNvbnN0IHBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcbiAgICAgICAgbGFiZWw6ICdiZnJkIGx1dCBwaXBlbGluZScsXG4gICAgICAgIGxheW91dDogJ2F1dG8nLFxuICAgICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgICAgIGVudHJ5UG9pbnQ6ICd2cycsXG4gICAgICAgICAgICBtb2R1bGUsXG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgICAgICBlbnRyeVBvaW50OiAnZnMnLFxuICAgICAgICAgICAgdGFyZ2V0czogW3sgZm9ybWF0IH1dLFxuICAgICAgICAgICAgY29uc3RhbnRzOiBzYW1wbGVDb3VudCA/IHsgU0FNUExFX0NPVU5UOiBzYW1wbGVDb3VudCB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgZW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgIGNvbnN0IHBhc3MgPSBlbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyh7XG4gICAgICAgIGxhYmVsOiAnYnJkZiBsdXQgcmVuZGVyIHBhc3MnLFxuICAgICAgICBjb2xvckF0dGFjaG1lbnRzOiBbe1xuICAgICAgICAgICAgdmlldzogYmZyZEx1dC5jcmVhdGVWaWV3KCksXG4gICAgICAgICAgICBsb2FkT3A6ICdjbGVhcicsXG4gICAgICAgICAgICBzdG9yZU9wOiAnc3RvcmUnLFxuICAgICAgICB9XSxcbiAgICB9KTtcblxuICAgIHBhc3Muc2V0UGlwZWxpbmUocGlwZWxpbmUpO1xuICAgIHBhc3MuZHJhdygzKTtcbiAgICBwYXNzLmVuZCgpO1xuXG4gICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZW5jb2Rlci5maW5pc2goKV0pO1xuXG4gICAgcmV0dXJuIGJmcmRMdXQ7XG59XG4iLCJpbXBvcnQgeyB0b1dvcmxkRGlyIH0gZnJvbSAnLi4vLi4vc2hhZGVycy9jdWJlbWFwLXNhbXBsaW5nLnNoYWRlcic7XG5pbXBvcnQgYnJkZnMgZnJvbSAnLi4vLi4vc2hhZGVycy9icmRmcy5zaGFkZXInO1xuaW1wb3J0IGJsaXQgZnJvbSAnLi4vLi4vc2hhZGVycy9ibGl0LXZlcnQuc2hhZGVyJztcbmltcG9ydCB7IGNyZWF0ZUFuZENvcHlCdWZmZXIgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhLWNvcHknO1xuXG5jb25zdCBjb2RlID0gLyogd2dzbCAqL2BcbiAgICBjb25zdCBQSSA9IDMuMTQxNTkyNjUzNTk7XG5cbiAgICBvdmVycmlkZSBTQU1QTEVTOiB1MzIgPSAyMDQ4dTtcblxuICAgIHN0cnVjdCBQYXJhbXMge1xuICAgICAgICBmYWNlOiB1MzIsXG4gICAgICAgIHNpemU6IHUzMixcbiAgICB9XG5cbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyIGVudmlyb25tZW50OiB0ZXh0dXJlX2N1YmU8ZjMyPjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIGVudmlyb25tZW50U2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHVuaWZvcm0+IHBhcmFtczogUGFyYW1zO1xuXG4gICAgJHt0b1dvcmxkRGlyfVxuICAgICR7YnJkZnN9XG4gICAgJHtibGl0fVxuXG4gICAgQGZyYWdtZW50XG4gICAgZm4gZnMoQGJ1aWx0aW4ocG9zaXRpb24pIHBvczogdmVjNGYpIC0+IEBsb2NhdGlvbigwKSB2ZWM0ZiB7XG4gICAgICAgIGxldCBjb29yZCA9IHZlYzN1KHZlYzJ1KGZsb29yKHBvcy54eSkpLCBwYXJhbXMuZmFjZSk7XG4gICAgICAgIGxldCBzaXplID0gZjMyKHRleHR1cmVEaW1lbnNpb25zKGVudmlyb25tZW50KS54KTtcbiAgICAgICAgbGV0IGxvZEZhY3RvciA9IDYuMCAqIHNpemUgKiBzaXplIC8gZjMyKFNBTVBMRVMpO1xuXG4gICAgICAgIGxldCBOID0gdG9Xb3JsZERpcihjb29yZCwgcGFyYW1zLnNpemUpO1xuICAgICAgICBsZXQgcmlnaHQgPSBub3JtYWxpemUoY3Jvc3ModmVjMygwLjAsIDEuMCwgMC4wKSwgTikpO1xuICAgICAgICBsZXQgdXAgPSBub3JtYWxpemUoY3Jvc3MoTiwgcmlnaHQpKTtcbiAgICAgICAgbGV0IFRCTiA9IG1hdDN4MyhyaWdodCwgdXAsIE4pO1xuICAgICAgICBcbiAgICAgICAgdmFyIGlycmFkaWFuY2UgPSB2ZWMzKDAuMCk7XG4gICAgICAgIHZhciBzYW1wbGVzID0gMC4wO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8IFNBTVBMRVM7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGV0IHhpID0gaGFtbWVyc2xleShpLCBTQU1QTEVTKTtcbiAgICAgICAgICAgIGxldCBjb3NUaGV0YSA9IHNxcnQoMS4wIC0geGkueSk7XG4gICAgICAgICAgICBsZXQgc2luVGhldGEgPSBzcXJ0KHhpLnkpO1xuICAgICAgICAgICAgbGV0IHBoaSA9IDIuMCAqIFBJICogeGkueDtcbiAgICAgICAgICAgIGxldCBpbnZQZGYgPSBQSSAvIGNvc1RoZXRhO1xuICAgICAgICAgICAgbGV0IGxvY2FsRGlyID0gbm9ybWFsaXplKHZlYzMoc2luVGhldGEgKiBjb3MocGhpKSwgc2luVGhldGEgKiBzaW4ocGhpKSwgY29zVGhldGEpKTtcbiAgICAgICAgICAgIGxldCB3b3JsZERpciA9IFRCTiAqIGxvY2FsRGlyO1xuICAgICAgICAgICAgbGV0IGxvZCA9IDAuNSAqIGxvZzIobG9kRmFjdG9yICogaW52UGRmKTtcbiAgICAgICAgICAgIGlycmFkaWFuY2UgKz0gdGV4dHVyZVNhbXBsZUxldmVsKGVudmlyb25tZW50LCBlbnZpcm9ubWVudFNhbXBsZXIsIHdvcmxkRGlyLCBsb2QpLnJnYjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZWM0KGlycmFkaWFuY2UgLyBmMzIoU0FNUExFUyksIDEuMCk7XG4gICAgfVxuYDtcblxuZXhwb3J0IHR5cGUgSXJyYWRpYW5jZVRleHR1cmVEZXNjcmlwdG9yID0ge1xuICAgIGRldmljZTogR1BVRGV2aWNlLFxuICAgIHRleHR1cmU6IEdQVVRleHR1cmUsXG4gICAgbGFiZWw/OiBzdHJpbmcsXG4gICAgdXNhZ2U/OiBHUFVUZXh0dXJlVXNhZ2VGbGFncyxcbiAgICBzYW1wbGVzPzogbnVtYmVyLFxuICAgIG91dHB1dFdpZHRoPzogbnVtYmVyLFxuICAgIG91dHB1dEZvcm1hdD86IEdQVVRleHR1cmVGb3JtYXQsXG4gICAgb3V0cHV0VGV4dHVyZT86IEdQVVRleHR1cmUsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVJcnJhZGlhbmNlVGV4dHVyZSh7XG4gICAgZGV2aWNlLFxuICAgIHRleHR1cmUsXG4gICAgbGFiZWwgPSAnaXJyYWRpYW5jZScsXG4gICAgdXNhZ2UgPSAwLFxuICAgIHNhbXBsZXMgPSAyMDQ4LFxuICAgIG91dHB1dFdpZHRoLFxuICAgIG91dHB1dEZvcm1hdCxcbiAgICBvdXRwdXRUZXh0dXJlLFxufTogSXJyYWRpYW5jZVRleHR1cmVEZXNjcmlwdG9yKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gb3V0cHV0VGV4dHVyZT8uZm9ybWF0ID8/IG91dHB1dEZvcm1hdCA/PyB0ZXh0dXJlLmZvcm1hdDtcbiAgICBjb25zdCB3aWR0aCA9IG91dHB1dFRleHR1cmU/LndpZHRoID8/IG91dHB1dFdpZHRoID8/IDY0O1xuXG4gICAgY29uc3QgYmluZGdyb3VwTGF5b3V0ID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiB7IHZpZXdEaW1lbnNpb246ICdjdWJlJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgIHNhbXBsZXI6IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAyLFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgIGJ1ZmZlcjogeyB0eXBlOiAndW5pZm9ybScgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBzYW1wbGVyID0gZGV2aWNlLmNyZWF0ZVNhbXBsZXIoeyBtaW5GaWx0ZXI6ICdsaW5lYXInLCBtYWdGaWx0ZXI6ICdsaW5lYXInLCBtaXBtYXBGaWx0ZXI6ICdsaW5lYXInIH0pO1xuXG4gICAgY29uc3QgaXJyYWRpYW5jZVRleHR1cmUgPSBvdXRwdXRUZXh0dXJlPy5kZXB0aE9yQXJyYXlMYXllcnMgPT09IDZcbiAgICAgICAgPyBvdXRwdXRUZXh0dXJlXG4gICAgICAgIDogZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBkaW1lbnNpb246ICcyZCcsXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UIHwgdXNhZ2UsXG4gICAgICAgICAgICBzaXplOiB7IHdpZHRoLCBoZWlnaHQ6IHdpZHRoLCBkZXB0aE9yQXJyYXlMYXllcnM6IDYgfSxcbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVWludDMyQXJyYXkoWzAsIGlycmFkaWFuY2VUZXh0dXJlLndpZHRoXSk7XG4gICAgY29uc3QgcGFyYW1CdWZmZXIgPSBjcmVhdGVBbmRDb3B5QnVmZmVyKFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSxcbiAgICAgICAgZGV2aWNlLFxuICAgICk7XG5cbiAgICBjb25zdCBiaW5kZ3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGxheW91dDogYmluZGdyb3VwTGF5b3V0LFxuICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogdGV4dHVyZS5jcmVhdGVWaWV3KHsgZGltZW5zaW9uOiAnY3ViZScgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IHNhbXBsZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDIsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IHsgYnVmZmVyOiBwYXJhbUJ1ZmZlciB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHBpcGVsaW5lTGF5b3V0ID0gZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGJpbmRHcm91cExheW91dHM6IFtiaW5kZ3JvdXBMYXlvdXRdLFxuICAgIH0pO1xuXG4gICAgY29uc3QgbW9kdWxlID0gZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7IGxhYmVsLCBjb2RlIH0pO1xuXG4gICAgY29uc3QgcGlwZWxpbmUgPSBkZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgbGF5b3V0OiBwaXBlbGluZUxheW91dCxcbiAgICAgICAgdmVydGV4OiB7XG4gICAgICAgICAgICBtb2R1bGUsXG4gICAgICAgICAgICBlbnRyeVBvaW50OiAndnMnLFxuICAgICAgICB9LFxuICAgICAgICBmcmFnbWVudDoge1xuICAgICAgICAgICAgZW50cnlQb2ludDogJ2ZzJyxcbiAgICAgICAgICAgIGNvbnN0YW50czoge1xuICAgICAgICAgICAgICAgIFNBTVBMRVM6IHNhbXBsZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgdGFyZ2V0czogW3sgZm9ybWF0IH1dLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpICs9IDEpIHtcbiAgICAgICAgcGFyYW1zWzBdID0gaTtcbiAgICAgICAgZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKHBhcmFtQnVmZmVyLCAwLCBwYXJhbXMsIDAsIDEpO1xuXG4gICAgICAgIGNvbnN0IHZpZXcgPSBpcnJhZGlhbmNlVGV4dHVyZS5jcmVhdGVWaWV3KHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogJzJkJyxcbiAgICAgICAgICAgIGFycmF5TGF5ZXJDb3VudDogMSxcbiAgICAgICAgICAgIGJhc2VBcnJheUxheWVyOiBpLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBlbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IHBhc3MgPSBlbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyh7XG4gICAgICAgICAgICBjb2xvckF0dGFjaG1lbnRzOiBbe1xuICAgICAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICAgICAgbG9hZE9wOiAnY2xlYXInLFxuICAgICAgICAgICAgICAgIHN0b3JlT3A6ICdzdG9yZScsXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGFzcy5zZXRQaXBlbGluZShwaXBlbGluZSk7XG4gICAgICAgIHBhc3Muc2V0QmluZEdyb3VwKDAsIGJpbmRncm91cCk7XG4gICAgICAgIHBhc3MuZHJhdygzKTtcbiAgICAgICAgcGFzcy5lbmQoKTtcbiAgICAgICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZW5jb2Rlci5maW5pc2goKV0pO1xuICAgIH1cblxuICAgIHJldHVybiBpcnJhZGlhbmNlVGV4dHVyZTtcbn1cbiIsImltcG9ydCB7IHRvV29ybGREaXIgfSBmcm9tICcuLi8uLi9zaGFkZXJzL2N1YmVtYXAtc2FtcGxpbmcuc2hhZGVyJztcbmltcG9ydCBicmRmcyBmcm9tICcuLi8uLi9zaGFkZXJzL2JyZGZzLnNoYWRlcic7XG5pbXBvcnQgYmxpdCBmcm9tICcuLi8uLi9zaGFkZXJzL2JsaXQtdmVydC5zaGFkZXInO1xuaW1wb3J0IHsgY3JlYXRlQW5kQ29weUJ1ZmZlciB9IGZyb20gJy4uLy4uL3V0aWxzL2RhdGEtY29weSc7XG5cbmNvbnN0IGNvZGUgPSAvKiB3Z3NsICovYFxuICAgIG92ZXJyaWRlIFNBTVBMRVM6IHUzMiA9IDEwMjR1O1xuXG4gICAgY29uc3QgUEkgPSAzLjE0MTU5MjY1MzU5O1xuICAgIGNvbnN0IGludlBJID0gMS4wIC8gUEk7XG5cbiAgICBzdHJ1Y3QgUGFyYW1zIHtcbiAgICAgICAgZmFjZTogdTMyLFxuICAgICAgICBtaXBTaXplOiB1MzIsXG4gICAgICAgIGludk9tZWdhUDogZjMyLFxuICAgICAgICBhMjogZjMyLFxuICAgIH1cblxuICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXIgZW52aXJvbm1lbnQ6IHRleHR1cmVfY3ViZTxmMzI+O1xuICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXIgZW52aXJvbm1lbnRTYW1wbGVyOiBzYW1wbGVyO1xuICAgIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8dW5pZm9ybT4gcGFyYW1zOiBQYXJhbXM7XG5cbiAgICAke3RvV29ybGREaXJ9XG4gICAgJHticmRmc31cbiAgICAke2JsaXR9XG5cbiAgICBAZnJhZ21lbnRcbiAgICBmbiBmcyhAbG9jYXRpb24oMCkgdXY6IHZlYzJmKSAtPiBAbG9jYXRpb24oMCkgdmVjNGYge1xuICAgICAgICBsZXQgTiA9IHRvV29ybGREaXJGMzIodXYsIHBhcmFtcy5mYWNlKTtcblxuICAgICAgICB2YXIgcmFkaWFuY2UgPSB2ZWMzKDAuMCk7XG4gICAgICAgIHZhciB0b3RhbFdlaWdodCA9IDAuMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8IFNBTVBMRVM7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGV0IFhpID0gaGFtbWVyc2xleShpLCBTQU1QTEVTKTtcbiAgICAgICAgICAgIGxldCBIID0gdGFuZ2VudFNhbXBsZUdHWChOLCBYaSwgcGFyYW1zLmEyKTtcbiAgICAgICAgICAgIGxldCBIb1YgPSBzYXR1cmF0ZShkb3QoSCwgTikpO1xuICAgICAgICAgICAgbGV0IEwgPSBub3JtYWxpemUoMi4wICogSG9WICogSCAtIE4pO1xuICAgICAgICAgICAgbGV0IE5vTCA9IHNhdHVyYXRlKGRvdChOLCBMKSk7XG5cbiAgICAgICAgICAgIGlmIChOb0wgPD0gMC4wKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIGxldCBwZGYgPSBkR0dYKEhvViwgcGFyYW1zLmEyKSAvIDQuMCArIDAuMDAxO1xuICAgICAgICAgICAgbGV0IG9tZWdhUyA9IDEuMCAvIChmMzIoU0FNUExFUykgKiBwZGYpO1xuICAgICAgICAgICAgbGV0IG1pcExldmVsID0gMC41ICogbG9nMihvbWVnYVMgKiBwYXJhbXMuaW52T21lZ2FQKSArIHBhcmFtcy5hMjtcblxuICAgICAgICAgICAgcmFkaWFuY2UgKz0gdGV4dHVyZVNhbXBsZUxldmVsKGVudmlyb25tZW50LCBlbnZpcm9ubWVudFNhbXBsZXIsIEwsIG1pcExldmVsKS5yZ2IgKiBOb0w7XG4gICAgICAgICAgICB0b3RhbFdlaWdodCArPSBOb0w7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIHZlYzQocmFkaWFuY2UgLyB0b3RhbFdlaWdodCwgMS4wKTtcbiAgICB9XG5gO1xuXG5leHBvcnQgdHlwZSBJcnJhZGlhbmNlVGV4dHVyZURlc2NyaXB0b3IgPSB7XG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXG4gICAgdGV4dHVyZTogR1BVVGV4dHVyZSxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICB1c2FnZT86IEdQVVRleHR1cmVVc2FnZUZsYWdzLFxuICAgIHRhcmdldEZvcm1hdD86IEdQVVRleHR1cmVGb3JtYXQsXG4gICAgb3V0cHV0VGV4dHVyZT86IEdQVVRleHR1cmUsXG4gICAgb3V0cHV0V2lkdGg/OiBudW1iZXIsXG4gICAgc2FtcGxlcz86IG51bWJlcixcbiAgICBpblBsYWNlTWlwcz86IGJvb2xlYW4sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVSYWRpYW5jZVRleHR1cmUoe1xuICAgIGRldmljZSxcbiAgICB0ZXh0dXJlLFxuICAgIHRhcmdldEZvcm1hdCxcbiAgICB1c2FnZSA9IDAsXG4gICAgbGFiZWwgPSAncmFkaWFuY2UnLFxuICAgIHNhbXBsZXMgPSAxMDI0LFxuICAgIG91dHB1dFdpZHRoLFxuICAgIG91dHB1dFRleHR1cmUsXG59OiBJcnJhZGlhbmNlVGV4dHVyZURlc2NyaXB0b3IpIHtcbiAgICBjb25zdCBmb3JtYXQgPSBvdXRwdXRUZXh0dXJlPy5mb3JtYXQgPz8gdGFyZ2V0Rm9ybWF0ID8/IHRleHR1cmUuZm9ybWF0O1xuICAgIGNvbnN0IHdpZHRoID0gb3V0cHV0VGV4dHVyZT8ud2lkdGggPz8gb3V0cHV0V2lkdGggPz8gdGV4dHVyZS53aWR0aDtcblxuICAgIGNvbnN0IGJpbmRncm91cExheW91dCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDAsXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICAgICAgdGV4dHVyZTogeyB2aWV3RGltZW5zaW9uOiAnY3ViZScgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMSxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICBzYW1wbGVyOiB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMixcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICBidWZmZXI6IHsgdHlwZTogJ3VuaWZvcm0nIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2FtcGxlciA9IGRldmljZS5jcmVhdGVTYW1wbGVyKHsgbWluRmlsdGVyOiAnbGluZWFyJywgbWFnRmlsdGVyOiAnbGluZWFyJywgbWlwbWFwRmlsdGVyOiAnbGluZWFyJyB9KTtcbiAgICBjb25zdCBwYXJhbUFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQgKiA0KTtcbiAgICBjb25zdCB1aW50UGFyYW1zID0gbmV3IFVpbnQzMkFycmF5KHBhcmFtQXJyYXlCdWZmZXIsIDAsIDIpO1xuICAgIGNvbnN0IGZsb2F0UGFyYW1zID0gbmV3IEZsb2F0MzJBcnJheShwYXJhbUFycmF5QnVmZmVyLCAyICogNCwgMik7XG5cbiAgICBjb25zdCBwYXJhbUJ1ZmZlciA9IGNyZWF0ZUFuZENvcHlCdWZmZXIoXG4gICAgICAgIHBhcmFtQXJyYXlCdWZmZXIsXG4gICAgICAgIEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSxcbiAgICAgICAgZGV2aWNlLFxuICAgICk7XG5cbiAgICBjb25zdCByYWRpYW5jZVRleHR1cmUgPSBvdXRwdXRUZXh0dXJlPy5kZXB0aE9yQXJyYXlMYXllcnMgPT09IDZcbiAgICAgICAgPyBvdXRwdXRUZXh0dXJlXG4gICAgICAgIDogZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBkaW1lbnNpb246ICcyZCcsXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUIHwgdXNhZ2UsXG4gICAgICAgICAgICBzaXplOiB7IHdpZHRoLCBoZWlnaHQ6IHdpZHRoLCBkZXB0aE9yQXJyYXlMYXllcnM6IDYgfSxcbiAgICAgICAgICAgIG1pcExldmVsQ291bnQ6IE1hdGgubWF4KChNYXRoLmxvZzIod2lkdGgpIHwgMCkgLSAyLCAxKSxcbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBjb3B5RW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2Rlcih7XG4gICAgICAgIGxhYmVsOiBgJHtsYWJlbH0gY29weSBlbmNvZGVyYCxcbiAgICB9KTtcblxuICAgIGNvcHlFbmNvZGVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlKFxuICAgICAgICB7IHRleHR1cmUsIG1pcExldmVsOiAwIH0sXG4gICAgICAgIHsgdGV4dHVyZTogcmFkaWFuY2VUZXh0dXJlLCBtaXBMZXZlbDogMCB9LFxuICAgICAgICB7IHdpZHRoLCBoZWlnaHQ6IHdpZHRoLCBkZXB0aE9yQXJyYXlMYXllcnM6IDYgfSxcbiAgICApO1xuICAgIGRldmljZS5xdWV1ZS5zdWJtaXQoW2NvcHlFbmNvZGVyLmZpbmlzaCgpXSk7XG5cbiAgICBjb25zdCBwaXBlbGluZUxheW91dCA9IGRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBiaW5kR3JvdXBMYXlvdXRzOiBbYmluZGdyb3VwTGF5b3V0XSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoeyBsYWJlbCwgY29kZSB9KTtcblxuICAgIGNvbnN0IHBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGxheW91dDogcGlwZWxpbmVMYXlvdXQsXG4gICAgICAgIHZlcnRleDoge1xuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgZW50cnlQb2ludDogJ3ZzJyxcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgICAgIGVudHJ5UG9pbnQ6ICdmcycsXG4gICAgICAgICAgICB0YXJnZXRzOiBbeyBmb3JtYXQ6IHJhZGlhbmNlVGV4dHVyZS5mb3JtYXQgfV0sXG4gICAgICAgICAgICBjb25zdGFudHM6IHtcbiAgICAgICAgICAgICAgICBTQU1QTEVTOiBzYW1wbGVzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vZHVsZSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGZsb2F0UGFyYW1zWzBdID0gKDYgKiB0ZXh0dXJlLndpZHRoICogdGV4dHVyZS53aWR0aCkgLyAoNCAqIE1hdGguUEkpO1xuXG4gICAgdm9pZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgYmluZGdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIGxheW91dDogYmluZGdyb3VwTGF5b3V0LFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRleHR1cmUuY3JlYXRlVmlldyh7IGRpbWVuc2lvbjogJ2N1YmUnIH0pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogc2FtcGxlcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMixcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHsgYnVmZmVyOiBwYXJhbUJ1ZmZlciB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGxldCBtaXAgPSAxOyBtaXAgPCByYWRpYW5jZVRleHR1cmUubWlwTGV2ZWxDb3VudDsgbWlwICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdWdobmVzcyA9IG1pcCAvIChyYWRpYW5jZVRleHR1cmUubWlwTGV2ZWxDb3VudCAtIDEpO1xuICAgICAgICAgICAgZmxvYXRQYXJhbXNbMV0gPSByb3VnaG5lc3MgKiogNDtcbiAgICAgICAgICAgIHVpbnRQYXJhbXNbMV0gPSAocmFkaWFuY2VUZXh0dXJlLndpZHRoID4+IG1pcCkgfCAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBmYWNlID0gMDsgZmFjZSA8IDY7IGZhY2UgKz0gMSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGRldmljZS5xdWV1ZS5vblN1Ym1pdHRlZFdvcmtEb25lKCk7XG4gICAgICAgICAgICAgICAgdWludFBhcmFtc1swXSA9IGZhY2U7XG4gICAgICAgICAgICAgICAgZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKHBhcmFtQnVmZmVyLCAwLCBwYXJhbUFycmF5QnVmZmVyKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSByYWRpYW5jZVRleHR1cmUuY3JlYXRlVmlldyh7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogJzJkJyxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlMYXllckNvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICBiYXNlQXJyYXlMYXllcjogZmFjZSxcbiAgICAgICAgICAgICAgICAgICAgbWlwTGV2ZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZU1pcExldmVsOiBtaXAsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFzcyA9IGVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkT3A6ICdjbGVhcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZU9wOiAnc3RvcmUnLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHBhc3Muc2V0UGlwZWxpbmUocGlwZWxpbmUpO1xuICAgICAgICAgICAgICAgIHBhc3Muc2V0QmluZEdyb3VwKDAsIGJpbmRncm91cCk7XG4gICAgICAgICAgICAgICAgcGFzcy5kcmF3KDMpO1xuICAgICAgICAgICAgICAgIHBhc3MuZW5kKCk7XG4gICAgICAgICAgICAgICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZW5jb2Rlci5maW5pc2goKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmFkaWFuY2VUZXh0dXJlO1xufVxuIiwiaW1wb3J0IEdCdWZmZXIgZnJvbSAnLi9nYnVmZmVyJztcbmltcG9ydCBicmRmcyBmcm9tICcuLi9zaGFkZXJzL2JyZGZzLnNoYWRlcic7XG5pbXBvcnQgYmxpdCBmcm9tICcuLi9zaGFkZXJzL2JsaXQtdmVydC5zaGFkZXInO1xuaW1wb3J0IEdsb2JhbFVuaWZvcm1zIGZyb20gJy4vZ2xvYmFsLXVuaWZvcm1zJztcbmltcG9ydCB7IGNyZWF0ZUJmcmRMdXQgfSBmcm9tICcuL2libC10ZXh0dXJlcy9jcmVhdGUtYmZyZC1sdXQnO1xuaW1wb3J0IGNyZWF0ZUlycmFkaWFuY2VUZXh0dXJlIGZyb20gJy4vaWJsLXRleHR1cmVzL2NyZWF0ZS1pcnJhZGlhbmNlLXRleHR1cmUnO1xuaW1wb3J0IGNyZWF0ZVJhZGlhbmNlVGV4dHVyZSBmcm9tICcuL2libC10ZXh0dXJlcy9jcmVhdGUtcmFkaWFuY2UtdGV4dHVyZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmVycmVkUGFzcyB7XG4gICAgc3RhdGljIHJlYWRvbmx5IGNvZGUgPSAvKiB3Z3NsICovYFxuICAgICAgICAke0dsb2JhbFVuaWZvcm1zLmNvZGUoMCl9XG4gICAgICAgICR7R0J1ZmZlci5jb2RlKDEpfVxuXG4gICAgICAgIEBncm91cCgyKSBAYmluZGluZygwKSB2YXIgcmFkaWFuY2VUZXh0dXJlOiB0ZXh0dXJlX2N1YmU8ZjMyPjtcbiAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDEpIHZhciBpcnJhZGlhbmNlVGV4dHVyZTogdGV4dHVyZV9jdWJlPGYzMj47XG4gICAgICAgIEBncm91cCgyKSBAYmluZGluZygyKSB2YXIgYnJkZlRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDMpIHZhciBnZW5lcmFsU2FtcGxlcjogc2FtcGxlcjtcblxuICAgICAgICAke2JyZGZzfVxuICAgICAgICAke2JsaXR9XG5cbiAgICAgICAgQGZyYWdtZW50XG4gICAgICAgIGZuIGZzKEBidWlsdGluKHBvc2l0aW9uKSBwb3M6IHZlYzRmLCBAbG9jYXRpb24oMCkgdXY6IHZlYzJmKSAtPiBAbG9jYXRpb24oMCkgdmVjNGYge1xuICAgICAgICAgICAgbGV0IHV2aSA9IHZlYzI8dTMyPihwb3MueHkpO1xuICAgICAgICAgICAgbGV0IGRlcHRoID0gdGV4dHVyZUxvYWQoZ0J1ZmZlckRlcHRoLCB1dmksIDApO1xuXG4gICAgICAgICAgICBpZiAoZGVwdGggPj0gMS4wKSB7IGRpc2NhcmQ7IH1cblxuICAgICAgICAgICAgbGV0IHV2Q2xpcCA9IHZlYzIodXYueCAqIDIuMCAtIDEuMCwgMS4wIC0gdXYueSAqIDIuMCk7XG4gICAgICAgICAgICBsZXQgY2xpcFBvcyA9IHZlYzQodXZDbGlwLCBkZXB0aCwgMS4wKTtcbiAgICAgICAgICAgIGxldCB2aWV3UG9zID0gZ2xvYmFscy5pbnZlcnNlVmlld1RvQ2xpcCAqIGNsaXBQb3M7XG4gICAgICAgICAgICBsZXQgd29ybGREaXIgPSBnbG9iYWxzLmludmVyc2VXb3JsZFRvVmlldyAqIHZlYzQodmlld1Bvcy54eXogLyB2aWV3UG9zLncsIDAuMCk7XG4gICAgICAgICAgICBsZXQgdmlldyA9IC1ub3JtYWxpemUod29ybGREaXIueHl6KTtcblxuICAgICAgICAgICAgbGV0IG5vcm1hbCA9IHRleHR1cmVMb2FkKGdCdWZmZXJOb3JtYWwsIHV2aSwgMCkucmdiO1xuICAgICAgICAgICAgbGV0IGFsYmVkbyA9IHRleHR1cmVMb2FkKGdCdWZmZXJBbGJlZG8sIHV2aSwgMCkucmdiO1xuICAgICAgICAgICAgbGV0IGVtaXNzaW9uID0gdGV4dHVyZUxvYWQoZ0J1ZmZlckVtaXNzaW9uLCB1dmksIDApLnJnYjtcbiAgICAgICAgICAgIGxldCBtZXRhbGxpY1JvdWdobmVzc1NhbXBsZSA9IHRleHR1cmVMb2FkKGdCdWZmZXJNZXRhbGxpY1JvdWdobmVzcywgdXZpLCAwKTtcbiAgICAgICAgICAgIGxldCBtZXRhbGxpYyA9IG1ldGFsbGljUm91Z2huZXNzU2FtcGxlLnI7XG4gICAgICAgICAgICBsZXQgcm91Z2huZXNzID0gbWV0YWxsaWNSb3VnaG5lc3NTYW1wbGUuZztcbiAgICAgICAgICAgIGxldCBhbHBoYSA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcbiAgICAgICAgICAgIGxldCBhMiA9IGFscGhhICogYWxwaGE7XG5cbiAgICAgICAgICAgIGxldCBOb1YgPSBzYXR1cmF0ZShkb3Qobm9ybWFsLCB2aWV3KSk7XG4gICAgICAgICAgICBsZXQgRjAgPSBtaXgodmVjM2YoMC4wNCksIGFsYmVkbywgbWV0YWxsaWMpO1xuICAgICAgICAgICAgbGV0IFIgPSByZWZsZWN0KC12aWV3LCBub3JtYWwpO1xuXG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSByb3VnaG5lc3MgKiBmMzIodGV4dHVyZU51bUxldmVscyhyYWRpYW5jZVRleHR1cmUpIC0gMXUpO1xuICAgICAgICAgICAgbGV0IHJhZGlhbmNlID0gdGV4dHVyZVNhbXBsZUxldmVsKHJhZGlhbmNlVGV4dHVyZSwgZ2VuZXJhbFNhbXBsZXIsIFIsIGxldmVsKS5yZ2I7XG4gICAgICAgICAgICBsZXQgaXJyYWRpYW5jZSA9IHRleHR1cmVTYW1wbGUoaXJyYWRpYW5jZVRleHR1cmUsIGdlbmVyYWxTYW1wbGVyLCBub3JtYWwpLnJnYjtcbiAgICAgICAgICAgIGxldCBicmRmID0gdGV4dHVyZVNhbXBsZShicmRmVGV4dHVyZSwgZ2VuZXJhbFNhbXBsZXIsIHNhdHVyYXRlKHZlYzJmKE5vViwgcm91Z2huZXNzKSkpLnh5O1xuXG4gICAgICAgICAgICAvLyBSb3VnaG5lc3MgZGVwZW5kZW50IGZyZXNuZWxcbiAgICAgICAgICAgIGxldCBGciA9IG1heCh2ZWMzZigxLjAgLSByb3VnaG5lc3MpLCBGMCkgLSBGMDtcbiAgICAgICAgICAgIGxldCBrUyA9IEYwICsgRnIgKiBwb3coMS4wIC0gTm9WLCA1LjApO1xuICAgICAgICAgICAgbGV0IEZzc0VzcyA9IGtTICogYnJkZi54ICsgYnJkZi55O1xuXG4gICAgICAgICAgICAvLyBNdWx0aXBsZSBzY2F0dGVyaW5nLCBvcmlnaW5hbGx5IHByb3Bvc2VkIGJ5IEZkZXotQWd1ZXJhXG4gICAgICAgICAgICAvLyBhbmQgaGVyZSBhZGFwdGVkIGZyb20gaHR0cHM6Ly9icnVvcC5naXRodWIuaW8vaWJsXG4gICAgICAgICAgICBsZXQgRW1zID0gMS4wIC0gKGJyZGYueCArIGJyZGYueSk7XG4gICAgICAgICAgICBsZXQgRmF2ZyA9IEYwICsgKDEuMCAtIEYwKSAvIDIxLjA7XG4gICAgICAgICAgICBsZXQgRm1zRW1zID0gRW1zICogRnNzRXNzICogRmF2ZyAvICgxLjAgLSBGYXZnICogRW1zKTtcbiAgICAgICAgICAgIGxldCBrRCA9IGFsYmVkbyAqICgxLjAgLSAwLjA0KSAqICgxLjAgLSBtZXRhbGxpYykgKiAoMS4wIC0gRnNzRXNzICsgRm1zRW1zKTtcblxuICAgICAgICAgICAgbGV0IHNwZWN1bGFyID0gRnNzRXNzICogcmFkaWFuY2U7XG4gICAgICAgICAgICBsZXQgZGlmZnVzZSA9IChGbXNFbXMgKyBrRCkgKiBpcnJhZGlhbmNlO1xuICAgICAgICAgICAgbGV0IGFtYmllbnQgPSBzcGVjdWxhciArIGRpZmZ1c2UgKyBlbWlzc2lvbjtcblxuICAgICAgICAgICAgcmV0dXJuIHZlYzRmKGFtYmllbnQsIDEuMCk7XG4gICAgICAgIH1cbiAgICBgO1xuXG4gICAgdGFyZ2V0OiBHUFVSZW5kZXJQYXNzQ29sb3JBdHRhY2htZW50ID0ge1xuICAgICAgICB2aWV3OiB1bmRlZmluZWQhLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY2xlYXJWYWx1ZTogeyByOiAwLCBnOiAwLCBiOiAwLCBhOiAxIH0sXG4gICAgICAgIGxvYWRPcDogJ2NsZWFyJyxcbiAgICAgICAgc3RvcmVPcDogJ3N0b3JlJyxcbiAgICB9O1xuXG4gICAgYmZyZEx1dCA9IGNyZWF0ZUJmcmRMdXQoeyBkZXZpY2U6IHRoaXMuZGV2aWNlIH0pO1xuICAgIGJmcmRMdXRWaWV3ID0gdGhpcy5iZnJkTHV0LmNyZWF0ZVZpZXcoKTtcblxuICAgIGlycmFkaWFuY2VUZXh0dXJlPzogR1BVVGV4dHVyZTtcbiAgICBpcnJhZGlhbmNlVmlldz86IEdQVVRleHR1cmVWaWV3O1xuICAgIHJhZGlhbmNlVGV4dHVyZT86IEdQVVRleHR1cmU7XG4gICAgcmFkaWFuY2VWaWV3PzogR1BVVGV4dHVyZVZpZXc7XG4gICAgYmluZGdyb3VwPzogR1BVQmluZEdyb3VwO1xuXG4gICAgc2FtcGxlcjogR1BVU2FtcGxlcjtcbiAgICBwaXBlbGluZTogR1BVUmVuZGVyUGlwZWxpbmU7XG4gICAgYmluZGdyb3VwTGF5b3V0OiBHUFVCaW5kR3JvdXBMYXlvdXQ7XG5cbiAgICByZWFkb25seSBwYXNzRGVzY3JpcHRvcjogR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3IgPSB7IGNvbG9yQXR0YWNobWVudHM6IFt0aGlzLnRhcmdldF0gfTtcblxuICAgIHNldCBza3lib3godGV4dHVyZTogR1BVVGV4dHVyZSkge1xuICAgICAgICB0aGlzLmlycmFkaWFuY2VUZXh0dXJlID0gY3JlYXRlSXJyYWRpYW5jZVRleHR1cmUoe1xuICAgICAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgICAgIGRldmljZTogdGhpcy5kZXZpY2UsXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yYWRpYW5jZVRleHR1cmUgPSBjcmVhdGVSYWRpYW5jZVRleHR1cmUoe1xuICAgICAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgICAgIGRldmljZTogdGhpcy5kZXZpY2UsXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pcnJhZGlhbmNlVmlldyA9IHRoaXMuaXJyYWRpYW5jZVRleHR1cmUuY3JlYXRlVmlldyh7IGRpbWVuc2lvbjogJ2N1YmUnIH0pO1xuICAgICAgICB0aGlzLnJhZGlhbmNlVmlldyA9IHRoaXMucmFkaWFuY2VUZXh0dXJlLmNyZWF0ZVZpZXcoeyBkaW1lbnNpb246ICdjdWJlJyB9KTtcblxuICAgICAgICB0aGlzLmJpbmRncm91cCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMuYmluZGdyb3VwTGF5b3V0LFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMucmFkaWFuY2VWaWV3LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogdGhpcy5pcnJhZGlhbmNlVmlldyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMixcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMuYmZyZEx1dFZpZXcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDMsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiB0aGlzLnNhbXBsZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkZXZpY2U6IEdQVURldmljZSwgcHVibGljIGdsb2JhbHM6IEdsb2JhbFVuaWZvcm1zLCBwdWJsaWMgZ2J1ZmZlcjogR0J1ZmZlciwgZm9ybWF0OiBHUFVUZXh0dXJlRm9ybWF0LCBza3lib3g/OiBHUFVUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuc2FtcGxlciA9IGRldmljZS5jcmVhdGVTYW1wbGVyKHsgbWFnRmlsdGVyOiAnbGluZWFyJywgbWluRmlsdGVyOiAnbGluZWFyJywgbWlwbWFwRmlsdGVyOiAnbGluZWFyJyB9KTtcblxuICAgICAgICBpZiAoc2t5Ym94ICE9IG51bGwpIHRoaXMuc2t5Ym94ID0gc2t5Ym94O1xuXG4gICAgICAgIHRoaXMuYmluZGdyb3VwTGF5b3V0ID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgICAgICBsYWJlbDogJ2RlZmVycmVkIHBhc3MnLFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmU6IHsgdmlld0RpbWVuc2lvbjogJ2N1YmUnIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlOiB7IHZpZXdEaW1lbnNpb246ICdjdWJlJyB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAyLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTogeyB2aWV3RGltZW5zaW9uOiAnMmQnIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDMsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyOiB7fSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbGF5b3V0ID0gZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtcbiAgICAgICAgICAgIGxhYmVsOiAnZGVmZXJyZWQgcGFzcyBiaW5kZ3JvdXAgbGF5b3V0JyxcbiAgICAgICAgICAgIGJpbmRHcm91cExheW91dHM6IFtcbiAgICAgICAgICAgICAgICB0aGlzLmdsb2JhbHMuYmluZEdyb3VwTGF5b3V0LFxuICAgICAgICAgICAgICAgIHRoaXMuZ2J1ZmZlci5iaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kZ3JvdXBMYXlvdXQsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtb2R1bGUgPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHsgY29kZTogRGVmZXJyZWRQYXNzLmNvZGUsIGxhYmVsOiAnZGVmZXJyZWQgcGFzcyBzaGFkZXInIH0pO1xuXG4gICAgICAgIHRoaXMucGlwZWxpbmUgPSBkZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoe1xuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgdmVydGV4OiB7XG4gICAgICAgICAgICAgICAgZW50cnlQb2ludDogJ3ZzJyxcbiAgICAgICAgICAgICAgICBtb2R1bGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgICAgICAgICBlbnRyeVBvaW50OiAnZnMnLFxuICAgICAgICAgICAgICAgIHRhcmdldHM6IFt7IGZvcm1hdCB9XSxcbiAgICAgICAgICAgICAgICBtb2R1bGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIocGFzczogR1BVUmVuZGVyUGFzc0VuY29kZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuYmluZGdyb3VwID09IG51bGwpIHJldHVybjtcbiAgICAgICAgcGFzcy5zZXRQaXBlbGluZSh0aGlzLnBpcGVsaW5lKTtcbiAgICAgICAgcGFzcy5zZXRCaW5kR3JvdXAoMCwgdGhpcy5nbG9iYWxzLmJpbmRncm91cCk7XG4gICAgICAgIHBhc3Muc2V0QmluZEdyb3VwKDEsIHRoaXMuZ2J1ZmZlci5iaW5kZ3JvdXApO1xuICAgICAgICBwYXNzLnNldEJpbmRHcm91cCgyLCB0aGlzLmJpbmRncm91cCk7XG4gICAgICAgIHBhc3MuZHJhdygzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ2FtZXJhIGZyb20gJy4vY2FtZXJhL2NhbWVyYSc7XHJcbmltcG9ydCBHbG9iYWxVbmlmb3JtcyBmcm9tICcuL2dsb2JhbC11bmlmb3Jtcyc7XHJcbmltcG9ydCBUb25lbWFwUGFzcyBmcm9tICcuL3RvbmVtYXAtcGFzcyc7XHJcbmltcG9ydCBTa3lib3hQYXNzIGZyb20gJy4vc2t5Ym94LXBhc3MnO1xyXG5pbXBvcnQgR0J1ZmZlciBmcm9tICcuL2didWZmZXInO1xyXG5pbXBvcnQgRGVmZXJyZWRQYXNzIGZyb20gJy4vZGVmZXJyZWQtcGFzcyc7XHJcblxyXG5pbXBvcnQgeyBiaW5hcnlJbnNlcnQsIGRlYm91bmNlIH0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJhbCc7XHJcblxyXG5leHBvcnQgdHlwZSBGb3J3YXJkUGFzc1BhcmFtcyA9IHtcclxuICAgIGVuY29kZXI6IEdQVUNvbW1hbmRFbmNvZGVyLFxyXG4gICAgZ2xvYmFsczogR2xvYmFsVW5pZm9ybXMsXHJcbiAgICBnYnVmZmVyOiBHQnVmZmVyLFxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgRm9yd2FyZFBhc3MgPSB7XHJcbiAgICByZW5kZXI6IChwYXJhbXM6IEZvcndhcmRQYXNzUGFyYW1zKSA9PiB2b2lkLFxyXG4gICAgcHJpb3JpdHk6IG51bWJlcixcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIHtcclxuICAgIHN0YXRpYyByZWFkb25seSByZXF1aXJlZEZlYXR1cmVzOiBHUFVGZWF0dXJlTmFtZVtdID0gWydmbG9hdDMyLWZpbHRlcmFibGUnXTtcclxuICAgIHN0YXRpYyByZWFkb25seSBvdXRwdXRGb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXQgPSBuYXZpZ2F0b3IuZ3B1LmdldFByZWZlcnJlZENhbnZhc0Zvcm1hdCgpO1xyXG4gICAgc3RhdGljIHJlYWRvbmx5IHBvc3RQcm9jZXNzRm9ybWF0OiBHUFVUZXh0dXJlRm9ybWF0ID0gJ3JnYmEzMmZsb2F0JztcclxuXHJcbiAgICBjb2xvckF0dGFjaG1lbnQ6IEdQVVJlbmRlclBhc3NDb2xvckF0dGFjaG1lbnQgPSB7XHJcbiAgICAgICAgY2xlYXJWYWx1ZTogeyByOiAwLCBnOiAwLCBiOiAwLCBhOiAxIH0sXHJcbiAgICAgICAgbG9hZE9wOiAnY2xlYXInLFxyXG4gICAgICAgIHN0b3JlT3A6ICdzdG9yZScsXHJcbiAgICAgICAgdmlldzogdW5kZWZpbmVkISwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXHJcbiAgICB9O1xyXG5cclxuICAgIHBhc3NEZXNjcmlwdG9yOiBHUFVSZW5kZXJQYXNzRGVzY3JpcHRvciA9IHsgY29sb3JBdHRhY2htZW50czogW3RoaXMuY29sb3JBdHRhY2htZW50XSB9O1xyXG5cclxuICAgIGNvbnRleHQ6IEdQVUNhbnZhc0NvbnRleHQ7XHJcbiAgICBjYW1lcmE6IENhbWVyYTtcclxuICAgIGdsb2JhbHM6IEdsb2JhbFVuaWZvcm1zO1xyXG4gICAgZ2J1ZmZlcjogR0J1ZmZlcjtcclxuXHJcbiAgICBmb3J3YXJkUGFzc2VzOiBGb3J3YXJkUGFzc1tdID0gW107XHJcbiAgICBkZWZlcnJlZFBhc3M6IERlZmVycmVkUGFzcztcclxuICAgIHNreWJveFBhc3M6IFNreWJveFBhc3M7XHJcbiAgICB0b25lbWFwUGFzczogVG9uZW1hcFBhc3M7XHJcblxyXG4gICAgcG9zdHByb2Nlc3NUYXJnZXQhOiBHUFVUZXh0dXJlO1xyXG5cclxuICAgIHNldCBza3lib3godGV4dHVyZTogR1BVVGV4dHVyZSkge1xyXG4gICAgICAgIHRoaXMuZGVmZXJyZWRQYXNzLnNreWJveCA9IHRleHR1cmU7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgICAgICB0aGlzLnNreWJveFBhc3Muc2t5VGV4dHVyZSA9IHRoaXMuZGVmZXJyZWRQYXNzLnJhZGlhbmNlVmlldyE7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXHJcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgKSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHsgd2lkdGg6IHRoaXMuY2FudmFzLndpZHRoLCBoZWlnaHQ6IHRoaXMuY2FudmFzLmhlaWdodCB9O1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IENhbWVyYShzaXplKTtcclxuICAgICAgICB0aGlzLmdsb2JhbHMgPSBuZXcgR2xvYmFsVW5pZm9ybXModGhpcy5kZXZpY2UpO1xyXG4gICAgICAgIHRoaXMuZ2J1ZmZlciA9IG5ldyBHQnVmZmVyKGRldmljZSwgc2l6ZSk7XHJcbiAgICAgICAgdGhpcy5kZWZlcnJlZFBhc3MgPSBuZXcgRGVmZXJyZWRQYXNzKGRldmljZSwgdGhpcy5nbG9iYWxzLCB0aGlzLmdidWZmZXIsIFJlbmRlcmVyLnBvc3RQcm9jZXNzRm9ybWF0KTtcclxuXHJcbiAgICAgICAgdGhpcy5za3lib3hQYXNzID0gbmV3IFNreWJveFBhc3MoXHJcbiAgICAgICAgICAgIHRoaXMuZGV2aWNlLFxyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbHMsXHJcbiAgICAgICAgICAgIFJlbmRlcmVyLnBvc3RQcm9jZXNzRm9ybWF0LFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy50b25lbWFwUGFzcyA9IG5ldyBUb25lbWFwUGFzcyh0aGlzLmRldmljZSwgUmVuZGVyZXIub3V0cHV0Rm9ybWF0KTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdwdScpO1xyXG4gICAgICAgIGlmIChjb250ZXh0ID09IG51bGwpIHRocm93IG5ldyBFcnJvcigncmVuZGVyZXIgLS0gZ2l2ZW4gY2FudmFzIGFscmVhZHkgaW5pdGlhbGl6ZWQgdG8gbm9uLXdlYmdwdSBjb250ZXh0Jyk7XHJcblxyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgYXMgdW5rbm93biBhcyBHUFVDYW52YXNDb250ZXh0O1xyXG5cclxuICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlndXJlKHtcclxuICAgICAgICAgICAgZGV2aWNlOiB0aGlzLmRldmljZSxcclxuICAgICAgICAgICAgZm9ybWF0OiBSZW5kZXJlci5vdXRwdXRGb3JtYXQsXHJcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9TUkMsXHJcbiAgICAgICAgICAgIGFscGhhTW9kZTogJ29wYXF1ZScsXHJcbiAgICAgICAgICAgIGNvbG9yU3BhY2U6ICdzcmdiJyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVCYWNraW5ncyhzaXplKTtcclxuICAgICAgICB0aGlzLiNjcmVhdGVSZXNpemVPYnNlcnZlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBhc3luYyBDcmVhdGVJbml0aWFsaXplZChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogUHJvbWlzZTxSZW5kZXJlcj4ge1xyXG4gICAgICAgIGNvbnN0IGFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCk7XHJcbiAgICAgICAgaWYgKGFkYXB0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBpbml0aWFsaXplIEdQVS4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLFxyXG4gICAgICAgICAgICBtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixcclxuICAgICAgICAgICAgbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLFxyXG4gICAgICAgIH0gPSBhZGFwdGVyLmxpbWl0cztcclxuXHJcbiAgICAgICAgY29uc3QgZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKHtcclxuICAgICAgICAgICAgbGFiZWw6ICdtYWluIGxvZ2ljYWwgZGV2aWNlJyxcclxuICAgICAgICAgICAgcmVxdWlyZWRGZWF0dXJlczogUmVuZGVyZXIucmVxdWlyZWRGZWF0dXJlcyxcclxuICAgICAgICAgICAgcmVxdWlyZWRMaW1pdHM6IHtcclxuICAgICAgICAgICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCxcclxuICAgICAgICAgICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uLFxyXG4gICAgICAgICAgICAgICAgbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFJlbmRlcmVyKGNhbnZhcywgZGV2aWNlKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVCYWNraW5ncyhzaXplOiB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH0pIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQYXJhbXMoc2l6ZSk7XHJcbiAgICAgICAgdGhpcy5wb3N0cHJvY2Vzc1RhcmdldCA9IHRoaXMuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xyXG4gICAgICAgICAgICBkaW1lbnNpb246ICcyZCcsXHJcbiAgICAgICAgICAgIGZvcm1hdDogUmVuZGVyZXIucG9zdFByb2Nlc3NGb3JtYXQsXHJcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQgfCBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HLFxyXG4gICAgICAgICAgICBzaXplLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmNvbG9yQXR0YWNobWVudC52aWV3ID0gdGhpcy5wb3N0cHJvY2Vzc1RhcmdldC5jcmVhdGVWaWV3KCk7XHJcbiAgICAgICAgdGhpcy50b25lbWFwUGFzcy51cGRhdGVJbnB1dCh0aGlzLmNvbG9yQXR0YWNobWVudC52aWV3KTtcclxuICAgICAgICB0aGlzLmdidWZmZXIuc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgICAgICB0aGlzLnNreWJveFBhc3MuZGVwdGhUZXh0dXJlID0gdGhpcy5nYnVmZmVyLmRlcHRoLnZpZXchO1xyXG4gICAgfVxyXG5cclxuICAgICNjcmVhdGVSZXNpemVPYnNlcnZlcigpIHtcclxuICAgICAgICBjb25zdCByZXNpemVDYW52YXMgPSBkZWJvdW5jZSgocmF3V2lkdGg6IG51bWJlciwgcmF3SGVpZ2h0OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLm1pbihyYXdXaWR0aCB8IDAsIHRoaXMuZGV2aWNlLmxpbWl0cy5tYXhUZXh0dXJlRGltZW5zaW9uMkQpKTtcclxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4ocmF3SGVpZ2h0IHwgMCwgdGhpcy5kZXZpY2UubGltaXRzLm1heFRleHR1cmVEaW1lbnNpb24yRCkpO1xyXG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zID0geyB3aWR0aCwgaGVpZ2h0IH07XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVCYWNraW5ncyhkaW1lbnNpb25zKTtcclxuICAgICAgICB9LCAyMCk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbeyBpbmxpbmVTaXplLCBibG9ja1NpemUgfV0gPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTtcclxuICAgICAgICAgICAgICAgIHJlc2l6ZUNhbnZhcyhpbmxpbmVTaXplLCBibG9ja1NpemUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNhbnZhcywgeyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH0pO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBzdXBwb3J0IGRldmljZS1waXhlbC1jb250ZW50LWJveCwgc28gaXQgd291bGQgZmFpbCBpbnRvIHRoaXMuXHJcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbeyBpbmxpbmVTaXplLCBibG9ja1NpemUgfV0gPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uY29udGVudEJveFNpemU7XHJcbiAgICAgICAgICAgICAgICByZXNpemVDYW52YXMoaW5saW5lU2l6ZSAqIGRldmljZVBpeGVsUmF0aW8sIGJsb2NrU2l6ZSAqIGRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNhbnZhcywgeyBib3g6ICdjb250ZW50LWJveCcgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZEZvcndhcmRQYXNzKGZvcndhcmRQYXNzOiBGb3J3YXJkUGFzcykge1xyXG4gICAgICAgIGJpbmFyeUluc2VydCh0aGlzLmZvcndhcmRQYXNzZXMsIGZvcndhcmRQYXNzLCAoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmdsb2JhbHMudXBkYXRlRGV2aWNlQnVmZmVyKHRoaXMuZGV2aWNlLnF1ZXVlLCB0aGlzLmNhbWVyYSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2Rlcih7IGxhYmVsOiAnbWFpbiByZW5kZXIgZW5jb2RlcicgfSk7XHJcbiAgICAgICAgY29uc3QgZm9yd2FyZFBhc3NQYXJhbXMgPSB7IGVuY29kZXIsIGdsb2JhbHM6IHRoaXMuZ2xvYmFscywgZ2J1ZmZlcjogdGhpcy5nYnVmZmVyIH07XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgZm9yd2FyZFBhc3Mgb2YgdGhpcy5mb3J3YXJkUGFzc2VzKSB7XHJcbiAgICAgICAgICAgIGZvcndhcmRQYXNzLnJlbmRlcihmb3J3YXJkUGFzc1BhcmFtcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwYXNzID0gZW5jb2Rlci5iZWdpblJlbmRlclBhc3ModGhpcy5wYXNzRGVzY3JpcHRvcik7XHJcbiAgICAgICAgdGhpcy5kZWZlcnJlZFBhc3MucmVuZGVyKHBhc3MpO1xyXG4gICAgICAgIHRoaXMuc2t5Ym94UGFzcy5yZW5kZXIocGFzcyk7XHJcbiAgICAgICAgcGFzcy5lbmQoKTtcclxuXHJcbiAgICAgICAgdGhpcy50b25lbWFwUGFzcy5yZW5kZXIoZW5jb2RlciwgdGhpcy5jb250ZXh0LmdldEN1cnJlbnRUZXh0dXJlKCkpO1xyXG5cclxuICAgICAgICB0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW2VuY29kZXIuZmluaXNoKCldKTtcclxuICAgIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3980\n")},157:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBLDJFQUF5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0J4QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3NoYWRlcnMvYmxpdC12ZXJ0LnNoYWRlci50cz9hNTE4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC8qIHdnc2wgKi9gXHJcbiAgICBzdHJ1Y3QgVmVydE91dCB7XHJcbiAgICAgICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvczogdmVjNGYsXHJcbiAgICAgICAgQGxvY2F0aW9uKDApIHV2OiB2ZWMyZixcclxuICAgIH1cclxuXHJcbiAgICBAdmVydGV4XHJcbiAgICBmbiB2cyhAYnVpbHRpbih2ZXJ0ZXhfaW5kZXgpIGlkeDogdTMyKSAtPiBWZXJ0T3V0IHtcclxuICAgICAgICBjb25zdCBwb3MgPSBhcnJheShcclxuICAgICAgICAgICAgdmVjMmYoLTEsICAzKSxcclxuICAgICAgICAgICAgdmVjMmYoMywgLTEpLFxyXG4gICAgICAgICAgICB2ZWMyZigtMSwgLTEpLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyIHJlczogVmVydE91dDtcclxuICAgICAgICByZXMucG9zID0gdmVjNGYocG9zW2lkeF0sIDAuMCwgMS4wKTtcclxuICAgICAgICByZXMudXYgPSBwb3NbaWR4XSAqIHZlYzJmKDAuNSwgLTAuNSkgKyAwLjU7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuYDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///157\n")},6097:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* binding */ toWorldDir),\n/* harmony export */   X: () => (/* binding */ cubemapSampleConversions)\n/* harmony export */ });\nconst toWorldDir = /* wgsl */ `\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nconst cubemapSampleConversions = /* wgsl */ `\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA5Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTSxVQUFVLEdBQVcsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQzNDLENBQUM7QUFFRjs7R0FFRztBQUNJLE1BQU0sd0JBQXdCLEdBQVcsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThJekQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy9zaGFkZXJzL2N1YmVtYXAtc2FtcGxpbmcuc2hhZGVyLnRzPzZjOTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHRvV29ybGREaXI6IHN0cmluZyA9IC8qIHdnc2wgKi9gXG4gICAgZm4gdG9Xb3JsZERpcihjb29yZDogdmVjM3UsIHNpemU6IHUzMikgLT4gdmVjM2Yge1xuICAgICAgICBsZXQgdXYgPSAoMi4wIC8gZjMyKHNpemUpKSAqICh2ZWMyZihjb29yZC54eSkgKyAwLjUpIC0gMS4wO1xuXG4gICAgICAgIHZhciBwb3M6IHZlYzNmO1xuICAgICAgICBzd2l0Y2ggKGNvb3JkLnopIHtcbiAgICAgICAgICAgIGNhc2UgMCAgeyBwb3MgPSB2ZWMzKCAgMS4wLCAtdXYueSwgLXV2LngpOyB9XG4gICAgICAgICAgICBjYXNlIDEgIHsgcG9zID0gdmVjMyggLTEuMCwgLXV2LnksICB1di54KTsgfVxuICAgICAgICAgICAgY2FzZSAyICB7IHBvcyA9IHZlYzMoIHV2LngsICAgMS4wLCAgdXYueSk7IH1cbiAgICAgICAgICAgIGNhc2UgMyAgeyBwb3MgPSB2ZWMzKCB1di54LCAgLTEuMCwgLXV2LnkpOyB9XG4gICAgICAgICAgICBjYXNlIDQgIHsgcG9zID0gdmVjMyggdXYueCwgLXV2LnksICAgMS4wKTsgfVxuICAgICAgICAgICAgZGVmYXVsdCB7IHBvcyA9IHZlYzMoLXV2LngsIC11di55LCAgLTEuMCk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemUocG9zKTtcbiAgICB9XG5cbiAgICBmbiB0b1dvcmxkRGlyRjMyKGNvb3JkOiB2ZWMyZiwgZmFjZTogdTMyKSAtPiB2ZWMzZiB7XG4gICAgICAgIGxldCB1diA9IDIuMCAqIGNvb3JkIC0gMS4wO1xuXG4gICAgICAgIHZhciBwb3M6IHZlYzNmO1xuICAgICAgICBzd2l0Y2ggKGZhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgMCAgeyBwb3MgPSB2ZWMzKCAgMS4wLCAtdXYueSwgLXV2LngpOyB9XG4gICAgICAgICAgICBjYXNlIDEgIHsgcG9zID0gdmVjMyggLTEuMCwgLXV2LnksICB1di54KTsgfVxuICAgICAgICAgICAgY2FzZSAyICB7IHBvcyA9IHZlYzMoIHV2LngsICAgMS4wLCAgdXYueSk7IH1cbiAgICAgICAgICAgIGNhc2UgMyAgeyBwb3MgPSB2ZWMzKCB1di54LCAgLTEuMCwgLXV2LnkpOyB9XG4gICAgICAgICAgICBjYXNlIDQgIHsgcG9zID0gdmVjMyggdXYueCwgLXV2LnksICAgMS4wKTsgfVxuICAgICAgICAgICAgZGVmYXVsdCB7IHBvcyA9IHZlYzMoLXV2LngsIC11di55LCAgLTEuMCk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemUocG9zKTtcbiAgICB9XG5gO1xuXG4vKipcbiAqICBXR1NMIGZ1bmN0aW9ucyBmb3Igc2FtcGxpbmcgYWNyb3NzIGFkamFjZW50IGZhY2VzIG9mIGEgY3ViZW1hcFxuICovXG5leHBvcnQgY29uc3QgY3ViZW1hcFNhbXBsZUNvbnZlcnNpb25zOiBzdHJpbmcgPSAvKiB3Z3NsICovYFxuICAgIGNvbnN0IElOVkFMSURfRkFDRSA9IDY7XG4gICAgY29uc3QgSU5WQUxJRF9JRFggPSA0Mjk0OTY3Mjk1dTsgLy8gbWF4IHUzMlxuXG4gICAgZm4gY3ViZVNhbXBsZUNvb3JkKGNvb3JkOiB2ZWMzaSwgdzogdTMyKSAtPiB2ZWMzdSB7XG4gICAgICAgIC8vIGEgZmxhdHRlbmVkIG1hdHJpeCBvZiBkZXN0aW5hdGlvbiBmYWNlcyBiYXNlZCBvblxuICAgICAgICAvLyBzdGFydGluZyBmYWNlIGFuZCBkaXJlY3Rpb25cbiAgICAgICAgY29uc3QgZGZhY2VzID0gYXJyYXkoXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJICBVcCBEb3duIExlZnQgUmlnaHQgSW52YWxpZFxuICAgICAgICAgICAgMCwgMiwgMywgNCwgNSwgSU5WQUxJRF9GQUNFLCAvLyArWCAgK1kgICAtWSAgICtaICAgLVogICBcbiAgICAgICAgICAgIDEsIDIsIDMsIDUsIDQsIElOVkFMSURfRkFDRSwgLy8gLVggICtZICAgLVkgICAtWiAgICtaIFxuICAgICAgICAgICAgMiwgNSwgNCwgMSwgMCwgSU5WQUxJRF9GQUNFLCAvLyArWSAgLVogICArWiAgIC1YICAgK1ggXG4gICAgICAgICAgICAzLCA0LCA1LCAxLCAwLCBJTlZBTElEX0ZBQ0UsIC8vIC1ZICArWiAgIC1aICAgLVggICArWCBcbiAgICAgICAgICAgIDQsIDIsIDMsIDEsIDAsIElOVkFMSURfRkFDRSwgLy8gK1ogICtZICAgLVkgICAtWCAgICtYIFxuICAgICAgICAgICAgNSwgMiwgMywgMCwgMSwgSU5WQUxJRF9GQUNFLCAvLyAtWiAgK1kgICAtWSAgICtYICAgLVggXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYSBmbGF0dGVuZWQgbWF0cml4IGluIHRoZSBzYW1lIGZvcm0gYXMgZGZhY2VzXG4gICAgICAgIC8vIGdpdmluZyB0aGUgaW5kZXggb2YgdGhlIGRtYXQgYXJyYXkgY29udGFpbmluZyBcbiAgICAgICAgLy8gdGhlIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIHN0YXJ0aW5nIGZhY2UgdG8gXG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBmYWNlXG4gICAgICAgIGNvbnN0IGRpbmRpY2VzID0gYXJyYXkoXG4gICAgICAgICAgICAwLCAxLCAgMiwgIDMsICA0LCAgMCxcbiAgICAgICAgICAgIDAsIDUsICA2LCAgMywgIDQsICAwLFxuICAgICAgICAgICAgMCwgNywgIDgsICA5LCAgMTAsIDAsXG4gICAgICAgICAgICAwLCAxMSwgMTIsIDEzLCAxNCwgMCxcbiAgICAgICAgICAgIDAsIDExLCA4LCAgMywgIDQsICAwLFxuICAgICAgICAgICAgMCwgNywgIDEyLCAzLCAgNCwgIDAsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gMng0IG1hdHJpY2VzIHRyYW5zZm9ybWluZyBhIGNvb3JkaW5hdGUgdmVjdG9yIDx1LCB2LCB3LCAxPlxuICAgICAgICAvLyBmcm9tIG9uZSBmYWNlIHRvIGFub3RoZXJcbiAgICAgICAgY29uc3QgZG1hdHMgPSBhcnJheShcbiAgICAgICAgICAgIGFycmF5KC8vIDBcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDAsIDApLCAgIC8vIHUgPSB1XG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAwLCAwKSwgICAvLyB2ID0gdlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDEsIDApLCAgIC8vIHUgPSB2ICsgd1xuICAgICAgICAgICAgICAgIHZlYzQoLTEsIDAsIDEsIC0xKSwgLy8gdiA9IHcgLSB1IC0gMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDJcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAyLCAtMSksIC8vIHUgPSAydyAtIHYgLSAxXG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAwLCAwKSwgICAvLyB2ID0gdVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDNcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDEsIDApLCAgIC8vIHUgPSB1ICsgd1xuICAgICAgICAgICAgICAgIHZlYzQoMCwgMSwgMCwgMCksICAgLy8gdiA9IHZcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhcnJheSgvLyA0XG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAtMSwgMCksICAvLyB1ID0gdSAtIHdcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDAsIDApLCAgIC8vIHYgPSB2XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gNVxuICAgICAgICAgICAgICAgIHZlYzQoMCwgLTEsIDAsIC0xKSwgLy8gdSA9IC12IC0gMVxuICAgICAgICAgICAgICAgIHZlYzQoMSwgMCwgMCwgMCksICAgLy8gdiA9IHVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhcnJheSgvLyA2XG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAtMSwgMCksICAvLyB1ID0gdiAtIHdcbiAgICAgICAgICAgICAgICB2ZWM0KC0xLCAwLCAxLCAtMSksIC8vIHYgPSB3IC0gdSAtIDFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhcnJheSgvLyA3XG4gICAgICAgICAgICAgICAgdmVjNCgtMSwgMCwgMSwgLTEpLCAvLyB1ID0gdyAtIHUgLSAxXG4gICAgICAgICAgICAgICAgdmVjNCgwLCAtMSwgMCwgLTEpLCAvLyB2ID0gLXYgLSAxXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gOFxuICAgICAgICAgICAgICAgIHZlYzQoMSwgMCwgMCwgMCksICAgLy8gdSA9IHVcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIC0xLCAwKSwgIC8vIHYgPSB2IC0gd1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDlcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDAsIDApLCAgIC8vIHUgPSB2XG4gICAgICAgICAgICAgICAgdmVjNCgtMSwgMCwgMCwgLTEpLCAvLyB2ID0gLXUgLSAxXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gMTBcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAxLCAtMSksIC8vIHUgPSB3IC0gdiAtIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIC0xLCAwKSwgIC8vIHYgPSB1IC0gd1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDExXG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAwLCAwKSwgICAvLyB1ID0gdVxuICAgICAgICAgICAgICAgIHZlYzQoMCwgMSwgMSwgMCksICAgLy8gdiA9IHYgKyB3XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gMTJcbiAgICAgICAgICAgICAgICB2ZWM0KC0xLCAwLCAxLCAtMSksIC8vIHUgPSB3IC0gdSAtIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAyLCAtMSksIC8vIHYgPSAydyAtIHYgLSAxXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gMTNcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAxLCAtMSksIC8vIHUgPSB3IC0gdiAtIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDEsIDApLCAgIC8vIHYgPSB1ICsgd1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDE0XG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAwLCAwKSwgICAvLyB1ID0gdlxuICAgICAgICAgICAgICAgIHZlYzQoLTEsIDAsIDIsIC0xKSwgLy8gdiA9IDJ3IC0gdSAtIDFcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGl3ID0gaTMyKHcpO1xuXG4gICAgICAgIHZhciBkaXIgPSAwO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb29yZC55ID49IGl3ICogMiAtIDEgXG4gICAgICAgICAgICB8fCBjb29yZC55IDw9IC1pdyBcbiAgICAgICAgICAgIHx8IGNvb3JkLnggPj0gaXcgKiAyIC0gMSBcbiAgICAgICAgICAgIHx8IGNvb3JkLnggPD0gLWl3XG4gICAgICAgICkge1xuICAgICAgICAgICAgZGlyID0gNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb29yZC55IDwgMCkge1xuICAgICAgICAgICAgICAgIGRpciA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvb3JkLnkgPj0gaXcpIHtcbiAgICAgICAgICAgICAgICBkaXIgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvb3JkLnggPCAwKSB7XG4gICAgICAgICAgICAgICAgZGlyID0gc2VsZWN0KDUsIDMsIGRpciA9PSAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29vcmQueCA+PSBpdykge1xuICAgICAgICAgICAgICAgIGRpciA9IHNlbGVjdCg1LCA0LCBkaXIgPT0gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaWR4ID0gY29vcmQueiAqIDYgKyBkaXI7XG4gICAgICAgIGxldCBzYW1wID0gdmVjNChjb29yZC54eSwgaXcsIDEpO1xuICAgICAgICBsZXQgZG1hdCA9IGRtYXRzW2RpbmRpY2VzW2lkeF1dO1xuICAgICAgICByZXR1cm4gdmVjM3UodmVjMyhkb3QoZG1hdFswXSwgc2FtcCksIGRvdChkbWF0WzFdLCBzYW1wKSwgZGZhY2VzW2lkeF0pKTtcbiAgICB9XG5cbiAgICBmbiBjdWJlQ29vcmRUb0lkeChjb29yZDogdmVjM3UsIHc6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkLnggKyBjb29yZC55ICogdyArIGNvb3JkLnogKiB3ICogdztcbiAgICB9XG5cbiAgICBmbiBjdWJlSWR4VG9Db29yZChpZHg6IHUzMiwgdzogdTMyKSAtPiB2ZWMzdSB7XG4gICAgICAgIGxldCB3MiA9IHcgKiB3O1xuICAgICAgICBsZXQgZmlkeCA9IGlkeCAlIHcyO1xuICAgICAgICByZXR1cm4gdmVjM3UoZmlkeCAlIHcsIGZpZHggLyB3LCBpZHggLyB3Mik7XG4gICAgfVxuXG4gICAgZm4gY3ViZVNhbXBsZUlkeCh1dmY6IHZlYzNpLCB3OiB1MzIpIC0+IHUzMiB7XG4gICAgICAgIGxldCBjb29yZCA9IGN1YmVTYW1wbGVDb29yZCh1dmYsIHcpO1xuICAgICAgICByZXR1cm4gc2VsZWN0KFxuICAgICAgICAgICAgY3ViZUNvb3JkVG9JZHgoY29vcmQsIHcpLCBcbiAgICAgICAgICAgIElOVkFMSURfSURYLCBcbiAgICAgICAgICAgIGNvb3JkLnogPT0gSU5WQUxJRF9GQUNFLFxuICAgICAgICApO1xuICAgIH1cbmA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6097\n")},5752:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lr: () => (/* binding */ createAndCopyBuffer),\n/* harmony export */   gU: () => (/* binding */ textureToKTX)\n/* harmony export */ });\n/* unused harmony exports createAndCopyCubemap, ktx2ToTexture, textureToArrayBuffer */\nif (344 == __webpack_require__.j) {\n\t/* harmony import */ var ktx_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9253);\n}\n/* harmony import */ var _rendering_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3970);\nif (344 == __webpack_require__.j) {\n\t/* harmony import */ var _general__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4742);\n}\n\n\n\nfunction createAndCopyBuffer(arr, usage, device, label, alignment = 4) {\n    const pad = alignment - 1;\n    const buffer = device.createBuffer({\n        label,\n        usage,\n        size: (arr.byteLength + pad) & ~pad,\n        mappedAtCreation: true,\n    });\n    const writeArray = new Uint8Array(buffer.getMappedRange());\n    const readArray = arr instanceof ArrayBuffer\n        ? new Uint8Array(arr)\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n    writeArray.set(readArray);\n    buffer.unmap();\n    return buffer;\n}\nfunction createAndCopyCubemap(device, data, format, usage, label) {\n    const pixelSize = TextureFormatToSize[format];\n    if (pixelSize == null) {\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\n    }\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\n    const size = { width, height: width, depthOrArrayLayers: 6 };\n    const texture = device.createTexture({\n        usage: usage | GPUTextureUsage.COPY_DST,\n        label,\n        format,\n        size,\n    });\n    device.queue.writeTexture({ texture }, data, { bytesPerRow: width * pixelSize, rowsPerImage: width }, size);\n    return texture;\n}\nfunction ktx2ToTexture(buffer, device, options) {\n    const arr = new Uint8Array(buffer);\n    const ktx = ktxparse.read(arr);\n    const format = VkFormatToWebGPU[ktx.vkFormat];\n    if (format == null) {\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not covert to webgpu`);\n    }\n    const pixelSize = TextureFormatToSize[format];\n    if (pixelSize == null) {\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not get pixel byte size`);\n    }\n    const size = {\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        depthOrArrayLayers: ktx.faceCount,\n    };\n    const maxMipCount = Math.ceil(Math.log2(Math.max(size.width, size.height))) + 1;\n    let mipLevelCount = ktx.levels.length;\n    if (options?.mipLevelCount === 'max') {\n        mipLevelCount = maxMipCount;\n    }\n    else if (typeof options?.mipLevelCount === 'number') {\n        mipLevelCount = Math.min(maxMipCount, options.mipLevelCount);\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (options?.textureUsage)\n        usage |= options.textureUsage;\n    const texture = device.createTexture({\n        label: options?.label,\n        size,\n        mipLevelCount,\n        format,\n        usage,\n    });\n    const mipCopies = Math.min(ktx.levels.length, mipLevelCount) - 1;\n    for (let mipLevel = mipCopies; mipLevel >= 0; mipLevel -= 1) {\n        const width = size.width >> mipLevel;\n        const height = size.height >> mipLevel;\n        const { levelData } = ktx.levels[mipLevel];\n        const rawBytesPerRow = width * pixelSize;\n        const bytesPerRow = Math.max(rawBytesPerRow, 256);\n        const rowsPerImage = height;\n        const bytesPerImage = rowsPerImage * bytesPerRow;\n        let imageData = levelData;\n        if (bytesPerRow > rawBytesPerRow) {\n            imageData = new Uint8Array(bytesPerImage * texture.depthOrArrayLayers);\n            for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\n                for (let w = 0; w < rawBytesPerRow; w += 1) {\n                    imageData[w + h * bytesPerRow] = levelData[w + h * rawBytesPerRow];\n                }\n            }\n        }\n        const layerBatch = Math.min(Math.floor(device.limits.maxBufferSize / bytesPerImage), ktx.faceCount);\n        const layerCount = Math.ceil(ktx.faceCount / layerBatch);\n        for (let l = 0; l < layerCount; l += 1) {\n            const offset = l * layerBatch;\n            const count = Math.min(layerBatch, ktx.faceCount - offset);\n            const data = layerCount > 1\n                ? imageData.subarray(offset * bytesPerImage, (offset + count) * bytesPerImage)\n                : imageData;\n            device.queue.writeTexture({ mipLevel, texture, origin: [0, 0, offset] }, data, { bytesPerRow, rowsPerImage }, [width, height, count]);\n        }\n    }\n    return texture;\n}\nasync function textureToArrayBuffer({ device, texture, mipLevel = 0, returnBuffer, storageBuffer, resultBuffer, description, }) {\n    const pixelSize = _rendering_constants__WEBPACK_IMPORTED_MODULE_0__/* .TextureFormatToSize */ .T2[texture.format];\n    const fullDescription = (0,_general__WEBPACK_IMPORTED_MODULE_1__/* .padTemplate */ .OY) `[textureToKTX${description ?? ''}${texture.label}] --`;\n    if (pixelSize == null) {\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\n    }\n    const width = texture.width >> mipLevel;\n    const height = texture.height >> mipLevel;\n    const rawBytesPerRow = width * pixelSize;\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\n    const rowsPerImage = height;\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\n    }\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\n    }\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\n    }\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\n    const storage = storageBuffer ?? device.createBuffer({\n        label: `${fullDescription} storage buffer`,\n        size: byteSize,\n        usage: requiredUsage,\n    });\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\n    encoder.copyTextureToBuffer({ texture, mipLevel }, { buffer: storage, rowsPerImage, bytesPerRow }, { width, height, depthOrArrayLayers: texture.depthOrArrayLayers });\n    device.queue.submit([encoder.finish()]);\n    await Promise.all([\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\n        device.queue.onSubmittedWorkDone(),\n    ]);\n    const mapped = storage.getMappedRange(0, byteSize);\n    imageData.set(new Uint8Array(mapped));\n    storage.unmap();\n    if (bytesPerRow > rawBytesPerRow) {\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\n            }\n        }\n        imageData = imageData.slice(0, resultSize);\n    }\n    return {\n        imageData,\n        storageBuffer: returnBuffer ? storage : undefined,\n    };\n}\nasync function textureToKTX(device, texture, cube = false) {\n    const pixelSize = _rendering_constants__WEBPACK_IMPORTED_MODULE_0__/* .TextureFormatToSize */ .T2[texture.format];\n    const typeSize = _rendering_constants__WEBPACK_IMPORTED_MODULE_0__/* .TextureFormatToChannelSize */ .GE[texture.format];\n    if (pixelSize == null || typeSize == null) {\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\n    }\n    const container = new ktx_parse__WEBPACK_IMPORTED_MODULE_2__/* .KTX2Container */ .nYd();\n    container.pixelWidth = texture.width;\n    container.pixelHeight = texture.height;\n    container.vkFormat = _rendering_constants__WEBPACK_IMPORTED_MODULE_0__/* .WebGPUToVkFormat */ .KO[texture.format];\n    container.typeSize = typeSize;\n    delete container.keyValue.KTXswizzle;\n    const dataFormat = container.dataFormatDescriptor[0];\n    dataFormat.colorModel = ktx_parse__WEBPACK_IMPORTED_MODULE_2__/* .KHR_DF_MODEL_RGBSDA */ .Tre;\n    dataFormat.transferFunction = ktx_parse__WEBPACK_IMPORTED_MODULE_2__/* .KHR_DF_TRANSFER_LINEAR */ .T5j;\n    dataFormat.bytesPlane[0] = pixelSize;\n    dataFormat.samples = [0, 1, 2, 3].map((i) => ({\n        channelType: [192, 193, 194, 207][i],\n        samplePosition: [0, 0, 0, 0],\n        bitLength: container.typeSize * 8 - 1,\n        bitOffset: container.typeSize * 8 * i,\n        sampleLower: -1082130432,\n        sampleUpper: 1065353216,\n    }));\n    if (texture.dimension === '3d') {\n        container.faceCount = 1;\n        container.pixelDepth = texture.depthOrArrayLayers;\n    }\n    else if (cube) {\n        const cubeLayers = texture.depthOrArrayLayers / 6;\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\n        container.faceCount = 6;\n    }\n    else {\n        container.layerCount = texture.depthOrArrayLayers;\n        container.faceCount = 1;\n    }\n    let storageBuffer;\n    let imageData;\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\n        // eslint-disable-next-line no-await-in-loop\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\n            mipLevel: i,\n            returnBuffer: true,\n            device,\n            texture,\n            storageBuffer,\n        }));\n        container.levels.push({\n            levelData: imageData,\n            uncompressedByteLength: imageData.byteLength,\n        });\n    }\n    return ktx_parse__WEBPACK_IMPORTED_MODULE_2__/* .write */ .M98(container);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM7WUFDdkQsUUFBUSxFQUFFLENBQUM7WUFDWCxZQUFZLEVBQUUsSUFBSTtZQUNsQixNQUFNO1lBQ04sT0FBTztZQUNQLGFBQWE7U0FDaEIsQ0FBQyxDQUFDLENBQUM7UUFFSixTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztZQUNsQixTQUFTLEVBQUUsU0FBUztZQUNwQixzQkFBc0IsRUFBRSxTQUFTLENBQUMsVUFBVTtTQUMvQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsT0FBTyx1REFBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3JDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvdXRpbHMvZGF0YS1jb3B5LnRzP2JhNWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMga3R4cGFyc2UgZnJvbSAna3R4LXBhcnNlJztcclxuXHJcbmltcG9ydCB7IFZrRm9ybWF0VG9XZWJHUFUsIFRleHR1cmVGb3JtYXRUb1NpemUsIFRleHR1cmVGb3JtYXRUb0NoYW5uZWxTaXplLCBXZWJHUFVUb1ZrRm9ybWF0IH0gZnJvbSAnLi4vcmVuZGVyaW5nL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IHBhZFRlbXBsYXRlIH0gZnJvbSAnLi9nZW5lcmFsJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBbmRDb3B5QnVmZmVyKFxyXG4gICAgYXJyOiBBcnJheUJ1ZmZlciB8IFR5cGVkQXJyYXlMaWtlLFxyXG4gICAgdXNhZ2U6IEdQVUZsYWdzQ29uc3RhbnQsXHJcbiAgICBkZXZpY2U6IEdQVURldmljZSxcclxuICAgIGxhYmVsPzogc3RyaW5nLFxyXG4gICAgYWxpZ25tZW50ID0gNCxcclxuKTogR1BVQnVmZmVyIHtcclxuICAgIGNvbnN0IHBhZCA9IGFsaWdubWVudCAtIDE7XHJcbiAgICBjb25zdCBidWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcclxuICAgICAgICBsYWJlbCxcclxuICAgICAgICB1c2FnZSxcclxuICAgICAgICBzaXplOiAoYXJyLmJ5dGVMZW5ndGggKyBwYWQpICYgfnBhZCxcclxuICAgICAgICBtYXBwZWRBdENyZWF0aW9uOiB0cnVlLFxyXG4gICAgfSBhcyBHUFVCdWZmZXJEZXNjcmlwdG9yKTtcclxuXHJcbiAgICBjb25zdCB3cml0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpO1xyXG4gICAgY29uc3QgcmVhZEFycmF5ID0gYXJyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcclxuICAgICAgICA/IG5ldyBVaW50OEFycmF5KGFycilcclxuICAgICAgICA6IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XHJcblxyXG4gICAgd3JpdGVBcnJheS5zZXQocmVhZEFycmF5KTtcclxuICAgIGJ1ZmZlci51bm1hcCgpO1xyXG5cclxuICAgIHJldHVybiBidWZmZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBbmRDb3B5Q3ViZW1hcChcclxuICAgIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgZGF0YTogQXJyYXlCdWZmZXIsXHJcbiAgICBmb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXQsXHJcbiAgICB1c2FnZTogbnVtYmVyLFxyXG4gICAgbGFiZWw/OiBzdHJpbmcsXHJcbikge1xyXG4gICAgY29uc3QgcGl4ZWxTaXplID0gVGV4dHVyZUZvcm1hdFRvU2l6ZVtmb3JtYXRdO1xyXG4gICAgaWYgKHBpeGVsU2l6ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb3B5IGN1YmVtYXAgLS0gdW5zdXBwb3J0ZWQgZm9ybWF0OiAke2Zvcm1hdH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguc3FydChkYXRhLmJ5dGVMZW5ndGggLyAoNiAqIHBpeGVsU2l6ZSkpO1xyXG4gICAgY29uc3Qgc2l6ZSA9IHsgd2lkdGgsIGhlaWdodDogd2lkdGgsIGRlcHRoT3JBcnJheUxheWVyczogNiB9O1xyXG5cclxuICAgIGNvbnN0IHRleHR1cmUgPSBkZXZpY2UuY3JlYXRlVGV4dHVyZSh7XHJcbiAgICAgICAgdXNhZ2U6IHVzYWdlIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNULFxyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGZvcm1hdCxcclxuICAgICAgICBzaXplLFxyXG4gICAgfSk7XHJcblxyXG4gICAgZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZShcclxuICAgICAgICB7IHRleHR1cmUgfSxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIHsgYnl0ZXNQZXJSb3c6IHdpZHRoICogcGl4ZWxTaXplLCByb3dzUGVySW1hZ2U6IHdpZHRoIH0sXHJcbiAgICAgICAgc2l6ZSxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEtUWEltcG9ydE9wdGlvbnMgPSB7XHJcbiAgICBsYWJlbD86IHN0cmluZyxcclxuICAgIG1pcExldmVsQ291bnQ/OiBudW1iZXIgfCAnbWF4JyB8ICdkZWZhdWx0JyxcclxuICAgIHRleHR1cmVVc2FnZT86IG51bWJlcixcclxuICAgIHZhbGlkYXRlPzogYm9vbGVhbixcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBrdHgyVG9UZXh0dXJlKFxyXG4gICAgYnVmZmVyOiBBcnJheUJ1ZmZlcixcclxuICAgIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgb3B0aW9ucz86IEtUWEltcG9ydE9wdGlvbnMsXHJcbikge1xyXG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgIGNvbnN0IGt0eCA9IGt0eHBhcnNlLnJlYWQoYXJyKTtcclxuICAgIGNvbnN0IGZvcm1hdCA9IFZrRm9ybWF0VG9XZWJHUFVba3R4LnZrRm9ybWF0XTtcclxuXHJcbiAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGt0eCB0ZXh0dXJlIGltcG9ydCAtLSB1bnN1cHBvcnRlZCBmb3JtYXQ6ICR7a3R4LnZrRm9ybWF0fVxcblxcdENvdWxkIG5vdCBjb3ZlcnQgdG8gd2ViZ3B1YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGl4ZWxTaXplID0gVGV4dHVyZUZvcm1hdFRvU2l6ZVtmb3JtYXRdO1xyXG4gICAgaWYgKHBpeGVsU2l6ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBrdHggdGV4dHVyZSBpbXBvcnQgLS0gdW5zdXBwb3J0ZWQgZm9ybWF0OiAke2t0eC52a0Zvcm1hdH1cXG5cXHRDb3VsZCBub3QgZ2V0IHBpeGVsIGJ5dGUgc2l6ZWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNpemUgPSB7XHJcbiAgICAgICAgd2lkdGg6IGt0eC5waXhlbFdpZHRoLFxyXG4gICAgICAgIGhlaWdodDoga3R4LnBpeGVsSGVpZ2h0LFxyXG4gICAgICAgIGRlcHRoT3JBcnJheUxheWVyczoga3R4LmZhY2VDb3VudCxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgbWF4TWlwQ291bnQgPSBNYXRoLmNlaWwoTWF0aC5sb2cyKE1hdGgubWF4KHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KSkpICsgMTtcclxuICAgIGxldCBtaXBMZXZlbENvdW50ID0ga3R4LmxldmVscy5sZW5ndGg7XHJcbiAgICBpZiAob3B0aW9ucz8ubWlwTGV2ZWxDb3VudCA9PT0gJ21heCcpIHtcclxuICAgICAgICBtaXBMZXZlbENvdW50ID0gbWF4TWlwQ291bnQ7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zPy5taXBMZXZlbENvdW50ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIG1pcExldmVsQ291bnQgPSBNYXRoLm1pbihtYXhNaXBDb3VudCwgb3B0aW9ucy5taXBMZXZlbENvdW50KTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdXNhZ2UgPSBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUO1xyXG4gICAgaWYgKG9wdGlvbnM/LnRleHR1cmVVc2FnZSkgdXNhZ2UgfD0gb3B0aW9ucy50ZXh0dXJlVXNhZ2U7XHJcblxyXG4gICAgY29uc3QgdGV4dHVyZSA9IGRldmljZS5jcmVhdGVUZXh0dXJlKHtcclxuICAgICAgICBsYWJlbDogb3B0aW9ucz8ubGFiZWwsXHJcbiAgICAgICAgc2l6ZSxcclxuICAgICAgICBtaXBMZXZlbENvdW50LFxyXG4gICAgICAgIGZvcm1hdCxcclxuICAgICAgICB1c2FnZSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG1pcENvcGllcyA9IE1hdGgubWluKGt0eC5sZXZlbHMubGVuZ3RoLCBtaXBMZXZlbENvdW50KSAtIDE7XHJcblxyXG4gICAgZm9yIChsZXQgbWlwTGV2ZWwgPSBtaXBDb3BpZXM7IG1pcExldmVsID49IDA7IG1pcExldmVsIC09IDEpIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHNpemUud2lkdGggPj4gbWlwTGV2ZWw7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQgPj4gbWlwTGV2ZWw7XHJcbiAgICAgICAgY29uc3QgeyBsZXZlbERhdGEgfSA9IGt0eC5sZXZlbHNbbWlwTGV2ZWxdO1xyXG5cclxuICAgICAgICBjb25zdCByYXdCeXRlc1BlclJvdyA9IHdpZHRoICogcGl4ZWxTaXplO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVzUGVyUm93ID0gTWF0aC5tYXgocmF3Qnl0ZXNQZXJSb3csIDI1Nik7XHJcbiAgICAgICAgY29uc3Qgcm93c1BlckltYWdlID0gaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGJ5dGVzUGVySW1hZ2UgPSByb3dzUGVySW1hZ2UgKiBieXRlc1BlclJvdztcclxuXHJcbiAgICAgICAgbGV0IGltYWdlRGF0YSA9IGxldmVsRGF0YTtcclxuICAgICAgICBpZiAoYnl0ZXNQZXJSb3cgPiByYXdCeXRlc1BlclJvdykge1xyXG4gICAgICAgICAgICBpbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShieXRlc1BlckltYWdlICogdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnMpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCBoZWlnaHQgKiB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVyczsgaCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHJhd0J5dGVzUGVyUm93OyB3ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFbdyArIGggKiBieXRlc1BlclJvd10gPSBsZXZlbERhdGFbdyArIGggKiByYXdCeXRlc1BlclJvd107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGxheWVyQmF0Y2ggPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgTWF0aC5mbG9vcihkZXZpY2UubGltaXRzLm1heEJ1ZmZlclNpemUgLyBieXRlc1BlckltYWdlKSxcclxuICAgICAgICAgICAga3R4LmZhY2VDb3VudCxcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IGxheWVyQ291bnQgPSBNYXRoLmNlaWwoa3R4LmZhY2VDb3VudCAvIGxheWVyQmF0Y2gpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IGxheWVyQ291bnQ7IGwgKz0gMSkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBsICogbGF5ZXJCYXRjaDtcclxuICAgICAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihsYXllckJhdGNoLCBrdHguZmFjZUNvdW50IC0gb2Zmc2V0KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBsYXllckNvdW50ID4gMVxyXG4gICAgICAgICAgICAgICAgPyBpbWFnZURhdGEuc3ViYXJyYXkob2Zmc2V0ICogYnl0ZXNQZXJJbWFnZSwgKG9mZnNldCArIGNvdW50KSAqIGJ5dGVzUGVySW1hZ2UpXHJcbiAgICAgICAgICAgICAgICA6IGltYWdlRGF0YTtcclxuXHJcbiAgICAgICAgICAgIGRldmljZS5xdWV1ZS53cml0ZVRleHR1cmUoXHJcbiAgICAgICAgICAgICAgICB7IG1pcExldmVsLCB0ZXh0dXJlLCBvcmlnaW46IFswLCAwLCBvZmZzZXRdIH0sXHJcbiAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgeyBieXRlc1BlclJvdywgcm93c1BlckltYWdlIH0sXHJcbiAgICAgICAgICAgICAgICBbd2lkdGgsIGhlaWdodCwgY291bnRdLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVGV4dHVyZVRvQXJyYXlCdWZmZXJPcHRpb25zID0ge1xyXG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXHJcbiAgICB0ZXh0dXJlOiBHUFVUZXh0dXJlLFxyXG4gICAgbWlwTGV2ZWw/OiBudW1iZXIsXHJcbiAgICByZXN1bHRCdWZmZXI/OiBVaW50OEFycmF5LFxyXG4gICAgc3RvcmFnZUJ1ZmZlcj86IEdQVUJ1ZmZlcixcclxuICAgIHJldHVybkJ1ZmZlcj86IGJvb2xlYW4sXHJcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZyxcclxufTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0ZXh0dXJlVG9BcnJheUJ1ZmZlcihcclxuICAgIG9wdGlvbnM6IE9taXQ8VGV4dHVyZVRvQXJyYXlCdWZmZXJPcHRpb25zLCAncmV0dXJuQnVmZmVyJz4gJiB7IHJldHVybkJ1ZmZlcj86IGZhbHNlIH0sXHJcbik6IFByb21pc2U8eyBpbWFnZURhdGE6IFVpbnQ4QXJyYXkgfT47XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGV4dHVyZVRvQXJyYXlCdWZmZXIoXHJcbiAgICBvcHRpb25zOiBPbWl0PFRleHR1cmVUb0FycmF5QnVmZmVyT3B0aW9ucywgJ3JldHVybkJ1ZmZlcic+ICYgeyByZXR1cm5CdWZmZXI6IHRydWUgfSxcclxuKTogUHJvbWlzZTx7IGltYWdlRGF0YTogVWludDhBcnJheSwgc3RvcmFnZUJ1ZmZlcjogR1BVQnVmZmVyIH0+O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRleHR1cmVUb0FycmF5QnVmZmVyKHtcclxuICAgIGRldmljZSxcclxuICAgIHRleHR1cmUsXHJcbiAgICBtaXBMZXZlbCA9IDAsXHJcbiAgICByZXR1cm5CdWZmZXIsXHJcbiAgICBzdG9yYWdlQnVmZmVyLFxyXG4gICAgcmVzdWx0QnVmZmVyLFxyXG4gICAgZGVzY3JpcHRpb24sXHJcbn06IFRleHR1cmVUb0FycmF5QnVmZmVyT3B0aW9ucykge1xyXG4gICAgY29uc3QgcGl4ZWxTaXplID0gVGV4dHVyZUZvcm1hdFRvU2l6ZVt0ZXh0dXJlLmZvcm1hdF07XHJcbiAgICBjb25zdCBmdWxsRGVzY3JpcHRpb24gPSBwYWRUZW1wbGF0ZWBbdGV4dHVyZVRvS1RYJHtkZXNjcmlwdGlvbiA/PyAnJ30ke3RleHR1cmUubGFiZWx9XSAtLWA7XHJcblxyXG4gICAgaWYgKHBpeGVsU2l6ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bGxEZXNjcmlwdGlvbn0gZm9ybWF0ICR7dGV4dHVyZS5mb3JtYXR9IHVuc3VwcG9ydGVkYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgd2lkdGggPSB0ZXh0dXJlLndpZHRoID4+IG1pcExldmVsO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQgPj4gbWlwTGV2ZWw7XHJcbiAgICBjb25zdCByYXdCeXRlc1BlclJvdyA9IHdpZHRoICogcGl4ZWxTaXplO1xyXG4gICAgY29uc3QgYnl0ZXNQZXJSb3cgPSBNYXRoLm1heChyYXdCeXRlc1BlclJvdywgMjU2KTtcclxuICAgIGNvbnN0IHJvd3NQZXJJbWFnZSA9IGhlaWdodDtcclxuICAgIGNvbnN0IGJ5dGVTaXplID0gcm93c1BlckltYWdlICogYnl0ZXNQZXJSb3cgKiB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycztcclxuICAgIGNvbnN0IHJlc3VsdFNpemUgPSByYXdCeXRlc1BlclJvdyAqIGhlaWdodCAqIHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzO1xyXG5cclxuICAgIGlmIChyZXN1bHRCdWZmZXIgIT0gbnVsbCAmJiByZXN1bHRCdWZmZXIuYnl0ZUxlbmd0aCA8IGJ5dGVTaXplKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bGxEZXNjcmlwdGlvbn0gZ2l2ZW4gcmVzdWx0IGFycmF5IG5vdCBsYXJnZSBlbm91Z2guXHJcbiR7cmVzdWx0QnVmZmVyLmJ5dGVMZW5ndGh9IDwgJHtieXRlU2l6ZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RvcmFnZUJ1ZmZlciAhPSBudWxsICYmIHN0b3JhZ2VCdWZmZXIuc2l6ZSA8IGJ5dGVTaXplKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bGxEZXNjcmlwdGlvbn0gZ2l2ZW4gc3RvcmFnZSBidWZmZXIgbm90IGxhcmdlIGVub3VnaC5cclxuJHtzdG9yYWdlQnVmZmVyLnNpemV9IDwgJHtieXRlU2l6ZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXF1aXJlZFVzYWdlID0gR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfCBHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRDtcclxuXHJcbiAgICBpZiAoc3RvcmFnZUJ1ZmZlciAhPSBudWxsICYmIChzdG9yYWdlQnVmZmVyLnVzYWdlICYgcmVxdWlyZWRVc2FnZSkgIT09IHJlcXVpcmVkVXNhZ2UpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVsbERlc2NyaXB0aW9ufSBnaXZlbiBzdG9yYWdlIGRvZXMgbm90IGhhdmUgY29ycmVjdCB1c2FnZSBmbGFncy5cclxuR2l2ZW46ICR7c3RvcmFnZUJ1ZmZlci51c2FnZX1cclxuUmVxdWlyZWQ6ICR7cmVxdWlyZWRVc2FnZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaW1hZ2VEYXRhID0gcmVzdWx0QnVmZmVyID8/IG5ldyBVaW50OEFycmF5KGJ5dGVTaXplKTtcclxuICAgIGNvbnN0IHN0b3JhZ2UgPSBzdG9yYWdlQnVmZmVyID8/IGRldmljZS5jcmVhdGVCdWZmZXIoe1xyXG4gICAgICAgIGxhYmVsOiBgJHtmdWxsRGVzY3JpcHRpb259IHN0b3JhZ2UgYnVmZmVyYCxcclxuICAgICAgICBzaXplOiBieXRlU2l6ZSxcclxuICAgICAgICB1c2FnZTogcmVxdWlyZWRVc2FnZSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoeyBsYWJlbDogYCR7ZnVsbERlc2NyaXB0aW9ufSBlbmNvZGVyYCB9KTtcclxuICAgIGVuY29kZXIuY29weVRleHR1cmVUb0J1ZmZlcihcclxuICAgICAgICB7IHRleHR1cmUsIG1pcExldmVsIH0sXHJcbiAgICAgICAgeyBidWZmZXI6IHN0b3JhZ2UsIHJvd3NQZXJJbWFnZSwgYnl0ZXNQZXJSb3cgfSxcclxuICAgICAgICB7IHdpZHRoLCBoZWlnaHQsIGRlcHRoT3JBcnJheUxheWVyczogdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnMgfSxcclxuICAgICk7XHJcbiAgICBkZXZpY2UucXVldWUuc3VibWl0KFtlbmNvZGVyLmZpbmlzaCgpXSk7XHJcblxyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgIHN0b3JhZ2UubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFELCAwLCBieXRlU2l6ZSksXHJcbiAgICAgICAgZGV2aWNlLnF1ZXVlLm9uU3VibWl0dGVkV29ya0RvbmUoKSxcclxuICAgIF0pO1xyXG5cclxuICAgIGNvbnN0IG1hcHBlZCA9IHN0b3JhZ2UuZ2V0TWFwcGVkUmFuZ2UoMCwgYnl0ZVNpemUpO1xyXG4gICAgaW1hZ2VEYXRhLnNldChuZXcgVWludDhBcnJheShtYXBwZWQpKTtcclxuICAgIHN0b3JhZ2UudW5tYXAoKTtcclxuXHJcbiAgICBpZiAoYnl0ZXNQZXJSb3cgPiByYXdCeXRlc1BlclJvdykge1xyXG4gICAgICAgIGZvciAobGV0IGggPSAwOyBoIDwgaGVpZ2h0ICogdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnM7IGggKz0gMSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHJhd0J5dGVzUGVyUm93OyB3ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGltYWdlRGF0YVt3ICsgaCAqIHJhd0J5dGVzUGVyUm93XSA9IGltYWdlRGF0YVt3ICsgaCAqIGJ5dGVzUGVyUm93XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpbWFnZURhdGEgPSBpbWFnZURhdGEuc2xpY2UoMCwgcmVzdWx0U2l6ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbWFnZURhdGEsXHJcbiAgICAgICAgc3RvcmFnZUJ1ZmZlcjogcmV0dXJuQnVmZmVyID8gc3RvcmFnZSA6IHVuZGVmaW5lZCxcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0ZXh0dXJlVG9LVFgoZGV2aWNlOiBHUFVEZXZpY2UsIHRleHR1cmU6IEdQVVRleHR1cmUsIGN1YmUgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcGl4ZWxTaXplID0gVGV4dHVyZUZvcm1hdFRvU2l6ZVt0ZXh0dXJlLmZvcm1hdF07XHJcbiAgICBjb25zdCB0eXBlU2l6ZSA9IFRleHR1cmVGb3JtYXRUb0NoYW5uZWxTaXplW3RleHR1cmUuZm9ybWF0XTtcclxuXHJcbiAgICBpZiAocGl4ZWxTaXplID09IG51bGwgfHwgdHlwZVNpemUgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdGV4dHVyZVRvS1RYIC0tIGZvcm1hdCAke3RleHR1cmUuZm9ybWF0fSBvZiAke3RleHR1cmUubGFiZWx9IHVuc3VwcG9ydGVkYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IGt0eHBhcnNlLktUWDJDb250YWluZXIoKTtcclxuICAgIGNvbnRhaW5lci5waXhlbFdpZHRoID0gdGV4dHVyZS53aWR0aDtcclxuICAgIGNvbnRhaW5lci5waXhlbEhlaWdodCA9IHRleHR1cmUuaGVpZ2h0O1xyXG4gICAgY29udGFpbmVyLnZrRm9ybWF0ID0gV2ViR1BVVG9Wa0Zvcm1hdFt0ZXh0dXJlLmZvcm1hdF07XHJcbiAgICBjb250YWluZXIudHlwZVNpemUgPSB0eXBlU2l6ZTtcclxuICAgIGRlbGV0ZSBjb250YWluZXIua2V5VmFsdWUuS1RYc3dpenpsZTtcclxuXHJcbiAgICBjb25zdCBkYXRhRm9ybWF0ID0gY29udGFpbmVyLmRhdGFGb3JtYXREZXNjcmlwdG9yWzBdO1xyXG4gICAgZGF0YUZvcm1hdC5jb2xvck1vZGVsID0ga3R4cGFyc2UuS0hSX0RGX01PREVMX1JHQlNEQTtcclxuICAgIGRhdGFGb3JtYXQudHJhbnNmZXJGdW5jdGlvbiA9IGt0eHBhcnNlLktIUl9ERl9UUkFOU0ZFUl9MSU5FQVI7XHJcbiAgICBkYXRhRm9ybWF0LmJ5dGVzUGxhbmVbMF0gPSBwaXhlbFNpemU7XHJcblxyXG4gICAgZGF0YUZvcm1hdC5zYW1wbGVzID0gWzAsIDEsIDIsIDNdLm1hcCgoaSkgPT4gKHtcclxuICAgICAgICBjaGFubmVsVHlwZTogWzE5MiwgMTkzLCAxOTQsIDIwN11baV0sXHJcbiAgICAgICAgc2FtcGxlUG9zaXRpb246IFswLCAwLCAwLCAwXSxcclxuICAgICAgICBiaXRMZW5ndGg6IGNvbnRhaW5lci50eXBlU2l6ZSAqIDggLSAxLFxyXG4gICAgICAgIGJpdE9mZnNldDogY29udGFpbmVyLnR5cGVTaXplICogOCAqIGksXHJcbiAgICAgICAgc2FtcGxlTG93ZXI6IC0xMDgyMTMwNDMyLFxyXG4gICAgICAgIHNhbXBsZVVwcGVyOiAxMDY1MzUzMjE2LFxyXG4gICAgfSkpO1xyXG5cclxuICAgIGlmICh0ZXh0dXJlLmRpbWVuc2lvbiA9PT0gJzNkJykge1xyXG4gICAgICAgIGNvbnRhaW5lci5mYWNlQ291bnQgPSAxO1xyXG4gICAgICAgIGNvbnRhaW5lci5waXhlbERlcHRoID0gdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnM7XHJcbiAgICB9IGVsc2UgaWYgKGN1YmUpIHtcclxuICAgICAgICBjb25zdCBjdWJlTGF5ZXJzID0gdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnMgLyA2O1xyXG4gICAgICAgIGNvbnRhaW5lci5sYXllckNvdW50ID0gY3ViZUxheWVycyA9PT0gMSA/IDAgOiBjdWJlTGF5ZXJzO1xyXG4gICAgICAgIGNvbnRhaW5lci5mYWNlQ291bnQgPSA2O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb250YWluZXIubGF5ZXJDb3VudCA9IHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzO1xyXG4gICAgICAgIGNvbnRhaW5lci5mYWNlQ291bnQgPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzdG9yYWdlQnVmZmVyOiBHUFVCdWZmZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBsZXQgaW1hZ2VEYXRhOiBVaW50OEFycmF5O1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dHVyZS5taXBMZXZlbENvdW50OyBpICs9IDEpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxyXG4gICAgICAgICh7IGltYWdlRGF0YSwgc3RvcmFnZUJ1ZmZlciB9ID0gYXdhaXQgdGV4dHVyZVRvQXJyYXlCdWZmZXIoe1xyXG4gICAgICAgICAgICBtaXBMZXZlbDogaSxcclxuICAgICAgICAgICAgcmV0dXJuQnVmZmVyOiB0cnVlLFxyXG4gICAgICAgICAgICBkZXZpY2UsXHJcbiAgICAgICAgICAgIHRleHR1cmUsXHJcbiAgICAgICAgICAgIHN0b3JhZ2VCdWZmZXIsXHJcbiAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICBjb250YWluZXIubGV2ZWxzLnB1c2goe1xyXG4gICAgICAgICAgICBsZXZlbERhdGE6IGltYWdlRGF0YSxcclxuICAgICAgICAgICAgdW5jb21wcmVzc2VkQnl0ZUxlbmd0aDogaW1hZ2VEYXRhLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGt0eHBhcnNlLndyaXRlKGNvbnRhaW5lcik7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5752\n")}}]);