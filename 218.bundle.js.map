{"version":3,"file":"218.bundle.js","mappings":"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","sources":["webpack://cbunt-portfolio/./src/rendering/core/constants.ts","webpack://cbunt-portfolio/./src/rendering/samples/cubemap-blur/cubemap-blur-sample.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-copy.ts","webpack://cbunt-portfolio/./src/rendering/utils/texture-importing.ts","webpack://cbunt-portfolio/./src/rendering/utils/texture-processing.ts","webpack://cbunt-portfolio/./src/utils/general.ts"],"sourcesContent":["import * as ktxp from 'ktx-parse';\r\n\r\nexport const TypeSizes = {\r\n    mat4x4Count: 16,\r\n    sizeofMat4x4f: 16 * Float32Array.BYTES_PER_ELEMENT,\r\n};\r\n\r\nexport const VkFormatToWebGPU: Record<number, GPUTextureFormat | undefined> = {\r\n    // 8-bit formats\r\n    [ktxp.VK_FORMAT_R8_UNORM]: 'r8unorm',\r\n    [ktxp.VK_FORMAT_R8_SNORM]: 'r8snorm',\r\n    [ktxp.VK_FORMAT_R8_UINT]: 'r8uint',\r\n    [ktxp.VK_FORMAT_R8_SINT]: 'r8sint',\r\n    // 16-bit formats\r\n    [ktxp.VK_FORMAT_R16_UINT]: 'r16uint',\r\n    [ktxp.VK_FORMAT_R16_SINT]: 'r16sint',\r\n    [ktxp.VK_FORMAT_R16_SFLOAT]: 'r16float',\r\n    [ktxp.VK_FORMAT_R8G8_UNORM]: 'rg8unorm',\r\n    [ktxp.VK_FORMAT_R8G8_SNORM]: 'rg8snorm',\r\n    [ktxp.VK_FORMAT_R8G8_UINT]: 'rg8uint',\r\n    [ktxp.VK_FORMAT_R8G8_SINT]: 'rg8sint',\r\n    // 32-bit formats\r\n    [ktxp.VK_FORMAT_R32_UINT]: 'r32uint',\r\n    [ktxp.VK_FORMAT_R32_SINT]: 'r32sint',\r\n    [ktxp.VK_FORMAT_R32_SFLOAT]: 'r32float',\r\n    [ktxp.VK_FORMAT_R16G16_UINT]: 'rg16uint',\r\n    [ktxp.VK_FORMAT_R16G16_SINT]: 'rg16sint',\r\n    [ktxp.VK_FORMAT_R16G16_SFLOAT]: 'rg16float',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UNORM]: 'rgba8unorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SRGB]: 'rgba8unorm-srgb',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SNORM]: 'rgba8snorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UINT]: 'rgba8uint',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SINT]: 'rgba8sint',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_UNORM]: 'bgra8unorm',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_SRGB]: 'bgra8unorm-srgb',\r\n    // Packed 32-bit formats\r\n    [ktxp.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32]: 'rgb9e5ufloat',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UINT_PACK32]: 'rgb10a2uint',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UNORM_PACK32]: 'rgb10a2unorm',\r\n    [ktxp.VK_FORMAT_B10G11R11_UFLOAT_PACK32]: 'rg11b10ufloat',\r\n    // 64-bit formats\r\n    [ktxp.VK_FORMAT_R32G32_UINT]: 'rg32uint',\r\n    [ktxp.VK_FORMAT_R32G32_SINT]: 'rg32sint',\r\n    [ktxp.VK_FORMAT_R32G32_SFLOAT]: 'rg32float',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_UINT]: 'rgba16uint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SINT]: 'rgba16sint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SFLOAT]: 'rgba16float',\r\n    // 128-bit formats\r\n    [ktxp.VK_FORMAT_R32G32B32A32_UINT]: 'rgba32uint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SINT]: 'rgba32sint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SFLOAT]: 'rgba32float',\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    [ktxp.VK_FORMAT_BC1_RGBA_UNORM_BLOCK]: 'bc1-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC1_RGBA_SRGB_BLOCK]: 'bc1-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC2_UNORM_BLOCK]: 'bc2-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC2_SRGB_BLOCK]: 'bc2-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC3_UNORM_BLOCK]: 'bc3-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC3_SRGB_BLOCK]: 'bc3-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC4_UNORM_BLOCK]: 'bc4-r-unorm',\r\n    [ktxp.VK_FORMAT_BC4_SNORM_BLOCK]: 'bc4-r-snorm',\r\n    [ktxp.VK_FORMAT_BC5_UNORM_BLOCK]: 'bc5-rg-unorm',\r\n    [ktxp.VK_FORMAT_BC5_SNORM_BLOCK]: 'bc5-rg-snorm',\r\n    [ktxp.VK_FORMAT_BC6H_UFLOAT_BLOCK]: 'bc6h-rgb-ufloat',\r\n    [ktxp.VK_FORMAT_BC6H_SFLOAT_BLOCK]: 'bc6h-rgb-float',\r\n    [ktxp.VK_FORMAT_BC7_UNORM_BLOCK]: 'bc7-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC7_SRGB_BLOCK]: 'bc7-rgba-unorm-srgb',\r\n    // Currently unsupported extension formats:\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"etc2-rgb8unorm\",\r\n    // \"etc2-rgb8unorm-srgb\",\r\n    // \"etc2-rgb8a1unorm\",\r\n    // \"etc2-rgb8a1unorm-srgb\",\r\n    // \"etc2-rgba8unorm\",\r\n    // \"etc2-rgba8unorm-srgb\",\r\n    // \"eac-r11unorm\",\r\n    // \"eac-r11snorm\",\r\n    // \"eac-rg11unorm\",\r\n    // \"eac-rg11snorm\",\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"astc-4x4-unorm\",\r\n    // \"astc-4x4-unorm-srgb\",\r\n    // \"astc-5x4-unorm\",\r\n    // \"astc-5x4-unorm-srgb\",\r\n    // \"astc-5x5-unorm\",\r\n    // \"astc-5x5-unorm-srgb\",\r\n    // \"astc-6x5-unorm\",\r\n    // \"astc-6x5-unorm-srgb\",\r\n    // \"astc-6x6-unorm\",\r\n    // \"astc-6x6-unorm-srgb\",\r\n    // \"astc-8x5-unorm\",\r\n    // \"astc-8x5-unorm-srgb\",\r\n    // \"astc-8x6-unorm\",\r\n    // \"astc-8x6-unorm-srgb\",\r\n    // \"astc-8x8-unorm\",\r\n    // \"astc-8x8-unorm-srgb\",\r\n    // \"astc-10x5-unorm\",\r\n    // \"astc-10x5-unorm-srgb\",\r\n    // \"astc-10x6-unorm\",\r\n    // \"astc-10x6-unorm-srgb\",\r\n    // \"astc-10x8-unorm\",\r\n    // \"astc-10x8-unorm-srgb\",\r\n    // \"astc-10x10-unorm\",\r\n    // \"astc-10x10-unorm-srgb\",\r\n    // \"astc-12x10-unorm\",\r\n    // \"astc-12x10-unorm-srgb\",\r\n    // \"astc-12x12-unorm\",\r\n};\r\n\r\nexport const TextureFormatToSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 2,\r\n    rg8snorm: 2,\r\n    rg8uint: 2,\r\n    rg8sint: 2,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 4,\r\n    rg16sint: 4,\r\n    rg16float: 4,\r\n    rgba8unorm: 4,\r\n    'rgba8unorm-srgb': 4,\r\n    rgba8snorm: 4,\r\n    rgba8uint: 4,\r\n    rgba8sint: 4,\r\n    bgra8unorm: 4,\r\n    'bgra8unorm-srgb': 4,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 8,\r\n    rg32sint: 8,\r\n    rg32float: 8,\r\n    rgba16uint: 8,\r\n    rgba16sint: 8,\r\n    rgba16float: 8,\r\n    // 128-bit formats\r\n    rgba32uint: 16,\r\n    rgba32sint: 16,\r\n    rgba32float: 16,\r\n};\r\n\r\nexport const TextureFormatToChannelSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 1,\r\n    rg8snorm: 1,\r\n    rg8uint: 1,\r\n    rg8sint: 1,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 2,\r\n    rg16sint: 2,\r\n    rg16float: 2,\r\n    rgba8unorm: 1,\r\n    'rgba8unorm-srgb': 1,\r\n    rgba8snorm: 1,\r\n    rgba8uint: 1,\r\n    rgba8sint: 1,\r\n    bgra8unorm: 1,\r\n    'bgra8unorm-srgb': 1,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 4,\r\n    rg32sint: 4,\r\n    rg32float: 4,\r\n    rgba16uint: 2,\r\n    rgba16sint: 2,\r\n    rgba16float: 2,\r\n    // 128-bit formats\r\n    rgba32uint: 4,\r\n    rgba32sint: 4,\r\n    rgba32float: 4,\r\n};\r\n\r\nexport const WebGPUToVkFormat = Object.fromEntries(\r\n    Object.entries(VkFormatToWebGPU).map(([vk, wgpu]) => [wgpu, parseInt(vk, 10)]),\r\n) as Record<GPUTextureFormat, ktxp.VKFormat>;\r\n\r\nexport const textureTypeToDimension: Record<string, GPUTextureViewDimension> = {\r\n    texture_cube: 'cube',\r\n    texture_3d: '3d',\r\n    texture_2d: '2d',\r\n};\r\n","import { showSaveFilePicker } from 'native-file-system-adapter';\n\nimport getSkyboxOptions from '../settings/skybox-options';\nimport { RenderModel } from '../settings/sample-spec';\nimport propertyListener, { ListenerSyms } from '../settings/property-listener';\n\nimport { textureToKTX } from '../../utils/data-copy';\nimport Renderer, { ForwardPassParams } from '../../core/renderer';\n\nimport cubemapGuassianPyramid from './cubemap-guassian-pyramid';\n\nenum BlurState { IDLE, BLUR, WAIT }\n\nexport default class CubemapBlurModel implements RenderModel {\n    skybox?: GPUTexture;\n    state: BlurState = BlurState.IDLE;\n\n    readonly #settings = propertyListener({\n        nearestSample: {\n            [ListenerSyms.$type]: 'checkbox' as const,\n            [ListenerSyms.$callback]: (val: unknown) => {\n                if (typeof val === 'boolean') this.renderer.skyboxPass.useNearestSample = val;\n            },\n            value: false,\n            description: 'Disables linear sampling in the viewer.',\n        },\n        mipLevel: {\n            [ListenerSyms.$type]: 'slider' as const,\n            [ListenerSyms.$callback]: (value: unknown) => {\n                if (typeof value === 'number') this.renderer.skyboxPass.mipLevel = value;\n            },\n            value: 0,\n            min: 0,\n            max: 1,\n            step: 0.1,\n            description: 'The mip level to display in the viewer. 0 is the original image, max is completely blurred with 1 pixel faces.',\n        },\n        filterDistance: {\n            [ListenerSyms.$type]: 'slider' as const,\n            [ListenerSyms.$callback]: this.reblur.bind(this) as () => void,\n            value: 8,\n            max: 64,\n            min: 0,\n            step: 0.1,\n            description: 'The number of pixels to blur from.',\n        },\n        skybox: getSkyboxOptions(this),\n        'Download Result': {\n            [ListenerSyms.$type]: 'button' as const,\n            onClick: () => { void this.saveFile(); },\n        },\n    });\n\n    readonly settings = this.#settings.publicSettings;\n    readonly priority = 0;\n    device: GPUDevice;\n\n    constructor(public renderer: Renderer) {\n        renderer.addForwardPass(this);\n        this.device = renderer.device;\n    }\n\n    setSkybox(skybox: GPUTexture) {\n        this.skybox = skybox;\n        this.#settings.privateSettings.mipLevel.max = this.skybox.mipLevelCount - 1;\n        this.#settings.privateSettings.mipLevel.value = 1;\n        this.renderer.skyboxPass.mipLevel = 1;\n\n        this.refresh();\n        void this.reblur();\n    }\n\n    resolve() {\n        this.refresh();\n        const lastState = this.state;\n        this.state = BlurState.IDLE;\n        if (lastState === BlurState.WAIT) void this.reblur();\n    }\n\n    async reblur() {\n        if (this.skybox == null || this.state === BlurState.WAIT) return;\n\n        if (this.state === BlurState.BLUR) {\n            this.state = BlurState.WAIT;\n            return;\n        }\n\n        this.state = BlurState.BLUR;\n\n        await cubemapGuassianPyramid({\n            device: this.renderer.device,\n            texture: this.skybox,\n            steps: this.settings.filterDistance.value,\n            inPlace: true,\n            delayWork: requestAnimationFrame,\n        });\n\n        this.resolve();\n    }\n\n    refresh() {\n        if (this.skybox == null) return;\n        this.renderer.skyboxPass.skyTexture = this.skybox.createView({ dimension: 'cube' });\n    }\n\n    async saveFile() {\n        if (this.skybox == null) return;\n        try {\n            const proms = Promise.all([\n                textureToKTX(this.renderer.device, this.skybox, true)\n                    .then((ktx2) => new Blob([ktx2], { type: 'image/ktx2' })),\n                showSaveFilePicker({\n                    types: [{ accept: { 'image/ktx2': ['.ktx2'] } }],\n                    suggestedName: 'blurred-skybox.ktx2',\n                }).then((handle) => handle.createWritable({ keepExistingData: false })),\n            ]);\n\n            const [blob, stream] = await proms;\n            await blob.stream().pipeTo(stream);\n        } catch (e) {\n            console.warn(e);\n        }\n    }\n\n    render({ encoder, gbuffer }: ForwardPassParams) {\n        encoder.beginRenderPass({\n            colorAttachments: [],\n            depthStencilAttachment: {\n                depthClearValue: 1,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n                view: gbuffer.depth.view,\n            },\n        }).end();\n    }\n}\n","import * as ktxparse from 'ktx-parse';\r\n\r\nimport { TextureFormatToSize, TextureFormatToChannelSize, WebGPUToVkFormat } from '../core/constants';\r\nimport { mapRange, padTemplate } from '../../utils/general';\r\n\r\nexport function createAndCopyBuffer(\r\n    arr: ArrayBuffer | ArrayBufferView,\r\n    usage: GPUFlagsConstant,\r\n    device: GPUDevice,\r\n    label?: string,\r\n    alignment = 4,\r\n): GPUBuffer {\r\n    const pad = alignment - 1;\r\n    const buffer = device.createBuffer({\r\n        label,\r\n        usage,\r\n        size: (arr.byteLength + pad) & ~pad,\r\n        mappedAtCreation: true,\r\n    } as GPUBufferDescriptor);\r\n\r\n    const writeArray = new Uint8Array(buffer.getMappedRange());\r\n    const readArray = arr instanceof ArrayBuffer\r\n        ? new Uint8Array(arr)\r\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n\r\n    writeArray.set(readArray);\r\n    buffer.unmap();\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function createAndCopyCubemap(\r\n    device: GPUDevice,\r\n    data: ArrayBuffer,\r\n    format: GPUTextureFormat,\r\n    usage: number,\r\n    label?: string,\r\n) {\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\r\n    }\r\n\r\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\r\n    const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n    const texture = device.createTexture({\r\n        usage: usage | GPUTextureUsage.COPY_DST,\r\n        label,\r\n        format,\r\n        size,\r\n    });\r\n\r\n    device.queue.writeTexture(\r\n        { texture },\r\n        data,\r\n        { bytesPerRow: width * pixelSize, rowsPerImage: width },\r\n        size,\r\n    );\r\n\r\n    return texture;\r\n}\r\n\r\nexport type TextureToArrayBufferOptions = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    mipLevel?: number,\r\n    resultBuffer?: Uint8Array,\r\n    storageBuffer?: GPUBuffer,\r\n    returnBuffer?: boolean,\r\n    description?: string,\r\n};\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer?: false },\r\n): Promise<{ imageData: Uint8Array }>;\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer: true },\r\n): Promise<{ imageData: Uint8Array, storageBuffer: GPUBuffer }>;\r\n\r\nexport async function textureToArrayBuffer({\r\n    device,\r\n    texture,\r\n    mipLevel = 0,\r\n    returnBuffer,\r\n    storageBuffer,\r\n    resultBuffer,\r\n    description,\r\n}: TextureToArrayBufferOptions) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const fullDescription = padTemplate`[textureToKTX${description ?? ''}${texture.label}] --`;\r\n\r\n    if (pixelSize == null) {\r\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\r\n    }\r\n\r\n    const width = texture.width >> mipLevel;\r\n    const height = texture.height >> mipLevel;\r\n    const rawBytesPerRow = width * pixelSize;\r\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n    const rowsPerImage = height;\r\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\r\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\r\n\r\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\r\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\r\n    }\r\n\r\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\r\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\r\n    }\r\n\r\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\r\n\r\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\r\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\r\n    }\r\n\r\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\r\n    const storage = storageBuffer ?? device.createBuffer({\r\n        label: `${fullDescription} storage buffer`,\r\n        size: byteSize,\r\n        usage: requiredUsage,\r\n    });\r\n\r\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\r\n    encoder.copyTextureToBuffer(\r\n        { texture, mipLevel },\r\n        { buffer: storage, rowsPerImage, bytesPerRow },\r\n        { width, height, depthOrArrayLayers: texture.depthOrArrayLayers },\r\n    );\r\n    device.queue.submit([encoder.finish()]);\r\n\r\n    await Promise.all([\r\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\r\n        device.queue.onSubmittedWorkDone(),\r\n    ]);\r\n\r\n    const mapped = storage.getMappedRange(0, byteSize);\r\n    imageData.set(new Uint8Array(mapped));\r\n    storage.unmap();\r\n\r\n    if (bytesPerRow > rawBytesPerRow) {\r\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\r\n            }\r\n        }\r\n        imageData = imageData.slice(0, resultSize);\r\n    }\r\n\r\n    return {\r\n        imageData,\r\n        storageBuffer: returnBuffer ? storage : undefined,\r\n    };\r\n}\r\n\r\nexport async function textureToKTX(device: GPUDevice, texture: GPUTexture, cube = false) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const typeSize = TextureFormatToChannelSize[texture.format];\r\n\r\n    if (pixelSize == null || typeSize == null) {\r\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\r\n    }\r\n\r\n    const container = new ktxparse.KTX2Container();\r\n    container.pixelWidth = texture.width;\r\n    container.pixelHeight = texture.height;\r\n    container.vkFormat = WebGPUToVkFormat[texture.format];\r\n    container.typeSize = typeSize;\r\n    delete container.keyValue.KTXswizzle;\r\n\r\n    const dataFormat = container.dataFormatDescriptor[0];\r\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\r\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\r\n    dataFormat.bytesPlane[0] = pixelSize;\r\n\r\n    dataFormat.samples = mapRange(4, (i) => ({\r\n        channelType: [192, 193, 194, 207][i],\r\n        samplePosition: [0, 0, 0, 0],\r\n        bitLength: container.typeSize * 8 - 1,\r\n        bitOffset: container.typeSize * 8 * i,\r\n        sampleLower: -1082130432,\r\n        sampleUpper: 1065353216,\r\n    }));\r\n\r\n    if (texture.dimension === '3d') {\r\n        container.faceCount = 1;\r\n        container.pixelDepth = texture.depthOrArrayLayers;\r\n    } else if (cube) {\r\n        const cubeLayers = texture.depthOrArrayLayers / 6;\r\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\r\n        container.faceCount = 6;\r\n    } else {\r\n        container.layerCount = texture.depthOrArrayLayers;\r\n        container.faceCount = 1;\r\n    }\r\n\r\n    let storageBuffer: GPUBuffer | undefined;\r\n    let imageData: Uint8Array;\r\n\r\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\r\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\r\n            mipLevel: i,\r\n            returnBuffer: true,\r\n            device,\r\n            texture,\r\n            storageBuffer,\r\n        }));\r\n\r\n        container.levels.push({\r\n            levelData: imageData,\r\n            uncompressedByteLength: imageData.byteLength,\r\n        });\r\n    }\r\n\r\n    return ktxparse.write(container);\r\n}\r\n","import { toFloat16Bytes } from './data-conversion';\nimport { srgbTextureToLinear, generateMips } from './texture-processing';\n\nexport type imageToTextureDescriptor = {\n    device: GPUDevice,\n    data: Uint8Array | Blob | File | ImageBitmap,\n    mimeType?: string,\n    label?: string,\n    usage?: number,\n    format?: GPUTextureFormat,\n    mips?: boolean,\n    srgbToLinear?: boolean,\n    colorSpace?: PredefinedColorSpace,\n};\n\nexport async function imageToTexture({\n    device,\n    data,\n    mimeType,\n    usage = GPUTextureUsage.TEXTURE_BINDING,\n    mips = true,\n    format = 'rgba8unorm',\n    colorSpace = 'srgb',\n    label = '',\n    srgbToLinear,\n}: imageToTextureDescriptor) {\n    let bitmap: ImageBitmap;\n\n    if (data instanceof ImageBitmap) {\n        bitmap = data;\n    } else {\n        const blob = (data instanceof Blob || data instanceof File)\n            ? data\n            : new Blob([data], { type: mimeType });\n        bitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n    }\n\n    const size = { width: bitmap.width, height: bitmap.height };\n\n    const texture = device.createTexture({\n        label,\n        format,\n        size: size,\n        usage: usage | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: mips ? 1 + (Math.log2(Math.max(bitmap.width, bitmap.height)) | 0) : 1,\n    });\n\n    device.queue.copyExternalImageToTexture(\n        { source: bitmap },\n        { texture, colorSpace },\n        size,\n    );\n\n    if (srgbToLinear) srgbTextureToLinear(device, texture);\n    if (mips) void generateMips(device, texture);\n\n    return texture;\n}\n\nexport function parseHDR(inData: Uint8Array | ArrayBuffer) {\n    const decoder = new TextDecoder();\n    const buffer = inData instanceof Uint8Array ? inData : new Uint8Array(inData);\n    let pos = 0;\n\n    const getLine = (lineLimit = 1024) => {\n        const limit = Math.min(buffer.length, lineLimit + pos);\n        const sub = buffer.subarray(pos, limit);\n        const end = sub.indexOf(0x0A) + 1;\n        pos += end;\n        return end === 0 ? undefined : decoder.decode(sub.subarray(0, end));\n    };\n\n    const importError = (msg: string) => new Error('HDR Import Error: ' + msg);\n\n    // #region Read Header\n    const magicTokenRegex = /^#\\?(\\S+)/;\n    const magicTokenLine = getLine();\n\n    if (magicTokenLine == null) throw importError('no header found');\n    if (!magicTokenRegex.test(magicTokenLine)) throw importError('bad initial token');\n\n    const headerRegs = [\n        /FORMAT=(?<format>\\S+)/, // format\n        /-Y\\s+(?<Y>\\d+)\\s+\\+X\\s+(?<X>\\d+)/, // size\n        /EXPOSURE\\s*=\\s*(?<exposure>\\d+(\\.\\d+)?)/, // exposure\n        /GAMMA\\s*=\\s*(?<gamma>\\d+(\\.\\d+)?)/, // gamma\n    ];\n\n    const headerReg = new RegExp(`^\\\\s*(${\n        headerRegs.map(({ source }) => `(${source})`).join('|')\n    })\\\\s*$`);\n\n    let noFormat = true;\n    let gamma = 1; /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n    let exposure = 1; /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n    let width: number | undefined = undefined;\n    let height: number | undefined = undefined;\n\n    for (let line = getLine(); line != null; line = width == null ? getLine() : undefined) {\n        const groups = line.match(headerReg)?.groups as Partial<Record<string, string>> | undefined;\n        if (groups == null) continue;\n\n        if (groups.format != null) {\n            noFormat = false;\n        } else if (groups.X != null && groups.Y != null) {\n            width = parseInt(groups.X);\n            height = parseInt(groups.Y);\n        } else if (groups.gamma != null) {\n            gamma = parseFloat(groups.gamma);\n        } else if (groups.exposure != null) {\n            exposure = parseFloat(groups.exposure);\n        }\n    }\n\n    if (noFormat) throw importError('missing format specifier');\n    if (width == null || height == null) throw importError('missing image size specifier');\n    // #endregion\n\n    // #region Read Scanline Data\n    let rawData: Uint8Array;\n    const unencodable = width < 8 || width > 0x7fff;\n    const flatData = buffer[pos] !== 2 || buffer[pos + 1] !== 2 || (buffer[pos + 2] & 0x80) !== 0;\n\n    if (unencodable || flatData) {\n        rawData = buffer.subarray(pos);\n    } else {\n        rawData = new Uint8Array(width * height * 4);\n        const end = 4 * width;\n        const scanline_buffer = new Uint8Array(end);\n        const len = buffer.byteLength;\n\n        for (let k = 0, offset = 0; k < height && pos < len; k++) {\n            if (pos + 4 > len)\n                throw importError('file ended durning scanline');\n\n            if ((2 != buffer[pos++]) || (2 != buffer[pos++]) || (((buffer[pos++] << 8) | buffer[pos++]) != width))\n                throw importError('bad rgbe scanline format');\n\n            let count;\n            for (let ptr = 0; ptr < end && pos < len; ptr += count) {\n                count = buffer[pos++];\n                const isEncodedRun = count > 128;\n                if (isEncodedRun) count -= 128;\n\n                if (count == 0 || ptr + count > end)\n                    throw importError('bad scanline data');\n\n                if (isEncodedRun) {\n                    scanline_buffer.fill(buffer[pos], ptr, ptr + count);\n                    pos += 1;\n                } else {\n                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                    pos += count;\n                }\n            }\n\n            for (let i = 0; i < width; i++)\n                for (let j = 0; j < end; j += width)\n                    rawData[offset++] = scanline_buffer[i + j];\n        }\n    }\n    // #endregion\n\n    // #region Convert to Float16\n    const data = new Uint16Array(rawData.length);\n    const float16One = toFloat16Bytes(1);\n\n    for (let i = 0; i < width * height * 4; i += 4) {\n        const raw_e = rawData[i + 3];\n        const scale = Math.pow(2.0, raw_e - 128.0) / 255.0;\n\n        for (let j = 0; j < 3; j += 1) {\n            data[i + j] = toFloat16Bytes(Math.min(rawData[i + j] * scale, 65504));\n        }\n        data[i + 3] = float16One;\n    }\n    // #endregion\n\n    return { data, width, height, gamma, exposure };\n}\n","import blit from '../shaders/blit-vert.shader';\nimport { toWorldDir } from '../shaders/cubemap-sampling.shader';\nimport { createAndCopyBuffer } from './data-copy';\nimport { padTemplate } from '../../utils/general';\n\ntype EquirectangularDescriptor = {\n    data: SharedArrayBuffer | BufferSource | GPUTexture,\n    width: number,\n    height: number,\n    gamma?: number,\n    exposure?: number,\n};\n\nexport async function equirectangularToCubemap(\n    device: GPUDevice,\n    { data, width, height, gamma = 1, exposure = 1 }: EquirectangularDescriptor,\n    outputDescriptor: Omit<GPUTextureDescriptor, 'dimension' | 'size'>,\n) {\n    const code = /* wgsl */ `\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${blit}\n        ${toWorldDir}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;\n\n    let FLIP_Y = 0;\n    let equirectangular: GPUTexture;\n    if (data instanceof GPUTexture) {\n        equirectangular = data;\n    } else {\n        FLIP_Y = 1;\n        equirectangular = device.createTexture({\n            label: `${outputDescriptor.label} equirectangular`,\n            dimension: '2d',\n            format: 'rgba16float',\n            size: { width, height },\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        device.queue.writeTexture(\n            { texture: equirectangular, mipLevel: 0 },\n            data,\n            { bytesPerRow: width * 2 * 4 },\n            { width, height, depthOrArrayLayers: 1 },\n        );\n        await device.queue.onSubmittedWorkDone();\n    }\n\n    const faceSize = equirectangular.height >> 1;\n    const cubemapDescriptor = outputDescriptor as GPUTextureDescriptor;\n    cubemapDescriptor.mipLevelCount ??= Math.log2(faceSize) | 0;\n    cubemapDescriptor.size = { width: faceSize, height: faceSize, depthOrArrayLayers: 6 };\n    cubemapDescriptor.dimension = '2d';\n    cubemapDescriptor.usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    const cubemap = device.createTexture(cubemapDescriptor);\n\n    const label = padTemplate`hdr copy${outputDescriptor.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 2,\n                buffer: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const module = device.createShaderModule({ label, code });\n    const sampler = device.createSampler({ label, minFilter: 'linear', magFilter: 'linear' });\n    const params = new Uint32Array(1);\n    const paramBuffer = createAndCopyBuffer(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device, label);\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            { binding: 0, resource: equirectangular.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: paramBuffer } },\n        ],\n    });\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: { module },\n        fragment: {\n            module,\n            targets: [{ format: cubemap.format }],\n            constants: {\n                GAMMA: gamma,\n                EXPOSURE: exposure,\n                FLIP_Y,\n            },\n        },\n    });\n\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n\n        const view = cubemap.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n            mipLevelCount: 1,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [{\n                view,\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n\n    return cubemap;\n}\nexport async function generateMips(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${blit}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `;\n\n    const label = padTemplate`mip generation${texture.label}`;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d', sampleType: 'float' },\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const colorAttachment = {\n        view: undefined as GPUTextureView | undefined,\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: 0 });\n    await device.queue.onSubmittedWorkDone();\n\n    for (let i = 1; i < texture.mipLevelCount; i += 1) {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: colorAttachment.view,\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n\n        colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: i });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [colorAttachment as GPURenderPassColorAttachment],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n\n        device.queue.submit([encoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport function srgbTextureToLinear(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${blit}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `;\n\n    const label = padTemplate`srgb to linear${texture.label}`;\n\n    const size = { width: texture.width, height: texture.height };\n\n    const tempTexture = device.createTexture({\n        format: texture.format,\n        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        size,\n    });\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n\n    const module = device.createShaderModule({ label, code: code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: tempTexture.createView(),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n        ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n        { texture },\n        { texture: tempTexture },\n        size,\n    );\n\n    const pass = encoder.beginRenderPass({\n        label,\n        colorAttachments: [{\n            view: texture.createView({ mipLevelCount: 1, baseMipLevel: 0 }),\n            loadOp: 'clear',\n            storeOp: 'store',\n        }],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindgroup);\n    pass.draw(3);\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n}\n","export type UnknownObject = Record<PropertyKey, unknown>;\r\n\r\nexport function mapValues<Input, ObjectType extends Partial<Record<keyof ObjectType, Input>>, Output>(\r\n    obj: ObjectType,\r\n    fn: (val: Input) => Output,\r\n) {\r\n    const entries = Object.entries(obj) as [keyof ObjectType, Input][];\r\n    const mapped = entries.map(([key, val]) => [key, fn(val)]);\r\n    return Object.fromEntries(mapped) as { [K in keyof ObjectType]: Output };\r\n}\r\n\r\nexport function clamp(num: number, min: number, max: number) {\r\n    return Math.max(min, Math.min(max, num));\r\n}\r\n\r\nexport function padCheck(str: string | undefined) {\r\n    return str == null || str === '' ? '' : ` ${str}`;\r\n}\r\n\r\nexport function padTemplate(strings: TemplateStringsArray, ...values: (string | undefined)[]) {\r\n    const result = [strings[0]];\r\n    values.forEach((key, i) => result.push(padCheck(key), strings[i + 1]));\r\n    return result.join('');\r\n}\r\n\r\nexport function range(n: number) {\r\n    return [...Array(n).keys()];\r\n}\r\n\r\nexport function mapRange<T>(n: number, fn: (i: number) => T) {\r\n    return range(n).map(fn);\r\n}\r\n\r\nexport function debounce<Args extends Array<unknown>>(callback: (...args: Args) => unknown, delay: number) {\r\n    let tid: ReturnType<typeof setTimeout> | undefined;\r\n    return function (...args: Args) {\r\n        const ctx = self;\r\n        if (tid != null) clearTimeout(tid);\r\n        tid = setTimeout(() => { callback.apply(ctx, args); }, delay);\r\n    };\r\n};\r\n\r\n// adapted from https://stackoverflow.com/a/60702475/17108769\r\nexport function binaryInsert<T>(\r\n    arr: T[],\r\n    element: T,\r\n    comparator: (a: T, b: T) => number,\r\n    left = 0,\r\n    right = arr.length - 1,\r\n) {\r\n    if (right - left <= 1) {\r\n        if (comparator(element, arr[left] ?? element) < 0) arr.splice(left, 0, element);\r\n        else if (comparator(element, arr[right] ?? element) > 0) arr.splice(right + 1, 0, element);\r\n        else arr.splice(right, 0, element);\r\n    } else {\r\n        const pivot = Math.floor((right - left) / 2) + left;\r\n        if (comparator(element, arr[pivot]) < 0) binaryInsert(arr, element, comparator, left, pivot);\r\n        else binaryInsert(arr, element, comparator, pivot, right);\r\n    }\r\n}\r\n\r\nexport function isObject(val: unknown): val is NonNullable<UnknownObject> {\r\n    return typeof val === 'object' && val != null;\r\n}\r\n"],"names":["TypeSizes","mat4x4Count","sizeofMat4x4f","Float32Array","BYTES_PER_ELEMENT","VkFormatToWebGPU","TextureFormatToSize","r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","rgb9e5ufloat","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","TextureFormatToChannelSize","WebGPUToVkFormat","Object","fromEntries","entries","map","vk","wgpu","parseInt","BlurState","CubemapBlurModel","constructor","renderer","state","IDLE","nearestSample","$type","$callback","val","this","skyboxPass","useNearestSample","value","description","mipLevel","min","max","step","filterDistance","reblur","bind","skybox","onClick","saveFile","settings","publicSettings","priority","addForwardPass","device","setSkybox","privateSettings","mipLevelCount","refresh","resolve","lastState","WAIT","BLUR","texture","steps","inPlace","delayWork","requestAnimationFrame","skyTexture","createView","dimension","proms","Promise","all","then","ktx2","Blob","type","types","accept","suggestedName","handle","createWritable","keepExistingData","blob","stream","pipeTo","e","console","warn","render","encoder","gbuffer","beginRenderPass","colorAttachments","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","view","depth","end","createAndCopyBuffer","arr","usage","label","alignment","pad","buffer","createBuffer","size","byteLength","mappedAtCreation","writeArray","Uint8Array","getMappedRange","readArray","ArrayBuffer","byteOffset","set","unmap","async","textureToArrayBuffer","returnBuffer","storageBuffer","resultBuffer","pixelSize","format","fullDescription","Error","width","height","rawBytesPerRow","bytesPerRow","Math","rowsPerImage","byteSize","depthOrArrayLayers","resultSize","requiredUsage","GPUBufferUsage","COPY_DST","MAP_READ","imageData","storage","createCommandEncoder","copyTextureToBuffer","queue","submit","finish","mapAsync","GPUMapMode","READ","onSubmittedWorkDone","mapped","h","w","slice","undefined","textureToKTX","cube","typeSize","container","pixelWidth","pixelHeight","vkFormat","keyValue","KTXswizzle","dataFormat","dataFormatDescriptor","colorModel","transferFunction","bytesPlane","samples","i","channelType","samplePosition","bitLength","bitOffset","sampleLower","sampleUpper","faceCount","pixelDepth","cubeLayers","layerCount","levels","push","levelData","uncompressedByteLength","parseHDR","inData","decoder","TextDecoder","pos","getLine","lineLimit","limit","length","sub","subarray","indexOf","decode","importError","msg","magicTokenLine","test","headerReg","RegExp","source","join","rawData","noFormat","gamma","exposure","line","groups","match","X","Y","parseFloat","unencodable","flatData","scanline_buffer","len","k","offset","count","ptr","isEncodedRun","fill","j","data","Uint16Array","float16One","raw_e","scale","pow","equirectangularToCubemap","outputDescriptor","code","equirectangular","FLIP_Y","GPUTexture","createTexture","GPUTextureUsage","TEXTURE_BINDING","writeTexture","faceSize","cubemapDescriptor","log2","RENDER_ATTACHMENT","cubemap","bindgroupLayout","createBindGroupLayout","binding","visibility","GPUShaderStage","FRAGMENT","sampler","module","createShaderModule","createSampler","minFilter","magFilter","params","Uint32Array","paramBuffer","UNIFORM","bindgroup","createBindGroup","layout","resource","pipelineLayout","createPipelineLayout","bindGroupLayouts","pipeline","createRenderPipeline","vertex","fragment","targets","constants","GAMMA","EXPOSURE","writeBuffer","arrayLayerCount","baseArrayLayer","pass","loadOp","storeOp","setPipeline","setBindGroup","draw","mapValues","obj","fn","key","clamp","num","padTemplate","strings","values","result","forEach","str","mapRange","n","Array","keys","range","debounce","callback","delay","tid","args","ctx","self","clearTimeout","setTimeout","apply","binaryInsert","element","comparator","left","right","splice","pivot","floor"],"sourceRoot":""}