/*! For license information see: https://cbunt.ing/oss-licenses.json */
"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[908],{856:(e,n,r)=>{r.a(e,(async(e,t)=>{try{r.d(n,{A:()=>v});var o=r(1044),a=r(8452),i=r(7561);const c=await fetch("https://api.github.com/repos/KhronosGroup/glTF-Sample-Environments/contents?ref=low_resolution_hdrs",{headers:{"Content-Type":"application/vnd.github.object+json"}}).then((e=>e.json())),s=Object.fromEntries(c.flatMap((({name:e,download_url:n})=>"string"==typeof e&&"string"==typeof n&&n.endsWith(".hdr")?[[e,n]]:[])));async function u(e,n){let r;if(n instanceof ArrayBuffer)r=n;else if(n instanceof File)r=await n.arrayBuffer();else{const e=await fetch(n);r=await e.arrayBuffer()}const t=(0,o.y)(r);return(0,a.l3)(e,t,{format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC})}function v(e){return{[i.t.$type]:"file",[i.t.$callback]:async(n,r)=>{if("value"===r&&null!=n&&("string"==typeof n||n instanceof File)){const r=await u(e.device,n),t=e.setSkybox(r);t instanceof Promise&&await t}},accept:".hdr",value:Object.keys(s)[0],initialValues:s,process:e=>e}}t()}catch(d){t(d)}}),1)},3706:(e,n,r)=>{r.d(n,{Q:()=>s});const{baseTable:t,shiftTable:o}=(()=>{const e=new Uint32Array(256),n=new Uint32Array(256);for(let r=0;r<255;++r){const t=r-127;t<-27?(e[r]=0,n[r]=24):t<-14?(e[r]=1024>>-t-14,n[r]=-t-1):t<=15?(e[r]=t+15<<10,n[r]=13):(e[r]=31744,n[r]=24)}return e[255]=31744,n[255]=13,{baseTable:e,shiftTable:n}})(),a=new ArrayBuffer(4),i=new Float32Array(a),c=new Uint32Array(a);function s(e){i[0]=e;const n=c[0],r=n>>23&511,a=255&r,s=(8388607&n)>>o[a];return((256&r)<<7)+t[a]+s}},3938:(e,n,r)=>{r.d(n,{V:()=>t,X:()=>o});const t="\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n",o="\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n"},7499:(e,n,r)=>{r.d(n,{A:()=>s});var t=r(3938),o=r(1075),a=r(5834);const i=113639424,c=(e,n)=>`\n    ${t.X}\n    ${t.V}\n\n    override STEPS: i32 = 4;\n\n    struct Params {\n        offset: u32,\n        sigmas: array<f32>,\n    }\n\n    @group(0) @binding(0) \n    var previousMip: texture_2d_array<f32>;\n\n    @group(0) @binding(1) \n    var outputTexture: texture_storage_2d_array<${n}, write>;\n\n    @group(0) @binding(2) \n    var<storage> params: Params;\n    \n    @compute @workgroup_size(${e}, 1, 1)\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\n        let mipSize = textureDimensions(outputTexture).x;\n\n        let idx = gid.x + params.offset;\n        let faceSize = mipSize * mipSize;\n        let faceIdx = idx % faceSize;\n\n        let coord = vec3u(\n            faceIdx % mipSize, \n            faceIdx / mipSize, \n            idx / faceSize,\n        ); \n\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \n            return; \n        }\n\n        let previousSize = textureDimensions(previousMip).x;\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\n        let pos = toWorldDir(vec3u(coord), mipSize);\n\n        let size = arrayLength(&params.sigmas);\n        let level = size - u32(ceil(log2(f32(previousSize))));\n        let sigma = params.sigmas[level];\n        let guassian_factor = -0.5 / (sigma * sigma);\n\n        var weight = 0.0;\n        var res = vec3(0.0);\n\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\n                if (sample.z == INVALID_FACE) { continue; }\n\n                let samplePos = toWorldDir(sample, previousSize);\n                let x = max(0.0, acos(dot(samplePos, pos)));\n                let w = exp(x * x * guassian_factor);\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\n\n                res += color.rgb * w;\n                weight += w;\n            }\n        }\n\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\n    }\n`;async function s({device:e,texture:n,outputTextureLabel:r,inPlace:t=!1,minWidth:u=8,steps:v=4,maxOpsPerPass:d=i,label:l=s.name,delayWork:f}){const{width:p,format:m}=n,y=t?n.mipLevelCount:Math.log2(p)-Math.log2(u)+1;if(y<=1)return n;const x=Math.min(e.limits.maxComputeWorkgroupSizeX,e.limits.maxComputeInvocationsPerWorkgroup),w=e.createShaderModule({label:l,code:c(x,m)}),b=e.createBindGroupLayout({label:l,entries:[{binding:0,texture:{viewDimension:"2d-array"},visibility:GPUShaderStage.COMPUTE},{binding:1,storageTexture:{access:"write-only",viewDimension:"2d-array",format:m},visibility:GPUShaderStage.COMPUTE},{binding:2,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.COMPUTE}]}),g=e.createComputePipeline({label:l,layout:e.createPipelineLayout({label:l,bindGroupLayouts:[b]}),compute:{module:w,entryPoint:"main",constants:{STEPS:Math.ceil(v)}}});let h=n;if(!t){const t={width:p,height:p,depthOrArrayLayers:6};h=e.createTexture({label:r,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,dimension:"2d",format:m,mipLevelCount:y,size:t});const o=e.createCommandEncoder({label:`${l} copy encoder`});o.copyTextureToTexture({texture:n,mipLevel:0},{texture:h,mipLevel:0},t),e.queue.submit([o.finish()]),await e.queue.onSubmittedWorkDone()}const S=(0,a._b)(y,(e=>h.createView({label:`${l} mip view ${e}`,dimension:"2d-array",baseMipLevel:e,mipLevelCount:1}))),P=e.limits.maxComputeWorkgroupsPerDimension,T=Math.ceil(Math.log2(p)),C=Math.max(d/((1+2*v)**2*x)|0,1),I=new ArrayBuffer(4*(T+1)),A=new Uint32Array(I,0,1);new Float32Array(I,4,T).set((0,a._b)(T,(e=>{const n=p>>e;return Math.acos(1-function(e,n){const r=n>>1,t=r-Math.floor(e/4)-1,o=2/r*(t+.5)-1,a=1/r-1,i=1+o*o+a*a,c=2/n*(2*n-2*t-e-2+.5)-1,s=1/n-1,u=1+c*c+s*s,v=3/n-1,d=1+c*c+v*v,l=(c+o+s*a)/Math.sqrt(u*i),f=(c+o+v*a)/Math.sqrt(d*i);return Math.min(1-l,1-f)}(Math.min(n,v),n))/3})));const _=(0,o.Lr)(I,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,e);let z,L=0,D=0,U=0,E=0,G=0;return await async function n(){if(E>=U){if(L+=1,E=0,D=0,L>=y)return;const n=6*(p>>L)**2;U=Math.ceil(n/x),z=e.createBindGroup({layout:b,entries:[{binding:0,resource:S[L-1]},{binding:1,resource:S[L]},{binding:2,resource:{buffer:_}}]})}A[0]=E*x,e.queue.writeBuffer(_,0,A);const r=Math.min(U-E,C-G,P),t=`${l} mip ${L}, pass ${D}`,o=e.createCommandEncoder({label:t}),a=o.beginComputePass({label:t});a.setPipeline(g),a.setBindGroup(0,z),a.dispatchWorkgroups(r,1,1),a.end(),e.queue.submit([o.finish()]),E+=r,G+=r,D+=1,null!=f&&G>=C?(G=0,await e.queue.onSubmittedWorkDone(),f(n)):await n()}(),h}},7561:(e,n,r)=>{r.d(n,{A:()=>u,t:()=>c});var t=r(5834);const o=Symbol("PropertyListener -- Type"),a=Symbol("PropertyListener -- Callback"),i=Symbol("PropertyListener -- Listeners"),c=Object.freeze({$type:o,$callback:a,$listeners:i});function s(e,n){return Object.keys(e).reduce(((r,t)=>Object.defineProperty(r,t,{enumerable:!0,get:()=>e[t],set(r){e[t]!==r&&(e[t]=r,n?.(r,t))}})),{[o]:e[o],[i]:e[i]})}function u(e){for(const n of Object.values(e))n[i]=new Set;return{publicSettings:(0,t.LG)(e,(e=>s(e,e[a]))),privateSettings:(0,t.LG)(e,(e=>{const n=e;return s(n,((e,r)=>{n[i].forEach((n=>{n(e,r)}))}))}))}}},7812:(e,n,r)=>{r.d(n,{A:()=>t});const t="\n    struct VertOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n    }\n\n    @vertex\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\n        const pos = array(\n            vec2f(-1,  3),\n            vec2f(3, -1),\n            vec2f(-1, -1),\n        );\n        var res: VertOut;\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\n        return res;\n    }\n"}}]);
//# sourceMappingURL=908.bundle.js.map