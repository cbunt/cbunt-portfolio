{"version":3,"file":"519.bundle.js","mappings":"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","sources":["webpack://cbunt-portfolio/./src/rendering/utils/texture-importing.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-copy.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/weld.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/primitive-draw-data.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/type-conversions.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/attribute-wrapper.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/primitive-loader.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/interleave-vertices.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/material-loader.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/material-draw-data.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/geometry-pipeline.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/loader/gltf-loader.ts","webpack://cbunt-portfolio/./src/rendering/core/camera/camera.ts","webpack://cbunt-portfolio/./src/utils/general.ts","webpack://cbunt-portfolio/./src/rendering/core/constants.ts","webpack://cbunt-portfolio/./src/rendering/utils/texture-processing.ts","webpack://cbunt-portfolio/./src/rendering/samples/gltf-viewer/gltf-viewer-sample.ts","webpack://cbunt-portfolio/./src/rendering/core/global-uniforms.ts","webpack://cbunt-portfolio/./src/rendering/utils/shader.ts","webpack://cbunt-portfolio/./src/rendering/shaders/forward.shader.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/descriptor-map.ts","webpack://cbunt-portfolio/./src/rendering/core/default-forward-pass/pipeline-feature-flags.ts"],"sourcesContent":["import { toFloat16Bytes } from './data-conversion';\nimport { srgbTextureToLinear, generateMips } from './texture-processing';\n\nexport type imageToTextureDescriptor = {\n    device: GPUDevice,\n    data: Uint8Array | Blob | File | ImageBitmap,\n    mimeType?: string,\n    label?: string,\n    usage?: number,\n    format?: GPUTextureFormat,\n    mips?: boolean,\n    srgbToLinear?: boolean,\n    colorSpace?: PredefinedColorSpace,\n};\n\nexport async function imageToTexture({\n    device,\n    data,\n    mimeType,\n    usage = GPUTextureUsage.TEXTURE_BINDING,\n    mips = true,\n    format = 'rgba8unorm',\n    colorSpace = 'srgb',\n    label = '',\n    srgbToLinear,\n}: imageToTextureDescriptor) {\n    let bitmap: ImageBitmap;\n\n    if (data instanceof ImageBitmap) {\n        bitmap = data;\n    } else {\n        const blob = (data instanceof Blob || data instanceof File)\n            ? data\n            : new Blob([data], { type: mimeType });\n        bitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n    }\n\n    const size = { width: bitmap.width, height: bitmap.height };\n\n    const texture = device.createTexture({\n        label,\n        format,\n        size: size,\n        usage: usage | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: mips ? 1 + (Math.log2(Math.max(bitmap.width, bitmap.height)) | 0) : 1,\n    });\n\n    device.queue.copyExternalImageToTexture(\n        { source: bitmap },\n        { texture, colorSpace },\n        size,\n    );\n\n    if (srgbToLinear) srgbTextureToLinear(device, texture);\n    if (mips) void generateMips(device, texture);\n\n    return texture;\n}\n\nexport function parseHDR(inData: Uint8Array | ArrayBuffer) {\n    const decoder = new TextDecoder();\n    const buffer = inData instanceof Uint8Array ? inData : new Uint8Array(inData);\n    let pos = 0;\n\n    const getLine = (lineLimit = 1024) => {\n        const limit = Math.min(buffer.length, lineLimit + pos);\n        const sub = buffer.subarray(pos, limit);\n        const end = sub.indexOf(0x0A) + 1;\n        pos += end;\n        return end === 0 ? undefined : decoder.decode(sub.subarray(0, end));\n    };\n\n    const importError = (msg: string) => new Error('HDR Import Error: ' + msg);\n\n    // #region Read Header\n    const magicTokenRegex = /^#\\?(\\S+)/;\n    const magicTokenLine = getLine();\n\n    if (magicTokenLine == null) throw importError('no header found');\n    if (!magicTokenRegex.test(magicTokenLine)) throw importError('bad initial token');\n\n    const headerRegs = [\n        /FORMAT=(?<format>\\S+)/, // format\n        /-Y\\s+(?<Y>\\d+)\\s+\\+X\\s+(?<X>\\d+)/, // size\n        /EXPOSURE\\s*=\\s*(?<exposure>\\d+(\\.\\d+)?)/, // exposure\n        /GAMMA\\s*=\\s*(?<gamma>\\d+(\\.\\d+)?)/, // gamma\n    ];\n\n    const headerReg = new RegExp(`^\\\\s*(${\n        headerRegs.map(({ source }) => `(${source})`).join('|')\n    })\\\\s*$`);\n\n    let noFormat = true;\n    let gamma = 1; /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n    let exposure = 1; /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n    let width: number | undefined = undefined;\n    let height: number | undefined = undefined;\n\n    for (let line = getLine(); line != null; line = width == null ? getLine() : undefined) {\n        const groups = line.match(headerReg)?.groups as Partial<Record<string, string>> | undefined;\n        if (groups == null) continue;\n\n        if (groups.format != null) {\n            noFormat = false;\n        } else if (groups.X != null && groups.Y != null) {\n            width = parseInt(groups.X);\n            height = parseInt(groups.Y);\n        } else if (groups.gamma != null) {\n            gamma = parseFloat(groups.gamma);\n        } else if (groups.exposure != null) {\n            exposure = parseFloat(groups.exposure);\n        }\n    }\n\n    if (noFormat) throw importError('missing format specifier');\n    if (width == null || height == null) throw importError('missing image size specifier');\n    // #endregion\n\n    // #region Read Scanline Data\n    let rawData: Uint8Array;\n    const unencodable = width < 8 || width > 0x7fff;\n    const flatData = buffer[pos] !== 2 || buffer[pos + 1] !== 2 || (buffer[pos + 2] & 0x80) !== 0;\n\n    if (unencodable || flatData) {\n        rawData = buffer.subarray(pos);\n    } else {\n        rawData = new Uint8Array(width * height * 4);\n        const end = 4 * width;\n        const scanline_buffer = new Uint8Array(end);\n        const len = buffer.byteLength;\n\n        for (let k = 0, offset = 0; k < height && pos < len; k++) {\n            if (pos + 4 > len)\n                throw importError('file ended durning scanline');\n\n            if ((2 != buffer[pos++]) || (2 != buffer[pos++]) || (((buffer[pos++] << 8) | buffer[pos++]) != width))\n                throw importError('bad rgbe scanline format');\n\n            let count;\n            for (let ptr = 0; ptr < end && pos < len; ptr += count) {\n                count = buffer[pos++];\n                const isEncodedRun = count > 128;\n                if (isEncodedRun) count -= 128;\n\n                if (count == 0 || ptr + count > end)\n                    throw importError('bad scanline data');\n\n                if (isEncodedRun) {\n                    scanline_buffer.fill(buffer[pos], ptr, ptr + count);\n                    pos += 1;\n                } else {\n                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                    pos += count;\n                }\n            }\n\n            for (let i = 0; i < width; i++)\n                for (let j = 0; j < end; j += width)\n                    rawData[offset++] = scanline_buffer[i + j];\n        }\n    }\n    // #endregion\n\n    // #region Convert to Float16\n    const data = new Uint16Array(rawData.length);\n    const float16One = toFloat16Bytes(1);\n\n    for (let i = 0; i < width * height * 4; i += 4) {\n        const raw_e = rawData[i + 3];\n        const scale = Math.pow(2.0, raw_e - 128.0) / 255.0;\n\n        for (let j = 0; j < 3; j += 1) {\n            data[i + j] = toFloat16Bytes(Math.min(rawData[i + j] * scale, 65504));\n        }\n        data[i + 3] = float16One;\n    }\n    // #endregion\n\n    return { data, width, height, gamma, exposure };\n}\n","import * as ktxparse from 'ktx-parse';\r\n\r\nimport { TextureFormatToSize, TextureFormatToChannelSize, WebGPUToVkFormat } from '../core/constants';\r\nimport { mapRange, padTemplate } from '../../utils/general';\r\n\r\nexport function createAndCopyBuffer(\r\n    arr: ArrayBuffer | ArrayBufferView,\r\n    usage: GPUFlagsConstant,\r\n    device: GPUDevice,\r\n    label?: string,\r\n    alignment = 4,\r\n): GPUBuffer {\r\n    const pad = alignment - 1;\r\n    const buffer = device.createBuffer({\r\n        label,\r\n        usage,\r\n        size: (arr.byteLength + pad) & ~pad,\r\n        mappedAtCreation: true,\r\n    } as GPUBufferDescriptor);\r\n\r\n    const writeArray = new Uint8Array(buffer.getMappedRange());\r\n    const readArray = arr instanceof ArrayBuffer\r\n        ? new Uint8Array(arr)\r\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n\r\n    writeArray.set(readArray);\r\n    buffer.unmap();\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function createAndCopyCubemap(\r\n    device: GPUDevice,\r\n    data: ArrayBuffer,\r\n    format: GPUTextureFormat,\r\n    usage: number,\r\n    label?: string,\r\n) {\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\r\n    }\r\n\r\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\r\n    const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n    const texture = device.createTexture({\r\n        usage: usage | GPUTextureUsage.COPY_DST,\r\n        label,\r\n        format,\r\n        size,\r\n    });\r\n\r\n    device.queue.writeTexture(\r\n        { texture },\r\n        data,\r\n        { bytesPerRow: width * pixelSize, rowsPerImage: width },\r\n        size,\r\n    );\r\n\r\n    return texture;\r\n}\r\n\r\nexport type TextureToArrayBufferOptions = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    mipLevel?: number,\r\n    resultBuffer?: Uint8Array,\r\n    storageBuffer?: GPUBuffer,\r\n    returnBuffer?: boolean,\r\n    description?: string,\r\n};\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer?: false },\r\n): Promise<{ imageData: Uint8Array }>;\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer: true },\r\n): Promise<{ imageData: Uint8Array, storageBuffer: GPUBuffer }>;\r\n\r\nexport async function textureToArrayBuffer({\r\n    device,\r\n    texture,\r\n    mipLevel = 0,\r\n    returnBuffer,\r\n    storageBuffer,\r\n    resultBuffer,\r\n    description,\r\n}: TextureToArrayBufferOptions) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const fullDescription = padTemplate`[textureToKTX${description ?? ''}${texture.label}] --`;\r\n\r\n    if (pixelSize == null) {\r\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\r\n    }\r\n\r\n    const width = texture.width >> mipLevel;\r\n    const height = texture.height >> mipLevel;\r\n    const rawBytesPerRow = width * pixelSize;\r\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n    const rowsPerImage = height;\r\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\r\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\r\n\r\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\r\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\r\n    }\r\n\r\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\r\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\r\n    }\r\n\r\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\r\n\r\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\r\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\r\n    }\r\n\r\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\r\n    const storage = storageBuffer ?? device.createBuffer({\r\n        label: `${fullDescription} storage buffer`,\r\n        size: byteSize,\r\n        usage: requiredUsage,\r\n    });\r\n\r\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\r\n    encoder.copyTextureToBuffer(\r\n        { texture, mipLevel },\r\n        { buffer: storage, rowsPerImage, bytesPerRow },\r\n        { width, height, depthOrArrayLayers: texture.depthOrArrayLayers },\r\n    );\r\n    device.queue.submit([encoder.finish()]);\r\n\r\n    await Promise.all([\r\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\r\n        device.queue.onSubmittedWorkDone(),\r\n    ]);\r\n\r\n    const mapped = storage.getMappedRange(0, byteSize);\r\n    imageData.set(new Uint8Array(mapped));\r\n    storage.unmap();\r\n\r\n    if (bytesPerRow > rawBytesPerRow) {\r\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\r\n            }\r\n        }\r\n        imageData = imageData.slice(0, resultSize);\r\n    }\r\n\r\n    return {\r\n        imageData,\r\n        storageBuffer: returnBuffer ? storage : undefined,\r\n    };\r\n}\r\n\r\nexport async function textureToKTX(device: GPUDevice, texture: GPUTexture, cube = false) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const typeSize = TextureFormatToChannelSize[texture.format];\r\n\r\n    if (pixelSize == null || typeSize == null) {\r\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\r\n    }\r\n\r\n    const container = ktxparse.createDefaultContainer();\r\n    container.pixelWidth = texture.width;\r\n    container.pixelHeight = texture.height;\r\n    container.vkFormat = WebGPUToVkFormat[texture.format];\r\n    container.typeSize = typeSize;\r\n    delete container.keyValue.KTXswizzle;\r\n\r\n    const dataFormat = container.dataFormatDescriptor[0];\r\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\r\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\r\n    dataFormat.bytesPlane[0] = pixelSize;\r\n\r\n    dataFormat.samples = mapRange(4, (i) => ({\r\n        channelType: [192, 193, 194, 207][i],\r\n        samplePosition: [0, 0, 0, 0],\r\n        bitLength: container.typeSize * 8 - 1,\r\n        bitOffset: container.typeSize * 8 * i,\r\n        sampleLower: -1082130432,\r\n        sampleUpper: 1065353216,\r\n    }));\r\n\r\n    if (texture.dimension === '3d') {\r\n        container.faceCount = 1;\r\n        container.pixelDepth = texture.depthOrArrayLayers;\r\n    } else if (cube) {\r\n        const cubeLayers = texture.depthOrArrayLayers / 6;\r\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\r\n        container.faceCount = 6;\r\n    } else {\r\n        container.layerCount = texture.depthOrArrayLayers;\r\n        container.faceCount = 1;\r\n    }\r\n\r\n    let storageBuffer: GPUBuffer | undefined;\r\n    let imageData: Uint8Array;\r\n\r\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\r\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\r\n            mipLevel: i,\r\n            returnBuffer: true,\r\n            device,\r\n            texture,\r\n            storageBuffer,\r\n        }));\r\n\r\n        container.levels.push({\r\n            levelData: imageData,\r\n            uncompressedByteLength: imageData.byteLength,\r\n        });\r\n    }\r\n\r\n    return ktxparse.write(container);\r\n}\r\n","import AttributeWrapper from './attribute-wrapper';\n\n/**\n * Adapted from gltf-transform's version:\n * github.com/donmccurdy/glTF-Transform/blob/main/packages/functions/src/weld.ts\n */\nclass HashTable {\n    private attributes: { u8: Uint8Array, byteStride: number }[] = [];\n    private u8: Uint8Array;\n    private u32: Uint32Array;\n\n    constructor(prim: Record<string, AttributeWrapper>) {\n        let byteStride = 0;\n        for (const attribute of Object.values(prim)) {\n            byteStride += this.initAttribute(attribute);\n        }\n        const paddedByteStride = (byteStride + 3) & ~3;\n        this.u8 = new Uint8Array(paddedByteStride);\n        this.u32 = new Uint32Array(this.u8.buffer);\n    }\n\n    private initAttribute(attribute: AttributeWrapper): number {\n        const u8 = attribute.data instanceof Uint8Array\n            ? attribute.data\n            : new Uint8Array(attribute.data.buffer);\n        const byteStride = attribute.bytesPerComponent * attribute.componentsPerElement;\n        this.attributes.push({ u8, byteStride });\n        return byteStride;\n    }\n\n    hash(index: number): number {\n        let byteOffset = 0;\n        for (const { u8, byteStride } of this.attributes) {\n            for (let i = 0; i < byteStride; i += 1) {\n                this.u8[byteOffset + i] = u8[index * byteStride + i];\n            }\n            byteOffset += byteStride;\n        }\n        return this.murmurHash2();\n    }\n\n    equal(a: number, b: number): boolean {\n        for (const { u8, byteStride } of this.attributes) {\n            for (let j = 0; j < byteStride; j += 1) {\n                if (u8[a * byteStride + j] !== u8[b * byteStride + j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    hashLookup(table: TypedArray, buckets: number, key: number, empty: number): number {\n        const hashmod = buckets - 1;\n        const hashval = this.hash(key);\n        let bucket = hashval & hashmod;\n\n        for (let probe = 0; probe <= hashmod; probe += 1) {\n            const item = table[bucket];\n\n            if (item === empty || this.equal(item, key)) {\n                return bucket;\n            }\n\n            bucket = (bucket + probe + 1) & hashmod; // Hash collision.\n        }\n\n        throw new Error('Hash table full.');\n    }\n\n    /**\n     * References:\n     * - https://github.com/mikolalysenko/murmurhash-js/blob/f19136e9f9c17f8cddc216ca3d44ec7c5c502f60/murmurhash2_gc.js#L14\n     * - https://github.com/zeux/meshoptimizer/blob/e47e1be6d3d9513153188216455bdbed40a206ef/src/indexgenerator.cpp#L12\n     */\n    murmurHash2(): number {\n        const m = 0x5bd1e995;\n        const r = 24;\n        let h = 0;\n\n        for (let k of this.u32) {\n            k = Math.imul(k, m) >>> 0;\n            k = (k ^ (k >> r)) >>> 0;\n            k = Math.imul(k, m) >>> 0;\n\n            h = Math.imul(h, m) >>> 0;\n            h = (h ^ k) >>> 0;\n        }\n\n        return h;\n    }\n}\n\nfunction ceilPowerOfTwo(value: number): number {\n    return 2 ** Math.ceil(Math.log(value) / Math.LN2);\n}\n\n/**\n * Weld and merge, combining vertices that are bitwise-equal.\n *\n * Adapted from gltf-transform's _weldPrimitiveStrict:\n * github.com/donmccurdy/glTF-Transform/blob/main/packages/functions/src/weld.ts#L193\n */\nexport default function weld(prim: Record<string, AttributeWrapper>) {\n    const srcVertexCount = prim.POSITION.count;\n    const hash = new HashTable(prim);\n    const tableSize = ceilPowerOfTwo(srcVertexCount + (srcVertexCount / 4));\n    const is16Bit = srcVertexCount < (2 ** 16 - 1);\n    const empty = 2 ** (is16Bit ? 16 : 32) - 1;\n    const indexFormat: GPUIndexFormat = is16Bit ? 'uint16' : 'uint32';\n    const writeMap = is16Bit ? new Uint16Array(srcVertexCount) : new Uint32Array(srcVertexCount);\n    const table = is16Bit ? new Uint16Array(tableSize) : new Uint32Array(tableSize);\n    table.fill(empty);\n\n    let dstVertexCount = 0;\n\n    for (let i = 0; i < srcVertexCount; i += 1) {\n        const hashIndex = hash.hashLookup(table, tableSize, i, empty);\n        const dstIndex = table[hashIndex];\n\n        if (dstIndex === empty) {\n            table[hashIndex] = i;\n            writeMap[i] = dstVertexCount;\n            dstVertexCount += 1;\n        } else {\n            writeMap[i] = writeMap[dstIndex];\n        }\n    }\n\n    for (const attribute of Object.values(prim)) {\n        attribute.remap(writeMap, dstVertexCount);\n    }\n\n    // The gltf-transform version checks for degenerate triangles to remove.\n    // This is omitted here.\n    return { indexArray: writeMap, indexFormat, vertexCount: dstVertexCount };\n}\n","import { mat3, mat4, Mat3, Mat4 } from 'wgpu-matrix';\n\nimport { TypeSizes } from '../constants';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\nimport { PipelineFeatureFlags } from './pipeline-feature-flags';\nimport DescriptorMap from './descriptor-map';\n\nexport type PrimitiveDescriptor = {\n    name?: string,\n    // vertexBufferLayouts: GPUVertexBufferLayout;\n    features: PipelineFeatureFlags,\n    vertexCount: number,\n    vertexArray: ArrayBuffer | TypedArray | GPUBuffer,\n    indexArray?: ArrayBuffer | TypedArray,\n    indexFormat?: GPUIndexFormat,\n};\n\nexport type IndexData = {\n    indexBuffer: GPUBuffer,\n    indexCount: number,\n    indexFormat: GPUIndexFormat,\n};\n\nexport class PrimitiveDrawData {\n    name: string;\n    vertexBuffer: GPUBuffer;\n    indexData?: IndexData;\n    instanceBuffer: GPUBuffer;\n    instanceBindGroup: GPUBindGroup;\n    vertexCount: number;\n    features: number;\n\n    instanceSize: number;\n\n    instances: ArrayBuffer;\n    modelMatrices: Mat4[];\n    normalMatrices!: Mat3[];\n    max: number;\n\n    instanceCount: number = 0;\n    dirty: boolean = false;\n\n    constructor(\n        primitive: PrimitiveDescriptor,\n        device: GPUDevice,\n        max: number,\n        descriptorMap: DescriptorMap,\n        instances?: Mat4[],\n    ) {\n        this.max = max;\n        this.features = primitive.features;\n        this.name = primitive.name ?? 'mesh';\n        this.vertexCount = primitive.vertexCount;\n\n        if (primitive.vertexArray instanceof GPUBuffer) {\n            this.vertexBuffer = primitive.vertexArray;\n        } else {\n            this.vertexBuffer = createAndCopyBuffer(\n                primitive.vertexArray,\n                GPUBufferUsage.VERTEX,\n                device,\n                `${this.name} vertex buffer`,\n            );\n        }\n\n        if (primitive.indexArray && primitive.indexFormat) {\n            const { indexArray, indexFormat } = primitive;\n            this.indexData = {\n                indexFormat,\n                indexCount: indexArray.byteLength / (indexFormat === 'uint16' ? 2 : 4),\n                indexBuffer: createAndCopyBuffer(\n                    primitive.indexArray,\n                    GPUBufferUsage.INDEX,\n                    device,\n                    `${this.name} index buffer`,\n                ),\n            };\n        }\n\n        this.instanceSize = TypeSizes.sizeofMat4x4f;\n        if (this.features & PipelineFeatureFlags.VertexNormals) {\n            this.instanceSize += 12 * 4;\n        }\n\n        this.instances = new ArrayBuffer(max * this.instanceSize);\n        this.modelMatrices = new Array(max) as Float32Array[];\n\n        for (let i = 0; i < max; i += 1) {\n            const offset = i * this.instanceSize;\n            this.modelMatrices[i] = new Float32Array(this.instances, offset, 16);\n        }\n\n        if (this.features & PipelineFeatureFlags.VertexNormals) {\n            this.normalMatrices = new Array(max) as Float32Array[];\n\n            for (let i = 0; i < max; i += 1) {\n                const offset = (i * this.instanceSize) + TypeSizes.sizeofMat4x4f;\n                this.normalMatrices[i] = new Float32Array(this.instances, offset, 12);\n            }\n        }\n\n        this.instanceBuffer = device.createBuffer({\n            label: `${this.name} instance buffer`,\n            size: this.instances.byteLength,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        });\n\n        this.instanceBindGroup = device.createBindGroup({\n            label: `PrimitiveDrawData instance bind group`,\n            layout: descriptorMap.forwardBindgroupLayout,\n            entries: [{\n                binding: 0,\n                resource: { buffer: this.instanceBuffer },\n            }],\n        });\n\n        if (instances) {\n            for (const instance of instances) {\n                this.addInstance(instance);\n            }\n        }\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        if (this.dirty) {\n            queue.writeBuffer(this.instanceBuffer, 0, this.instances);\n            this.dirty = false;\n        }\n\n        passEncoder.setVertexBuffer(0, this.vertexBuffer);\n        passEncoder.setBindGroup(2, this.instanceBindGroup);\n\n        if (this.indexData != null) {\n            const { indexBuffer, indexCount, indexFormat } = this.indexData;\n            passEncoder.setIndexBuffer(indexBuffer, indexFormat);\n            passEncoder.drawIndexed(indexCount, this.instanceCount);\n        } else {\n            passEncoder.draw(this.vertexCount, this.instanceCount);\n        }\n    }\n\n    addInstance(transform: Mat4) {\n        if (this.instanceCount === this.max) return;\n        mat4.copy(transform, this.modelMatrices[this.instanceCount]);\n        this.calculateNormalMatrix(this.instanceCount);\n        this.instanceCount += 1;\n        this.dirty = true;\n    }\n\n    calculateNormalMatrix(idx: number) {\n        if (!(this.features & PipelineFeatureFlags.VertexNormals)) return;\n        const normalMatrix = this.normalMatrices[idx];\n        mat3.fromMat4(this.modelMatrices[idx], normalMatrix);\n        mat3.invert(normalMatrix, normalMatrix);\n        mat3.transpose(normalMatrix, normalMatrix);\n    }\n}\n","import { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\n\nexport type AccessorComponentType = 5120 | 5121 | 5122 | 5123 | 5125 | 5126;\n\nexport type AccessorType = 'SCALAR' | 'VEC2' | 'VEC3' | 'VEC4' | 'MAT2' | 'MAT3' | 'MAT4';\n\nexport type AttributeDetails = {\n    name: string,\n    type: AccessorType,\n    componentType: AccessorComponentType,\n    strip?: boolean,\n    depends?: string[],\n    feature?: PipelineFeatureFlags,\n    fill?: number[],\n};\n\nexport const enum ComponentType {\n    int8 = 5120,\n    uint8 = 5121,\n    int16 = 5122,\n    uint16 = 5123,\n    uint32 = 5125,\n    float32 = 5126,\n}\n\nexport const typeToElementCount: Record<AccessorType, number> = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 12,\n    MAT4: 16,\n};\n\nexport const componentToSize: Record<ComponentType, number> = {\n    [ComponentType.int8]: 1,\n    [ComponentType.uint8]: 1,\n    [ComponentType.int16]: 2,\n    [ComponentType.uint16]: 2,\n    [ComponentType.uint32]: 4,\n    [ComponentType.float32]: 4,\n};\n\nexport const enum TopologyMode {\n    Points = 0,\n    LineList = 1,\n    LineLoop = 2,\n    LineStrip = 3,\n    TriangleList = 4,\n    TriangleStrip = 5,\n    TriangleFan = 6,\n}\n\nexport const modeToTopology: Partial<Record<TopologyMode, PipelineFeatureFlags>> = {\n    [TopologyMode.Points]: PipelineFeatureFlags.PointList, // POINTS\n    [TopologyMode.LineList]: PipelineFeatureFlags.LineList, // LINES\n    // 2: LINE_LOOP (unsupported by webgpu)\n    // 3: PipelineFeatureFlags.LineStrip, // LINE_STRIP\n    [TopologyMode.TriangleList]: PipelineFeatureFlags.TriangleList, // TRIANGLES\n    // 5: PipelineFeatureFlags.TriangleStrip, // TRIANGLE_STRIP\n    // 6: TRIANGLE_FAN (unsupported by webgpu)\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\nimport { GLTFAccessorPostprocessed } from '@loaders.gl/gltf';\nimport { ComponentType } from './type-conversions';\n\nexport default class AttributeWrapper {\n    data: TypedArray;\n    processed: boolean;\n    componentsPerElement: number;\n    bytesPerComponent: number;\n    count: number;\n\n    copyFrom: (srcIdx: number, dstIdx: number, dst: Float32Array) => void;\n\n    at?: (i: number, j: number) => number;\n    view?: DataView;\n\n    unwelded = false;\n\n    constructor(accessor: GLTFAccessorPostprocessed);\n    constructor(array: Float32Array, componentCount: number);\n\n    constructor(accessor: GLTFAccessorPostprocessed | Float32Array, componentCount?: number) {\n        if (accessor instanceof Float32Array) {\n            this.data = accessor;\n            this.componentsPerElement = componentCount!;\n            this.count = accessor.length / componentCount!;\n            this.processed = true;\n            this.bytesPerComponent = 4;\n            this.copyFrom = this.copyProcessed.bind(this);\n        } else {\n            this.data = accessor.value;\n            this.componentsPerElement = accessor.components;\n            this.count = accessor.count;\n            this.bytesPerComponent = accessor.bytesPerComponent;\n            this.processed = false;\n            this.view = new DataView(this.data.buffer);\n            this.copyFrom = this.copyUnprocessed.bind(this);\n\n            switch (accessor.componentType as ComponentType) {\n                case ComponentType.int8: {\n                    this.at = (i, j) => this.view!.getInt8(i * this.componentsPerElement + j);\n                    break;\n                }\n                case ComponentType.uint8: {\n                    this.at = (i, j) => this.view!.getUint8(i * this.componentsPerElement + j);\n                    break;\n                }\n                case ComponentType.int16: {\n                    this.at = (i, j) => {\n                        const offset = 2 * (i * this.componentsPerElement + j);\n                        return this.view!.getInt16(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.uint16: {\n                    this.at = (i, j) => {\n                        const offset = 2 * (i * this.componentsPerElement + j);\n                        return this.view!.getUint16(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.uint32: {\n                    this.at = (i, j) => {\n                        const offset = 4 * (i * this.componentsPerElement + j);\n                        return this.view!.getUint32(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.float32: {\n                    this.at = (i, j) => {\n                        const offset = 4 * (i * this.componentsPerElement + j);\n                        return this.view!.getFloat32(offset, true);\n                    };\n                    break;\n                }\n                default: throw new Error(`gltf importer -- invalid componentType ${accessor.componentType}`);\n            }\n\n            if (accessor.normalized) {\n                let val: number;\n                switch (accessor.componentType as ComponentType) {\n                    case ComponentType.uint8: val = 255; break;\n                    case ComponentType.int8: val = 127; break;\n                    case ComponentType.uint16: val = 65535; break;\n                    case ComponentType.int16: val = 32767; break;\n                    case ComponentType.uint32: val = 4294967295; break;\n                    default: throw new Error(`gltf importer -- invalid componentType ${accessor.componentType}`);\n                }\n\n                this.at = (i, j) => this.at!(i, j) / val;\n            }\n        }\n    }\n\n    get array(): Float32Array {\n        if (!this.processed) this.process();\n        return this.data as Float32Array;\n    }\n\n    copyProcessed(srcIdx: number, dstIdx: number, dst: Float32Array) {\n        for (let j = 0; j < this.componentsPerElement; j += 1) {\n            dst[dstIdx + j] = this.data[(srcIdx * this.componentsPerElement) + j];\n        }\n    }\n\n    copyUnprocessed(srcIdx: number, dstIdx: number, dst: Float32Array) {\n        for (let j = 0; j < this.componentsPerElement; j += 1) {\n            dst[dstIdx + j] = this.at!(srcIdx, j);\n        }\n    }\n\n    markProcessed() {\n        this.processed = true;\n        this.copyFrom = this.copyProcessed.bind(this);\n        delete this.view;\n        delete this.at;\n    }\n\n    process() {\n        if (this.processed) return;\n        const newView = new Float32Array(this.count * this.componentsPerElement);\n\n        for (let i = 0; i < this.count; i += 1) {\n            this.copyFrom(i, i * this.componentsPerElement, newView);\n        }\n\n        this.data = newView;\n        this.markProcessed();\n    }\n\n    unweld(indexArray: TypedArray): void {\n        if (this.unwelded) return;\n        this.unwelded = true;\n        const newView = new Float32Array(indexArray.length * this.componentsPerElement);\n\n        for (let i = 0; i < indexArray.length; i += 1) {\n            this.copyFrom(indexArray[i], i * this.componentsPerElement, newView);\n        }\n\n        this.count = indexArray.length;\n        this.data = newView;\n        this.markProcessed();\n    }\n\n    remap(remap: TypedArray, dstCount: number): void {\n        const dstArray = new Float32Array(dstCount * this.componentsPerElement);\n        const done = new Uint8Array(dstCount);\n\n        for (let srcIndex = 0; srcIndex < this.count; srcIndex += 1) {\n            const dstIndex = remap[srcIndex];\n            if (done[dstIndex]) continue;\n            this.copyFrom(srcIndex, dstIndex * this.componentsPerElement, dstArray);\n            done[dstIndex] = 1;\n        }\n\n        this.data = dstArray;\n        this.markProcessed();\n    }\n}\n","import { Mat4, mat4 } from 'wgpu-matrix';\nimport { GLTFAccessorPostprocessed, GLTFMaterialPostprocessed, GLTFMeshPrimitivePostprocessed } from '@loaders.gl/gltf';\n\nimport weld from './weld';\nimport { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\nimport { PrimitiveDrawData } from '../../../core/default-forward-pass/primitive-draw-data';\nimport { AttributeDetails, TopologyMode, modeToTopology } from './type-conversions';\nimport DescriptorMap from '../../../core/default-forward-pass/descriptor-map';\nimport AttributeWrapper from './attribute-wrapper';\nimport interleaveVertices from './interleave-vertices';\nimport { mapValues } from '../../../../utils/general';\n\nexport type NamedAttribute = 'POSITION' | 'NORMAL' | 'TANGENT';\nexport type NumberedAttribute = 'TEXCOORD' | 'COLOR' | 'JOINTS' | 'WEIGHTS';\nexport type PrimitiveAttributeKey = NamedAttribute | `${NumberedAttribute}_${number}` | `_${string}`;\n\nconst generateTangentsAsync = import('mikktspace').then((module) => module.generateTangents);\n\nfunction wrapIndices(indices: GLTFAccessorPostprocessed) {\n    switch (indices.bytesPerComponent) {\n        case 2: return {\n            indexArray: new Uint16Array(indices.value.buffer),\n            indexFormat: 'uint16' as GPUIndexFormat,\n        };\n        case 4: return {\n            indexArray: new Uint32Array(indices.value.buffer),\n            indexFormat: 'uint32' as GPUIndexFormat,\n        };\n        case 1:\n        default: return {\n            indexArray: new Uint16Array(indices.value),\n            indexFormat: 'uint16' as GPUIndexFormat,\n        };\n    }\n}\n\nfunction reindex(indices: GLTFAccessorPostprocessed, originalMode?: number) {\n    switch (originalMode) {\n        case TopologyMode.LineLoop:\n        case TopologyMode.LineStrip:\n        case TopologyMode.TriangleFan:\n        case TopologyMode.TriangleStrip: {\n            // TODO: convert non-list topologies into lists.\n            throw new Error('Topology currently unsupported');\n        }\n        default: return { ...wrapIndices(indices), mode: TopologyMode.TriangleList };\n    }\n}\n\n/**\n * Checks the determinant of each given matrix and returns a culling mode such that\n * a primitive will render correctly for all nodes containing it, using 'none'\n * for primitive which are rendered both inverted and normally.\n *\n * @param instanceMatrices the instance matrices to render the primitive with\n * @returns The cull mode to use on the primitive.\n *\n * @remarks\n * The glFT spec determines the winding direction of a model by the\n * determinant of the transform of the node which uses it, allowing\n * inversion through negative scale. Changing cullMode instead\n * more easily integrates with instanced rendering, although comes\n * at a performance cost.\n */\nfunction getCullMode(instanceMatrices: Mat4[]) {\n    let overallSign: number | undefined;\n\n    for (let i = 0; i < instanceMatrices.length; i += 1) {\n        const det = mat4.determinant(instanceMatrices[i]);\n        const sign = Math.sign(det);\n        overallSign ??= sign;\n\n        if (sign !== overallSign) return PipelineFeatureFlags.DoubleSided;\n    }\n\n    return (overallSign == null || overallSign > 0)\n        ? PipelineFeatureFlags.Defaults\n        : PipelineFeatureFlags.ClockwiseWinding;\n}\n\nexport default async function loadPrimitive(\n    layout: AttributeDetails[],\n    primitive: GLTFMeshPrimitivePostprocessed,\n    instances: Mat4[],\n    descriptorMap: DescriptorMap,\n    device: GPUDevice,\n): Promise<{ drawData?: PrimitiveDrawData, material?: GLTFMaterialPostprocessed }> {\n    const attributes = primitive.attributes as Partial<Record<PrimitiveAttributeKey, GLTFAccessorPostprocessed>>;\n    if (attributes.POSITION == null) return {};\n\n    const { indices } = primitive;\n    const atrs = mapValues(attributes, (atr) => new AttributeWrapper(atr as GLTFAccessorPostprocessed));\n    let { mode } = primitive;\n    let vertexCount = attributes.POSITION.count;\n    let indexArray: TypedArray | undefined;\n    let indexFormat: GPUIndexFormat | undefined;\n\n    if (indices != null) {\n        ({ indexArray, indexFormat } = wrapIndices(indices));\n\n        if (\n            mode !== TopologyMode.Points\n            && mode !== TopologyMode.LineList\n            && mode !== TopologyMode.TriangleList\n        ) {\n            ({ indexArray, indexFormat, mode } = reindex(indices, mode));\n        }\n    }\n\n    if (atrs.NORMAL != null && atrs.TANGENT == null) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (atrs.TEXCOORD_0 != null) {\n            if (indexArray != null) {\n                vertexCount = indexArray.length;\n                for (const atr of Object.values(atrs)) {\n                    atr.unweld(indexArray);\n                }\n            }\n\n            const start = Date.now();\n\n            const tangent = await generateTangentsAsync.then((func) => func(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                atrs.POSITION!.array,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                atrs.NORMAL!.array,\n                atrs.TEXCOORD_0.array,\n            ));\n\n            for (let i = 3; i < tangent.length; i += 4) {\n                tangent[i] *= -1;\n            }\n            console.log(`tangents generated in ${Date.now() - start}`);\n\n            atrs.TANGENT = new AttributeWrapper(tangent, 4);\n\n            ({ indexArray, indexFormat, vertexCount } = weld(atrs));\n            mode = TopologyMode.TriangleList;\n        } else {\n            const tangent = new Float32Array(vertexCount * 4);\n            for (let i = 0; i < vertexCount; i += 1) {\n                tangent.set([1, 0, 0, 1], i * 4);\n            }\n            atrs.TANGENT = new AttributeWrapper(tangent, 4);\n        }\n    }\n\n    const { vertexArray, vertexFeatures } = interleaveVertices(atrs, vertexCount);\n    let features = getCullMode(instances) | vertexFeatures;\n    if (mode != null) features |= modeToTopology[mode as TopologyMode] || 0;\n\n    const drawData = new PrimitiveDrawData({\n        features,\n        indexArray,\n        indexFormat,\n        vertexCount,\n        vertexArray,\n    }, device, instances.length, descriptorMap, instances);\n\n    return { material: primitive.material, drawData };\n}\n","import AttributeWrapper from './attribute-wrapper';\nimport { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\n\n// const goalLayout: AttributeDetails[] = [\n//     {\n//         name: 'POSITION',\n//         type: 'VEC3',\n//         componentType: ComponentType.float32,\n//     },\n//     {\n//         name: 'TEXCOORD_0',\n//         type: 'VEC2',\n//         componentType: ComponentType.float32,\n//     },\n//     {\n//         name: 'TANGENT',\n//         type: 'VEC4',\n//         componentType: ComponentType.float32,\n//         depends: ['NORMAL'],\n//         fill: [1, 0, 0, 1],\n//     },\n//     {\n//         name: 'NORMAL',\n//         type: 'VEC3',\n//         componentType: ComponentType.float32,\n//         strip: true,\n//         feature: PipelineFeatureFlags.VertexNormals,\n//     },\n//     {\n//         name: 'COLOR_0',\n//         type: 'VEC4',\n//         componentType: ComponentType.float32,\n//         strip: true,\n//         feature: PipelineFeatureFlags.VertexColors,\n//         fill: [1, 1, 1, 1],\n//     },\n// ];\n\nexport default function interleaveVertices(\n    attributes: Partial<Record<string, AttributeWrapper>>,\n    count: number,\n) {\n    let vertexFeatures: PipelineFeatureFlags = PipelineFeatureFlags.Defaults;\n    let stride = 5;\n    if (attributes.NORMAL != null) stride += 7;\n    if (attributes.COLOR_0 != null) stride += 4;\n\n    const vertexArray = new ArrayBuffer(stride * count * 4);\n    const vertexView = new Float32Array(vertexArray);\n\n    for (let i = 0; i < count; i += 1) {\n        attributes.POSITION?.copyFrom(i, stride * i, vertexView);\n    }\n\n    const uv = attributes.TEXCOORD_0 ?? new AttributeWrapper(new Float32Array(count * 2), 2);\n    for (let i = 0; i < count; i += 1) {\n        uv.copyFrom(i, i * stride + 3, vertexView);\n    }\n\n    if (attributes.NORMAL != null && attributes.TANGENT != null) {\n        vertexFeatures |= PipelineFeatureFlags.VertexNormals;\n\n        for (let i = 0; i < count; i += 1) {\n            attributes.TANGENT.copyFrom(i, i * stride + 5, vertexView);\n        }\n\n        for (let i = 0; i < count; i += 1) {\n            attributes.NORMAL.copyFrom(i, i * stride + 9, vertexView);\n        }\n    }\n\n    if (attributes.COLOR_0 != null) {\n        vertexFeatures |= PipelineFeatureFlags.VertexColors;\n        const step = attributes.NORMAL != null ? 12 : 5;\n        for (let i = 0; i < count; i += 1) {\n            attributes.COLOR_0.copyFrom(i, i * stride + step, vertexView);\n            vertexView[i * stride + step + 3] = 1;\n        }\n    }\n\n    return { vertexArray, vertexFeatures };\n}\n","import { GLTFMaterialPostprocessed, GLTFSampler, GLTFTexturePostprocessed } from '@loaders.gl/gltf';\n\nimport { vec3 } from 'wgpu-matrix';\nimport { MaterialDescriptor } from '../../../core/default-forward-pass/material-draw-data';\nimport { imageToTexture } from '../../../utils/texture-importing';\n\nconst DEFAULT_METALLIC = 0.0;\nconst DEFAULT_ROUGHNESS = 1.0;\n\nconst gltfToMagDescription: Record<number, GPUFilterMode> = {\n    9728: 'nearest',\n    9729: 'linear',\n    9984: 'nearest', // NEAREST_MIPMAP_NEAREST\n    9985: 'linear', // LINEAR_MIPMAP_NEAREST\n    9986: 'nearest', // NEAREST_MIPMAP_LINEAR\n    9987: 'linear', // LINEAR_MIPMAP_LINEAR\n};\n\nconst gltfToMipDescription: Partial<Record<number, GPUFilterMode>> = {\n    9984: 'nearest', // NEAREST_MIPMAP_NEAREST\n    9985: 'nearest', // LINEAR_MIPMAP_NEAREST\n    9986: 'linear', // NEAREST_MIPMAP_LINEAR\n    9987: 'linear', // LINEAR_MIPMAP_LINEAR\n};\n\nconst gltfToAddressMode: Record<number, GPUAddressMode> = {\n    33071: 'clamp-to-edge', // CLAMP_TO_EDGE\n    33648: 'mirror-repeat', // MIRRORED_REPEAT\n    10497: 'repeat', // REPEAT\n};\n\nfunction toSamplerDescription(sampler: GLTFSampler): GPUSamplerDescriptor {\n    const { magFilter, minFilter, wrapS, wrapT } = sampler;\n\n    return {\n        addressModeU: gltfToAddressMode[wrapS ?? 10497],\n        addressModeV: gltfToAddressMode[wrapT ?? 10497],\n        minFilter: gltfToMagDescription[minFilter ?? 9987],\n        magFilter: gltfToMagDescription[magFilter ?? 9729],\n        mipmapFilter: gltfToMipDescription[minFilter ?? 9987] ?? 'linear',\n    };\n}\n\nfunction getImageData(handle: GLTFTexturePostprocessed) {\n    const { source, sampler } = handle;\n    if (source == null) return {};\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const data = source.image.data ?? source.bufferView?.data;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (data == null) return {};\n\n    return { data, mimeType: source.mimeType, sampler };\n}\n\nexport default async function loadMaterial(\n    material: GLTFMaterialPostprocessed,\n    defaultMaterial: MaterialDescriptor,\n    device: GPUDevice,\n): Promise<MaterialDescriptor> {\n    const mat: Partial<MaterialDescriptor> = {};\n    if (material.pbrMetallicRoughness != null) {\n        const {\n            baseColorFactor,\n            baseColorTexture,\n            metallicFactor,\n            metallicRoughnessTexture,\n            roughnessFactor,\n        } = material.pbrMetallicRoughness;\n\n        if (metallicRoughnessTexture?.texture.source == null) {\n            if (metallicFactor == null) mat.metallicFactor = DEFAULT_METALLIC;\n            if (roughnessFactor == null) mat.roughnessFactor = DEFAULT_ROUGHNESS;\n        } else {\n            const { data, mimeType, sampler } = getImageData(metallicRoughnessTexture.texture);\n            if (data != null) {\n                mat.metallicRoughnessTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                });\n                if (sampler) mat.metallicRoughnessSampler = toSamplerDescription(sampler);\n            }\n        }\n\n        if (baseColorTexture?.texture.source != null) {\n            const { data, mimeType, sampler } = getImageData(baseColorTexture.texture);\n            if (data != null) {\n                mat.baseColorTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                    srgbToLinear: true,\n                });\n                if (sampler) mat.baseColorSampler = toSamplerDescription(sampler);\n            }\n        }\n\n        if (baseColorFactor != null) mat.baseColorFactor = baseColorFactor;\n        if (metallicFactor != null) mat.metallicFactor = metallicFactor;\n        if (roughnessFactor != null) mat.metallicFactor = roughnessFactor;\n    } else {\n        mat.metallicFactor = DEFAULT_METALLIC;\n        mat.roughnessFactor = DEFAULT_ROUGHNESS;\n    }\n\n    if (material.normalTexture?.texture.source != null) {\n        const { data, mimeType, sampler } = getImageData(material.normalTexture.texture);\n\n        if (data != null) {\n            mat.normalTexture = await imageToTexture({\n                label: `${material.id} mr texture`,\n                data,\n                mimeType,\n                usage: GPUTextureUsage.TEXTURE_BINDING,\n                device,\n            });\n            if (sampler) mat.normalSampler = toSamplerDescription(sampler);\n        }\n    }\n\n    const { emissiveFactor, emissiveTexture } = material;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    const emissiveStrength = material.extensions?.KHR_materials_emissive_strength?.emissiveStrength;\n\n    if (emissiveTexture != null || emissiveFactor?.some((x) => x > 0)) {\n        mat.emissiveFactor = emissiveFactor ?? [1, 1, 1];\n        mat.emissiveSampler = { magFilter: 'linear', minFilter: 'linear' };\n\n        if (emissiveTexture?.texture.source != null) {\n            const { data, mimeType, sampler } = getImageData(emissiveTexture.texture);\n            if (data != null) {\n                mat.emissiveTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                    srgbToLinear: true,\n                });\n                if (sampler) mat.emissiveSampler = toSamplerDescription(sampler);\n            }\n        } else {\n            mat.emissiveTexture = defaultMaterial.baseColorTexture;\n        }\n\n        if (emissiveStrength != null && typeof emissiveStrength === 'number') {\n            vec3.scale(mat.emissiveFactor, emissiveStrength, mat.emissiveFactor);\n        }\n    }\n\n    if (material.doubleSided) mat.doubleSided = true;\n    if (material.alphaMode === 'MASK') mat.alphaCutoff = material.alphaCutoff ?? 0.5;\n\n    return { ...defaultMaterial, ...mat };\n}\n","import { Vec3n, Vec4n } from 'wgpu-matrix';\nimport DescriptorMap from './descriptor-map';\nimport { featureFlagsToString, PipelineFeatureFlags } from './pipeline-feature-flags';\nimport { PrimitiveDrawData } from './primitive-draw-data';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\n\nexport type MaterialDescriptor = {\n    name?: string,\n\n    baseColorFactor: Vec4n,\n    baseColorTexture: GPUTexture,\n    baseColorSampler: GPUSamplerDescriptor,\n\n    roughnessFactor: number,\n    metallicFactor: number,\n    metallicRoughnessTexture: GPUTexture,\n    metallicRoughnessSampler: GPUSamplerDescriptor,\n\n    normalTexture: GPUTexture,\n    normalSampler: GPUSamplerDescriptor,\n\n    alphaCutoff?: number,\n\n    emissiveFactor?: Vec3n,\n    emissiveTexture?: GPUTexture,\n    emissiveSampler?: GPUSamplerDescriptor,\n\n    doubleSided?: boolean,\n};\n\nexport class MaterialDrawData {\n    layout: GPUBindGroupLayout;\n    primitives: PrimitiveDrawData[] = [];\n    matData: MaterialDescriptor;\n    bindGroup: GPUBindGroup;\n    propertiesBuffer: GPUBuffer;\n    features: PipelineFeatureFlags;\n\n    constructor(\n        data: MaterialDescriptor,\n        device: GPUDevice,\n        descriptorMap: DescriptorMap,\n        primitiveFeatures: PipelineFeatureFlags,\n        primitives?: PrimitiveDrawData[],\n    ) {\n        this.features = primitiveFeatures;\n        if (data.doubleSided) this.features |= PipelineFeatureFlags.DoubleSided;\n\n        // TODO : don't hardcode the properties features\n        const properties = new Float32Array(12);\n        properties.set(data.baseColorFactor);\n        properties[4] = data.metallicFactor;\n        properties[5] = data.roughnessFactor;\n\n        if (data.alphaCutoff != null) {\n            this.features |= PipelineFeatureFlags.AlphaCutoff;\n            properties[6] = data.alphaCutoff;\n        }\n\n        if (data.emissiveFactor != null) {\n            properties.set(data.emissiveFactor, 8);\n        }\n\n        this.propertiesBuffer = createAndCopyBuffer(\n            properties,\n            GPUBufferUsage.UNIFORM,\n            device,\n        );\n\n        const entries = [\n            { binding: 0, resource: { buffer: this.propertiesBuffer } },\n            { binding: 1, resource: descriptorMap.getSampler(data.baseColorSampler) },\n            { binding: 2, resource: data.baseColorTexture.createView({ dimension: '2d' }) },\n            { binding: 3, resource: descriptorMap.getSampler(data.normalSampler) },\n            { binding: 4, resource: data.normalTexture.createView({ dimension: '2d' }) },\n            { binding: 5, resource: descriptorMap.getSampler(data.metallicRoughnessSampler) },\n            { binding: 6, resource: data.metallicRoughnessTexture.createView({ dimension: '2d' }) },\n        ];\n\n        if (data.emissiveTexture != null) {\n            this.features |= PipelineFeatureFlags.Emissive;\n\n            entries.push({\n                binding: 7,\n                resource: descriptorMap.getSampler(data.emissiveSampler ?? {}),\n            });\n\n            entries.push({\n                binding: 8,\n                resource: data.emissiveTexture.createView({ dimension: '2d' }),\n            });\n        }\n\n        this.layout = descriptorMap.getMaterialBindGroup(this.features);\n        this.matData = data;\n        this.bindGroup = device.createBindGroup({\n            label: featureFlagsToString(this.features),\n            layout: this.layout,\n            entries,\n        });\n\n        if (primitives != null) {\n            this.addPrimitives(...primitives);\n        }\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        if (this.primitives.length === 0) return;\n\n        passEncoder.setBindGroup(1, this.bindGroup);\n        for (const primitive of this.primitives) {\n            primitive.draw(passEncoder, queue);\n        }\n    }\n\n    addPrimitives(...drawData: PrimitiveDrawData[]) {\n        const filtered = drawData.filter((data) => {\n            if ((data.features & this.features) === data.features) return true;\n            console.warn(`invalid primitive added to material: \nprimitive: ${data.name}\nprimitive features: ${featureFlagsToString(data.features).toString()}\nmaterial: ${this.matData.name}\nmaterial features: ${featureFlagsToString(this.features).toString()}`);\n            return false;\n        });\n        this.primitives.push(...filtered);\n    }\n}\n","import DescriptorMap from './descriptor-map';\nimport { MaterialDrawData } from './material-draw-data';\nimport { PipelineFeatureFlags, featureFlagsToString, maskRedundantFeatures } from './pipeline-feature-flags';\n\nexport default class GeometryPipeline {\n    features: PipelineFeatureFlags;\n    pipeline: GPURenderPipeline;\n\n    materials: MaterialDrawData[] = [];\n\n    constructor(features: PipelineFeatureFlags, maps: DescriptorMap) {\n        this.features = maskRedundantFeatures(features);\n\n        const module = maps.getShaderModule(features);\n\n        this.pipeline = maps.device.createRenderPipeline({\n            label: featureFlagsToString(features),\n            layout: maps.getForwardPipelineLayout(features),\n            primitive: maps.getPrimitiveState(features),\n            vertex: {\n                entryPoint: 'vs',\n                buffers: [maps.getVertexLayout(features)],\n                module,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                module,\n                targets: maps.gbuffer.targets,\n            },\n            depthStencil: {\n                depthWriteEnabled: true,\n                depthCompare: 'less-equal',\n                format: maps.gbuffer.depth.format,\n            },\n        });\n    }\n\n    addMaterials(...materials: MaterialDrawData[]) {\n        if (materials.some((data) => data.features !== this.features)) {\n            throw new Error('invalid primitive added to material');\n        }\n        this.materials.push(...materials);\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        passEncoder.setPipeline(this.pipeline);\n        for (const mat of this.materials) {\n            mat.draw(passEncoder, queue);\n        }\n    }\n}\n","import { Mat4, mat4, Mat4Arg, Mat4Type, quat } from 'wgpu-matrix';\nimport { DataType, load } from '@loaders.gl/core';\nimport { GLTFLoader, GLTFMeshPostprocessed, GLTFNodePostprocessed, postProcessGLTF } from '@loaders.gl/gltf';\n\nimport { ComponentType, AttributeDetails } from './type-conversions';\nimport loadPrimitive from './primitive-loader';\nimport loadMaterial from './material-loader';\n\nimport { MaterialDescriptor, MaterialDrawData } from '../../../core/default-forward-pass/material-draw-data';\nimport { PipelineFeatureFlags } from '../../../core/default-forward-pass/pipeline-feature-flags';\nimport { PrimitiveDrawData } from '../../../core/default-forward-pass/primitive-draw-data';\nimport DescriptorMap from '../../../core/default-forward-pass/descriptor-map';\nimport GeometryPipeline from '../../../core/default-forward-pass/geometry-pipeline';\n\nconst defaultLayout: AttributeDetails[] = [\n    {\n        name: 'POSITION',\n        type: 'VEC3',\n        componentType: ComponentType.float32,\n    },\n    {\n        name: 'TEXCOORD_0',\n        type: 'VEC2',\n        componentType: ComponentType.float32,\n    },\n    {\n        name: 'TANGENT',\n        type: 'VEC4',\n        componentType: ComponentType.float32,\n        depends: ['NORMAL'],\n        fill: [1, 0, 0, 1],\n    },\n    {\n        name: 'NORMAL',\n        type: 'VEC3',\n        componentType: ComponentType.float32,\n        strip: true,\n        feature: PipelineFeatureFlags.VertexNormals,\n    },\n    {\n        name: 'COLOR_0',\n        type: 'VEC4',\n        componentType: ComponentType.float32,\n        strip: true,\n        feature: PipelineFeatureFlags.VertexColors,\n        fill: [1, 1, 1, 1],\n    },\n];\n\nconst recurseNode = (\n    parentMatrix: Mat4Type<Mat4Arg>,\n    meshes: Map<GLTFMeshPostprocessed, Mat4Type<Mat4Arg>[]>,\n) => (node: GLTFNodePostprocessed) => {\n    const matrix = node.matrix ?? mat4.identity();\n\n    if (node.matrix == null) {\n        if (node.scale) mat4.scaling(node.scale, matrix);\n\n        if (node.rotation) {\n            const { axis, angle } = quat.toAxisAngle(node.rotation);\n            mat4.rotate(matrix, axis, angle, matrix);\n        }\n\n        if (node.translation != null) {\n            mat4.setTranslation(matrix, node.translation, matrix);\n        }\n    }\n\n    mat4.mul(parentMatrix, matrix, matrix);\n\n    if (node.mesh != null) {\n        if (!meshes.has(node.mesh)) meshes.set(node.mesh, []);\n        meshes.get(node.mesh)!.push(matrix); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    }\n\n    node.children?.forEach(recurseNode(matrix, meshes));\n};\n\nexport default async function importGltf(\n    url: string | DataType,\n    device: GPUDevice,\n    descriptorMap: DescriptorMap,\n    defaultMaterial: MaterialDescriptor,\n    layout: AttributeDetails[] = defaultLayout,\n    pipelines: Partial<Record<number, GeometryPipeline>> = {},\n    // eslint-disable-next-line no-console\n    log: ((msg: unknown) => void) = console.log,\n) {\n    log('starting import');\n\n    const start = Date.now();\n    const gltfWithBuffers = await load(url, GLTFLoader);\n    log(`finished loading: ${Date.now() - start}`);\n\n    const { scene } = postProcessGLTF(gltfWithBuffers);\n    if (scene?.nodes == null) return pipelines;\n    log(`finished processing: ${Date.now() - start}`);\n\n    const meshes = new Map<GLTFMeshPostprocessed, Mat4[]>();\n    scene.nodes.forEach(recurseNode(mat4.identity(), meshes));\n    log(`finished creating instances: ${Date.now() - start}`);\n\n    const meshEntries = Array.from(meshes.entries());\n    const primitivePromises = meshEntries.flatMap(([{ primitives }, instances]) =>\n        primitives.map((prim) => loadPrimitive(\n            layout,\n            prim,\n            instances,\n            descriptorMap,\n            device,\n        )),\n    );\n\n    const primitiveDescriptors = await Promise.all(primitivePromises);\n    log(`finished creating primitives: ${Date.now() - start}`);\n\n    type MaterialKey = { materialId?: string, features: number };\n    const materialMap = new Map<MaterialKey, PrimitiveDrawData[]>();\n    const materialPromises: Record<string, Promise<MaterialDescriptor>> = {};\n\n    for (const { material, drawData } of primitiveDescriptors) {\n        if (drawData == null) continue;\n\n        const key = { materialId: material?.id, features: drawData.features };\n        if (!materialMap.has(key)) materialMap.set(key, []);\n        materialMap.get(key)!.push(drawData); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n\n        if (material != null) {\n            materialPromises[material.id] = loadMaterial(material, defaultMaterial, device);\n        }\n    }\n\n    const materialEntries = Object.entries(materialPromises)\n        .map(async ([id, mat]) => [id, await mat]);\n\n    const materialDescriptors = Object.fromEntries(await Promise.all(materialEntries)) as Record<string, MaterialDescriptor>;\n    log(`finished creating material descriptors: ${Date.now() - start}`);\n\n    const fullDefaultMat: MaterialDescriptor = { ...defaultMaterial, metallicFactor: 0 };\n\n    for (const [{ features, materialId }, drawDatas] of materialMap.entries()) {\n        const descriptor = materialId != null ? materialDescriptors[materialId] : fullDefaultMat;\n        const mat = new MaterialDrawData(descriptor, device, descriptorMap, features, drawDatas);\n        const { features: f } = mat;\n\n        pipelines[f] ??= new GeometryPipeline(f, descriptorMap);\n        pipelines[f].addMaterials(mat);\n    }\n\n    log(`finished: ${Date.now() - start}`);\n    return pipelines;\n}\n","import { Vec3, Mat4, mat4, Quat } from 'wgpu-matrix';\r\nimport { TypeSizes } from '../constants';\r\n\r\nexport type CameraParams = {\r\n    nearPlane: number,\r\n    farPlane: number,\r\n    fov: number,\r\n    width: number,\r\n    height: number,\r\n    projection: 'perspective' | 'ortho',\r\n};\r\n\r\nexport default class Camera {\r\n    static readonly worldToViewOffset = 0;\r\n    static readonly viewToClipOffset = this.worldToViewOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly worldToClipOffset = this.viewToClipOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly viewToWorldOffset = this.worldToClipOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly clipToViewOffset = this.viewToWorldOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly clipToWorldOffset = this.clipToViewOffset + TypeSizes.sizeofMat4x4f;\r\n\r\n    static readonly bufferLength = this.clipToWorldOffset + TypeSizes.sizeofMat4x4f;\r\n\r\n    /**\r\n   *  An ArrayBuffer containing the camera's worldToView, viewToClip, worldToClip,\r\n   *  viewToWorld, clipToView, and clipToWorld matrices as Float32Arrays for\r\n   *  easier transfer. Ordered as listed above.\r\n   */\r\n    readonly buffer: ArrayBuffer = new ArrayBuffer(Camera.bufferLength);\r\n\r\n    readonly worldToView: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.worldToViewOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly viewToClip: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.viewToClipOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly worldToClip: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.worldToClipOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly viewToWorld: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.viewToWorldOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly clipToView: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.clipToViewOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly clipToWorld: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.clipToWorldOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly location: Vec3 = new Float32Array([0, 0, 0]);\r\n    readonly rotation: Quat = new Float32Array([0, 0, 0, 1]);\r\n\r\n    params: CameraParams = {\r\n        nearPlane: 0.01,\r\n        farPlane: 500.0,\r\n        fov: 40,\r\n        width: 1920,\r\n        height: 1080,\r\n        projection: 'perspective',\r\n    };\r\n\r\n    constructor(viewParams: Partial<CameraParams> = {}) {\r\n        this.updateParams(viewParams);\r\n    }\r\n\r\n    updateParams(val: Partial<CameraParams>) {\r\n        this.params = { ...this.params, ...val };\r\n        this.#cacheProjection();\r\n    }\r\n\r\n    cacheView(): void {\r\n        mat4.fromQuat(this.rotation, this.viewToWorld);\r\n        mat4.setTranslation(this.viewToWorld, this.location, this.viewToWorld);\r\n        mat4.invert(this.viewToWorld, this.worldToView);\r\n        mat4.mul(this.viewToClip, this.worldToView, this.worldToClip);\r\n        mat4.mul(this.viewToWorld, this.clipToView, this.clipToWorld);\r\n    }\r\n\r\n    #cacheProjection(): void {\r\n        if (this.params.projection === 'perspective') {\r\n            mat4.perspective(\r\n                this.params.fov * (Math.PI / 180),\r\n                this.params.width / this.params.height,\r\n                this.params.nearPlane,\r\n                this.params.farPlane,\r\n                this.viewToClip,\r\n            );\r\n        } else {\r\n            const x = this.params.width / 2;\r\n            const y = this.params.height / 2;\r\n\r\n            mat4.ortho(\r\n                -x,\r\n                x,\r\n                -y,\r\n                y,\r\n                this.params.nearPlane,\r\n                this.params.farPlane,\r\n                this.viewToClip,\r\n            );\r\n        }\r\n\r\n        mat4.invert(this.viewToClip, this.clipToView);\r\n    }\r\n}\r\n","export type UnknownObject = Record<PropertyKey, unknown>;\r\n\r\nexport function mapValues<Input, ObjectType extends Partial<Record<keyof ObjectType, Input>>, Output>(\r\n    obj: ObjectType,\r\n    fn: (val: Input) => Output,\r\n) {\r\n    const entries = Object.entries(obj) as [keyof ObjectType, Input][];\r\n    const mapped = entries.map(([key, val]) => [key, fn(val)]);\r\n    return Object.fromEntries(mapped) as { [K in keyof ObjectType]: Output };\r\n}\r\n\r\nexport function clamp(num: number, min: number, max: number) {\r\n    return Math.max(min, Math.min(max, num));\r\n}\r\n\r\nexport function padCheck(str: string | undefined) {\r\n    return str == null || str === '' ? '' : ` ${str}`;\r\n}\r\n\r\nexport function padTemplate(strings: TemplateStringsArray, ...values: (string | undefined)[]) {\r\n    const result = [strings[0]];\r\n    values.forEach((key, i) => result.push(padCheck(key), strings[i + 1]));\r\n    return result.join('');\r\n}\r\n\r\nexport function range(n: number) {\r\n    return [...Array(n).keys()];\r\n}\r\n\r\nexport function mapRange<T>(n: number, fn: (i: number) => T) {\r\n    return range(n).map(fn);\r\n}\r\n\r\nexport function debounce<Args extends Array<unknown>>(callback: (...args: Args) => unknown, delay: number) {\r\n    let tid: ReturnType<typeof setTimeout> | undefined;\r\n    return function (...args: Args) {\r\n        const ctx = self;\r\n        if (tid != null) clearTimeout(tid);\r\n        tid = setTimeout(() => { callback.apply(ctx, args); }, delay);\r\n    };\r\n};\r\n\r\n// adapted from https://stackoverflow.com/a/60702475/17108769\r\nexport function binaryInsert<T>(\r\n    arr: T[],\r\n    element: T,\r\n    comparator: (a: T, b: T) => number,\r\n    left = 0,\r\n    right = arr.length - 1,\r\n) {\r\n    if (right - left <= 1) {\r\n        if (comparator(element, arr[left] ?? element) < 0) arr.splice(left, 0, element);\r\n        else if (comparator(element, arr[right] ?? element) > 0) arr.splice(right + 1, 0, element);\r\n        else arr.splice(right, 0, element);\r\n    } else {\r\n        const pivot = Math.floor((right - left) / 2) + left;\r\n        if (comparator(element, arr[pivot]) < 0) binaryInsert(arr, element, comparator, left, pivot);\r\n        else binaryInsert(arr, element, comparator, pivot, right);\r\n    }\r\n}\r\n\r\nexport function isObject(val: unknown): val is NonNullable<UnknownObject> {\r\n    return typeof val === 'object' && val != null;\r\n}\r\n","import * as ktxp from 'ktx-parse';\r\n\r\nexport const TypeSizes = {\r\n    mat4x4Count: 16,\r\n    sizeofMat4x4f: 16 * Float32Array.BYTES_PER_ELEMENT,\r\n};\r\n\r\nexport const VkFormatToWebGPU: Record<number, GPUTextureFormat | undefined> = {\r\n    // 8-bit formats\r\n    [ktxp.VK_FORMAT_R8_UNORM]: 'r8unorm',\r\n    [ktxp.VK_FORMAT_R8_SNORM]: 'r8snorm',\r\n    [ktxp.VK_FORMAT_R8_UINT]: 'r8uint',\r\n    [ktxp.VK_FORMAT_R8_SINT]: 'r8sint',\r\n    // 16-bit formats\r\n    [ktxp.VK_FORMAT_R16_UINT]: 'r16uint',\r\n    [ktxp.VK_FORMAT_R16_SINT]: 'r16sint',\r\n    [ktxp.VK_FORMAT_R16_SFLOAT]: 'r16float',\r\n    [ktxp.VK_FORMAT_R8G8_UNORM]: 'rg8unorm',\r\n    [ktxp.VK_FORMAT_R8G8_SNORM]: 'rg8snorm',\r\n    [ktxp.VK_FORMAT_R8G8_UINT]: 'rg8uint',\r\n    [ktxp.VK_FORMAT_R8G8_SINT]: 'rg8sint',\r\n    // 32-bit formats\r\n    [ktxp.VK_FORMAT_R32_UINT]: 'r32uint',\r\n    [ktxp.VK_FORMAT_R32_SINT]: 'r32sint',\r\n    [ktxp.VK_FORMAT_R32_SFLOAT]: 'r32float',\r\n    [ktxp.VK_FORMAT_R16G16_UINT]: 'rg16uint',\r\n    [ktxp.VK_FORMAT_R16G16_SINT]: 'rg16sint',\r\n    [ktxp.VK_FORMAT_R16G16_SFLOAT]: 'rg16float',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UNORM]: 'rgba8unorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SRGB]: 'rgba8unorm-srgb',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SNORM]: 'rgba8snorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UINT]: 'rgba8uint',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SINT]: 'rgba8sint',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_UNORM]: 'bgra8unorm',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_SRGB]: 'bgra8unorm-srgb',\r\n    // Packed 32-bit formats\r\n    [ktxp.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32]: 'rgb9e5ufloat',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UINT_PACK32]: 'rgb10a2uint',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UNORM_PACK32]: 'rgb10a2unorm',\r\n    [ktxp.VK_FORMAT_B10G11R11_UFLOAT_PACK32]: 'rg11b10ufloat',\r\n    // 64-bit formats\r\n    [ktxp.VK_FORMAT_R32G32_UINT]: 'rg32uint',\r\n    [ktxp.VK_FORMAT_R32G32_SINT]: 'rg32sint',\r\n    [ktxp.VK_FORMAT_R32G32_SFLOAT]: 'rg32float',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_UINT]: 'rgba16uint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SINT]: 'rgba16sint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SFLOAT]: 'rgba16float',\r\n    // 128-bit formats\r\n    [ktxp.VK_FORMAT_R32G32B32A32_UINT]: 'rgba32uint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SINT]: 'rgba32sint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SFLOAT]: 'rgba32float',\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    [ktxp.VK_FORMAT_BC1_RGBA_UNORM_BLOCK]: 'bc1-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC1_RGBA_SRGB_BLOCK]: 'bc1-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC2_UNORM_BLOCK]: 'bc2-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC2_SRGB_BLOCK]: 'bc2-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC3_UNORM_BLOCK]: 'bc3-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC3_SRGB_BLOCK]: 'bc3-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC4_UNORM_BLOCK]: 'bc4-r-unorm',\r\n    [ktxp.VK_FORMAT_BC4_SNORM_BLOCK]: 'bc4-r-snorm',\r\n    [ktxp.VK_FORMAT_BC5_UNORM_BLOCK]: 'bc5-rg-unorm',\r\n    [ktxp.VK_FORMAT_BC5_SNORM_BLOCK]: 'bc5-rg-snorm',\r\n    [ktxp.VK_FORMAT_BC6H_UFLOAT_BLOCK]: 'bc6h-rgb-ufloat',\r\n    [ktxp.VK_FORMAT_BC6H_SFLOAT_BLOCK]: 'bc6h-rgb-float',\r\n    [ktxp.VK_FORMAT_BC7_UNORM_BLOCK]: 'bc7-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC7_SRGB_BLOCK]: 'bc7-rgba-unorm-srgb',\r\n    // Currently unsupported extension formats:\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"etc2-rgb8unorm\",\r\n    // \"etc2-rgb8unorm-srgb\",\r\n    // \"etc2-rgb8a1unorm\",\r\n    // \"etc2-rgb8a1unorm-srgb\",\r\n    // \"etc2-rgba8unorm\",\r\n    // \"etc2-rgba8unorm-srgb\",\r\n    // \"eac-r11unorm\",\r\n    // \"eac-r11snorm\",\r\n    // \"eac-rg11unorm\",\r\n    // \"eac-rg11snorm\",\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"astc-4x4-unorm\",\r\n    // \"astc-4x4-unorm-srgb\",\r\n    // \"astc-5x4-unorm\",\r\n    // \"astc-5x4-unorm-srgb\",\r\n    // \"astc-5x5-unorm\",\r\n    // \"astc-5x5-unorm-srgb\",\r\n    // \"astc-6x5-unorm\",\r\n    // \"astc-6x5-unorm-srgb\",\r\n    // \"astc-6x6-unorm\",\r\n    // \"astc-6x6-unorm-srgb\",\r\n    // \"astc-8x5-unorm\",\r\n    // \"astc-8x5-unorm-srgb\",\r\n    // \"astc-8x6-unorm\",\r\n    // \"astc-8x6-unorm-srgb\",\r\n    // \"astc-8x8-unorm\",\r\n    // \"astc-8x8-unorm-srgb\",\r\n    // \"astc-10x5-unorm\",\r\n    // \"astc-10x5-unorm-srgb\",\r\n    // \"astc-10x6-unorm\",\r\n    // \"astc-10x6-unorm-srgb\",\r\n    // \"astc-10x8-unorm\",\r\n    // \"astc-10x8-unorm-srgb\",\r\n    // \"astc-10x10-unorm\",\r\n    // \"astc-10x10-unorm-srgb\",\r\n    // \"astc-12x10-unorm\",\r\n    // \"astc-12x10-unorm-srgb\",\r\n    // \"astc-12x12-unorm\",\r\n};\r\n\r\nexport const TextureFormatToSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 2,\r\n    rg8snorm: 2,\r\n    rg8uint: 2,\r\n    rg8sint: 2,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 4,\r\n    rg16sint: 4,\r\n    rg16float: 4,\r\n    rgba8unorm: 4,\r\n    'rgba8unorm-srgb': 4,\r\n    rgba8snorm: 4,\r\n    rgba8uint: 4,\r\n    rgba8sint: 4,\r\n    bgra8unorm: 4,\r\n    'bgra8unorm-srgb': 4,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 8,\r\n    rg32sint: 8,\r\n    rg32float: 8,\r\n    rgba16uint: 8,\r\n    rgba16sint: 8,\r\n    rgba16float: 8,\r\n    // 128-bit formats\r\n    rgba32uint: 16,\r\n    rgba32sint: 16,\r\n    rgba32float: 16,\r\n};\r\n\r\nexport const TextureFormatToChannelSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 1,\r\n    rg8snorm: 1,\r\n    rg8uint: 1,\r\n    rg8sint: 1,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 2,\r\n    rg16sint: 2,\r\n    rg16float: 2,\r\n    rgba8unorm: 1,\r\n    'rgba8unorm-srgb': 1,\r\n    rgba8snorm: 1,\r\n    rgba8uint: 1,\r\n    rgba8sint: 1,\r\n    bgra8unorm: 1,\r\n    'bgra8unorm-srgb': 1,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 4,\r\n    rg32sint: 4,\r\n    rg32float: 4,\r\n    rgba16uint: 2,\r\n    rgba16sint: 2,\r\n    rgba16float: 2,\r\n    // 128-bit formats\r\n    rgba32uint: 4,\r\n    rgba32sint: 4,\r\n    rgba32float: 4,\r\n};\r\n\r\nexport const WebGPUToVkFormat = Object.fromEntries(\r\n    Object.entries(VkFormatToWebGPU).map(([vk, wgpu]) => [wgpu, parseInt(vk, 10)]),\r\n) as Record<GPUTextureFormat, ktxp.VKFormat>;\r\n\r\nexport const textureTypeToDimension: Record<string, GPUTextureViewDimension> = {\r\n    texture_cube: 'cube',\r\n    texture_3d: '3d',\r\n    texture_2d: '2d',\r\n};\r\n","import blit from '../shaders/blit-vert.shader';\nimport { toWorldDir } from '../shaders/cubemap-sampling.shader';\nimport { createAndCopyBuffer } from './data-copy';\nimport { padTemplate } from '../../utils/general';\n\ntype EquirectangularDescriptor = {\n    data: SharedArrayBuffer | BufferSource | GPUTexture,\n    width: number,\n    height: number,\n    gamma?: number,\n    exposure?: number,\n};\n\nexport async function equirectangularToCubemap(\n    device: GPUDevice,\n    { data, width, height, gamma = 1, exposure = 1 }: EquirectangularDescriptor,\n    outputDescriptor: Omit<GPUTextureDescriptor, 'dimension' | 'size'>,\n) {\n    const code = /* wgsl */ `\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${blit}\n        ${toWorldDir}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;\n\n    let FLIP_Y = 0;\n    let equirectangular: GPUTexture;\n    if (data instanceof GPUTexture) {\n        equirectangular = data;\n    } else {\n        FLIP_Y = 1;\n        equirectangular = device.createTexture({\n            label: `${outputDescriptor.label} equirectangular`,\n            dimension: '2d',\n            format: 'rgba16float',\n            size: { width, height },\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        device.queue.writeTexture(\n            { texture: equirectangular, mipLevel: 0 },\n            data,\n            { bytesPerRow: width * 2 * 4 },\n            { width, height, depthOrArrayLayers: 1 },\n        );\n        await device.queue.onSubmittedWorkDone();\n    }\n\n    const faceSize = equirectangular.height >> 1;\n    const cubemapDescriptor = outputDescriptor as GPUTextureDescriptor;\n    cubemapDescriptor.mipLevelCount ??= Math.log2(faceSize) | 0;\n    cubemapDescriptor.size = { width: faceSize, height: faceSize, depthOrArrayLayers: 6 };\n    cubemapDescriptor.dimension = '2d';\n    cubemapDescriptor.usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    const cubemap = device.createTexture(cubemapDescriptor);\n\n    const label = padTemplate`hdr copy${outputDescriptor.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 2,\n                buffer: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const module = device.createShaderModule({ label, code });\n    const sampler = device.createSampler({ label, minFilter: 'linear', magFilter: 'linear' });\n    const params = new Uint32Array(1);\n    const paramBuffer = createAndCopyBuffer(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device, label);\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            { binding: 0, resource: equirectangular.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: paramBuffer } },\n        ],\n    });\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: { module },\n        fragment: {\n            module,\n            targets: [{ format: cubemap.format }],\n            constants: {\n                GAMMA: gamma,\n                EXPOSURE: exposure,\n                FLIP_Y,\n            },\n        },\n    });\n\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n\n        const view = cubemap.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n            mipLevelCount: 1,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [{\n                view,\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n\n    return cubemap;\n}\nexport async function generateMips(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${blit}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `;\n\n    const label = padTemplate`mip generation${texture.label}`;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d', sampleType: 'float' },\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const colorAttachment = {\n        view: undefined as GPUTextureView | undefined,\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: 0 });\n    await device.queue.onSubmittedWorkDone();\n\n    for (let i = 1; i < texture.mipLevelCount; i += 1) {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: colorAttachment.view,\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n\n        colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: i });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [colorAttachment as GPURenderPassColorAttachment],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n\n        device.queue.submit([encoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport function srgbTextureToLinear(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${blit}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `;\n\n    const label = padTemplate`srgb to linear${texture.label}`;\n\n    const size = { width: texture.width, height: texture.height };\n\n    const tempTexture = device.createTexture({\n        format: texture.format,\n        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        size,\n    });\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n\n    const module = device.createShaderModule({ label, code: code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: tempTexture.createView(),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n        ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n        { texture },\n        { texture: tempTexture },\n        size,\n    );\n\n    const pass = encoder.beginRenderPass({\n        label,\n        colorAttachments: [{\n            view: texture.createView({ mipLevelCount: 1, baseMipLevel: 0 }),\n            loadOp: 'clear',\n            storeOp: 'store',\n        }],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindgroup);\n    pass.draw(3);\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n}\n","import { RenderModel } from '../settings/sample-spec';\nimport propertyListener, { ListenerSyms } from '../settings/property-listener';\nimport getSkyboxOptions from '../settings/skybox-options';\n\nimport GeometryPipeline from '../../core/default-forward-pass/geometry-pipeline';\nimport DescriptorMap from '../../core/default-forward-pass/descriptor-map';\nimport Renderer, { ForwardPassParams } from '../../core/renderer';\nimport { MaterialDescriptor } from '../../core/default-forward-pass/material-draw-data';\nimport { PipelineFeatureFlags } from '../../core/default-forward-pass/pipeline-feature-flags';\n\nimport cubemapGuassianPyramid from '../cubemap-blur/cubemap-guassian-pyramid';\n\nimport { AttributeDetails, ComponentType } from './loader/type-conversions';\nimport importGltf from './loader/gltf-loader';\nimport { DataType } from '@loaders.gl/core';\nimport { isObject } from '../../../utils/general';\n\nconst gltfIndex = await getGltfIndex();\n\nasync function getGltfIndex() {\n    const indexUrl = GLTF_BASE_URL__ + GLTF_INDEX_FILE__;\n    const indexRes = await fetch(indexUrl);\n    const indexStr = await indexRes.text();\n    const indexJson = JSON.parse(indexStr) as unknown;\n\n    if (!Array.isArray(indexJson)) {\n        throw new Error('Could not load index for glTF sample models.');\n    }\n\n    const entries: [string, string][] = indexJson.flatMap((gltf: unknown) => {\n        if (\n            !isObject(gltf)\n            || !('label' in gltf)\n            || typeof gltf.label !== 'string'\n            || !('name' in gltf)\n            || typeof gltf.name !== 'string'\n            || !('variants' in gltf)\n            || !isObject(gltf.variants)\n            || typeof gltf.variants.glTF !== 'string'\n        ) return [];\n\n        const { variants: { glTF: file }, label, name } = gltf;\n        const path = `${GLTF_BASE_URL__}${name}/glTF/${file}`;\n        return [[label, path]];\n    });\n\n    return Object.fromEntries(entries);\n}\n\nexport default class GltfModel implements RenderModel {\n    static readonly goalLayout: AttributeDetails[] = [\n        {\n            name: 'POSITION',\n            type: 'VEC3',\n            componentType: ComponentType.float32,\n        },\n        {\n            name: 'TEXCOORD_0',\n            type: 'VEC2',\n            componentType: ComponentType.float32,\n        },\n        {\n            name: 'TANGENT',\n            type: 'VEC4',\n            componentType: ComponentType.float32,\n            depends: ['NORMAL'],\n            fill: [1, 0, 0, 1],\n        },\n        {\n            name: 'NORMAL',\n            type: 'VEC3',\n            componentType: ComponentType.float32,\n            strip: true,\n            feature: PipelineFeatureFlags.VertexNormals,\n        },\n        {\n            name: 'COLOR_0',\n            type: 'VEC4',\n            componentType: ComponentType.float32,\n            strip: true,\n            feature: PipelineFeatureFlags.VertexColors,\n            fill: [1, 1, 1, 1],\n        },\n    ];\n\n    geometryPipelines: Partial<Record<number, GeometryPipeline>> = {};\n    descriptorMap: DescriptorMap;\n    device: GPUDevice;\n\n    get depthTextureView() {\n        return this.descriptorMap.gbuffer.depth.view;\n    }\n\n    readonly #settings = propertyListener({\n        skybox: getSkyboxOptions(this),\n        model: {\n            [ListenerSyms.$type]: 'file' as const,\n            [ListenerSyms.$callback]: (val: unknown, key: PropertyKey) => {\n                if (key !== 'value' || val == null) return;\n                if (typeof val === 'string' || val instanceof File) {\n                    void this.setModel(val);\n                }\n            },\n            accept: '.hdr',\n            value: 'Environment Test',\n            initialValues: gltfIndex,\n            process: (file: File) => file,\n        },\n    });\n\n    readonly settings = this.#settings.publicSettings;\n    readonly priority = 1000;\n\n    constructor(public renderer: Renderer) {\n        this.descriptorMap = new DescriptorMap(renderer.device, renderer.gbuffer, renderer.globals);\n        this.device = renderer.device;\n        this.renderer.addForwardPass(this);\n    }\n\n    async setSkybox(skybox: GPUTexture) {\n        await cubemapGuassianPyramid({\n            texture: skybox,\n            device: this.renderer.device,\n            inPlace: true,\n            delayWork: requestAnimationFrame,\n        });\n\n        this.renderer.skybox = skybox;\n    }\n\n    async setModel(modelPath: string | DataType) {\n        const size = { width: 1, height: 1 };\n        const colorArray = new Float32Array([1, 1, 1, 1]);\n\n        const opaqueWhite = this.renderer.device.createTexture({\n            size,\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        this.renderer.device.queue.writeTexture({ texture: opaqueWhite }, colorArray, {}, size);\n\n        const normalMap = this.renderer.device.createTexture({\n            size,\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        colorArray.set([0.5, 0.5, 1, 1]);\n        this.renderer.device.queue.writeTexture({ texture: normalMap }, colorArray, {}, size);\n\n        const sampler = {\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'linear',\n            mipmapFilter: 'linear',\n        } as GPUSamplerDescriptor;\n\n        const matData: MaterialDescriptor = {\n            baseColorTexture: opaqueWhite,\n            baseColorFactor: [1, 1, 1, 1],\n            normalTexture: normalMap,\n            metallicRoughnessTexture: opaqueWhite,\n            metallicFactor: 1,\n            roughnessFactor: 1,\n            baseColorSampler: sampler,\n            normalSampler: sampler,\n            metallicRoughnessSampler: sampler,\n        };\n\n        this.geometryPipelines = await importGltf(\n            modelPath,\n            this.renderer.device,\n            this.descriptorMap,\n            matData,\n            GltfModel.goalLayout,\n            {},\n        );\n    }\n\n    render({ encoder, gbuffer, globals }: ForwardPassParams) {\n        const pass = encoder.beginRenderPass(gbuffer.passDescriptor);\n        pass.setBindGroup(0, globals.bindgroup);\n\n        for (const pipeline of Object.values(this.geometryPipelines)) {\n            pipeline?.draw(pass, this.renderer.device.queue);\n        }\n        pass.end();\n    }\n}\n","import Camera from './camera/camera';\r\n\r\nconst label = 'global uniforms';\r\n\r\nexport default class GlobalUniforms {\r\n    static readonly code = (group: number) => /* wgsl */`\r\n        struct GlobalUniforms {\r\n            worldToView: mat4x4f,\r\n            viewToClip: mat4x4f,\r\n            worldToClip: mat4x4f,\r\n            inverseWorldToView: mat4x4f,\r\n            inverseViewToClip: mat4x4f,\r\n            inverseWorldToClip: mat4x4f,\r\n        }\r\n\r\n        @group(${group}) @binding(0) var<uniform> globals: GlobalUniforms;\r\n    `;\r\n\r\n    static readonly bufferSize = Camera.bufferLength;\r\n\r\n    static readonly layoutDescriptor: GPUBindGroupLayoutDescriptor = {\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                buffer: { minBindingSize: GlobalUniforms.bufferSize },\r\n                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\r\n            },\r\n        ],\r\n    };\r\n\r\n    static readonly bufferDescriptor: GPUBufferDescriptor = {\r\n        label,\r\n        size: GlobalUniforms.bufferSize,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    };\r\n\r\n    deviceBuffer: GPUBuffer;\r\n    bindGroupLayout: GPUBindGroupLayout;\r\n    bindGroupDescriptor!: GPUBindGroupDescriptor;\r\n    bindgroup!: GPUBindGroup;\r\n\r\n    constructor(device: GPUDevice) {\r\n        this.deviceBuffer = device.createBuffer(GlobalUniforms.bufferDescriptor);\r\n        this.bindGroupLayout = device.createBindGroupLayout(GlobalUniforms.layoutDescriptor);\r\n\r\n        this.bindGroupDescriptor = {\r\n            label,\r\n            layout: this.bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.deviceBuffer,\r\n                        offset: 0,\r\n                        size: GlobalUniforms.bufferSize,\r\n                    },\r\n                },\r\n            ],\r\n        };\r\n\r\n        this.bindgroup = device.createBindGroup(this.bindGroupDescriptor);\r\n    }\r\n\r\n    updateDeviceBuffer(queue: GPUQueue, camera: Camera) {\r\n        camera.cacheView();\r\n        queue.writeBuffer(this.deviceBuffer, 0, camera.buffer);\r\n    }\r\n}\r\n","export type Branch = string | (() => string);\r\n\r\nfunction resolveBranch(branch: Branch) {\r\n    return typeof branch === 'string' ? branch : branch();\r\n}\r\n\r\nclass PreprocessorStatement {\r\n    res?: string;\r\n\r\n    constructor(cond: boolean, branch: Branch) {\r\n        if (cond) this.res = resolveBranch(branch);\r\n    }\r\n\r\n    elif(cond: boolean, branch: Branch) {\r\n        if (cond) this.res ??= resolveBranch(branch);\r\n        return this;\r\n    }\r\n\r\n    else = (branch: Branch) => this.res ?? resolveBranch(branch);\r\n\r\n    toString = () => this.res ?? '';\r\n\r\n    get [Symbol.toStringTag]() { return this.toString(); }\r\n}\r\n\r\nexport function preprocessors(flags: number) {\r\n    return {\r\n        ifdef(sym: number, branch: Branch) {\r\n            return new PreprocessorStatement((flags & sym) === sym, branch);\r\n        },\r\n        ifndef(sym: number, branch: Branch) {\r\n            return new PreprocessorStatement((flags & sym) !== sym, branch);\r\n        },\r\n    };\r\n}\r\n\r\nexport function wrapWithIncrement<T>(fn: (counter: number) => T, start = 0): () => T {\r\n    return () => fn(start++);\r\n}\r\n","/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\nimport { PipelineFeatureFlags, featureFlagsToString } from '../core/default-forward-pass/pipeline-feature-flags';\nimport { preprocessors, wrapWithIncrement } from '../utils/shader';\nimport GlobalUniforms from '../core/global-uniforms';\nimport { GBufferGroupIndices } from '../core/gbuffer';\n\nexport function getBindgroupInfo(flags: PipelineFeatureFlags): GPUBindGroupLayoutDescriptor {\n    const entries: GPUBindGroupLayoutEntry[] = [];\n\n    function pushItem(item: Omit<GPUBindGroupLayoutEntry, 'binding' | 'visibility'>) {\n        entries.push({ ...item, binding: entries.length, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX });\n    }\n\n    pushItem({ buffer: { type: 'uniform' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    if (flags & PipelineFeatureFlags.Emissive) {\n        pushItem({ sampler: {} });\n        pushItem({ texture: { viewDimension: '2d' } });\n    }\n\n    return { label: featureFlagsToString(flags), entries };\n}\n\n/**\n * @param flags A flag enum containing the features this code should be generated for\n * @returns A string containing preprocessed wgsl shader code for the given features\n */\nexport default function include(flags: PipelineFeatureFlags) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { ifdef } = preprocessors(flags as number);\n    const vertexInLocation = wrapWithIncrement((idx) => /* wgsl */`@location(${idx})`);\n    const varyingsLocation = wrapWithIncrement((idx) => /* wgsl */`@location(${idx})`);\n\n    const materialBinding = wrapWithIncrement((idx) => /* wgsl */`\n        @group(1) @binding(${idx})\n    `);\n\n    const varyings = /* wgsl */`\n        ${varyingsLocation()} pos: vec3f,\n        ${varyingsLocation()} camPos: vec3f,\n        ${varyingsLocation()} uv: vec2f,\n\n        ${ifdef(PipelineFeatureFlags.VertexNormals, () => /* wgsl */`\n            ${varyingsLocation()} tangent: vec4f,\n            ${varyingsLocation()} normal: vec3f,\n        `)}\n\n        ${ifdef(PipelineFeatureFlags.VertexColors, () => /* wgsl */`\n            ${varyingsLocation()} color: vec4f,\n        `)}\n    `;\n\n    return /* wgsl */`\n        ${GlobalUniforms.code(0)}\n\n        struct ForwardOut {\n            @location(${GBufferGroupIndices.Normal}) normal: vec4f,\n            @location(${GBufferGroupIndices.Albedo}) albedo: vec4f,\n            @location(${GBufferGroupIndices.Emission}) emission: vec4f,\n            @location(${GBufferGroupIndices.MetallicRoughness}) metallicRoughness: vec4f,\n        }\n\n        struct MaterialProperties {\n            baseColorFactor: vec4f,\n            metallicFactor: f32,\n            roughnessFactor: f32,\n\n            ${ifdef(PipelineFeatureFlags.AlphaCutoff, 'alphaCutoff: f32,')}\n            ${ifdef(PipelineFeatureFlags.Emissive, 'emissiveFactor: vec3f,')}\n        }\n\n        ${materialBinding()} var<uniform> material: MaterialProperties;\n\n        ${materialBinding()} var baseColorSampler: sampler;\n        ${materialBinding()} var baseColorTexture: texture_2d<f32>;\n\n        ${materialBinding()} var normalSampler: sampler;\n        ${materialBinding()} var normalTexture: texture_2d<f32>;\n\n        ${materialBinding()} var metallicRoughnessSampler: sampler;\n        ${materialBinding()} var metallicRoughnessTexture: texture_2d<f32>;\n\n        ${ifdef(PipelineFeatureFlags.Emissive, () => /* wgsl */`\n            ${materialBinding()} var emissionSampler: sampler;\n            ${materialBinding()} var emissionTexture: texture_2d<f32>;\n        `)}\n\n        struct ModelProperties {\n            modelToWorldMatrix: mat4x4f,\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, 'normalMatrix: mat3x3f,')}\n        }\n\n        @group(2) @binding(0) var<storage, read> instances : array<ModelProperties>;\n\n        struct VertIn {\n            @builtin(instance_index) instance: u32,\n            ${vertexInLocation()} pos: vec3f,\n            ${vertexInLocation()} uv: vec2f,\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, () => /* wgsl */`\n                ${vertexInLocation()} tangent: vec4f,\n                ${vertexInLocation()} normal: vec3f,\n            `)}\n\n            ${ifdef(PipelineFeatureFlags.VertexColors, () => /* wgsl */`\n                ${vertexInLocation()} color: vec4f,\n            `)}\n        }\n\n        struct VertOut {\n            ${varyings}\n            @builtin(position) Position: vec4f,\n        }\n\n        struct FragIn {\n            ${varyings}\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals | PipelineFeatureFlags.DoubleSided, /* wgsl */`\n                @builtin(front_facing) front_facing: bool,\n            `)}\n        }\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @vertex \n        fn vs(inData: VertIn) -> VertOut {\n            var vsOut: VertOut;\n            let instance = instances[inData.instance];\n            let worldPos = instance.modelToWorldMatrix * vec4f(inData.pos, 1);\n            vsOut.pos = worldPos.xyz;\n            vsOut.Position = globals.worldToClip * worldPos;\n            vsOut.camPos = globals.inverseWorldToView[3].xyz;\n            vsOut.uv = inData.uv;\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, /* wgsl */`\n                vsOut.normal = normalize(instance.normalMatrix * inData.normal);\n                let wsTangent = normalize((instance.modelToWorldMatrix * vec4(inData.tangent.xyz, 0.0)).xyz);\n                vsOut.tangent = vec4(wsTangent, inData.tangent.w);\n            `)}\n\n            return vsOut;\n        }\n\n        // much of this code is adapted from https://learnopengl.com/PBR\n        @fragment\n        fn fs(inData: FragIn) -> ForwardOut {\n            var out: ForwardOut;\n            let rawColor = textureSample(baseColorTexture, baseColorSampler, inData.uv);\n\n            ${ifdef(PipelineFeatureFlags.AlphaCutoff, /* wgsl */`\n                var alpha = rawColor.a * material.baseColorFactor.a;\n\n                ${ifdef(PipelineFeatureFlags.VertexColors, /* wgsl */`\n                    alpha *= inData.color.a;\n                `)}\n\n                if (alpha <= material.alphaCutoff) { \n                    discard;\n                }\n            `)}\n\n            out.albedo = vec4f(rawColor.rgb * material.baseColorFactor.rgb, 1);\n\n            ${ifdef(PipelineFeatureFlags.VertexColors, /* wgsl */`\n                out.albedo *= vec4f(inData.color.rgb, 1);\n            `)}\n\n            let metallicRoughness = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, inData.uv);\n            out.metallicRoughness.r = saturate(metallicRoughness.b * material.metallicFactor);\n            out.metallicRoughness.g = saturate(metallicRoughness.g * material.roughnessFactor);\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, /* wgsl */`\n                let normalSample = textureSample(normalTexture, normalSampler, inData.uv).xyz;\n                let tangentNormal = normalize(normalSample * 2.0 - 1.0);\n                let bitangent =inData.tangent.w * cross(inData.normal, inData.tangent.xyz);\n                let tbn = mat3x3f(normalize(inData.tangent.xyz), bitangent, normalize(inData.normal));\n                var normal = normalize(tbn * tangentNormal);\n\n                ${ifdef(PipelineFeatureFlags.DoubleSided, /* wgsl */`\n                    if (!inData.front_facing) { normal *= -1.0; }\n                `)}\n            `).else(/* wgsl */`\n                let fdx = dpdx(inData.pos);\n                let fdy = dpdy(inData.pos);\n                let normal = normalize(cross(fdy, fdx));\n            `)}\n\n            out.normal = vec4f(normal, 1);\n\n            ${ifdef(PipelineFeatureFlags.Emissive, /* wgsl */`\n                let emission = textureSample(emissionTexture, emissionSampler, inData.uv).rgb;\n                out.emission = vec4f(emission, 1);\n            `)}\n\n            return out;\n        }\n    `;\n}\n","import { PipelineFeatureFlags } from './pipeline-feature-flags';\nimport * as PipelineFeatures from './pipeline-feature-flags';\nimport include, { getBindgroupInfo as getBindGroupInfo } from '../../shaders/forward.shader';\n\nimport GBuffer from '../gbuffer';\nimport GlobalUniforms from '../global-uniforms';\n\ntype PipelineFeatureMap<T> = Partial<Record<number, T>>;\n\nexport default class DescriptorMap {\n    static readonly flagToTopology: Partial<Record<PipelineFeatureFlags, GPUPrimitiveTopology>> = {\n        [PipelineFeatureFlags.TriangleList]: 'triangle-list',\n        [PipelineFeatureFlags.TriangleStrip]: 'triangle-strip',\n        [PipelineFeatureFlags.PointList]: 'point-list',\n        [PipelineFeatureFlags.LineList]: 'line-list',\n        [PipelineFeatureFlags.LineStrip]: 'line-strip',\n    };\n\n    readonly pipelineLayouts: PipelineFeatureMap<GPUPipelineLayout> = {};\n    readonly primitiveStates: PipelineFeatureMap<GPUPrimitiveState> = {};\n    readonly vertexLayouts: PipelineFeatureMap<GPUVertexBufferLayout> = {};\n    readonly shaderModules: PipelineFeatureMap<GPUShaderModule> = {};\n    readonly bindgroupLayouts: PipelineFeatureMap<GPUBindGroupLayout> = {};\n\n    readonly samplers: Partial<Record<string, GPUSampler>> = {};\n\n    readonly forwardBindgroupLayout = this.device.createBindGroupLayout({\n        label: `forward material`,\n        entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n            buffer: { type: 'read-only-storage' },\n        }],\n    });\n\n    constructor(\n        public readonly device: GPUDevice,\n        public readonly gbuffer: GBuffer,\n        public readonly globals: GlobalUniforms,\n    ) { }\n\n    getSampler(descriptor: GPUSamplerDescriptor) {\n        const key = JSON.stringify(descriptor);\n        this.samplers[key] ??= this.device.createSampler(descriptor);\n        return this.samplers[key];\n    }\n\n    getVertexLayout(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.VertexBufferLayoutMask;\n\n        if (this.vertexLayouts[masked] == null) {\n            const attributes: GPUVertexAttribute[] = [\n                { shaderLocation: 0, offset: 0, format: 'float32x3' }, // position\n                { shaderLocation: 1, offset: 12, format: 'float32x2' }, // uv\n            ];\n\n            let arrayStride = 20;\n            let shaderLocation = 2;\n\n            if (masked & PipelineFeatureFlags.VertexNormals) {\n                attributes.push({ shaderLocation, offset: arrayStride, format: 'float32x4' }); // tangent\n                attributes.push({ shaderLocation: shaderLocation + 1, offset: arrayStride + 16, format: 'float32x3' }); // normal\n                shaderLocation += 2;\n                arrayStride += 28;\n            }\n\n            if (masked & PipelineFeatureFlags.VertexColors) {\n                attributes.push({ shaderLocation, offset: arrayStride, format: 'float32x4' }); // color\n                arrayStride += 16;\n            }\n\n            this.vertexLayouts[masked] = { attributes, arrayStride, stepMode: 'vertex' };\n        }\n\n        return this.vertexLayouts[masked];\n    }\n\n    getForwardPipelineLayout(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.PipelineLayoutMask;\n\n        this.pipelineLayouts[masked] ??= this.device.createPipelineLayout({\n            label: PipelineFeatures.featureFlagsToString(masked),\n            bindGroupLayouts: [\n                this.globals.bindGroupLayout,\n                this.getMaterialBindGroup(flags),\n                this.forwardBindgroupLayout,\n            ],\n        });\n\n        return this.pipelineLayouts[masked];\n    }\n\n    getShaderModule(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.CodeMask;\n        this.shaderModules[masked] ??= this.device.createShaderModule({\n            label: PipelineFeatures.featureFlagsToString(masked),\n            code: include(masked),\n        });\n        return this.shaderModules[masked];\n    }\n\n    getPrimitiveState(flags: PipelineFeatureFlags) {\n        const masked = flags & PipelineFeatures.PrimitiveStateMask;\n\n        this.primitiveStates[masked] ??= {\n            topology: DescriptorMap.flagToTopology[(flags & PipelineFeatures.TopologyFormatMask) as PipelineFeatureFlags],\n            cullMode: masked & PipelineFeatureFlags.DoubleSided ? 'none' : 'back',\n            frontFace: masked & PipelineFeatureFlags.ClockwiseWinding ? 'cw' : 'ccw',\n        };\n\n        return this.primitiveStates[masked];\n    }\n\n    getMaterialBindGroup(flags: PipelineFeatureFlags) {\n        const masked = flags & PipelineFeatures.MaterialBindgroupLayoutMask;\n        this.bindgroupLayouts[masked] ??= this.device.createBindGroupLayout(getBindGroupInfo(masked));\n        return this.bindgroupLayouts[masked];\n    }\n}\n","export enum PipelineFeatureFlags {\n    Defaults = 0,\n\n    /**\n     * If the meshes have vertex normals.\n     * If absent, meshes are shaded with flat normals.\n    */\n    VertexNormals = 1 << 0,\n\n    /**\n     * If the meshes have vertex colors.\n     * If absent, mesh is shaded with a base color texture.\n    */\n    VertexColors = 1 << 1,\n\n    AlphaCutoff = 1 << 2,\n    Emissive = 1 << 3,\n\n    DoubleSided = 1 << 4,\n    ClockwiseWinding = 1 << 5,\n\n    // Topology formats\n    TriangleList = 0 << 6,\n    TriangleStrip = 1 << 6,\n    PointList = 2 << 6,\n    LineList = 3 << 6,\n    LineStrip = 4 << 6,\n    Unindexed = 5 << 6,\n    // LINE_LOOP (currently unsupported by webgpu)\n    // TRIANGLE_FAN (currently unsupported by webgpu)\n}\n\nexport const TopologyFormatMask = 0x111 << 6;\n\nexport const PrimitiveStateMask = (\n    TopologyFormatMask\n    | PipelineFeatureFlags.DoubleSided\n    | PipelineFeatureFlags.ClockwiseWinding\n);\n\nexport const CodeMask = ~(\n    TopologyFormatMask\n    | PipelineFeatureFlags.ClockwiseWinding\n);\n\nexport const InstanceBufferLayoutMask = (\n    PipelineFeatureFlags.VertexNormals\n);\n\nexport const VertexBufferLayoutMask = (\n    PipelineFeatureFlags.VertexNormals\n    | PipelineFeatureFlags.VertexColors\n);\n\nexport const MaterialBufferLayoutMask = (\n    PipelineFeatureFlags.AlphaCutoff\n);\n\nexport const MaterialBindgroupLayoutMask = (\n    MaterialBufferLayoutMask\n    | PipelineFeatureFlags.Emissive\n);\n\nexport const MaterialMask = (\n    MaterialBindgroupLayoutMask\n    | PipelineFeatureFlags.DoubleSided\n);\n\nexport const PipelineLayoutMask = (\n    InstanceBufferLayoutMask\n    | MaterialMask\n);\n\nexport function featureFlagsToNames(val: number) {\n    return Object.entries(PipelineFeatureFlags)\n        .flatMap(([key, flag]) => typeof flag === 'number' && (flag & val) ? key : []);\n}\n\nexport function featureFlagsToString(val: number) {\n    return featureFlagsToNames(val).toString();\n}\n\nexport function maskRedundantFeatures(flags: PipelineFeatureFlags) {\n    let masked = flags;\n    if (masked & PipelineFeatureFlags.DoubleSided) masked &= ~PipelineFeatureFlags.ClockwiseWinding;\n    return masked;\n}\n"],"names":["async","imageToTexture","device","data","mimeType","usage","GPUTextureUsage","TEXTURE_BINDING","mips","format","colorSpace","label","srgbToLinear","bitmap","ImageBitmap","blob","Blob","File","type","createImageBitmap","colorSpaceConversion","size","width","height","texture","createTexture","COPY_DST","COPY_SRC","RENDER_ATTACHMENT","mipLevelCount","Math","log2","max","queue","copyExternalImageToTexture","source","parseHDR","inData","decoder","TextDecoder","buffer","Uint8Array","pos","getLine","lineLimit","limit","min","length","sub","subarray","end","indexOf","undefined","decode","importError","msg","Error","magicTokenLine","test","headerReg","RegExp","map","join","rawData","noFormat","gamma","exposure","line","groups","match","X","Y","parseInt","parseFloat","unencodable","flatData","scanline_buffer","len","byteLength","k","offset","count","ptr","isEncodedRun","fill","set","i","j","Uint16Array","float16One","raw_e","scale","pow","createAndCopyBuffer","arr","alignment","pad","createBuffer","mappedAtCreation","writeArray","getMappedRange","readArray","ArrayBuffer","byteOffset","unmap","HashTable","constructor","prim","attributes","byteStride","attribute","Object","values","this","initAttribute","paddedByteStride","u8","u32","Uint32Array","bytesPerComponent","componentsPerElement","push","hash","index","murmurHash2","equal","a","b","hashLookup","table","buckets","key","empty","hashmod","bucket","probe","item","m","h","imul","weld","srcVertexCount","POSITION","tableSize","value","ceil","log","LN2","is16Bit","indexFormat","writeMap","dstVertexCount","hashIndex","dstIndex","remap","indexArray","vertexCount","PrimitiveDrawData","primitive","descriptorMap","instances","instanceCount","dirty","features","name","vertexArray","GPUBuffer","vertexBuffer","GPUBufferUsage","VERTEX","indexData","indexCount","indexBuffer","INDEX","instanceSize","sizeofMat4x4f","VertexNormals","modelMatrices","Array","Float32Array","normalMatrices","instanceBuffer","STORAGE","UNIFORM","instanceBindGroup","createBindGroup","layout","forwardBindgroupLayout","entries","binding","resource","instance","addInstance","draw","passEncoder","writeBuffer","setVertexBuffer","setBindGroup","setIndexBuffer","drawIndexed","transform","copy","calculateNormalMatrix","idx","normalMatrix","fromMat4","invert","transpose","modeToTopology","PointList","LineList","TriangleList","AttributeWrapper","accessor","componentCount","unwelded","processed","copyFrom","copyProcessed","bind","components","view","DataView","copyUnprocessed","componentType","at","getInt8","getUint8","getInt16","getUint16","getUint32","getFloat32","normalized","val","array","process","srcIdx","dstIdx","dst","markProcessed","newView","unweld","dstCount","dstArray","done","srcIndex","generateTangentsAsync","then","module","generateTangents","wrapIndices","indices","loadPrimitive","atrs","atr","mode","originalMode","reindex","NORMAL","TANGENT","TEXCOORD_0","start","Date","now","tangent","func","console","vertexFeatures","Defaults","stride","COLOR_0","vertexView","uv","VertexColors","step","interleaveVertices","instanceMatrices","overallSign","det","determinant","sign","DoubleSided","ClockwiseWinding","getCullMode","drawData","material","DEFAULT_METALLIC","DEFAULT_ROUGHNESS","gltfToMagDescription","gltfToMipDescription","gltfToAddressMode","toSamplerDescription","sampler","magFilter","minFilter","wrapS","wrapT","addressModeU","addressModeV","mipmapFilter","getImageData","handle","image","bufferView","loadMaterial","defaultMaterial","mat","pbrMetallicRoughness","baseColorFactor","baseColorTexture","metallicFactor","metallicRoughnessTexture","roughnessFactor","id","metallicRoughnessSampler","baseColorSampler","normalTexture","normalSampler","emissiveFactor","emissiveTexture","emissiveStrength","extensions","KHR_materials_emissive_strength","some","x","emissiveSampler","doubleSided","alphaMode","alphaCutoff","MaterialDrawData","primitiveFeatures","primitives","properties","AlphaCutoff","propertiesBuffer","getSampler","createView","dimension","Emissive","getMaterialBindGroup","matData","bindGroup","addPrimitives","filtered","filter","warn","toString","GeometryPipeline","maps","materials","getShaderModule","pipeline","createRenderPipeline","getForwardPipelineLayout","getPrimitiveState","vertex","entryPoint","buffers","getVertexLayout","fragment","targets","gbuffer","depthStencil","depthWriteEnabled","depthCompare","depth","addMaterials","setPipeline","defaultLayout","depends","strip","feature","recurseNode","parentMatrix","meshes","node","matrix","identity","scaling","rotation","axis","angle","toAxisAngle","rotate","translation","setTranslation","mul","mesh","has","get","children","forEach","importGltf","url","pipelines","gltfWithBuffers","load","scene","nodes","Map","primitivePromises","from","flatMap","primitiveDescriptors","Promise","all","materialMap","materialPromises","materialId","materialEntries","materialDescriptors","fromEntries","fullDefaultMat","drawDatas","descriptor","f","Camera","viewParams","bufferLength","worldToView","worldToViewOffset","mat4x4Count","viewToClip","viewToClipOffset","worldToClip","worldToClipOffset","viewToWorld","viewToWorldOffset","clipToView","clipToViewOffset","clipToWorld","clipToWorldOffset","location","params","nearPlane","farPlane","fov","projection","updateParams","cacheView","fromQuat","perspective","PI","y","ortho","mapValues","obj","fn","mapped","clamp","num","padTemplate","strings","result","str","mapRange","n","keys","range","debounce","callback","delay","tid","args","ctx","self","clearTimeout","setTimeout","apply","binaryInsert","element","comparator","left","right","splice","pivot","floor","isObject","TypeSizes","BYTES_PER_ELEMENT","VkFormatToWebGPU","vk","wgpu","equirectangularToCubemap","outputDescriptor","code","equirectangular","FLIP_Y","GPUTexture","writeTexture","mipLevel","bytesPerRow","depthOrArrayLayers","onSubmittedWorkDone","faceSize","cubemapDescriptor","cubemap","bindgroupLayout","createBindGroupLayout","visibility","GPUShaderStage","FRAGMENT","createShaderModule","createSampler","paramBuffer","bindgroup","pipelineLayout","createPipelineLayout","bindGroupLayouts","constants","GAMMA","EXPOSURE","arrayLayerCount","baseArrayLayer","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","loadOp","storeOp","submit","finish","generateMips","viewDimension","sampleType","colorAttachment","baseMipLevel","srgbTextureToLinear","tempTexture","copyTextureToTexture","gltfIndex","getGltfIndex","indexRes","fetch","indexStr","text","indexJson","JSON","parse","isArray","gltf","variants","glTF","file","GltfModel","depthTextureView","renderer","geometryPipelines","skybox","model","$type","$callback","setModel","accept","initialValues","settings","publicSettings","priority","globals","addForwardPass","setSkybox","inPlace","delayWork","requestAnimationFrame","modelPath","colorArray","opaqueWhite","normalMap","goalLayout","render","passDescriptor","GlobalUniforms","deviceBuffer","bufferDescriptor","bindGroupLayout","layoutDescriptor","bindGroupDescriptor","bufferSize","updateDeviceBuffer","camera","group","minBindingSize","resolveBranch","branch","PreprocessorStatement","cond","else","res","elif","Symbol","toStringTag","wrapWithIncrement","include","flags","ifdef","sym","ifndef","preprocessors","vertexInLocation","varyingsLocation","materialBinding","varyings","DescriptorMap","pipelineLayouts","primitiveStates","vertexLayouts","shaderModules","bindgroupLayouts","samplers","stringify","masked","shaderLocation","arrayStride","stepMode","topology","flagToTopology","cullMode","frontFace","pushItem","TriangleStrip","LineStrip","PipelineFeatureFlags","TopologyFormatMask","PrimitiveStateMask","CodeMask","InstanceBufferLayoutMask","VertexBufferLayoutMask","MaterialBindgroupLayoutMask","PipelineLayoutMask","featureFlagsToString","flag","featureFlagsToNames","maskRedundantFeatures"],"sourceRoot":""}