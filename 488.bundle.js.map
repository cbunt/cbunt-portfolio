{"version":3,"file":"488.bundle.js","mappings":";ycAYA,MAAqBA,EAiEjB,WAAAC,CAAYC,EAAoC,CAAC,eAlDxC,KAAAC,OAAsB,IAAIC,YAAY,EAAOC,cAE7C,KAAAC,YAAoB,IAAIC,aAC7BC,KAAKL,OACL,EAAOM,kBACP,KAAUC,aAGL,KAAAC,WAAmB,IAAIJ,aAC5BC,KAAKL,OACL,EAAOS,iBACP,KAAUF,aAGL,KAAAG,YAAoB,IAAIN,aAC7BC,KAAKL,OACL,EAAOW,kBACP,KAAUJ,aAGL,KAAAK,YAAoB,IAAIR,aAC7BC,KAAKL,OACL,EAAOa,kBACP,KAAUN,aAGL,KAAAO,WAAmB,IAAIV,aAC5BC,KAAKL,OACL,EAAOe,iBACP,KAAUR,aAGL,KAAAS,YAAoB,IAAIZ,aAC7BC,KAAKL,OACL,EAAOiB,kBACP,KAAUV,aAGL,KAAAW,SAAiB,IAAId,aAAa,CAAC,EAAG,EAAG,IACzC,KAAAe,SAAiB,IAAIf,aAAa,CAAC,EAAG,EAAG,EAAG,IAErD,KAAAgB,OAAuB,CACnBC,UAAW,IACXC,SAAU,IACVC,IAAK,GACLC,MAAO,KACPC,OAAQ,KACRC,WAAY,eAIZrB,KAAKsB,aAAa5B,EACtB,CAEA,YAAA4B,CAAaC,GACTvB,KAAKe,OAAS,IAAKf,KAAKe,UAAWQ,GACnC,EAAAvB,KAAI,SAAiB,KAArBA,KACJ,CAEA,SAAAwB,GACI,KAAKC,SAASzB,KAAKc,SAAUd,KAAKO,aAClC,KAAKmB,eAAe1B,KAAKO,YAAaP,KAAKa,SAAUb,KAAKO,aAC1D,KAAKoB,OAAO3B,KAAKO,YAAaP,KAAKF,aACnC,KAAK8B,IAAI5B,KAAKG,WAAYH,KAAKF,YAAaE,KAAKK,aACjD,KAAKuB,IAAI5B,KAAKO,YAAaP,KAAKS,WAAYT,KAAKW,YACrD,iCAGI,GAA+B,gBAA3BX,KAAKe,OAAOM,WACZ,KAAKQ,YACD7B,KAAKe,OAAOG,KAAOY,KAAKC,GAAK,KAC7B/B,KAAKe,OAAOI,MAAQnB,KAAKe,OAAOK,OAChCpB,KAAKe,OAAOC,UACZhB,KAAKe,OAAOE,SACZjB,KAAKG,gBAEN,CACH,MAAM6B,EAAIhC,KAAKe,OAAOI,MAAQ,EACxBc,EAAIjC,KAAKe,OAAOK,OAAS,EAE/B,KAAKc,OACAF,EACDA,GACCC,EACDA,EACAjC,KAAKe,OAAOC,UACZhB,KAAKe,OAAOE,SACZjB,KAAKG,WAEb,CAEA,KAAKwB,OAAO3B,KAAKG,WAAYH,KAAKS,WACtC,EA1GgB,EAAAR,kBAAoB,EACpB,EAAAG,iBAAmB,EAAKH,kBAAoB,KAAUkC,cACtD,EAAA7B,kBAAoB,EAAKF,iBAAmB,KAAU+B,cACtD,EAAA3B,kBAAoB,EAAKF,kBAAoB,KAAU6B,cACvD,EAAAzB,iBAAmB,EAAKF,kBAAoB,KAAU2B,cACtD,EAAAvB,kBAAoB,EAAKF,iBAAmB,KAAUyB,cAEtD,EAAAtC,aAAe,EAAKe,kBAAoB,KAAUuB,mGClB/D,MAAMC,EAAY,CACrBlC,YAAa,GACbiC,cAAe,GAAKpC,aAAasC,mBAGxBC,EAAiE,CAE1E,CAAC,OAA0B,UAC3B,CAAC,OAA0B,UAC3B,CAAC,OAAyB,SAC1B,CAAC,OAAyB,SAE1B,CAAC,OAA0B,UAC3B,CAAC,OAA0B,UAC3B,CAAC,OAA4B,WAC7B,CAAC,OAA4B,WAC7B,CAAC,OAA4B,WAC7B,CAAC,OAA2B,UAC5B,CAAC,OAA2B,UAE5B,CAAC,OAA0B,UAC3B,CAAC,OAA0B,UAC3B,CAAC,OAA4B,WAC7B,CAAC,OAA6B,WAC9B,CAAC,OAA6B,WAC9B,CAAC,OAA+B,YAChC,CAAC,OAAgC,aACjC,CAAC,OAA+B,kBAChC,CAAC,OAAgC,aACjC,CAAC,OAA+B,YAChC,CAAC,OAA+B,YAChC,CAAC,OAAgC,aACjC,CAAC,OAA+B,kBAEhC,CAAC,OAAwC,eACzC,CAAC,OAAyC,cAC1C,CAAC,OAA0C,eAC3C,CAAC,OAAyC,gBAE1C,CAAC,OAA6B,WAC9B,CAAC,OAA6B,WAC9B,CAAC,OAA+B,YAChC,CAAC,OAAmC,aACpC,CAAC,OAAmC,aACpC,CAAC,OAAqC,cAEtC,CAAC,OAAmC,aACpC,CAAC,OAAmC,aACpC,CAAC,OAAqC,cAGtC,CAAC,OAAsC,iBACvC,CAAC,OAAqC,sBACtC,CAAC,OAAiC,iBAClC,CAAC,OAAgC,sBACjC,CAAC,OAAiC,iBAClC,CAAC,OAAgC,sBACjC,CAAC,OAAiC,cAClC,CAAC,OAAiC,cAClC,CAAC,OAAiC,eAClC,CAAC,OAAiC,eAClC,CAAC,OAAmC,kBACpC,CAAC,OAAmC,iBACpC,CAAC,OAAiC,iBAClC,CAAC,OAAgC,uBA6CxBC,EAAiE,CAE1EC,QAAS,EACTC,QAAS,EACTC,OAAQ,EACRC,OAAQ,EAERC,QAAS,EACTC,QAAS,EACTC,SAAU,EACVC,SAAU,EACVC,SAAU,EACVC,QAAS,EACTC,QAAS,EAETC,QAAS,EACTC,QAAS,EACTC,SAAU,EACVC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,WAAY,EACZ,kBAAmB,EACnBC,WAAY,EACZC,UAAW,EACXC,UAAW,EACXC,WAAY,EACZ,kBAAmB,EAEnBC,aAAc,EACdC,YAAa,EACbC,aAAc,EACdC,cAAe,EAEfC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,WAAY,EACZC,WAAY,EACZC,YAAa,EAEbC,WAAY,GACZC,WAAY,GACZC,YAAa,IAGJC,EAAwE,CAEjFnC,QAAS,EACTC,QAAS,EACTC,OAAQ,EACRC,OAAQ,EAERC,QAAS,EACTC,QAAS,EACTC,SAAU,EACVC,SAAU,EACVC,SAAU,EACVC,QAAS,EACTC,QAAS,EAETC,QAAS,EACTC,QAAS,EACTC,SAAU,EACVC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,WAAY,EACZ,kBAAmB,EACnBC,WAAY,EACZC,UAAW,EACXC,UAAW,EACXC,WAAY,EACZ,kBAAmB,EAEnBC,aAAc,EACdC,YAAa,EACbC,aAAc,EACdC,cAAe,EAEfC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,WAAY,EACZC,WAAY,EACZC,YAAa,EAEbC,WAAY,EACZC,WAAY,EACZC,YAAa,GAGJE,EAAmBC,OAAOC,YACnCD,OAAOE,QAAQzC,GAAkB0C,KAAI,EAAEC,EAAIC,KAAU,CAACA,EAAMC,SAASF,EAAI,uDC1M7E,MAAMG,EAAQ,kBAEd,MAAqBC,EAsCjB,WAAA5F,CAAY6F,GACRtF,KAAKuF,aAAeD,EAAOE,aAAaH,EAAeI,kBACvDzF,KAAK0F,gBAAkBJ,EAAOK,sBAAsBN,EAAeO,kBAEnE5F,KAAK6F,oBAAsB,CACvBT,QACAU,OAAQ9F,KAAK0F,gBACbX,QAAS,CACL,CACIgB,QAAS,EACTC,SAAU,CACNrG,OAAQK,KAAKuF,aACbU,OAAQ,EACRC,KAAMb,EAAec,eAMrCnG,KAAKoG,UAAYd,EAAOe,gBAAgBrG,KAAK6F,oBACjD,CAEA,kBAAAS,CAAmBC,EAAiBC,GAChCA,EAAOhF,YACP+E,EAAME,YAAYzG,KAAKuF,aAAc,EAAGiB,EAAO7G,OACnD,EA9DgB,EAAA+G,KAAQC,GAA4B,uSAUvCA,6DAGG,EAAAR,WAAa,IAAOtG,aAEpB,EAAA+F,iBAAiD,CAC7DR,QACAL,QAAS,CACL,CACIgB,QAAS,EACTpG,OAAQ,CAAEiH,eAAgBvB,EAAec,YACzCU,WAAYC,eAAeC,OAASD,eAAeE,YAK/C,EAAAvB,iBAAwC,CACpDL,QACAc,KAAMb,EAAec,WACrBc,MAAOC,eAAeC,QAAUD,eAAeE,oGChCvD,MAAMhC,EAAQ,eAEd,MAAqBiC,EA2EjB,WAAA5H,CACW6F,EACPgC,GADO,KAAAhC,OAAAA,EApBX,KAAAiC,gBAAgD,CAC5CC,OAAQ,OACRC,QAAS,QAETC,UAAMC,GAGV,KAAAC,eAA0C,CACtCxC,QACAyC,iBAAkB,CAAC7H,KAAKuH,kBAcxBvH,KAAK8H,aAAe,CAAER,UACtBtH,KAAK+H,gBAAkBzC,EAAOK,sBAAsB0B,EAAYW,2BAChE,MAAMC,EAAS3C,EAAO4C,mBAAmB,CAAE9C,QAAOsB,KAAMW,EAAYX,OAEpE1G,KAAKmI,mBAAqB,CACtB/C,QACAU,OAAQR,EAAO8C,qBAAqB,CAChChD,QACAiD,iBAAkB,CAACrI,KAAK+H,mBAE5BO,OAAQ,CACJL,SACAM,WAAY,MAEhBC,SAAU,CACNP,SACAM,WAAY,KACZE,QAAS,CAACzI,KAAK8H,gBAIvB9H,KAAK0I,SAAWpD,EAAOqD,qBAAqB3I,KAAKmI,mBACrD,CAEA,WAAAS,CAAYC,GACR7I,KAAKoG,UAAYpG,KAAKsF,OAAOe,gBAAgB,CACzCjB,QACAU,OAAQ9F,KAAK+H,gBACbhD,QAAS,CAAC,CACNgB,QAAS,EACTC,SAAU6C,KAGtB,CAEA,MAAAC,CAAOC,EAA4BC,GAC/B,GAAsB,MAAlBhJ,KAAKoG,UAAmB,OAExBpG,KAAK8H,aAAaR,SAAW0B,EAAO1B,SACpCtH,KAAK8H,aAAaR,OAAS0B,EAAO1B,OAClCtH,KAAK0I,SAAW1I,KAAKsF,OAAOqD,qBAAqB3I,KAAKmI,qBAG1DnI,KAAKuH,gBAAgBG,KAAOsB,EAAOC,WAAW,CAAEC,UAAW,OAE3D,MAAMC,EAAOJ,EAAQK,gBAAgBpJ,KAAK4H,gBAC1CuB,EAAKE,YAAYrJ,KAAK0I,UACtBS,EAAKG,aAAa,EAAGtJ,KAAKoG,WAC1B+C,EAAKI,KAAK,GACVJ,EAAKK,KACT,EAhIgB,EAAA9C,KAAiB,iFAG3B,w1CA2CU,EAAAsB,0BAA0D,CACtE5C,QACAL,QAAS,CAAC,CACNgB,QAAS,EACT0D,QAAS,CAAEC,WAAY,QAASC,cAAe,MAC/C9C,WAAYC,eAAeE,0rBCtDvC,MAAM,EAAQ,cAEd,MAAqB4C,EAwEjB,YAAIC,GAAa,OAAO7J,KAAK8J,aAAa,EAAI,CAC9C,YAAID,CAAStI,GACLA,IAAQvB,KAAK8J,aAAa,KAC9B9J,KAAK8J,aAAa,GAAKvI,EACvBvB,KAAKsF,OAAOiB,MAAME,YAAYzG,KAAK+J,cAAe,EAAG/J,KAAK8J,aAAc,EAAG,GAC/E,CAEA,oBAAIE,GAAqB,OAAO,EAAAhK,KAAI,MAAoB,CACxD,oBAAIgK,CAAiBzI,GACbA,IAAQ,EAAAvB,KAAI,SAChB,EAAAA,KAAI,EAAqBuB,EAAG,KAC5B,EAAAvB,KAAI,SAAiB,KAArBA,MACJ,CAEA,gBAAIiK,GAAiB,OAAO,EAAAjK,KAAI,MAAgB,CAChD,gBAAIiK,CAAa3C,GACTA,IAAW,EAAAtH,KAAI,SACnB,EAAAA,KAAI,EAAiBsH,EAAM,KAE3BtH,KAAK0I,SAAW1I,KAAKsF,OAAOqD,qBAAqB,CAC7CvD,MAAK,EACLU,OAAQ9F,KAAKkK,eACb5B,OAAQ,CACJC,WAAY,KACZN,OAAQjI,KAAKmK,QAEjB3B,SAAU,CACND,WAAY,KACZE,QAAS,CAAC,CAAEnB,WACZW,OAAQjI,KAAKmK,UAGzB,CAEA,cAAIC,CAAWC,GACPA,IAAW,EAAArK,KAAI,SACnB,EAAAA,KAAI,EAAeqK,EAAM,KACzB,EAAArK,KAAI,SAAiB,KAArBA,MACJ,CAEA,gBAAIsK,CAAaA,GACTA,IAAiB,EAAAtK,KAAI,SACzB,EAAAA,KAAI,EAAiBsK,EAAY,KACjC,EAAAtK,KAAI,SAAiB,KAArBA,MACJ,CAYA,WAAAP,CACW6F,EACAiF,EACPN,EACAI,eAHO,KAAA/E,OAAAA,EACA,KAAAiF,QAAAA,EAnEX,KAAAT,aAAe,IAAI/J,aAAa,GAIhC,mBACA,mBACA,mBACA,YAAoB,GAgDpB,KAAAyK,OAAuC,CACnCC,WAAY,CAAEC,EAAG,EAAKC,EAAG,EAAKC,EAAG,EAAKC,EAAG,GACzCrD,OAAQ,QACRC,QAAS,QAETC,UAAMC,GAGD,KAAAC,eAA0C,CAAEC,iBAAkB,CAAC7H,KAAKwK,SAQzExK,KAAK+H,gBAAkBzC,EAAOK,sBAAsB,CAChDP,MAAK,EACLL,QAAS,CACL,CACIgB,QAAS,EACT0D,QAAS,CAAEE,cAAe,QAC1B9C,WAAYC,eAAeE,SAAWF,eAAeC,QAEzD,CACIhB,QAAS,EACT0D,QAAS,CACLE,cAAe,KACfD,WAAY,SAEhB7C,WAAYC,eAAeE,UAE/B,CACIjB,QAAS,EACTc,WAAYC,eAAeE,SAC3B8D,QAAS,CAAC,GAEd,CACI/E,QAAS,EACTc,WAAYC,eAAeC,OAC3BpH,OAAQ,CAAEoL,KAAM,eAK5B/K,KAAKgL,cAAgB1F,EAAO2F,cAAc,CACtCC,UAAW,SACXC,UAAW,SACXC,aAAc,WAGlBpL,KAAKqL,eAAiB/F,EAAO2F,cAAc,CACvCC,UAAW,UACXC,UAAW,UACXC,aAAc,YAGlBpL,KAAKmK,OAAS7E,EAAO4C,mBAAmB,CACpCxB,KAAMkD,EAAWlD,KACjBtB,MAAK,IAGTpF,KAAKkK,eAAiB5E,EAAO8C,qBAAqB,CAC9ChD,MAAK,EACLiD,iBAAkB,CACdkC,EAAQ7E,gBACR1F,KAAK+H,mBAIb/H,KAAK+J,cAAgBzE,EAAOE,aAAa,CACrCJ,MAAK,EACLc,KAAM,GACNe,MAAOC,eAAeE,SAAWF,eAAeC,UAGpDnH,KAAKiK,aAAeA,EACN,MAAVI,IAAgBrK,KAAKoK,WAAaC,EAC1C,CAEA,MAAAvB,CAAOK,GACH,OAA6B,MAAzBnJ,KAAKsL,kBAA6C,MAAjBtL,KAAK0I,WAC1CS,EAAKE,YAAYrJ,KAAK0I,UACtBS,EAAKG,aAAa,EAAGtJ,KAAKuK,QAAQnE,WAClC+C,EAAKG,aAAa,EAAGtJ,KAAKsL,kBAC1BnC,EAAKI,KAAK,IACH,EACX,qFAG4B,MAApB,EAAAvJ,KAAI,QAA8C,MAAtB,EAAAA,KAAI,SAEpCA,KAAKsL,iBAAmBtL,KAAKsF,OAAOe,gBAAgB,CAChDjB,MAAK,EACLU,OAAQ9F,KAAK+H,gBACbhD,QAAS,CACL,CACIgB,QAAS,EACTC,SAAU,EAAAhG,KAAI,QAElB,CACI+F,QAAS,EACTC,SAAU,EAAAhG,KAAI,QAElB,CACI+F,QAAS,EACTC,SAAUhG,KAAKgK,iBACThK,KAAKqL,eACLrL,KAAKgL,eAEf,CACIjF,QAAS,EACTC,SAAU,CAAErG,OAAQK,KAAK+J,mBAIzC,EAzOgB,EAAArD,KAAiB,aAC3B,IAAeA,KAAK,41DCU9B,MAAqB6E,EA4FjB,QAAIrF,GAAS,OAAOlG,KAAKwL,KAAO,CAChC,QAAItF,CAAKuF,GACLzL,KAAKwL,MAAQC,EAEbzL,KAAK0L,SAASC,SAASC,IAAU5L,KAAK6L,cAAcD,EAAI,IACxD5L,KAAKoG,UAAYpG,KAAK8L,kBACtB9L,KAAK4H,eAAiB5H,KAAK+L,sBAC/B,CAEA,WAAAtM,CACoB6F,EACRkG,GADQ,KAAAlG,OAAAA,EACR,KAAAkG,MAAAA,EAtDZ,KAAAQ,OAAShM,KAAK6L,cAAc,CACxBvE,OAAQ,cACR2E,KAAM,SACNxB,WAAY,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,KAGvC,KAAAqB,OAASlM,KAAK6L,cAAc,CACxBvE,OAAQ,aACR2E,KAAM,SACNxB,WAAY,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,KAGvC,KAAAsB,SAAWnM,KAAK6L,cAAc,CAC1BvE,OAAQ,cACR2E,KAAM,WACNxB,WAAY,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,KAGvC,KAAAuB,kBAAoBpM,KAAK6L,cAAc,CACnCvE,OAAQ,WACR2E,KAAM,qBACNxB,WAAY,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,KAGvC,KAAAwB,MAAQrM,KAAK6L,cAAc,CACvBvE,OAAQ,eACR2E,KAAM,UAGV,KAAAP,SAAW,CACP1L,KAAKgM,OACLhM,KAAKkM,OACLlM,KAAKmM,SACLnM,KAAKoM,kBACLpM,KAAKqM,OAGT,KAAA5D,QAAUzI,KAAK0L,SAASY,MAAM,GAAI,GAAGtH,KAAI,EAAGsC,aAAa,CAAGA,aAE5D,KAAA5B,gBAAkB1F,KAAKsF,OAAOK,sBAAsB4F,EAAQgB,mBAC5D,KAAAnG,UAAYpG,KAAK8L,kBACjB,KAAAlE,eAAiB5H,KAAK+L,sBAclB,CAEJ,eAAAD,GACI,MAAM/G,EAAU/E,KAAK0L,SAAS1G,KAAI,EAAG0C,QAAQ8E,KAAQ,CACjDzG,QAASyG,EACTxG,SAAU0B,MAGd,OAAO1H,KAAKsF,OAAOe,gBAAgB,CAC/BjB,MAAO,qBACPU,OAAQ9F,KAAK0F,gBACbX,WAER,CAEA,oBAAAgH,GAQI,MAAO,CACH3G,MAAO,uBACPyC,iBATqB7H,KAAK0L,SAASY,MAAM,GAAI,GAAGtH,KAAI,EAAG0C,OAAM+C,iBAAiB,CAC9E/C,KAAMA,EACN+C,WAAYA,EACZjD,OAAQ,QACRC,QAAS,YAMTgF,uBAAwB,CACpB/E,KAAM1H,KAAKqM,MAAM3E,KACjBgF,YAAa,QACbC,aAAc,QACdC,gBAAiB,GAG7B,CAEA,aAAAf,CAAcD,GACV,MAAMxG,EAAQ,WAAWwG,EAAIK,OAQ7B,OAPAL,EAAInC,QAAUzJ,KAAKsF,OAAOuG,cAAc,CACpCzG,QACAc,KAAMlG,KAAKwL,MACXlE,OAAQsE,EAAItE,OACZL,MAAO4F,gBAAgBC,kBAAoBD,gBAAgBE,kBAE/DnB,EAAIlE,KAAOkE,EAAInC,QAAQR,WAAW,CAAE7D,UAC7BwG,CACX,EApJgB,EAAAlF,KAAQC,GAA4B,oBACvCA,0FAGAA,0FAGAA,oFAGAA,qGAGAA,sEAIG,EAAA4F,kBAAkD,CAC9DnH,MAAO,4BACPL,QAAS,CACL,CACIgB,QAAS,EACTc,WAAYC,eAAeE,SAC3ByC,QAAS,CAAEC,WAAY,uBAE3B,CACI3D,QAAS,EACTc,WAAYC,eAAeE,SAC3ByC,QAAS,CAAEC,WAAY,UAE3B,CACI3D,QAAS,EACTc,WAAYC,eAAeE,SAC3ByC,QAAS,CAAEC,WAAY,UAE3B,CACI3D,QAAS,EACTc,WAAYC,eAAeE,SAC3ByC,QAAS,CAAEC,WAAY,uBAE3B,CACI3D,QAAS,EACTc,WAAYC,eAAeE,SAC3ByC,QAAS,CAAEC,WAAY,sBC5DvC,EAAyB,+vDCGnBhD,EAAkB,4CAGtB,QACA,64BCFF,MAAM,EAAiB,2UAcjB,YACA,UACA,6pCChBN,MAAM,EAAiB,sZAiBjB,YACA,UACA,y7BChBN,MAAqBsG,EAsFjB,UAAI3C,CAAOZ,GACPzJ,KAAKiN,kBF/BE,UAAiC,OAC5C3H,EAAM,QACNmE,EAAO,MACPrE,EAAQ,aAAY,MACpB6B,EAAQ,EAAC,QACTiG,EAAU,KAAI,YACdC,EAAW,aACXC,EAAY,cACZC,IAEA,MAAM/F,EAAS+F,GAAe/F,QAAU8F,GAAgB3D,EAAQnC,OAC1DnG,EAAQkM,GAAelM,OAASgM,GAAe,GAE/CpF,EAAkBzC,EAAOK,sBAAsB,CACjDP,QACAL,QAAS,CACL,CACIgB,QAAS,EACTc,WAAYC,eAAeE,SAC3ByC,QAAS,CAAEE,cAAe,SAE9B,CACI5D,QAAS,EACTc,WAAYC,eAAeE,SAC3B8D,QAAS,CAAC,GAEd,CACI/E,QAAS,EACTc,WAAYC,eAAeE,SAC3BrH,OAAQ,CAAEoL,KAAM,eAKtBD,EAAUxF,EAAO2F,cAAc,CAAEC,UAAW,SAAUC,UAAW,SAAUC,aAAc,WAEzF6B,EAA0D,IAAtCI,GAAeC,mBACnCD,EACA/H,EAAOuG,cAAc,CACfzG,QACAkC,SACA4B,UAAW,KACXjC,MAAO4F,gBAAgBC,kBAAoB7F,EAC3Cf,KAAM,CAAE/E,QAAOC,OAAQD,EAAOmM,mBAAoB,KAGxDvM,EAAS,IAAIwM,YAAY,CAAC,EAAGN,EAAkB9L,QAC/CqM,GAAc,QAChBzM,EACAmG,eAAeE,SAAWF,eAAeC,QACzC7B,GAGEc,EAAYd,EAAOe,gBAAgB,CACrCjB,QACAU,OAAQiC,EACRhD,QAAS,CACL,CACIgB,QAAS,EACTC,SAAUyD,EAAQR,WAAW,CAAEC,UAAW,UAE9C,CACInD,QAAS,EACTC,SAAU8E,GAEd,CACI/E,QAAS,EACTC,SAAU,CAAErG,OAAQ6N,OAK1BtD,EAAiB5E,EAAO8C,qBAAqB,CAC/ChD,QACAiD,iBAAkB,CAACN,KAGjBE,EAAS3C,EAAO4C,mBAAmB,CAAE9C,QAAOsB,KAAI,IAEhDgC,EAAWpD,EAAOqD,qBAAqB,CACzCvD,QACAU,OAAQoE,EACR5B,OAAQ,CACJL,SACAM,WAAY,MAEhBC,SAAU,CACND,WAAY,KACZkF,UAAW,CACPC,QAASR,GAEbjF,SACAQ,QAAS,CAAC,CAAEnB,cAIpB,IAAK,IAAIqG,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC3B5M,EAAO,GAAK4M,EACZrI,EAAOiB,MAAME,YAAY+G,EAAa,EAAGzM,EAAQ,EAAG,GAEpD,MAAM2G,EAAOuF,EAAkBhE,WAAW,CACtCC,UAAW,KACX0E,gBAAiB,EACjBC,eAAgBF,IAGd5E,EAAUzD,EAAOwI,uBACjB3E,EAAOJ,EAAQK,gBAAgB,CACjCvB,iBAAkB,CAAC,CACfH,OACAF,OAAQ,QACRC,QAAS,YAIjB0B,EAAKE,YAAYX,GACjBS,EAAKG,aAAa,EAAGlD,GACrB+C,EAAKI,KAAK,GACVJ,EAAKK,MACLlE,EAAOiB,MAAMwH,OAAO,CAAChF,EAAQiF,UACjC,CAEA,OAAOf,CACX,CE5FiCgB,CAAwB,CAC7CxE,UACAnE,OAAQtF,KAAKsF,OACb2B,MAAO4F,gBAAgBE,kBAG3B/M,KAAKkO,gBDnCE,UAA+B,OAC1C5I,EAAM,QACNmE,EAAO,aACPQ,EAAY,MACZhD,EAAQ,EAAC,MACT7B,EAAQ,WAAU,QAClB8H,EAAU,KAAI,YACdC,EAAW,cACXE,IAEA,MAAM/F,EAAS+F,GAAe/F,QAAU2C,GAAgBR,EAAQnC,OAC1DnG,EAAQkM,GAAelM,OAASgM,GAAe1D,EAAQtI,MAEvD4G,EAAkBzC,EAAOK,sBAAsB,CACjDP,QACAL,QAAS,CACL,CACIgB,QAAS,EACTc,WAAYC,eAAeE,SAC3ByC,QAAS,CAAEE,cAAe,SAE9B,CACI5D,QAAS,EACTc,WAAYC,eAAeE,SAC3B8D,QAAS,CAAC,GAEd,CACI/E,QAAS,EACTc,WAAYC,eAAeE,SAC3BrH,OAAQ,CAAEoL,KAAM,eAKtBD,EAAUxF,EAAO2F,cAAc,CAAEC,UAAW,SAAUC,UAAW,SAAUC,aAAc,WACzF+C,EAAmB,IAAIvO,YAAY,IACnCwO,EAAa,IAAIb,YAAYY,EAAkB,EAAG,GAClDE,EAAc,IAAItO,aAAaoO,EAAkB,EAAO,GAExDX,GAAc,QAChBW,EACAjH,eAAeE,SAAWF,eAAeC,QACzC7B,GAGE4I,EAAwD,IAAtCb,GAAeC,mBACjCD,EACA/H,EAAOuG,cAAc,CACfzG,QACAkC,SACA4B,UAAW,KACXjC,MAAO4F,gBAAgBC,kBAAoBD,gBAAgBzF,SAAWH,EACtEf,KAAM,CAAE/E,QAAOC,OAAQD,EAAOmM,mBAAoB,GAClDgB,cAAexM,KAAKyM,KAAwB,EAAnBzM,KAAK0M,KAAKrN,IAAc,EAAG,KAG1DsN,EAAcnJ,EAAOwI,qBAAqB,CAC5C1I,MAAO,GAAGA,mBAGdqJ,EAAYC,qBACR,CAAEjF,UAASI,SAAU,GACrB,CAAEJ,QAASyE,EAAiBrE,SAAU,GACtC,CAAE1I,QAAOC,OAAQD,EAAOmM,mBAAoB,IAEhDhI,EAAOiB,MAAMwH,OAAO,CAACU,EAAYT,WAEjC,MAAM9D,EAAiB5E,EAAO8C,qBAAqB,CAC/ChD,QACAiD,iBAAkB,CAACN,KAGjBE,EAAS3C,EAAO4C,mBAAmB,CAAE9C,QAAOsB,KAAI,IAEhDgC,EAAWpD,EAAOqD,qBAAqB,CACzCvD,QACAU,OAAQoE,EACR5B,OAAQ,CACJL,SACAM,WAAY,MAEhBC,SAAU,CACND,WAAY,KACZE,QAAS,CAAC,CAAEnB,OAAQ4G,EAAgB5G,SACpCmG,UAAW,CACPC,QAASR,GAEbjF,YA8DR,OA1DAoG,EAAY,GAAM,EAAI5E,EAAQtI,MAAQsI,EAAQtI,OAAU,EAAIW,KAAKC,IAE5D4M,QAAQC,UAAUC,MAAKC,UACxB,MAAM1I,EAAYd,EAAOe,gBAAgB,CACrCjB,QACAU,OAAQiC,EACRhD,QAAS,CACL,CACIgB,QAAS,EACTC,SAAUyD,EAAQR,WAAW,CAAEC,UAAW,UAE9C,CACInD,QAAS,EACTC,SAAU8E,GAEd,CACI/E,QAAS,EACTC,SAAU,CAAErG,OAAQ6N,OAKhC,IAAK,IAAIuB,EAAM,EAAGA,EAAMb,EAAgBI,cAAeS,GAAO,EAAG,CAC7D,MAAMC,EAAYD,GAAOb,EAAgBI,cAAgB,GACzDD,EAAY,GAAKW,GAAa,EAC9BZ,EAAW,GAAMF,EAAgB/M,OAAS4N,EAE1C,IAAK,IAAIE,EAAO,EAAGA,EAAO,EAAGA,GAAQ,EAAG,OAC9B3J,EAAOiB,MAAM2I,sBACnBd,EAAW,GAAKa,EAChB3J,EAAOiB,MAAME,YAAY+G,EAAa,EAAGW,GAEzC,MAAMzG,EAAOwG,EAAgBjF,WAAW,CACpCC,UAAW,KACX0E,gBAAiB,EACjBC,eAAgBoB,EAChBX,cAAe,EACfa,aAAcJ,IAGZhG,EAAUzD,EAAOwI,uBACjB3E,EAAOJ,EAAQK,gBAAgB,CACjCvB,iBAAkB,CAAC,CACfH,OACAF,OAAQ,QACRC,QAAS,YAIjB0B,EAAKE,YAAYX,GACjBS,EAAKG,aAAa,EAAGlD,GACrB+C,EAAKI,KAAK,GACVJ,EAAKK,MACLlE,EAAOiB,MAAMwH,OAAO,CAAChF,EAAQiF,UACjC,CACJ,KAGGE,CACX,CCnH+BkB,CAAsB,CACzC3F,UACAnE,OAAQtF,KAAKsF,OACb2B,MAAO4F,gBAAgBE,kBAG3B/M,KAAKqP,eAAiBrP,KAAKiN,kBAAkBhE,WAAW,CAAEC,UAAW,SACrElJ,KAAKsP,aAAetP,KAAKkO,gBAAgBjF,WAAW,CAAEC,UAAW,SAEjElJ,KAAKoG,UAAYpG,KAAKsF,OAAOe,gBAAgB,CACzCP,OAAQ9F,KAAK+H,gBACbhD,QAAS,CACL,CACIgB,QAAS,EACTC,SAAUhG,KAAKsP,cAEnB,CACIvJ,QAAS,EACTC,SAAUhG,KAAKqP,gBAEnB,CACItJ,QAAS,EACTC,SAAUhG,KAAKuP,aAEnB,CACIxJ,QAAS,EACTC,SAAUhG,KAAK8K,WAI/B,CAEA,WAAArL,CAAmB6F,EAA0BiF,EAAgCiF,EAAkBlI,EAA0B+C,GAAtG,KAAA/E,OAAAA,EAA0B,KAAAiF,QAAAA,EAAgC,KAAAiF,QAAAA,EA7D7E,KAAAhF,OAAuC,CACnC9C,UAAMC,EACN8C,WAAY,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GACnCrD,OAAQ,QACRC,QAAS,SAGb,KAAAgI,QH9BG,UAAuB,OAC1BnK,EAAM,MACNF,EAAK,YACLsK,EAAW,MACXvO,EAAQ,KAAI,OACZC,EAAS,KAAI,OACbkG,EAAS,cAET,MAAMmI,EAAUnK,EAAOuG,cAAc,CACjCzG,QACAkC,SACA4B,UAAW,KACXjC,MAAO4F,gBAAgBC,kBAAoBD,gBAAgBE,gBAC3D7G,KAAM,CAAE/E,QAAOC,YAGb6G,EAAS3C,EAAO4C,mBAAmB,CAAE9C,MAAO,iBAAkBsB,SAE9DgC,EAAWpD,EAAOqD,qBAAqB,CACzCvD,MAAO,oBACPU,OAAQ,OACRwC,OAAQ,CACJC,WAAY,KACZN,UAEJO,SAAU,CACND,WAAY,KACZE,QAAS,CAAC,CAAEnB,WACZmG,UAAWiC,EAAc,CAAEC,aAAcD,QAAgB/H,EACzDM,YAIFc,EAAUzD,EAAOwI,uBACjB3E,EAAOJ,EAAQK,gBAAgB,CACjChE,MAAO,uBACPyC,iBAAkB,CAAC,CACfH,KAAM+H,EAAQxG,aACdzB,OAAQ,QACRC,QAAS,YAUjB,OANA0B,EAAKE,YAAYX,GACjBS,EAAKI,KAAK,GACVJ,EAAKK,MAELlE,EAAOiB,MAAMwH,OAAO,CAAChF,EAAQiF,WAEtByB,CACX,CGpBcG,CAAc,CAAEtK,OAAQtF,KAAKsF,SACvC,KAAAiK,YAAcvP,KAAKyP,QAAQxG,aAYlB,KAAArB,eAA0C,CAAEC,iBAAkB,CAAC7H,KAAKwK,SA0CzExK,KAAK8K,QAAUxF,EAAO2F,cAAc,CAAEE,UAAW,SAAUD,UAAW,SAAUE,aAAc,WAEhF,MAAVf,IAAgBrK,KAAKqK,OAASA,GAElCrK,KAAK+H,gBAAkBzC,EAAOK,sBAAsB,CAChDP,MAAO,gBACPL,QAAS,CACL,CACIgB,QAAS,EACTc,WAAYC,eAAeE,SAC3ByC,QAAS,CAAEE,cAAe,SAE9B,CACI5D,QAAS,EACTc,WAAYC,eAAeE,SAC3ByC,QAAS,CAAEE,cAAe,SAE9B,CACI5D,QAAS,EACTc,WAAYC,eAAeE,SAC3ByC,QAAS,CAAEE,cAAe,OAE9B,CACI5D,QAAS,EACTc,WAAYC,eAAeE,SAC3B8D,QAAS,CAAC,MAKtB,MAAMhF,EAASR,EAAO8C,qBAAqB,CACvChD,MAAO,iCACPiD,iBAAkB,CACdrI,KAAKuK,QAAQ7E,gBACb1F,KAAKwP,QAAQ9J,gBACb1F,KAAK+H,mBAIPE,EAAS3C,EAAO4C,mBAAmB,CAAExB,KAAMsG,EAAatG,KAAMtB,MAAO,yBAE3EpF,KAAK0I,SAAWpD,EAAOqD,qBAAqB,CACxC7C,SACAwC,OAAQ,CACJC,WAAY,KACZN,UAEJO,SAAU,CACND,WAAY,KACZE,QAAS,CAAC,CAAEnB,WACZW,WAGZ,CAEA,MAAAa,CAAOK,GACmB,MAAlBnJ,KAAKoG,YACT+C,EAAKE,YAAYrJ,KAAK0I,UACtBS,EAAKG,aAAa,EAAGtJ,KAAKuK,QAAQnE,WAClC+C,EAAKG,aAAa,EAAGtJ,KAAKwP,QAAQpJ,WAClC+C,EAAKG,aAAa,EAAGtJ,KAAKoG,WAC1B+C,EAAKI,KAAK,GACd,EA3LgB,EAAA7C,KAAiB,aAC3B,IAAeA,KAAK,eACpB,EAAQA,KAAK,gSAOb,cACA,ktFCCV,MAAqBmJ,EA0BjB,UAAIxF,CAAOZ,GACPzJ,KAAK8P,aAAazF,OAASZ,EAE3BzJ,KAAK+P,WAAW3F,WAAapK,KAAK8P,aAAaR,YACnD,CAEA,WAAA7P,CACoBuQ,EACA1K,eADA,KAAA0K,OAAAA,EACA,KAAA1K,OAAAA,EA7BpB,KAAAiC,gBAAgD,CAC5CkD,WAAY,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GACnCrD,OAAQ,QACRC,QAAS,QACTC,UAAMC,GAGV,KAAAC,eAA0C,CAAEC,iBAAkB,CAAC7H,KAAKuH,kBAOpE,KAAA0I,cAA+B,GAsH/B,KAAAnH,OAAS,KACLoH,sBAAsBlQ,KAAK8I,QAE3B9I,KAAKuK,QAAQjE,mBAAmBtG,KAAKsF,OAAOiB,MAAOvG,KAAKwG,QAExD,MAAMuC,EAAU/I,KAAKsF,OAAOwI,qBAAqB,CAAE1I,MAAO,wBACpD+K,EAAoB,CAAEpH,UAASwB,QAASvK,KAAKuK,QAASiF,QAASxP,KAAKwP,SAE1E,IAAK,MAAMY,KAAepQ,KAAKiQ,cAC3BG,EAAYtH,OAAOqH,GAGvB,MAAMhH,EAAOJ,EAAQK,gBAAgBpJ,KAAK4H,gBAC1C5H,KAAK8P,aAAahH,OAAOK,GACzBnJ,KAAK+P,WAAWjH,OAAOK,GACvBA,EAAKK,MAELxJ,KAAKqQ,YAAYvH,OAAOC,EAAS/I,KAAKsQ,QAAQC,qBAE9CvQ,KAAKsF,OAAOiB,MAAMwH,OAAO,CAAChF,EAAQiF,UAAU,EAxH5C,MAAM9H,EAAO,CAAE/E,MAAOnB,KAAKgQ,OAAO7O,MAAOC,OAAQpB,KAAKgQ,OAAO5O,QAC7DpB,KAAKwG,OAAS,IAAI,IAAON,GACzBlG,KAAKuK,QAAU,IAAI,IAAevK,KAAKsF,QACvCtF,KAAKwP,QAAU,IAAI,EAAQlK,EAAQY,GACnClG,KAAK8P,aAAe,IAAI,EAAaxK,EAAQtF,KAAKuK,QAASvK,KAAKwP,QAASK,EAASW,mBAElFxQ,KAAK+P,WAAa,IAAI,EAClB/P,KAAKsF,OACLtF,KAAKuK,QACLsF,EAASW,mBAEbxQ,KAAKqQ,YAAc,IAAI,EAAYrQ,KAAKsF,OAAQuK,EAASzC,cAEzD,MAAMkD,EAAUtQ,KAAKgQ,OAAOS,WAAW,UACvC,GAAe,MAAXH,EAAiB,MAAM,IAAII,MAAM,sEAErC1Q,KAAKsQ,QAAUA,EAEftQ,KAAKsQ,QAAQK,UAAU,CACnBrL,OAAQtF,KAAKsF,OACbgC,OAAQuI,EAASzC,aACjBnG,MAAO4F,gBAAgBC,kBAAoBD,gBAAgB+D,SAC3DC,UAAW,SACXC,WAAY,SAGhB9Q,KAAK+Q,eAAe7K,GACpB,EAAAlG,KAAI,SAAsB,KAA1BA,KACJ,CAEA,8BAAagR,CAAkBhB,GAC3B,MAAMiB,QAAgBC,UAAUC,IAAIC,iBACpC,GAAe,MAAXH,EACA,MAAM,IAAIP,MAAM,6BAGpB,MAAM,yBACFW,EAAwB,iCACxBC,EAAgC,kCAChCC,GACAN,EAAQO,OAENlM,QAAe2L,EAAQQ,cAAc,CACvCrM,MAAO,sBACPsM,iBAAkB7B,EAAS6B,iBAC3BC,eAAgB,CACZN,2BACAC,mCACAC,uCAIR,OAAO,IAAI1B,EAASG,EAAQ1K,EAChC,CAEA,cAAAyL,CAAe7K,GACXlG,KAAKwG,OAAOlF,aAAa4E,GACzBlG,KAAK4R,kBAAoB5R,KAAKsF,OAAOuG,cAAc,CAC/C3C,UAAW,KACX5B,OAAQuI,EAASW,kBACjBvJ,MAAO4F,gBAAgBC,kBAAoBD,gBAAgBE,gBAC3D7G,SAGJlG,KAAKuH,gBAAgBG,KAAO1H,KAAK4R,kBAAkB3I,aACnDjJ,KAAKqQ,YAAYzH,YAAY5I,KAAKuH,gBAAgBG,MAClD1H,KAAKwP,QAAQtJ,KAAOA,EAEpBlG,KAAK+P,WAAWzF,aAAetK,KAAKwP,QAAQnD,MAAM3E,IACtD,CA4BA,cAAAmK,CAAezB,IACX,QAAapQ,KAAKiQ,cAAeG,GAAa,CAACvF,EAAGD,IAAMC,EAAEiH,SAAWlH,EAAEkH,UAC3E,6BA3BI,MAAMC,GAAe,SAAS,CAACC,EAAkBC,KAC7C,MAAM9Q,EAAQW,KAAKyM,IAAI,EAAGzM,KAAKoQ,IAAe,EAAXF,EAAchS,KAAKsF,OAAOkM,OAAOW,wBAC9D/Q,EAASU,KAAKyM,IAAI,EAAGzM,KAAKoQ,IAAgB,EAAZD,EAAejS,KAAKsF,OAAOkM,OAAOW,wBAChEC,EAAa,CAAEjR,QAAOC,UAC5BpB,KAAKgQ,OAAO7O,MAAQA,EACpBnB,KAAKgQ,OAAO5O,OAASA,EACrBpB,KAAK+Q,eAAeqB,EAAW,GAChC,IAEH,IACqB,IAAIC,gBAAgBtN,IACjC,OAAO,WAAEuN,EAAU,UAAEC,IAAexN,EAAQA,EAAQyN,OAAS,GAAGC,0BAChEV,EAAaO,EAAYC,EAAU,IAE9BG,QAAQ1S,KAAKgQ,OAAQ,CAAE2C,IAAK,4BACzC,CAAE,MAEmB,IAAIN,gBAAgBtN,IACjC,OAAO,WAAEuN,EAAU,UAAEC,IAAexN,EAAQA,EAAQyN,OAAS,GAAGI,eAChEb,EAAaO,EAAaO,iBAAkBN,EAAYM,iBAAiB,IAEpEH,QAAQ1S,KAAKgQ,OAAQ,CAAE2C,IAAK,eACzC,CACJ,EAlIgB,EAAAjB,iBAAqC,CAAC,sBACtC,EAAAtE,aAAiC8D,UAAUC,IAAI2B,2BAC/C,EAAAtC,kBAAsC,yDCvB1D,QAAyB,ifCAlB,MAAMuC,EAA+B,6mCAqC/BC,EAA6C,i1JChCnD,SAASC,EACZC,EACAjM,EACA3B,EACAF,EACA+N,EAAY,GAEZ,MAAMC,EAAMD,EAAY,EAClBxT,EAAS2F,EAAOE,aAAa,CAC/BJ,QACA6B,QACAf,KAAOgN,EAAIG,WAAaD,GAAQA,EAChCE,kBAAkB,IAGhBC,EAAa,IAAIC,WAAW7T,EAAO8T,kBACnCC,EAAYR,aAAetT,YAC3B,IAAI4T,WAAWN,GACf,IAAIM,WAAWN,EAAIvT,OAAQuT,EAAIS,WAAYT,EAAIG,YAKrD,OAHAE,EAAWK,IAAIF,GACf/T,EAAOkU,QAEAlU,CACX,CAoDOmP,eAAegF,GAAqB,OACvCxO,EAAM,QACNmE,EAAO,SACPI,EAAW,EAAC,aACZkK,EAAY,cACZC,EAAa,aACbC,EAAY,YACZC,IAEA,MAAMC,EAAY,KAAoB1K,EAAQnC,QACxC8M,EAAkB,IAAW,gBAAgBF,GAAe,KAAKzK,EAAQrE,YAE/E,GAAiB,MAAb+O,EACA,MAAM,IAAIzD,MAAM,GAAG0D,YAA0B3K,EAAQnC,sBAGzD,MAAMnG,EAAQsI,EAAQtI,OAAS0I,EACzBzI,EAASqI,EAAQrI,QAAUyI,EAC3BwK,EAAiBlT,EAAQgT,EACzBG,EAAcxS,KAAKyM,IAAI8F,EAAgB,KACvCE,EAAenT,EACfoT,EAAWD,EAAeD,EAAc7K,EAAQ6D,mBAChDmH,EAAaJ,EAAiBjT,EAASqI,EAAQ6D,mBAErD,GAAoB,MAAhB2G,GAAwBA,EAAaZ,WAAamB,EAClD,MAAM,IAAI9D,MAAM,GAAG0D,2CACzBH,EAAaZ,gBAAgBmB,KAG3B,GAAqB,MAAjBR,GAAyBA,EAAc9N,KAAOsO,EAC9C,MAAM,IAAI9D,MAAM,GAAG0D,6CACzBJ,EAAc9N,UAAUsO,KAGtB,MAAME,EAAgBxN,eAAeE,SAAWF,eAAeyN,SAE/D,GAAqB,MAAjBX,IAA0BA,EAAc/M,MAAQyN,KAAmBA,EACnE,MAAM,IAAIhE,MAAM,GAAG0D,8DAClBJ,EAAc/M,oBACXyN,KAGR,IAAIE,EAAYX,GAAgB,IAAIT,WAAWgB,GAC/C,MAAMK,EAAUb,GAAiB1O,EAAOE,aAAa,CACjDJ,MAAO,GAAGgP,mBACVlO,KAAMsO,EACNvN,MAAOyN,IAGL3L,EAAUzD,EAAOwI,qBAAqB,CAAE1I,MAAO,GAAGgP,cACxDrL,EAAQ+L,oBACJ,CAAErL,UAASI,YACX,CAAElK,OAAQkV,EAASN,eAAcD,eACjC,CAAEnT,QAAOC,SAAQkM,mBAAoB7D,EAAQ6D,qBAEjDhI,EAAOiB,MAAMwH,OAAO,CAAChF,EAAQiF,iBAEvBW,QAAQoG,IAAI,CACdF,EAAQG,SAASC,WAAWC,KAAM,EAAGV,GACrClP,EAAOiB,MAAM2I,wBAGjB,MAAMiG,EAASN,EAAQpB,eAAe,EAAGe,GAIzC,GAHAI,EAAUhB,IAAI,IAAIJ,WAAW2B,IAC7BN,EAAQhB,QAEJS,EAAcD,EAAgB,CAC9B,IAAK,IAAIe,EAAI,EAAGA,EAAIhU,EAASqI,EAAQ6D,mBAAoB8H,GAAK,EAC1D,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAgBgB,GAAK,EACrCT,EAAUS,EAAID,EAAIf,GAAkBO,EAAUS,EAAID,EAAId,GAG9DM,EAAYA,EAAUtI,MAAM,EAAGmI,EACnC,CAEA,MAAO,CACHG,YACAZ,cAAeD,EAAec,OAAUlN,EAEhD,CAEOmH,eAAewG,EAAahQ,EAAmBmE,EAAqB8L,GAAO,GAC9E,MAAMpB,EAAY,KAAoB1K,EAAQnC,QACxCkO,EAAW,KAA2B/L,EAAQnC,QAEpD,GAAiB,MAAb6M,GAAiC,MAAZqB,EACrB,MAAM,IAAI9E,MAAM,0BAA0BjH,EAAQnC,aAAamC,EAAQrE,qBAG3E,MAAMqQ,EAAY,IAAI,MACtBA,EAAUC,WAAajM,EAAQtI,MAC/BsU,EAAUE,YAAclM,EAAQrI,OAChCqU,EAAUG,SAAW,KAAiBnM,EAAQnC,QAC9CmO,EAAUD,SAAWA,SACdC,EAAUI,SAASC,WAE1B,MAAMC,EAAaN,EAAUO,qBAAqB,GAclD,GAbAD,EAAWE,WAAa,MACxBF,EAAWG,iBAAmB,MAC9BH,EAAWI,WAAW,GAAKhC,EAE3B4B,EAAW7I,SAAU,QAAS,GAAIS,IAAM,CACpCyI,YAAa,CAAC,IAAK,IAAK,IAAK,KAAKzI,GAClC0I,eAAgB,CAAC,EAAG,EAAG,EAAG,GAC1BC,UAAgC,EAArBb,EAAUD,SAAe,EACpCe,UAAgC,EAArBd,EAAUD,SAAe7H,EACpC6I,aAAc,WACdC,YAAa,eAGS,OAAtBhN,EAAQP,UACRuM,EAAUiB,UAAY,EACtBjB,EAAUkB,WAAalN,EAAQ6D,wBAC5B,GAAIiI,EAAM,CACb,MAAMqB,EAAanN,EAAQ6D,mBAAqB,EAChDmI,EAAUoB,WAA4B,IAAfD,EAAmB,EAAIA,EAC9CnB,EAAUiB,UAAY,CAC1B,MACIjB,EAAUoB,WAAapN,EAAQ6D,mBAC/BmI,EAAUiB,UAAY,EAG1B,IAAI1C,EACAY,EAEJ,IAAK,IAAIjH,EAAI,EAAGA,EAAIlE,EAAQ6E,cAAeX,GAAK,IACzCiH,YAAWZ,uBAAwBF,EAAqB,CACvDjK,SAAU8D,EACVoG,cAAc,EACdzO,SACAmE,UACAuK,mBAGJyB,EAAUqB,OAAOC,KAAK,CAClBC,UAAWpC,EACXqC,uBAAwBrC,EAAUvB,aAI1C,OAAO,MAAeoC,EAC1B","sources":["webpack://cbunt-portfolio/./src/rendering/core/camera/camera.ts","webpack://cbunt-portfolio/./src/rendering/core/constants.ts","webpack://cbunt-portfolio/./src/rendering/core/global-uniforms.ts","webpack://cbunt-portfolio/./src/rendering/core/tonemap-pass.ts","webpack://cbunt-portfolio/./src/rendering/core/skybox-pass.ts","webpack://cbunt-portfolio/./src/rendering/core/gbuffer.ts","webpack://cbunt-portfolio/./src/rendering/shaders/brdfs.shader.ts","webpack://cbunt-portfolio/./src/rendering/core/ibl-textures/create-bfrd-lut.ts","webpack://cbunt-portfolio/./src/rendering/core/ibl-textures/create-irradiance-texture.ts","webpack://cbunt-portfolio/./src/rendering/core/ibl-textures/create-radiance-texture.ts","webpack://cbunt-portfolio/./src/rendering/core/deferred-pass.ts","webpack://cbunt-portfolio/./src/rendering/core/renderer.ts","webpack://cbunt-portfolio/./src/rendering/shaders/blit-vert.shader.ts","webpack://cbunt-portfolio/./src/rendering/shaders/cubemap-sampling.shader.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-copy.ts"],"sourcesContent":["import { Vec3, Mat4, mat4, Quat } from 'wgpu-matrix';\r\nimport { TypeSizes } from '../constants';\r\n\r\nexport type CameraParams = {\r\n    nearPlane: number,\r\n    farPlane: number,\r\n    fov: number,\r\n    width: number,\r\n    height: number,\r\n    projection: 'perspective' | 'ortho',\r\n};\r\n\r\nexport default class Camera {\r\n    static readonly worldToViewOffset = 0;\r\n    static readonly viewToClipOffset = this.worldToViewOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly worldToClipOffset = this.viewToClipOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly viewToWorldOffset = this.worldToClipOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly clipToViewOffset = this.viewToWorldOffset + TypeSizes.sizeofMat4x4f;\r\n    static readonly clipToWorldOffset = this.clipToViewOffset + TypeSizes.sizeofMat4x4f;\r\n\r\n    static readonly bufferLength = this.clipToWorldOffset + TypeSizes.sizeofMat4x4f;\r\n\r\n    /**\r\n   *  An ArrayBuffer containing the camera's worldToView, viewToClip, worldToClip,\r\n   *  viewToWorld, clipToView, and clipToWorld matrices as Float32Arrays for\r\n   *  easier transfer. Ordered as listed above.\r\n   */\r\n    readonly buffer: ArrayBuffer = new ArrayBuffer(Camera.bufferLength);\r\n\r\n    readonly worldToView: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.worldToViewOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly viewToClip: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.viewToClipOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly worldToClip: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.worldToClipOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly viewToWorld: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.viewToWorldOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly clipToView: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.clipToViewOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly clipToWorld: Mat4 = new Float32Array(\r\n        this.buffer,\r\n        Camera.clipToWorldOffset,\r\n        TypeSizes.mat4x4Count,\r\n    );\r\n\r\n    readonly location: Vec3 = new Float32Array([0, 0, 0]);\r\n    readonly rotation: Quat = new Float32Array([0, 0, 0, 1]);\r\n\r\n    params: CameraParams = {\r\n        nearPlane: 0.01,\r\n        farPlane: 500.0,\r\n        fov: 40,\r\n        width: 1920,\r\n        height: 1080,\r\n        projection: 'perspective',\r\n    };\r\n\r\n    constructor(viewParams: Partial<CameraParams> = {}) {\r\n        this.updateParams(viewParams);\r\n    }\r\n\r\n    updateParams(val: Partial<CameraParams>) {\r\n        this.params = { ...this.params, ...val };\r\n        this.#cacheProjection();\r\n    }\r\n\r\n    cacheView(): void {\r\n        mat4.fromQuat(this.rotation, this.viewToWorld);\r\n        mat4.setTranslation(this.viewToWorld, this.location, this.viewToWorld);\r\n        mat4.invert(this.viewToWorld, this.worldToView);\r\n        mat4.mul(this.viewToClip, this.worldToView, this.worldToClip);\r\n        mat4.mul(this.viewToWorld, this.clipToView, this.clipToWorld);\r\n    }\r\n\r\n    #cacheProjection(): void {\r\n        if (this.params.projection === 'perspective') {\r\n            mat4.perspective(\r\n                this.params.fov * (Math.PI / 180),\r\n                this.params.width / this.params.height,\r\n                this.params.nearPlane,\r\n                this.params.farPlane,\r\n                this.viewToClip,\r\n            );\r\n        } else {\r\n            const x = this.params.width / 2;\r\n            const y = this.params.height / 2;\r\n\r\n            mat4.ortho(\r\n                -x,\r\n                x,\r\n                -y,\r\n                y,\r\n                this.params.nearPlane,\r\n                this.params.farPlane,\r\n                this.viewToClip,\r\n            );\r\n        }\r\n\r\n        mat4.invert(this.viewToClip, this.clipToView);\r\n    }\r\n}\r\n","import * as ktxp from 'ktx-parse';\r\n\r\nexport const TypeSizes = {\r\n    mat4x4Count: 16,\r\n    sizeofMat4x4f: 16 * Float32Array.BYTES_PER_ELEMENT,\r\n};\r\n\r\nexport const VkFormatToWebGPU: Record<number, GPUTextureFormat | undefined> = {\r\n    // 8-bit formats\r\n    [ktxp.VK_FORMAT_R8_UNORM]: 'r8unorm',\r\n    [ktxp.VK_FORMAT_R8_SNORM]: 'r8snorm',\r\n    [ktxp.VK_FORMAT_R8_UINT]: 'r8uint',\r\n    [ktxp.VK_FORMAT_R8_SINT]: 'r8sint',\r\n    // 16-bit formats\r\n    [ktxp.VK_FORMAT_R16_UINT]: 'r16uint',\r\n    [ktxp.VK_FORMAT_R16_SINT]: 'r16sint',\r\n    [ktxp.VK_FORMAT_R16_SFLOAT]: 'r16float',\r\n    [ktxp.VK_FORMAT_R8G8_UNORM]: 'rg8unorm',\r\n    [ktxp.VK_FORMAT_R8G8_SNORM]: 'rg8snorm',\r\n    [ktxp.VK_FORMAT_R8G8_UINT]: 'rg8uint',\r\n    [ktxp.VK_FORMAT_R8G8_SINT]: 'rg8sint',\r\n    // 32-bit formats\r\n    [ktxp.VK_FORMAT_R32_UINT]: 'r32uint',\r\n    [ktxp.VK_FORMAT_R32_SINT]: 'r32sint',\r\n    [ktxp.VK_FORMAT_R32_SFLOAT]: 'r32float',\r\n    [ktxp.VK_FORMAT_R16G16_UINT]: 'rg16uint',\r\n    [ktxp.VK_FORMAT_R16G16_SINT]: 'rg16sint',\r\n    [ktxp.VK_FORMAT_R16G16_SFLOAT]: 'rg16float',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UNORM]: 'rgba8unorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SRGB]: 'rgba8unorm-srgb',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SNORM]: 'rgba8snorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UINT]: 'rgba8uint',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SINT]: 'rgba8sint',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_UNORM]: 'bgra8unorm',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_SRGB]: 'bgra8unorm-srgb',\r\n    // Packed 32-bit formats\r\n    [ktxp.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32]: 'rgb9e5ufloat',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UINT_PACK32]: 'rgb10a2uint',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UNORM_PACK32]: 'rgb10a2unorm',\r\n    [ktxp.VK_FORMAT_B10G11R11_UFLOAT_PACK32]: 'rg11b10ufloat',\r\n    // 64-bit formats\r\n    [ktxp.VK_FORMAT_R32G32_UINT]: 'rg32uint',\r\n    [ktxp.VK_FORMAT_R32G32_SINT]: 'rg32sint',\r\n    [ktxp.VK_FORMAT_R32G32_SFLOAT]: 'rg32float',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_UINT]: 'rgba16uint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SINT]: 'rgba16sint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SFLOAT]: 'rgba16float',\r\n    // 128-bit formats\r\n    [ktxp.VK_FORMAT_R32G32B32A32_UINT]: 'rgba32uint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SINT]: 'rgba32sint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SFLOAT]: 'rgba32float',\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    [ktxp.VK_FORMAT_BC1_RGBA_UNORM_BLOCK]: 'bc1-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC1_RGBA_SRGB_BLOCK]: 'bc1-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC2_UNORM_BLOCK]: 'bc2-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC2_SRGB_BLOCK]: 'bc2-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC3_UNORM_BLOCK]: 'bc3-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC3_SRGB_BLOCK]: 'bc3-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC4_UNORM_BLOCK]: 'bc4-r-unorm',\r\n    [ktxp.VK_FORMAT_BC4_SNORM_BLOCK]: 'bc4-r-snorm',\r\n    [ktxp.VK_FORMAT_BC5_UNORM_BLOCK]: 'bc5-rg-unorm',\r\n    [ktxp.VK_FORMAT_BC5_SNORM_BLOCK]: 'bc5-rg-snorm',\r\n    [ktxp.VK_FORMAT_BC6H_UFLOAT_BLOCK]: 'bc6h-rgb-ufloat',\r\n    [ktxp.VK_FORMAT_BC6H_SFLOAT_BLOCK]: 'bc6h-rgb-float',\r\n    [ktxp.VK_FORMAT_BC7_UNORM_BLOCK]: 'bc7-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC7_SRGB_BLOCK]: 'bc7-rgba-unorm-srgb',\r\n    // Currently unsupported extension formats:\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"etc2-rgb8unorm\",\r\n    // \"etc2-rgb8unorm-srgb\",\r\n    // \"etc2-rgb8a1unorm\",\r\n    // \"etc2-rgb8a1unorm-srgb\",\r\n    // \"etc2-rgba8unorm\",\r\n    // \"etc2-rgba8unorm-srgb\",\r\n    // \"eac-r11unorm\",\r\n    // \"eac-r11snorm\",\r\n    // \"eac-rg11unorm\",\r\n    // \"eac-rg11snorm\",\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"astc-4x4-unorm\",\r\n    // \"astc-4x4-unorm-srgb\",\r\n    // \"astc-5x4-unorm\",\r\n    // \"astc-5x4-unorm-srgb\",\r\n    // \"astc-5x5-unorm\",\r\n    // \"astc-5x5-unorm-srgb\",\r\n    // \"astc-6x5-unorm\",\r\n    // \"astc-6x5-unorm-srgb\",\r\n    // \"astc-6x6-unorm\",\r\n    // \"astc-6x6-unorm-srgb\",\r\n    // \"astc-8x5-unorm\",\r\n    // \"astc-8x5-unorm-srgb\",\r\n    // \"astc-8x6-unorm\",\r\n    // \"astc-8x6-unorm-srgb\",\r\n    // \"astc-8x8-unorm\",\r\n    // \"astc-8x8-unorm-srgb\",\r\n    // \"astc-10x5-unorm\",\r\n    // \"astc-10x5-unorm-srgb\",\r\n    // \"astc-10x6-unorm\",\r\n    // \"astc-10x6-unorm-srgb\",\r\n    // \"astc-10x8-unorm\",\r\n    // \"astc-10x8-unorm-srgb\",\r\n    // \"astc-10x10-unorm\",\r\n    // \"astc-10x10-unorm-srgb\",\r\n    // \"astc-12x10-unorm\",\r\n    // \"astc-12x10-unorm-srgb\",\r\n    // \"astc-12x12-unorm\",\r\n};\r\n\r\nexport const TextureFormatToSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 2,\r\n    rg8snorm: 2,\r\n    rg8uint: 2,\r\n    rg8sint: 2,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 4,\r\n    rg16sint: 4,\r\n    rg16float: 4,\r\n    rgba8unorm: 4,\r\n    'rgba8unorm-srgb': 4,\r\n    rgba8snorm: 4,\r\n    rgba8uint: 4,\r\n    rgba8sint: 4,\r\n    bgra8unorm: 4,\r\n    'bgra8unorm-srgb': 4,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 8,\r\n    rg32sint: 8,\r\n    rg32float: 8,\r\n    rgba16uint: 8,\r\n    rgba16sint: 8,\r\n    rgba16float: 8,\r\n    // 128-bit formats\r\n    rgba32uint: 16,\r\n    rgba32sint: 16,\r\n    rgba32float: 16,\r\n};\r\n\r\nexport const TextureFormatToChannelSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 1,\r\n    rg8snorm: 1,\r\n    rg8uint: 1,\r\n    rg8sint: 1,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 2,\r\n    rg16sint: 2,\r\n    rg16float: 2,\r\n    rgba8unorm: 1,\r\n    'rgba8unorm-srgb': 1,\r\n    rgba8snorm: 1,\r\n    rgba8uint: 1,\r\n    rgba8sint: 1,\r\n    bgra8unorm: 1,\r\n    'bgra8unorm-srgb': 1,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 4,\r\n    rg32sint: 4,\r\n    rg32float: 4,\r\n    rgba16uint: 2,\r\n    rgba16sint: 2,\r\n    rgba16float: 2,\r\n    // 128-bit formats\r\n    rgba32uint: 4,\r\n    rgba32sint: 4,\r\n    rgba32float: 4,\r\n};\r\n\r\nexport const WebGPUToVkFormat = Object.fromEntries(\r\n    Object.entries(VkFormatToWebGPU).map(([vk, wgpu]) => [wgpu, parseInt(vk, 10)]),\r\n) as Record<GPUTextureFormat, ktxp.VKFormat>;\r\n\r\nexport const textureTypeToDimension: Record<string, GPUTextureViewDimension> = {\r\n    texture_cube: 'cube',\r\n    texture_3d: '3d',\r\n    texture_2d: '2d',\r\n};\r\n","import Camera from './camera/camera';\r\n\r\nconst label = 'global uniforms';\r\n\r\nexport default class GlobalUniforms {\r\n    static readonly code = (group: number) => /* wgsl */`\r\n        struct GlobalUniforms {\r\n            worldToView: mat4x4f,\r\n            viewToClip: mat4x4f,\r\n            worldToClip: mat4x4f,\r\n            inverseWorldToView: mat4x4f,\r\n            inverseViewToClip: mat4x4f,\r\n            inverseWorldToClip: mat4x4f,\r\n        }\r\n\r\n        @group(${group}) @binding(0) var<uniform> globals: GlobalUniforms;\r\n    `;\r\n\r\n    static readonly bufferSize = Camera.bufferLength;\r\n\r\n    static readonly layoutDescriptor: GPUBindGroupLayoutDescriptor = {\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                buffer: { minBindingSize: GlobalUniforms.bufferSize },\r\n                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\r\n            },\r\n        ],\r\n    };\r\n\r\n    static readonly bufferDescriptor: GPUBufferDescriptor = {\r\n        label,\r\n        size: GlobalUniforms.bufferSize,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    };\r\n\r\n    deviceBuffer: GPUBuffer;\r\n    bindGroupLayout: GPUBindGroupLayout;\r\n    bindGroupDescriptor!: GPUBindGroupDescriptor;\r\n    bindgroup!: GPUBindGroup;\r\n\r\n    constructor(device: GPUDevice) {\r\n        this.deviceBuffer = device.createBuffer(GlobalUniforms.bufferDescriptor);\r\n        this.bindGroupLayout = device.createBindGroupLayout(GlobalUniforms.layoutDescriptor);\r\n\r\n        this.bindGroupDescriptor = {\r\n            label,\r\n            layout: this.bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.deviceBuffer,\r\n                        offset: 0,\r\n                        size: GlobalUniforms.bufferSize,\r\n                    },\r\n                },\r\n            ],\r\n        };\r\n\r\n        this.bindgroup = device.createBindGroup(this.bindGroupDescriptor);\r\n    }\r\n\r\n    updateDeviceBuffer(queue: GPUQueue, camera: Camera) {\r\n        camera.cacheView();\r\n        queue.writeBuffer(this.deviceBuffer, 0, camera.buffer);\r\n    }\r\n}\r\n","import blit from '../shaders/blit-vert.shader';\r\n\r\nconst label = 'tonemap pass';\r\n\r\nexport default class TonemapPass {\r\n    static readonly code = /* wgsl */`\r\n        @group(0) @binding(0) var colorTexture: texture_2d<f32>;\r\n\r\n        ${blit}\r\n\r\n        fn fitRRTAndODT(color: vec3f) -> vec3f {\r\n            let a = color * (color + 0.0245786) - 0.000090537;\r\n            let b = color * (0.983729 * color + 0.4329510) + 0.238081;\r\n            return a / b;\r\n        }\r\n\r\n        fn aces_tone_map(hdr: vec3f) -> vec3f {\r\n            const inputMat = mat3x3(\r\n                0.59719, 0.07600, 0.02840,\r\n                0.35458, 0.90834, 0.13383,\r\n                0.04823, 0.01566, 0.83777,\r\n            );\r\n            const outputMat = mat3x3(\r\n                1.60475, -0.10208, -0.00327,\r\n                -0.53108, 1.10813, -0.07276,\r\n                -0.07367, -0.00605, 1.07602,\r\n            );\r\n            const boost = 1.0 / 0.6;\r\n\r\n            var color = hdr * boost;\r\n            color = inputMat * color;\r\n            color = fitRRTAndODT(color);\r\n            color = outputMat * color;\r\n            return saturate(color);\r\n        }\r\n\r\n        fn linear_to_srgb(color: vec3f) -> vec3f {\r\n            return pow(color, vec3(1.0/2.2));\r\n        }\r\n\r\n        @fragment\r\n        fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {\r\n            let uv = vec2<i32>(floor(pos.xy));\r\n\r\n            var color = textureLoad(colorTexture, uv, 0).rgb;\r\n            color = aces_tone_map(color);\r\n            color = linear_to_srgb(color);\r\n            return vec4f(color, 1.0);\r\n        }\r\n    `;\r\n\r\n    static readonly bindGroupLayoutDescriptor: GPUBindGroupLayoutDescriptor = {\r\n        label,\r\n        entries: [{\r\n            binding: 0,\r\n            texture: { sampleType: 'float', viewDimension: '2d' },\r\n            visibility: GPUShaderStage.FRAGMENT,\r\n        }],\r\n    };\r\n\r\n    colorAttachment: GPURenderPassColorAttachment = {\r\n        loadOp: 'load',\r\n        storeOp: 'store',\r\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n        view: undefined!,\r\n    };\r\n\r\n    passDescriptor: GPURenderPassDescriptor = {\r\n        label,\r\n        colorAttachments: [this.colorAttachment],\r\n    };\r\n\r\n    pipeline: GPURenderPipeline;\r\n    pipelineDescriptor: GPURenderPipelineDescriptor;\r\n\r\n    renderTarget: GPUColorTargetState;\r\n    bindgroupLayout: GPUBindGroupLayout;\r\n    bindgroup?: GPUBindGroup;\r\n\r\n    constructor(\r\n        public device: GPUDevice,\r\n        format: GPUTextureFormat,\r\n    ) {\r\n        this.renderTarget = { format };\r\n        this.bindgroupLayout = device.createBindGroupLayout(TonemapPass.bindGroupLayoutDescriptor);\r\n        const module = device.createShaderModule({ label, code: TonemapPass.code });\r\n\r\n        this.pipelineDescriptor = {\r\n            label,\r\n            layout: device.createPipelineLayout({\r\n                label,\r\n                bindGroupLayouts: [this.bindgroupLayout],\r\n            }),\r\n            vertex: {\r\n                module,\r\n                entryPoint: 'vs',\r\n            },\r\n            fragment: {\r\n                module,\r\n                entryPoint: 'fs',\r\n                targets: [this.renderTarget],\r\n            },\r\n        };\r\n\r\n        this.pipeline = device.createRenderPipeline(this.pipelineDescriptor);\r\n    }\r\n\r\n    updateInput(input: GPUTextureView) {\r\n        this.bindgroup = this.device.createBindGroup({\r\n            label,\r\n            layout: this.bindgroupLayout,\r\n            entries: [{\r\n                binding: 0,\r\n                resource: input,\r\n            }],\r\n        });\r\n    }\r\n\r\n    render(encoder: GPUCommandEncoder, output: GPUTexture) {\r\n        if (this.bindgroup == null) return;\r\n\r\n        if (this.renderTarget.format !== output.format) {\r\n            this.renderTarget.format = output.format;\r\n            this.pipeline = this.device.createRenderPipeline(this.pipelineDescriptor);\r\n        }\r\n\r\n        this.colorAttachment.view = output.createView({ dimension: '2d' });\r\n\r\n        const pass = encoder.beginRenderPass(this.passDescriptor);\r\n        pass.setPipeline(this.pipeline);\r\n        pass.setBindGroup(0, this.bindgroup);\r\n        pass.draw(3);\r\n        pass.end();\r\n    }\r\n}\r\n","import GlobalUniforms from './global-uniforms';\n\nconst label = 'skybox pass';\n\nexport default class SkyboxPass {\n    static readonly code = /* wgsl */`\n        ${GlobalUniforms.code(0)}\n\n        struct SkyboxUniforms {\n            mipBias: f32,\n        };\n\n        @group(1) @binding(0) var environmentTexture: texture_cube<f32>;\n        @group(1) @binding(1) var depthTexture: texture_depth_2d;\n        @group(1) @binding(2) var environmentSampler: sampler;\n        @group(1) @binding(3) var<uniform> skyboxUniforms: SkyboxUniforms;\n\n        struct Varyings {\n            @builtin(position) position: vec4f,\n            @location(0) pos: vec4f,\n            @location(1) mipBias: f32,\n        };\n    \n        @vertex \n        fn vs(@builtin(vertex_index) vNdx: u32) -> Varyings {\n            const pos = array(\n                vec2(-1.0,  3.0),\n                vec2(-1.0, -1.0),\n                vec2( 3.0, -1.0),\n            );\n    \n            var vsOut: Varyings;\n            vsOut.position = vec4(pos[vNdx], 0.0, 1.0);\n    \n            // Ignores the camera's translation without needing a separate rotation matrix.\n            vsOut.pos = globals.inverseViewToClip * vsOut.position;\n            let w = vsOut.pos.w;\n            vsOut.pos.w = 0.0;\n            vsOut.pos = globals.inverseWorldToView * vsOut.pos;\n            vsOut.pos.w = w;\n\n            vsOut.mipBias = clamp(skyboxUniforms.mipBias, 0, f32(textureNumLevels(environmentTexture)));\n            return vsOut;\n        }\n\n        @fragment\n        fn fs(in: Varyings) -> @location(0) vec4f {\n            let dimensions = textureDimensions(depthTexture);\n            let uv = min(vec2<u32>(floor(in.position.xy)), dimensions - 1);\n            let depth = textureLoad(depthTexture, uv, 0);\n            if (depth < 1.0) { discard; }\n\n            let t = normalize(in.pos.xyz / in.pos.w);\n            let color = textureSampleLevel(environmentTexture, environmentSampler, t, in.mipBias).rgb;\n            return vec4(color, 1.0);\n        }\n    `;\n\n    bindgroupLayout: GPUBindGroupLayout;\n    pipelineLayout: GPUPipelineLayout;\n    shader: GPUShaderModule;\n\n    linearSampler: GPUSampler;\n    nearestSampler: GPUSampler;\n    textureBindgroup?: GPUBindGroup;\n\n    uniformBuffer: GPUBuffer;\n    uniformArray = new Float32Array(8);\n\n    pipeline?: GPURenderPipeline;\n\n    #skyTexture?: GPUTextureView;\n    #depthTexture?: GPUTextureView;\n    #targetFormat!: GPUTextureFormat;\n    #useNearestSample = false;\n\n    get mipLevel() { return this.uniformArray[0]; }\n    set mipLevel(val: number) {\n        if (val === this.uniformArray[0]) return;\n        this.uniformArray[0] = val;\n        this.device.queue.writeBuffer(this.uniformBuffer, 0, this.uniformArray, 0, 1);\n    }\n\n    get useNearestSample() { return this.#useNearestSample; }\n    set useNearestSample(val: boolean) {\n        if (val === this.#useNearestSample) return;\n        this.#useNearestSample = val;\n        this.#updateBindgroup();\n    }\n\n    get targetFormat() { return this.#targetFormat; }\n    set targetFormat(format: GPUTextureFormat) {\n        if (format === this.#targetFormat) return;\n        this.#targetFormat = format;\n\n        this.pipeline = this.device.createRenderPipeline({\n            label,\n            layout: this.pipelineLayout,\n            vertex: {\n                entryPoint: 'vs',\n                module: this.shader,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                targets: [{ format }],\n                module: this.shader,\n            },\n        });\n    }\n\n    set skyTexture(skybox: GPUTextureView) {\n        if (skybox === this.#skyTexture) return;\n        this.#skyTexture = skybox;\n        this.#updateBindgroup();\n    }\n\n    set depthTexture(depthTexture: GPUTextureView) {\n        if (depthTexture === this.#depthTexture) return;\n        this.#depthTexture = depthTexture;\n        this.#updateBindgroup();\n    }\n\n    target: GPURenderPassColorAttachment = {\n        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        loadOp: 'clear',\n        storeOp: 'store',\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        view: undefined!,\n    };\n\n    readonly passDescriptor: GPURenderPassDescriptor = { colorAttachments: [this.target] };\n\n    constructor(\n        public device: GPUDevice,\n        public globals: GlobalUniforms,\n        targetFormat: GPUTextureFormat,\n        skybox?: GPUTextureView,\n    ) {\n        this.bindgroupLayout = device.createBindGroupLayout({\n            label,\n            entries: [\n                {\n                    binding: 0,\n                    texture: { viewDimension: 'cube' },\n                    visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n                },\n                {\n                    binding: 1,\n                    texture: {\n                        viewDimension: '2d',\n                        sampleType: 'depth',\n                    },\n                    visibility: GPUShaderStage.FRAGMENT,\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: { type: 'uniform' },\n                },\n            ],\n        });\n\n        this.linearSampler = device.createSampler({\n            minFilter: 'linear',\n            magFilter: 'linear',\n            mipmapFilter: 'linear',\n        });\n\n        this.nearestSampler = device.createSampler({\n            minFilter: 'nearest',\n            magFilter: 'nearest',\n            mipmapFilter: 'nearest',\n        });\n\n        this.shader = device.createShaderModule({\n            code: SkyboxPass.code,\n            label,\n        });\n\n        this.pipelineLayout = device.createPipelineLayout({\n            label,\n            bindGroupLayouts: [\n                globals.bindGroupLayout,\n                this.bindgroupLayout,\n            ],\n        });\n\n        this.uniformBuffer = device.createBuffer({\n            label,\n            size: 32,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        });\n\n        this.targetFormat = targetFormat;\n        if (skybox != null) this.skyTexture = skybox;\n    }\n\n    render(pass: GPURenderPassEncoder) {\n        if (this.textureBindgroup == null || this.pipeline == null) return false;\n        pass.setPipeline(this.pipeline);\n        pass.setBindGroup(0, this.globals.bindgroup);\n        pass.setBindGroup(1, this.textureBindgroup);\n        pass.draw(3);\n        return true;\n    }\n\n    #updateBindgroup() {\n        if (this.#skyTexture == null || this.#depthTexture == null) return;\n\n        this.textureBindgroup = this.device.createBindGroup({\n            label,\n            layout: this.bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: this.#skyTexture,\n                },\n                {\n                    binding: 1,\n                    resource: this.#depthTexture,\n                },\n                {\n                    binding: 2,\n                    resource: this.useNearestSample\n                        ? this.nearestSampler\n                        : this.linearSampler,\n                },\n                {\n                    binding: 3,\n                    resource: { buffer: this.uniformBuffer },\n                },\n            ],\n        });\n    }\n}\n","type TextureData = {\n    format: GPUTextureFormat,\n    name: string,\n    clearValue?: GPUColor,\n    texture?: GPUTexture,\n    view?: GPUTextureView,\n};\n\nexport const enum GBufferGroupIndices {\n    Normal = 0,\n    Albedo,\n    Emission,\n    MetallicRoughness,\n    Depth,\n}\n\nexport default class GBuffer {\n    static readonly code = (group: number) => /* wgsl */`\n        @group(${group}) @binding(${GBufferGroupIndices.Normal}) \n        var gBufferNormal: texture_2d<f32>;\n        \n        @group(${group}) @binding(${GBufferGroupIndices.Albedo}) \n        var gBufferAlbedo: texture_2d<f32>;\n        \n        @group(${group}) @binding(${GBufferGroupIndices.Emission}) \n        var gBufferEmission: texture_2d<f32>;\n\n        @group(${group}) @binding(${GBufferGroupIndices.MetallicRoughness}) \n        var gBufferMetallicRoughness: texture_2d<f32>;\n        \n        @group(${group}) @binding(${GBufferGroupIndices.Depth})  \n        var gBufferDepth: texture_depth_2d;\n    `;\n\n    static readonly layoutDescription: GPUBindGroupLayoutDescriptor = {\n        label: 'gbuffer bind group layout',\n        entries: [\n            {\n                binding: GBufferGroupIndices.Normal,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { sampleType: 'unfilterable-float' },\n            },\n            {\n                binding: GBufferGroupIndices.Albedo,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { sampleType: 'float' },\n            },\n            {\n                binding: GBufferGroupIndices.Emission,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { sampleType: 'float' },\n            },\n            {\n                binding: GBufferGroupIndices.MetallicRoughness,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { sampleType: 'unfilterable-float' },\n            },\n            {\n                binding: GBufferGroupIndices.Depth,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { sampleType: 'depth' },\n            },\n        ],\n    };\n\n    normal = this.createTexture({\n        format: 'rgba16float',\n        name: 'normal',\n        clearValue: { r: 0, g: 0, b: 1, a: 1 },\n    });\n\n    albedo = this.createTexture({\n        format: 'rgba8unorm',\n        name: 'albedo',\n        clearValue: { r: 0, g: 0, b: 0, a: 1 },\n    });\n\n    emission = this.createTexture({\n        format: 'rgba16float',\n        name: 'emission',\n        clearValue: { r: 0, g: 0, b: 0, a: 1 },\n    });\n\n    metallicRoughness = this.createTexture({\n        format: 'rg8unorm',\n        name: 'metallic roughness',\n        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n    });\n\n    depth = this.createTexture({\n        format: 'depth32float',\n        name: 'depth',\n    });\n\n    textures = [\n        this.normal,\n        this.albedo,\n        this.emission,\n        this.metallicRoughness,\n        this.depth,\n    ];\n\n    targets = this.textures.slice(0, -1).map(({ format }) => ({ format }));\n\n    bindGroupLayout = this.device.createBindGroupLayout(GBuffer.layoutDescription);\n    bindgroup = this.updateBindgroup();\n    passDescriptor = this.updatePassDescriptor();\n\n    get size() { return this._size; }\n    set size(value: GPUExtent3D) {\n        this._size = value;\n\n        this.textures.forEach((tex) => { this.createTexture(tex); });\n        this.bindgroup = this.updateBindgroup();\n        this.passDescriptor = this.updatePassDescriptor();\n    }\n\n    constructor(\n        public readonly device: GPUDevice,\n        private _size: GPUExtent3D,\n    ) { }\n\n    updateBindgroup() {\n        const entries = this.textures.map(({ view }, idx) => ({\n            binding: idx,\n            resource: view,\n        }));\n\n        return this.device.createBindGroup({\n            label: 'gbuffer bind group',\n            layout: this.bindGroupLayout,\n            entries,\n        });\n    }\n\n    updatePassDescriptor() {\n        const colorAttachments = this.textures.slice(0, -1).map(({ view, clearValue }) => ({\n            view: view,\n            clearValue: clearValue,\n            loadOp: 'clear',\n            storeOp: 'store',\n        }));\n\n        return {\n            label: 'forward pass encoder',\n            colorAttachments,\n            depthStencilAttachment: {\n                view: this.depth.view,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n                depthClearValue: 1.0,\n            },\n        } as GPURenderPassDescriptor;\n    }\n\n    createTexture(tex: TextureData) {\n        const label = `gbuffer ${tex.name}`;\n        tex.texture = this.device.createTexture({\n            label,\n            size: this._size,\n            format: tex.format,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n        });\n        tex.view = tex.texture.createView({ label });\n        return tex as TextureData & Required<Pick<TextureData, 'texture' | 'view'>>;\n    }\n}\n","export default /* wgsl */`\n    fn hammersley(i: u32, N: u32) -> vec2f {\n        var bits = (i << 16u) | (i >> 16u);\n        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n        let rdi = f32(bits) * 2.3283064365386963e-10; // / 0x100000000\n        return vec2(f32(i) / f32(N), rdi);\n    }\n\n    fn tangentSampleGGX(N: vec3f, Xi: vec2f, a2: f32) -> vec3f {\n        const PI = 3.14159265359;\n\n        let phi = 2.0 * PI * Xi.x;\n        let cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));\n        let sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n        \n        var H: vec3f;\n        H.x = cos(phi) * sinTheta;\n        H.y = sin(phi) * sinTheta;\n        H.z = cosTheta;\n\n        let up = select(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), abs(N.z) >= 0.999);\n        let T = normalize(cross(up, N));\n        let B = cross(N, T);\n\n        let S = T * H.x + B * H.y + N * H.z;\n        return normalize(S);\n    }\n\n    fn vPartLambda(NoV: f32, a2: f32) -> f32 {\n        return sqrt(NoV * NoV * (1.0 - a2) + a2);\n    }\n\n    fn vCorrelatedGGX(NoV: f32, NoL: f32, a2: f32) -> f32 {\n        let GGXV = NoL * vPartLambda(NoV, a2);\n        let GGXL = NoV * vPartLambda(NoL, a2);\n        return 0.5 / (GGXV + GGXL);\n    }\n\n    fn dS2GGX(NoH: f32, a2: f32) -> f32 {\n        let s = (a2 - 1.0) * NoH * NoH + 1.0;\n        return s * s;\n    }\n\n    fn dGGX(NoH: f32, a2: f32) -> f32 {\n        const invPI = 1.0 / 3.14159265359;\n\n        let s2 = dS2GGX(NoH, a2);\n        return invPI * select(1, a2 / s2, a2 != s2);\n    }\n`;\n","import brdfs from '../../shaders/brdfs.shader';\nimport blit from '../../shaders/blit-vert.shader';\n\nconst code = /* wgsl */ `\noverride SAMPLE_COUNT: u32 = 1024u;\n\n${blit}\n${brdfs}\n\n@fragment\nfn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n    let NoV = uv.x;\n    let roughness = uv.y;\n    let alpha = roughness * roughness;\n    let a2 = alpha * alpha;\n    let V = vec3(sqrt(1.0 - NoV * NoV), NoV, 0.0);\n    let N = vec3(0.0, 1.0, 0.0);\n\n    var brdf = vec2(0.0);\n\n    for (var i = 0u; i < SAMPLE_COUNT; i++) {\n        let Xi = hammersley(i, SAMPLE_COUNT);\n        let H = tangentSampleGGX(N, Xi, a2);\n        let L = normalize(2.0 * dot(V, H) * H - V);\n\n        let NoL = saturate(L.y);\n        let NoH = saturate(H.y);\n        let VoH = saturate(dot(V, H));\n\n        if (NoL > 0.0) {\n            let pdf = vCorrelatedGGX(NoV, NoL, a2) * VoH * NoL / NoH;\n            let Fc = pow(1.0 - VoH, 5.0);\n            brdf += vec2(1.0 - Fc, Fc) * pdf;\n        }\n    }\n\n    return vec4f(brdf * 4.0 / f32(SAMPLE_COUNT), 0.0, 1.0);\n}\n`;\n\nexport type BfrdLutDescriptor = {\n    device: GPUDevice,\n    label?: string,\n    width?: number,\n    height?: number,\n    format?: GPUTextureFormat,\n    sampleCount?: number,\n};\n\nexport function createBfrdLut({\n    device,\n    label,\n    sampleCount,\n    width = 1024,\n    height = 1024,\n    format = 'rg32float',\n}: BfrdLutDescriptor) {\n    const bfrdLut = device.createTexture({\n        label,\n        format,\n        dimension: '2d',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n        size: { width, height },\n    });\n\n    const module = device.createShaderModule({ label: 'bfrdLut shader', code });\n\n    const pipeline = device.createRenderPipeline({\n        label: 'bfrd lut pipeline',\n        layout: 'auto',\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format }],\n            constants: sampleCount ? { SAMPLE_COUNT: sampleCount } : undefined,\n            module,\n        },\n    });\n\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n        label: 'brdf lut render pass',\n        colorAttachments: [{\n            view: bfrdLut.createView(),\n            loadOp: 'clear',\n            storeOp: 'store',\n        }],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n\n    return bfrdLut;\n}\n","import { toWorldDir } from '../../shaders/cubemap-sampling.shader';\nimport brdfs from '../../shaders/brdfs.shader';\nimport blit from '../../shaders/blit-vert.shader';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\n\nconst code = /* wgsl */`\n    const PI = 3.14159265359;\n\n    override SAMPLES: u32 = 2048u;\n\n    struct Params {\n        face: u32,\n        size: u32,\n    }\n\n    @group(0) @binding(0) var environment: texture_cube<f32>;\n    @group(0) @binding(1) var environmentSampler: sampler;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    ${toWorldDir}\n    ${brdfs}\n    ${blit}\n\n    @fragment\n    fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {\n        let coord = vec3u(vec2u(floor(pos.xy)), params.face);\n        let size = f32(textureDimensions(environment).x);\n        let lodFactor = 6.0 * size * size / f32(SAMPLES);\n\n        let N = toWorldDir(coord, params.size);\n        let right = normalize(cross(vec3(0.0, 1.0, 0.0), N));\n        let up = normalize(cross(N, right));\n        let TBN = mat3x3(right, up, N);\n        \n        var irradiance = vec3(0.0);\n        var samples = 0.0;\n\n        for (var i = 0u; i < SAMPLES; i += 1) {\n            let xi = hammersley(i, SAMPLES);\n            let cosTheta = sqrt(1.0 - xi.y);\n            let sinTheta = sqrt(xi.y);\n            let phi = 2.0 * PI * xi.x;\n            let invPdf = PI / cosTheta;\n            let localDir = normalize(vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta));\n            let worldDir = TBN * localDir;\n            let lod = 0.5 * log2(lodFactor * invPdf);\n            irradiance += textureSampleLevel(environment, environmentSampler, worldDir, lod).rgb;\n        }\n\n        return vec4(irradiance / f32(SAMPLES), 1.0);\n    }\n`;\n\nexport type IrradianceTextureDescriptor = {\n    device: GPUDevice,\n    texture: GPUTexture,\n    label?: string,\n    usage?: GPUTextureUsageFlags,\n    samples?: number,\n    outputWidth?: number,\n    outputFormat?: GPUTextureFormat,\n    outputTexture?: GPUTexture,\n};\n\nexport default function createIrradianceTexture({\n    device,\n    texture,\n    label = 'irradiance',\n    usage = 0,\n    samples = 2048,\n    outputWidth,\n    outputFormat,\n    outputTexture,\n}: IrradianceTextureDescriptor) {\n    const format = outputTexture?.format ?? outputFormat ?? texture.format;\n    const width = outputTexture?.width ?? outputWidth ?? 64;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { viewDimension: 'cube' },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.FRAGMENT,\n                sampler: {},\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.FRAGMENT,\n                buffer: { type: 'uniform' },\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({ minFilter: 'linear', magFilter: 'linear', mipmapFilter: 'linear' });\n\n    const irradianceTexture = outputTexture?.depthOrArrayLayers === 6\n        ? outputTexture\n        : device.createTexture({\n                label,\n                format,\n                dimension: '2d',\n                usage: GPUTextureUsage.RENDER_ATTACHMENT | usage,\n                size: { width, height: width, depthOrArrayLayers: 6 },\n            });\n\n    const params = new Uint32Array([0, irradianceTexture.width]);\n    const paramBuffer = createAndCopyBuffer(\n        params,\n        GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        device,\n    );\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: texture.createView({ dimension: 'cube' }),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n            {\n                binding: 2,\n                resource: { buffer: paramBuffer },\n            },\n        ],\n    });\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const module = device.createShaderModule({ label, code });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            module,\n            entryPoint: 'vs',\n        },\n        fragment: {\n            entryPoint: 'fs',\n            constants: {\n                SAMPLES: samples,\n            },\n            module,\n            targets: [{ format }],\n        },\n    });\n\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n\n        const view = irradianceTexture.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            colorAttachments: [{\n                view,\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n\n    return irradianceTexture;\n}\n","import { toWorldDir } from '../../shaders/cubemap-sampling.shader';\nimport brdfs from '../../shaders/brdfs.shader';\nimport blit from '../../shaders/blit-vert.shader';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\n\nconst code = /* wgsl */`\n    override SAMPLES: u32 = 1024u;\n\n    const PI = 3.14159265359;\n    const invPI = 1.0 / PI;\n\n    struct Params {\n        face: u32,\n        mipSize: u32,\n        invOmegaP: f32,\n        a2: f32,\n    }\n\n    @group(0) @binding(0) var environment: texture_cube<f32>;\n    @group(0) @binding(1) var environmentSampler: sampler;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    ${toWorldDir}\n    ${brdfs}\n    ${blit}\n\n    @fragment\n    fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n        let N = toWorldDirF32(uv, params.face);\n\n        var radiance = vec3(0.0);\n        var totalWeight = 0.0;\n        \n        for (var i = 0u; i < SAMPLES; i += 1) {\n            let Xi = hammersley(i, SAMPLES);\n            let H = tangentSampleGGX(N, Xi, params.a2);\n            let HoV = saturate(dot(H, N));\n            let L = normalize(2.0 * HoV * H - N);\n            let NoL = saturate(dot(N, L));\n\n            if (NoL <= 0.0) { continue; }\n\n            let pdf = dGGX(HoV, params.a2) / 4.0 + 0.001;\n            let omegaS = 1.0 / (f32(SAMPLES) * pdf);\n            let mipLevel = 0.5 * log2(omegaS * params.invOmegaP) + params.a2;\n\n            radiance += textureSampleLevel(environment, environmentSampler, L, mipLevel).rgb * NoL;\n            totalWeight += NoL;\n        }\n    \n        return vec4(radiance / totalWeight, 1.0);\n    }\n`;\n\nexport type IrradianceTextureDescriptor = {\n    device: GPUDevice,\n    texture: GPUTexture,\n    label?: string,\n    usage?: GPUTextureUsageFlags,\n    targetFormat?: GPUTextureFormat,\n    outputTexture?: GPUTexture,\n    outputWidth?: number,\n    samples?: number,\n    inPlaceMips?: boolean,\n};\n\nexport default function createRadianceTexture({\n    device,\n    texture,\n    targetFormat,\n    usage = 0,\n    label = 'radiance',\n    samples = 1024,\n    outputWidth,\n    outputTexture,\n}: IrradianceTextureDescriptor) {\n    const format = outputTexture?.format ?? targetFormat ?? texture.format;\n    const width = outputTexture?.width ?? outputWidth ?? texture.width;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: { viewDimension: 'cube' },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.FRAGMENT,\n                sampler: {},\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.FRAGMENT,\n                buffer: { type: 'uniform' },\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({ minFilter: 'linear', magFilter: 'linear', mipmapFilter: 'linear' });\n    const paramArrayBuffer = new ArrayBuffer(4 * 4);\n    const uintParams = new Uint32Array(paramArrayBuffer, 0, 2);\n    const floatParams = new Float32Array(paramArrayBuffer, 2 * 4, 2);\n\n    const paramBuffer = createAndCopyBuffer(\n        paramArrayBuffer,\n        GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        device,\n    );\n\n    const radianceTexture = outputTexture?.depthOrArrayLayers === 6\n        ? outputTexture\n        : device.createTexture({\n                label,\n                format,\n                dimension: '2d',\n                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST | usage,\n                size: { width, height: width, depthOrArrayLayers: 6 },\n                mipLevelCount: Math.max((Math.log2(width) | 0) - 2, 1),\n            });\n\n    const copyEncoder = device.createCommandEncoder({\n        label: `${label} copy encoder`,\n    });\n\n    copyEncoder.copyTextureToTexture(\n        { texture, mipLevel: 0 },\n        { texture: radianceTexture, mipLevel: 0 },\n        { width, height: width, depthOrArrayLayers: 6 },\n    );\n    device.queue.submit([copyEncoder.finish()]);\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const module = device.createShaderModule({ label, code });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            module,\n            entryPoint: 'vs',\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: radianceTexture.format }],\n            constants: {\n                SAMPLES: samples,\n            },\n            module,\n        },\n    });\n\n    floatParams[0] = (6 * texture.width * texture.width) / (4 * Math.PI);\n\n    void Promise.resolve().then(async () => {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: texture.createView({ dimension: 'cube' }),\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n                {\n                    binding: 2,\n                    resource: { buffer: paramBuffer },\n                },\n            ],\n        });\n\n        for (let mip = 1; mip < radianceTexture.mipLevelCount; mip += 1) {\n            const roughness = mip / (radianceTexture.mipLevelCount - 1);\n            floatParams[1] = roughness ** 4;\n            uintParams[1] = (radianceTexture.width >> mip) | 0;\n\n            for (let face = 0; face < 6; face += 1) {\n                await device.queue.onSubmittedWorkDone();\n                uintParams[0] = face;\n                device.queue.writeBuffer(paramBuffer, 0, paramArrayBuffer);\n\n                const view = radianceTexture.createView({\n                    dimension: '2d',\n                    arrayLayerCount: 1,\n                    baseArrayLayer: face,\n                    mipLevelCount: 1,\n                    baseMipLevel: mip,\n                });\n\n                const encoder = device.createCommandEncoder();\n                const pass = encoder.beginRenderPass({\n                    colorAttachments: [{\n                        view,\n                        loadOp: 'clear',\n                        storeOp: 'store',\n                    }],\n                });\n\n                pass.setPipeline(pipeline);\n                pass.setBindGroup(0, bindgroup);\n                pass.draw(3);\n                pass.end();\n                device.queue.submit([encoder.finish()]);\n            }\n        }\n    });\n\n    return radianceTexture;\n}\n","import GBuffer from './gbuffer';\nimport brdfs from '../shaders/brdfs.shader';\nimport blit from '../shaders/blit-vert.shader';\nimport GlobalUniforms from './global-uniforms';\nimport { createBfrdLut } from './ibl-textures/create-bfrd-lut';\nimport createIrradianceTexture from './ibl-textures/create-irradiance-texture';\nimport createRadianceTexture from './ibl-textures/create-radiance-texture';\n\nexport default class DeferredPass {\n    static readonly code = /* wgsl */`\n        ${GlobalUniforms.code(0)}\n        ${GBuffer.code(1)}\n\n        @group(2) @binding(0) var radianceTexture: texture_cube<f32>;\n        @group(2) @binding(1) var irradianceTexture: texture_cube<f32>;\n        @group(2) @binding(2) var brdfTexture: texture_2d<f32>;\n        @group(2) @binding(3) var generalSampler: sampler;\n\n        ${brdfs}\n        ${blit}\n\n        @fragment\n        fn fs(@builtin(position) pos: vec4f, @location(0) uv: vec2f) -> @location(0) vec4f {\n            let uvi = vec2<u32>(pos.xy);\n            let depth = textureLoad(gBufferDepth, uvi, 0);\n\n            if (depth >= 1.0) { discard; }\n\n            let uvClip = vec2(uv.x * 2.0 - 1.0, 1.0 - uv.y * 2.0);\n            let clipPos = vec4(uvClip, depth, 1.0);\n            let viewPos = globals.inverseViewToClip * clipPos;\n            let worldDir = globals.inverseWorldToView * vec4(viewPos.xyz / viewPos.w, 0.0);\n            let view = -normalize(worldDir.xyz);\n\n            let normal = textureLoad(gBufferNormal, uvi, 0).rgb;\n            let albedo = textureLoad(gBufferAlbedo, uvi, 0).rgb;\n            let emission = textureLoad(gBufferEmission, uvi, 0).rgb;\n            let metallicRoughnessSample = textureLoad(gBufferMetallicRoughness, uvi, 0);\n            let metallic = metallicRoughnessSample.r;\n            let roughness = metallicRoughnessSample.g;\n            let alpha = roughness * roughness;\n            let a2 = alpha * alpha;\n\n            let NoV = saturate(dot(normal, view));\n            let F0 = mix(vec3f(0.04), albedo, metallic);\n            let R = reflect(-view, normal);\n\n            let level = roughness * f32(textureNumLevels(radianceTexture) - 1u);\n            let radiance = textureSampleLevel(radianceTexture, generalSampler, R, level).rgb;\n            let irradiance = textureSample(irradianceTexture, generalSampler, normal).rgb;\n            let brdf = textureSample(brdfTexture, generalSampler, saturate(vec2f(NoV, roughness))).xy;\n\n            // Roughness dependent fresnel\n            let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n            let kS = F0 + Fr * pow(1.0 - NoV, 5.0);\n            let FssEss = kS * brdf.x + brdf.y;\n\n            // Multiple scattering, originally proposed by Fdez-Aguera\n            // and here adapted from https://bruop.github.io/ibl\n            let Ems = 1.0 - (brdf.x + brdf.y);\n            let Favg = F0 + (1.0 - F0) / 21.0;\n            let FmsEms = Ems * FssEss * Favg / (1.0 - Favg * Ems);\n            let kD = albedo * (1.0 - 0.04) * (1.0 - metallic) * (1.0 - FssEss + FmsEms);\n\n            let specular = FssEss * radiance;\n            let diffuse = (FmsEms + kD) * irradiance;\n            let ambient = specular + diffuse + emission;\n\n            return vec4f(ambient, 1.0);\n        }\n    `;\n\n    target: GPURenderPassColorAttachment = {\n        view: undefined!, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        clearValue: { r: 0, g: 0, b: 0, a: 1 },\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n\n    bfrdLut = createBfrdLut({ device: this.device });\n    bfrdLutView = this.bfrdLut.createView();\n\n    irradianceTexture?: GPUTexture;\n    irradianceView?: GPUTextureView;\n    radianceTexture?: GPUTexture;\n    radianceView?: GPUTextureView;\n    bindgroup?: GPUBindGroup;\n\n    sampler: GPUSampler;\n    pipeline: GPURenderPipeline;\n    bindgroupLayout: GPUBindGroupLayout;\n\n    readonly passDescriptor: GPURenderPassDescriptor = { colorAttachments: [this.target] };\n\n    set skybox(texture: GPUTexture) {\n        this.irradianceTexture = createIrradianceTexture({\n            texture,\n            device: this.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        this.radianceTexture = createRadianceTexture({\n            texture,\n            device: this.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        this.irradianceView = this.irradianceTexture.createView({ dimension: 'cube' });\n        this.radianceView = this.radianceTexture.createView({ dimension: 'cube' });\n\n        this.bindgroup = this.device.createBindGroup({\n            layout: this.bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: this.radianceView,\n                },\n                {\n                    binding: 1,\n                    resource: this.irradianceView,\n                },\n                {\n                    binding: 2,\n                    resource: this.bfrdLutView,\n                },\n                {\n                    binding: 3,\n                    resource: this.sampler,\n                },\n            ],\n        });\n    }\n\n    constructor(public device: GPUDevice, public globals: GlobalUniforms, public gbuffer: GBuffer, format: GPUTextureFormat, skybox?: GPUTexture) {\n        this.sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear', mipmapFilter: 'linear' });\n\n        if (skybox != null) this.skybox = skybox;\n\n        this.bindgroupLayout = device.createBindGroupLayout({\n            label: 'deferred pass',\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: { viewDimension: 'cube' },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: { viewDimension: 'cube' },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: { viewDimension: '2d' },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n            ],\n        });\n\n        const layout = device.createPipelineLayout({\n            label: 'deferred pass bindgroup layout',\n            bindGroupLayouts: [\n                this.globals.bindGroupLayout,\n                this.gbuffer.bindGroupLayout,\n                this.bindgroupLayout,\n            ],\n        });\n\n        const module = device.createShaderModule({ code: DeferredPass.code, label: 'deferred pass shader' });\n\n        this.pipeline = device.createRenderPipeline({\n            layout,\n            vertex: {\n                entryPoint: 'vs',\n                module,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                targets: [{ format }],\n                module,\n            },\n        });\n    }\n\n    render(pass: GPURenderPassEncoder) {\n        if (this.bindgroup == null) return;\n        pass.setPipeline(this.pipeline);\n        pass.setBindGroup(0, this.globals.bindgroup);\n        pass.setBindGroup(1, this.gbuffer.bindgroup);\n        pass.setBindGroup(2, this.bindgroup);\n        pass.draw(3);\n    }\n}\n","import Camera from './camera/camera';\nimport GlobalUniforms from './global-uniforms';\nimport TonemapPass from './tonemap-pass';\nimport SkyboxPass from './skybox-pass';\nimport GBuffer from './gbuffer';\nimport DeferredPass from './deferred-pass';\n\nimport { binaryInsert, debounce } from '../../utils/general';\n\nexport type ForwardPassParams = {\n    encoder: GPUCommandEncoder,\n    globals: GlobalUniforms,\n    gbuffer: GBuffer,\n};\n\nexport type ForwardPass = {\n    render: (params: ForwardPassParams) => void,\n    priority: number,\n};\n\nexport default class Renderer {\n    static readonly requiredFeatures: GPUFeatureName[] = ['float32-filterable'];\n    static readonly outputFormat: GPUTextureFormat = navigator.gpu.getPreferredCanvasFormat();\n    static readonly postProcessFormat: GPUTextureFormat = 'rgba32float';\n\n    colorAttachment: GPURenderPassColorAttachment = {\n        clearValue: { r: 0, g: 0, b: 0, a: 1 },\n        loadOp: 'clear',\n        storeOp: 'store',\n        view: undefined!, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    };\n\n    passDescriptor: GPURenderPassDescriptor = { colorAttachments: [this.colorAttachment] };\n\n    context: GPUCanvasContext;\n    camera: Camera;\n    globals: GlobalUniforms;\n    gbuffer: GBuffer;\n\n    forwardPasses: ForwardPass[] = [];\n    deferredPass: DeferredPass;\n    skyboxPass: SkyboxPass;\n    tonemapPass: TonemapPass;\n\n    postprocessTarget!: GPUTexture;\n\n    set skybox(texture: GPUTexture) {\n        this.deferredPass.skybox = texture;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.skyboxPass.skyTexture = this.deferredPass.radianceView!;\n    }\n\n    constructor(\n        public readonly canvas: HTMLCanvasElement,\n        public readonly device: GPUDevice,\n    ) {\n        const size = { width: this.canvas.width, height: this.canvas.height };\n        this.camera = new Camera(size);\n        this.globals = new GlobalUniforms(this.device);\n        this.gbuffer = new GBuffer(device, size);\n        this.deferredPass = new DeferredPass(device, this.globals, this.gbuffer, Renderer.postProcessFormat);\n\n        this.skyboxPass = new SkyboxPass(\n            this.device,\n            this.globals,\n            Renderer.postProcessFormat,\n        );\n        this.tonemapPass = new TonemapPass(this.device, Renderer.outputFormat);\n\n        const context = this.canvas.getContext('webgpu');\n        if (context == null) throw new Error('renderer -- given canvas already initialized to non-webgpu context');\n\n        this.context = context as unknown as GPUCanvasContext;\n\n        this.context.configure({\n            device: this.device,\n            format: Renderer.outputFormat,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            alphaMode: 'opaque',\n            colorSpace: 'srgb',\n        });\n\n        this.updateBackings(size);\n        this.#createResizeObserver();\n    }\n\n    static async CreateInitialized(canvas: HTMLCanvasElement): Promise<Renderer> {\n        const adapter = await navigator.gpu.requestAdapter();\n        if (adapter == null) {\n            throw new Error('Could not initialize GPU.');\n        }\n\n        const {\n            maxComputeWorkgroupSizeX,\n            maxComputeWorkgroupsPerDimension,\n            maxComputeInvocationsPerWorkgroup,\n        } = adapter.limits;\n\n        const device = await adapter.requestDevice({\n            label: 'main logical device',\n            requiredFeatures: Renderer.requiredFeatures,\n            requiredLimits: {\n                maxComputeWorkgroupSizeX,\n                maxComputeWorkgroupsPerDimension,\n                maxComputeInvocationsPerWorkgroup,\n            },\n        });\n\n        return new Renderer(canvas, device);\n    }\n\n    updateBackings(size: { width: number, height: number }) {\n        this.camera.updateParams(size);\n        this.postprocessTarget = this.device.createTexture({\n            dimension: '2d',\n            format: Renderer.postProcessFormat,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n            size,\n        });\n\n        this.colorAttachment.view = this.postprocessTarget.createView();\n        this.tonemapPass.updateInput(this.colorAttachment.view);\n        this.gbuffer.size = size;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.skyboxPass.depthTexture = this.gbuffer.depth.view!;\n    }\n\n    #createResizeObserver() {\n        const resizeCanvas = debounce((rawWidth: number, rawHeight: number) => {\n            const width = Math.max(1, Math.min(rawWidth | 0, this.device.limits.maxTextureDimension2D));\n            const height = Math.max(1, Math.min(rawHeight | 0, this.device.limits.maxTextureDimension2D));\n            const dimensions = { width, height };\n            this.canvas.width = width;\n            this.canvas.height = height;\n            this.updateBackings(dimensions);\n        }, 20);\n\n        try {\n            const observer = new ResizeObserver((entries) => {\n                const [{ inlineSize, blockSize }] = entries[entries.length - 1].devicePixelContentBoxSize;\n                resizeCanvas(inlineSize, blockSize);\n            });\n            observer.observe(this.canvas, { box: 'device-pixel-content-box' });\n        } catch {\n            // Safari doesn't support device-pixel-content-box, so it would fail into this.\n            const observer = new ResizeObserver((entries) => {\n                const [{ inlineSize, blockSize }] = entries[entries.length - 1].contentBoxSize;\n                resizeCanvas(inlineSize * devicePixelRatio, blockSize * devicePixelRatio);\n            });\n            observer.observe(this.canvas, { box: 'content-box' });\n        }\n    }\n\n    addForwardPass(forwardPass: ForwardPass) {\n        binaryInsert(this.forwardPasses, forwardPass, (a, b) => a.priority - b.priority);\n    }\n\n    render = () => {\n        requestAnimationFrame(this.render);\n\n        this.globals.updateDeviceBuffer(this.device.queue, this.camera);\n\n        const encoder = this.device.createCommandEncoder({ label: 'main render encoder' });\n        const forwardPassParams = { encoder, globals: this.globals, gbuffer: this.gbuffer };\n\n        for (const forwardPass of this.forwardPasses) {\n            forwardPass.render(forwardPassParams);\n        }\n\n        const pass = encoder.beginRenderPass(this.passDescriptor);\n        this.deferredPass.render(pass);\n        this.skyboxPass.render(pass);\n        pass.end();\n\n        this.tonemapPass.render(encoder, this.context.getCurrentTexture());\n\n        this.device.queue.submit([encoder.finish()]);\n    };\n}\n","export default /* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`;\r\n","export const toWorldDir: string = /* wgsl */`\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nexport const cubemapSampleConversions: string = /* wgsl */`\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n","import * as ktxparse from 'ktx-parse';\r\n\r\nimport { TextureFormatToSize, TextureFormatToChannelSize, WebGPUToVkFormat } from '../core/constants';\r\nimport { mapRange, padTemplate } from '../../utils/general';\r\n\r\nexport function createAndCopyBuffer(\r\n    arr: ArrayBuffer | ArrayBufferView,\r\n    usage: GPUFlagsConstant,\r\n    device: GPUDevice,\r\n    label?: string,\r\n    alignment = 4,\r\n): GPUBuffer {\r\n    const pad = alignment - 1;\r\n    const buffer = device.createBuffer({\r\n        label,\r\n        usage,\r\n        size: (arr.byteLength + pad) & ~pad,\r\n        mappedAtCreation: true,\r\n    } as GPUBufferDescriptor);\r\n\r\n    const writeArray = new Uint8Array(buffer.getMappedRange());\r\n    const readArray = arr instanceof ArrayBuffer\r\n        ? new Uint8Array(arr)\r\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n\r\n    writeArray.set(readArray);\r\n    buffer.unmap();\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function createAndCopyCubemap(\r\n    device: GPUDevice,\r\n    data: ArrayBuffer,\r\n    format: GPUTextureFormat,\r\n    usage: number,\r\n    label?: string,\r\n) {\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\r\n    }\r\n\r\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\r\n    const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n    const texture = device.createTexture({\r\n        usage: usage | GPUTextureUsage.COPY_DST,\r\n        label,\r\n        format,\r\n        size,\r\n    });\r\n\r\n    device.queue.writeTexture(\r\n        { texture },\r\n        data,\r\n        { bytesPerRow: width * pixelSize, rowsPerImage: width },\r\n        size,\r\n    );\r\n\r\n    return texture;\r\n}\r\n\r\nexport type TextureToArrayBufferOptions = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    mipLevel?: number,\r\n    resultBuffer?: Uint8Array,\r\n    storageBuffer?: GPUBuffer,\r\n    returnBuffer?: boolean,\r\n    description?: string,\r\n};\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer?: false },\r\n): Promise<{ imageData: Uint8Array }>;\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer: true },\r\n): Promise<{ imageData: Uint8Array, storageBuffer: GPUBuffer }>;\r\n\r\nexport async function textureToArrayBuffer({\r\n    device,\r\n    texture,\r\n    mipLevel = 0,\r\n    returnBuffer,\r\n    storageBuffer,\r\n    resultBuffer,\r\n    description,\r\n}: TextureToArrayBufferOptions) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const fullDescription = padTemplate`[textureToKTX${description ?? ''}${texture.label}] --`;\r\n\r\n    if (pixelSize == null) {\r\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\r\n    }\r\n\r\n    const width = texture.width >> mipLevel;\r\n    const height = texture.height >> mipLevel;\r\n    const rawBytesPerRow = width * pixelSize;\r\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n    const rowsPerImage = height;\r\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\r\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\r\n\r\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\r\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\r\n    }\r\n\r\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\r\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\r\n    }\r\n\r\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\r\n\r\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\r\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\r\n    }\r\n\r\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\r\n    const storage = storageBuffer ?? device.createBuffer({\r\n        label: `${fullDescription} storage buffer`,\r\n        size: byteSize,\r\n        usage: requiredUsage,\r\n    });\r\n\r\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\r\n    encoder.copyTextureToBuffer(\r\n        { texture, mipLevel },\r\n        { buffer: storage, rowsPerImage, bytesPerRow },\r\n        { width, height, depthOrArrayLayers: texture.depthOrArrayLayers },\r\n    );\r\n    device.queue.submit([encoder.finish()]);\r\n\r\n    await Promise.all([\r\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\r\n        device.queue.onSubmittedWorkDone(),\r\n    ]);\r\n\r\n    const mapped = storage.getMappedRange(0, byteSize);\r\n    imageData.set(new Uint8Array(mapped));\r\n    storage.unmap();\r\n\r\n    if (bytesPerRow > rawBytesPerRow) {\r\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\r\n            }\r\n        }\r\n        imageData = imageData.slice(0, resultSize);\r\n    }\r\n\r\n    return {\r\n        imageData,\r\n        storageBuffer: returnBuffer ? storage : undefined,\r\n    };\r\n}\r\n\r\nexport async function textureToKTX(device: GPUDevice, texture: GPUTexture, cube = false) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const typeSize = TextureFormatToChannelSize[texture.format];\r\n\r\n    if (pixelSize == null || typeSize == null) {\r\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\r\n    }\r\n\r\n    const container = new ktxparse.KTX2Container();\r\n    container.pixelWidth = texture.width;\r\n    container.pixelHeight = texture.height;\r\n    container.vkFormat = WebGPUToVkFormat[texture.format];\r\n    container.typeSize = typeSize;\r\n    delete container.keyValue.KTXswizzle;\r\n\r\n    const dataFormat = container.dataFormatDescriptor[0];\r\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\r\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\r\n    dataFormat.bytesPlane[0] = pixelSize;\r\n\r\n    dataFormat.samples = mapRange(4, (i) => ({\r\n        channelType: [192, 193, 194, 207][i],\r\n        samplePosition: [0, 0, 0, 0],\r\n        bitLength: container.typeSize * 8 - 1,\r\n        bitOffset: container.typeSize * 8 * i,\r\n        sampleLower: -1082130432,\r\n        sampleUpper: 1065353216,\r\n    }));\r\n\r\n    if (texture.dimension === '3d') {\r\n        container.faceCount = 1;\r\n        container.pixelDepth = texture.depthOrArrayLayers;\r\n    } else if (cube) {\r\n        const cubeLayers = texture.depthOrArrayLayers / 6;\r\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\r\n        container.faceCount = 6;\r\n    } else {\r\n        container.layerCount = texture.depthOrArrayLayers;\r\n        container.faceCount = 1;\r\n    }\r\n\r\n    let storageBuffer: GPUBuffer | undefined;\r\n    let imageData: Uint8Array;\r\n\r\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\r\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\r\n            mipLevel: i,\r\n            returnBuffer: true,\r\n            device,\r\n            texture,\r\n            storageBuffer,\r\n        }));\r\n\r\n        container.levels.push({\r\n            levelData: imageData,\r\n            uncompressedByteLength: imageData.byteLength,\r\n        });\r\n    }\r\n\r\n    return ktxparse.write(container);\r\n}\r\n"],"names":["Camera","constructor","viewParams","buffer","ArrayBuffer","bufferLength","worldToView","Float32Array","this","worldToViewOffset","mat4x4Count","viewToClip","viewToClipOffset","worldToClip","worldToClipOffset","viewToWorld","viewToWorldOffset","clipToView","clipToViewOffset","clipToWorld","clipToWorldOffset","location","rotation","params","nearPlane","farPlane","fov","width","height","projection","updateParams","val","cacheView","fromQuat","setTranslation","invert","mul","perspective","Math","PI","x","y","ortho","sizeofMat4x4f","TypeSizes","BYTES_PER_ELEMENT","VkFormatToWebGPU","TextureFormatToSize","r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","rgb9e5ufloat","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","TextureFormatToChannelSize","WebGPUToVkFormat","Object","fromEntries","entries","map","vk","wgpu","parseInt","label","GlobalUniforms","device","deviceBuffer","createBuffer","bufferDescriptor","bindGroupLayout","createBindGroupLayout","layoutDescriptor","bindGroupDescriptor","layout","binding","resource","offset","size","bufferSize","bindgroup","createBindGroup","updateDeviceBuffer","queue","camera","writeBuffer","code","group","minBindingSize","visibility","GPUShaderStage","VERTEX","FRAGMENT","usage","GPUBufferUsage","UNIFORM","COPY_DST","TonemapPass","format","colorAttachment","loadOp","storeOp","view","undefined","passDescriptor","colorAttachments","renderTarget","bindgroupLayout","bindGroupLayoutDescriptor","module","createShaderModule","pipelineDescriptor","createPipelineLayout","bindGroupLayouts","vertex","entryPoint","fragment","targets","pipeline","createRenderPipeline","updateInput","input","render","encoder","output","createView","dimension","pass","beginRenderPass","setPipeline","setBindGroup","draw","end","texture","sampleType","viewDimension","SkyboxPass","mipLevel","uniformArray","uniformBuffer","useNearestSample","targetFormat","pipelineLayout","shader","skyTexture","skybox","depthTexture","globals","target","clearValue","r","g","b","a","sampler","type","linearSampler","createSampler","minFilter","magFilter","mipmapFilter","nearestSampler","textureBindgroup","GBuffer","_size","value","textures","forEach","tex","createTexture","updateBindgroup","updatePassDescriptor","normal","name","albedo","emission","metallicRoughness","depth","slice","layoutDescription","idx","depthStencilAttachment","depthLoadOp","depthStoreOp","depthClearValue","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","DeferredPass","irradianceTexture","samples","outputWidth","outputFormat","outputTexture","depthOrArrayLayers","Uint32Array","paramBuffer","constants","SAMPLES","i","arrayLayerCount","baseArrayLayer","createCommandEncoder","submit","finish","createIrradianceTexture","radianceTexture","paramArrayBuffer","uintParams","floatParams","mipLevelCount","max","log2","copyEncoder","copyTextureToTexture","Promise","resolve","then","async","mip","roughness","face","onSubmittedWorkDone","baseMipLevel","createRadianceTexture","irradianceView","radianceView","bfrdLutView","gbuffer","bfrdLut","sampleCount","SAMPLE_COUNT","createBfrdLut","Renderer","deferredPass","skyboxPass","canvas","forwardPasses","requestAnimationFrame","forwardPassParams","forwardPass","tonemapPass","context","getCurrentTexture","postProcessFormat","getContext","Error","configure","COPY_SRC","alphaMode","colorSpace","updateBackings","CreateInitialized","adapter","navigator","gpu","requestAdapter","maxComputeWorkgroupSizeX","maxComputeWorkgroupsPerDimension","maxComputeInvocationsPerWorkgroup","limits","requestDevice","requiredFeatures","requiredLimits","postprocessTarget","addForwardPass","priority","resizeCanvas","rawWidth","rawHeight","min","maxTextureDimension2D","dimensions","ResizeObserver","inlineSize","blockSize","length","devicePixelContentBoxSize","observe","box","contentBoxSize","devicePixelRatio","getPreferredCanvasFormat","toWorldDir","cubemapSampleConversions","createAndCopyBuffer","arr","alignment","pad","byteLength","mappedAtCreation","writeArray","Uint8Array","getMappedRange","readArray","byteOffset","set","unmap","textureToArrayBuffer","returnBuffer","storageBuffer","resultBuffer","description","pixelSize","fullDescription","rawBytesPerRow","bytesPerRow","rowsPerImage","byteSize","resultSize","requiredUsage","MAP_READ","imageData","storage","copyTextureToBuffer","all","mapAsync","GPUMapMode","READ","mapped","h","w","textureToKTX","cube","typeSize","container","pixelWidth","pixelHeight","vkFormat","keyValue","KTXswizzle","dataFormat","dataFormatDescriptor","colorModel","transferFunction","bytesPlane","channelType","samplePosition","bitLength","bitOffset","sampleLower","sampleUpper","faceCount","pixelDepth","cubeLayers","layerCount","levels","push","levelData","uncompressedByteLength"],"sourceRoot":""}