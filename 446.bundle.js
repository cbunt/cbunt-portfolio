/*! For license information see: https://cbunt.ing/oss-licenses.json */
"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[446],{3421:(e,t,r)=>{r.d(t,{A:()=>c});var n,i,a,o=r(282),s=r(2323),l=function(e,t,r,n){if("a"===r&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?n:"a"===r?n.call(e):n?n.value:t.get(e)};class u{constructor(e={}){n.add(this),this.buffer=new ArrayBuffer(i.bufferLength),this.worldToView=new Float32Array(this.buffer,i.worldToViewOffset,s.vV.mat4x4Count),this.viewToClip=new Float32Array(this.buffer,i.viewToClipOffset,s.vV.mat4x4Count),this.worldToClip=new Float32Array(this.buffer,i.worldToClipOffset,s.vV.mat4x4Count),this.viewToWorld=new Float32Array(this.buffer,i.viewToWorldOffset,s.vV.mat4x4Count),this.clipToView=new Float32Array(this.buffer,i.clipToViewOffset,s.vV.mat4x4Count),this.clipToWorld=new Float32Array(this.buffer,i.clipToWorldOffset,s.vV.mat4x4Count),this.location=new Float32Array([0,0,0]),this.rotation=new Float32Array([0,0,0,1]),this.params={nearPlane:.01,farPlane:500,fov:40,width:1920,height:1080,projection:"perspective"},this.updateParams(e)}updateParams(e){this.params={...this.params,...e},l(this,n,"m",a).call(this)}cacheView(){o.pB.fromQuat(this.rotation,this.viewToWorld),o.pB.setTranslation(this.viewToWorld,this.location,this.viewToWorld),o.pB.invert(this.viewToWorld,this.worldToView),o.pB.mul(this.viewToClip,this.worldToView,this.worldToClip),o.pB.mul(this.viewToWorld,this.clipToView,this.clipToWorld)}}i=u,n=new WeakSet,a=function(){if("perspective"===this.params.projection)o.pB.perspective(this.params.fov*(Math.PI/180),this.params.width/this.params.height,this.params.nearPlane,this.params.farPlane,this.viewToClip);else{const e=this.params.width/2,t=this.params.height/2;o.pB.ortho(-e,e,-t,t,this.params.nearPlane,this.params.farPlane,this.viewToClip)}o.pB.invert(this.viewToClip,this.clipToView)},u.worldToViewOffset=0,u.viewToClipOffset=i.worldToViewOffset+s.vV.sizeofMat4x4f,u.worldToClipOffset=i.viewToClipOffset+s.vV.sizeofMat4x4f,u.viewToWorldOffset=i.worldToClipOffset+s.vV.sizeofMat4x4f,u.clipToViewOffset=i.viewToWorldOffset+s.vV.sizeofMat4x4f,u.clipToWorldOffset=i.clipToViewOffset+s.vV.sizeofMat4x4f,u.bufferLength=i.clipToWorldOffset+s.vV.sizeofMat4x4f;const c=u},2323:(e,t,r)=>{r.d(t,{vV:()=>i});var n=r(9253);const i={mat4x4Count:16,sizeofMat4x4f:16*Float32Array.BYTES_PER_ELEMENT},a={[n.VIE]:"r8unorm",[n.B7n]:"r8snorm",[n.W_U]:"r8uint",[n.YeG]:"r8sint",[n.HYY]:"r16uint",[n.brc]:"r16sint",[n.eLQ]:"r16float",[n.sk6]:"rg8unorm",[n.aiL]:"rg8snorm",[n.xWH]:"rg8uint",[n.$Kq]:"rg8sint",[n.nR0]:"r32uint",[n.rwM]:"r32sint",[n.e4n]:"r32float",[n.P1c]:"rg16uint",[n.bc6]:"rg16sint",[n.cps]:"rg16float",[n.tsP]:"rgba8unorm",[n.Wm_]:"rgba8unorm-srgb",[n.zqn]:"rgba8snorm",[n.MZV]:"rgba8uint",[n._Je]:"rgba8sint",[n.J6Z]:"bgra8unorm",[n.mIY]:"bgra8unorm-srgb",[n.KIZ]:"rgb9e5ufloat",[n.eAA]:"rgb10a2uint",[n.fJh]:"rgb10a2unorm",[n.kot]:"rg11b10ufloat",[n.nlo]:"rg32uint",[n.x9e]:"rg32sint",[n.yAK]:"rg32float",[n.CSc]:"rgba16uint",[n.GF$]:"rgba16sint",[n.l2T]:"rgba16float",[n.KMX]:"rgba32uint",[n.KBq]:"rgba32sint",[n.Ze1]:"rgba32float",[n.QFs]:"bc1-rgba-unorm",[n.bOE]:"bc1-rgba-unorm-srgb",[n.wt4]:"bc2-rgba-unorm",[n.ZBp]:"bc2-rgba-unorm-srgb",[n.D_t]:"bc3-rgba-unorm",[n.elk]:"bc3-rgba-unorm-srgb",[n.ydS]:"bc4-r-unorm",[n.iIv]:"bc4-r-snorm",[n.LHP]:"bc5-rg-unorm",[n.xXb]:"bc5-rg-snorm",[n.mQu]:"bc6h-rgb-ufloat",[n.CpY]:"bc6h-rgb-float",[n.FD_]:"bc7-rgba-unorm",[n.GJu]:"bc7-rgba-unorm-srgb"};Object.fromEntries(Object.entries(a).map((([e,t])=>[t,parseInt(e,10)])))},1648:(e,t,r)=>{r.d(t,{A:()=>c});var n=r(7815);function i(e){return"string"==typeof e?e:e()}class a{constructor(e,t){this.else=e=>this.res??i(e),this.toString=()=>this.res??"",e&&(this.res=i(t))}elif(e,t){return e&&(this.res??=i(t)),this}get[Symbol.toStringTag](){return this.toString()}}function o(e,t=0){return()=>e(t++)}var s=r(5701);function l(e){const{ifdef:t}=function(e){return{ifdef:(t,r)=>new a((e&t)===t,r),ifndef:(t,r)=>new a((e&t)!==t,r)}}(e),r=o((e=>`@location(${e})`)),i=o((e=>`@location(${e})`)),l=o((e=>`\n        @group(1) @binding(${e})\n    `)),u=`\n        ${i()} pos: vec3f,\n        ${i()} camPos: vec3f,\n        ${i()} uv: vec2f,\n\n        ${t(n.Ot.VertexNormals,(()=>`\n            ${i()} tangent: vec4f,\n            ${i()} normal: vec3f,\n        `))}\n\n        ${t(n.Ot.VertexColors,(()=>`\n            ${i()} color: vec4f,\n        `))}\n    `;return`\n        ${s.A.code(0)}\n\n        struct ForwardOut {\n            @location(0) normal: vec4f,\n            @location(1) albedo: vec4f,\n            @location(2) emission: vec4f,\n            @location(3) metallicRoughness: vec4f,\n        }\n\n        struct MaterialProperties {\n            baseColorFactor: vec4f,\n            metallicFactor: f32,\n            roughnessFactor: f32,\n\n            ${t(n.Ot.AlphaCutoff,"alphaCutoff: f32,")}\n            ${t(n.Ot.Emissive,"emissiveFactor: vec3f,")}\n        }\n\n        ${l()} var<uniform> material: MaterialProperties;\n\n        ${l()} var baseColorSampler: sampler;\n        ${l()} var baseColorTexture: texture_2d<f32>;\n\n        ${l()} var normalSampler: sampler;\n        ${l()} var normalTexture: texture_2d<f32>;\n\n        ${l()} var metallicRoughnessSampler: sampler;\n        ${l()} var metallicRoughnessTexture: texture_2d<f32>;\n\n        ${t(n.Ot.Emissive,(()=>`\n            ${l()} var emissionSampler: sampler;\n            ${l()} var emissionTexture: texture_2d<f32>;\n        `))}\n\n        struct ModelProperties {\n            modelToWorldMatrix: mat4x4f,\n\n            ${t(n.Ot.VertexNormals,"normalMatrix: mat3x3f,")}\n        }\n\n        @group(2) @binding(0) var<storage, read> instances : array<ModelProperties>;\n\n        struct VertIn {\n            @builtin(instance_index) instance: u32,\n            ${r()} pos: vec3f,\n            ${r()} uv: vec2f,\n\n            ${t(n.Ot.VertexNormals,(()=>`\n                ${r()} tangent: vec4f,\n                ${r()} normal: vec3f,\n            `))}\n\n            ${t(n.Ot.VertexColors,(()=>`\n                ${r()} color: vec4f,\n            `))}\n        }\n\n        struct VertOut {\n            ${u}\n            @builtin(position) Position: vec4f,\n        }\n\n        struct FragIn {\n            ${u}\n\n            ${t(n.Ot.VertexNormals|n.Ot.DoubleSided,"\n                @builtin(front_facing) front_facing: bool,\n            ")}\n        }\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @vertex \n        fn vs(inData: VertIn) -> VertOut {\n            var vsOut: VertOut;\n            let instance = instances[inData.instance];\n            let worldPos = instance.modelToWorldMatrix * vec4f(inData.pos, 1);\n            vsOut.pos = worldPos.xyz;\n            vsOut.Position = globals.worldToClip * worldPos;\n            vsOut.camPos = globals.inverseWorldToView[3].xyz;\n            vsOut.uv = inData.uv;\n\n            ${t(n.Ot.VertexNormals,"\n                vsOut.normal = normalize(instance.normalMatrix * inData.normal);\n                let wsTangent = normalize((instance.modelToWorldMatrix * vec4(inData.tangent.xyz, 0.0)).xyz);\n                vsOut.tangent = vec4(wsTangent, inData.tangent.w);\n            ")}\n\n            return vsOut;\n        }\n\n        // much of this code is adapted from https://learnopengl.com/PBR\n        @fragment\n        fn fs(inData: FragIn) -> ForwardOut {\n            var out: ForwardOut;\n            let rawColor = textureSample(baseColorTexture, baseColorSampler, inData.uv);\n\n            ${t(n.Ot.AlphaCutoff,`\n                var alpha = rawColor.a * material.baseColorFactor.a;\n\n                ${t(n.Ot.VertexColors,"\n                    alpha *= inData.color.a;\n                ")}\n\n                if (alpha <= material.alphaCutoff) { \n                    discard;\n                }\n            `)}\n\n            out.albedo = vec4f(rawColor.rgb * material.baseColorFactor.rgb, 1);\n\n            ${t(n.Ot.VertexColors,"\n                out.albedo *= vec4f(inData.color.rgb, 1);\n            ")}\n\n            let metallicRoughness = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, inData.uv);\n            out.metallicRoughness.r = saturate(metallicRoughness.b * material.metallicFactor);\n            out.metallicRoughness.g = saturate(metallicRoughness.g * material.roughnessFactor);\n\n            ${t(n.Ot.VertexNormals,`\n                let normalSample = textureSample(normalTexture, normalSampler, inData.uv).xyz;\n                let tangentNormal = normalize(normalSample * 2.0 - 1.0);\n                let bitangent =inData.tangent.w * cross(inData.normal, inData.tangent.xyz);\n                let tbn = mat3x3f(normalize(inData.tangent.xyz), bitangent, normalize(inData.normal));\n                var normal = normalize(tbn * tangentNormal);\n\n                ${t(n.Ot.DoubleSided,"\n                    if (!inData.front_facing) { normal *= -1.0; }\n                ")}\n            `).else("\n                let fdx = dpdx(inData.pos);\n                let fdy = dpdy(inData.pos);\n                let normal = normalize(cross(fdy, fdx));\n            ")}\n\n            out.normal = vec4f(normal, 1);\n\n            ${t(n.Ot.Emissive,"\n                let emission = textureSample(emissionTexture, emissionSampler, inData.uv).rgb;\n                out.emission = vec4f(emission, 1);\n            ")}\n\n            return out;\n        }\n    `}class u{constructor(e,t,r){this.device=e,this.gbuffer=t,this.globals=r,this.pipelineLayouts={},this.primitiveStates={},this.vertexLayouts={},this.shaderModules={},this.bindgroupLayouts={},this.samplers={},this.forwardBindgroupLayout=this.device.createBindGroupLayout({label:"forward material",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]})}getSampler(e){const t=JSON.stringify(e);return this.samplers[t]??=this.device.createSampler(e),this.samplers[t]}getVertexLayout(e){const t=e&n.V3;if(null==this.vertexLayouts[t]){const e=[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}];let r=20,i=2;t&n.Ot.VertexNormals&&(e.push({shaderLocation:i,offset:r,format:"float32x4"}),e.push({shaderLocation:i+1,offset:r+16,format:"float32x3"}),i+=2,r+=28),t&n.Ot.VertexColors&&(e.push({shaderLocation:i,offset:r,format:"float32x4"}),r+=16),this.vertexLayouts[t]={attributes:e,arrayStride:r,stepMode:"vertex"}}return this.vertexLayouts[t]}getForwardPipelineLayout(e){const t=e&n.FO;return this.pipelineLayouts[t]??=this.device.createPipelineLayout({label:n.UZ(t),bindGroupLayouts:[this.globals.bindGroupLayout,this.getMaterialBindGroup(e),this.forwardBindgroupLayout]}),this.pipelineLayouts[t]}getShaderModule(e){const t=e&n.Q7;return this.shaderModules[t]??=this.device.createShaderModule({label:n.UZ(t),code:l(t)}),this.shaderModules[t]}getPrimitiveState(e){const t=e&n.XY;return this.primitiveStates[t]??={topology:u.flagToTopology[e&n.Py],cullMode:t&n.Ot.DoubleSided?"none":"back",frontFace:t&n.Ot.ClockwiseWinding?"cw":"ccw"},this.primitiveStates[t]}getMaterialBindGroup(e){const t=e&n.Wq;return this.bindgroupLayouts[t]??=this.device.createBindGroupLayout(function(e){const t=[];function r(e){t.push({...e,binding:t.length,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.VERTEX})}return r({buffer:{type:"uniform"}}),r({sampler:{}}),r({texture:{viewDimension:"2d"}}),r({sampler:{}}),r({texture:{viewDimension:"2d"}}),r({sampler:{}}),r({texture:{viewDimension:"2d"}}),e&n.Ot.Emissive&&(r({sampler:{}}),r({texture:{viewDimension:"2d"}})),{label:(0,n.UZ)(e),entries:t}}(t)),this.bindgroupLayouts[t]}}u.flagToTopology={[n.Ot.TriangleList]:"triangle-list",[n.Ot.TriangleStrip]:"triangle-strip",[n.Ot.PointList]:"point-list",[n.Ot.LineList]:"line-list",[n.Ot.LineStrip]:"line-strip"};const c=u},7815:(e,t,r)=>{var n;r.d(t,{FO:()=>c,Ot:()=>n,P7:()=>f,Py:()=>i,Q7:()=>o,UZ:()=>d,V3:()=>l,Wq:()=>u,XY:()=>a}),function(e){e[e.Defaults=0]="Defaults",e[e.VertexNormals=1]="VertexNormals",e[e.VertexColors=2]="VertexColors",e[e.AlphaCutoff=4]="AlphaCutoff",e[e.Emissive=8]="Emissive",e[e.DoubleSided=16]="DoubleSided",e[e.ClockwiseWinding=32]="ClockwiseWinding",e[e.TriangleList=0]="TriangleList",e[e.TriangleStrip=64]="TriangleStrip",e[e.PointList=128]="PointList",e[e.LineList=192]="LineList",e[e.LineStrip=256]="LineStrip",e[e.Unindexed=320]="Unindexed"}(n||(n={}));const i=17472,a=i|n.DoubleSided|n.ClockwiseWinding,o=~(i|n.ClockwiseWinding),s=n.VertexNormals,l=n.VertexNormals|n.VertexColors,u=n.AlphaCutoff|n.Emissive,c=s|(u|n.DoubleSided);function d(e){return function(e){return Object.entries(n).flatMap((([t,r])=>"number"==typeof r&&r&e?t:[]))}(e).toString()}function f(e){let t=e;return t&n.DoubleSided&&(t&=~n.ClockwiseWinding),t}},5701:(e,t,r)=>{r.d(t,{A:()=>o});var n=r(3421);const i="global uniforms";class a{constructor(e){this.deviceBuffer=e.createBuffer(a.bufferDescriptor),this.bindGroupLayout=e.createBindGroupLayout(a.layoutDescriptor),this.bindGroupDescriptor={label:i,layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:this.deviceBuffer,offset:0,size:a.bufferSize}}]},this.bindgroup=e.createBindGroup(this.bindGroupDescriptor)}updateDeviceBuffer(e,t){t.cacheView(),e.writeBuffer(this.deviceBuffer,0,t.buffer)}}a.code=e=>`\n        struct GlobalUniforms {\n            worldToView: mat4x4f,\n            viewToClip: mat4x4f,\n            worldToClip: mat4x4f,\n            inverseWorldToView: mat4x4f,\n            inverseViewToClip: mat4x4f,\n            inverseWorldToClip: mat4x4f,\n        }\n\n        @group(${e}) @binding(0) var<uniform> globals: GlobalUniforms;\n    `,a.bufferSize=n.A.bufferLength,a.layoutDescriptor={label:i,entries:[{binding:0,buffer:{minBindingSize:a.bufferSize},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}]},a.bufferDescriptor={label:i,size:a.bufferSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};const o=a},9196:(e,t,r)=>{r.d(t,{A:()=>l});var n=r(5753),i=r(3936),a=r(2349);const o=113639424,s=(e,t)=>`\n    ${n.X}\n    ${n.V}\n\n    override STEPS: i32 = 4;\n\n    struct Params {\n        offset: u32,\n        sigmas: array<f32>,\n    }\n\n    @group(0) @binding(0) \n    var previousMip: texture_2d_array<f32>;\n\n    @group(0) @binding(1) \n    var outputTexture: texture_storage_2d_array<${t}, write>;\n\n    @group(0) @binding(2) \n    var<storage> params: Params;\n    \n    @compute @workgroup_size(${e}, 1, 1)\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\n        let mipSize = textureDimensions(outputTexture).x;\n\n        let idx = gid.x + params.offset;\n        let faceSize = mipSize * mipSize;\n        let faceIdx = idx % faceSize;\n\n        let coord = vec3u(\n            faceIdx % mipSize, \n            faceIdx / mipSize, \n            idx / faceSize,\n        ); \n\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \n            return; \n        }\n\n        let previousSize = textureDimensions(previousMip).x;\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\n        let pos = toWorldDir(vec3u(coord), mipSize);\n\n        let size = arrayLength(&params.sigmas);\n        let level = size - u32(ceil(log2(f32(previousSize))));\n        let sigma = params.sigmas[level];\n        let guassian_factor = -0.5 / (sigma * sigma);\n\n        var weight = 0.0;\n        var res = vec3(0.0);\n\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\n                if (sample.z == INVALID_FACE) { continue; }\n\n                let samplePos = toWorldDir(sample, previousSize);\n                let x = max(0.0, acos(dot(samplePos, pos)));\n                let w = exp(x * x * guassian_factor);\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\n\n                res += color.rgb * w;\n                weight += w;\n            }\n        }\n\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\n    }\n`;async function l({device:e,texture:t,outputTextureLabel:r,inPlace:n=!1,minWidth:u=8,steps:c=4,maxOpsPerPass:d=o,label:f=l.name,delayWork:m}){const{width:p,format:h}=t,v=n?t.mipLevelCount:Math.log2(p)-Math.log2(u)+1;if(v<=1)return t;const g=Math.min(e.limits.maxComputeWorkgroupSizeX,e.limits.maxComputeInvocationsPerWorkgroup),b=e.createShaderModule({label:f,code:s(g,h)}),y=e.createBindGroupLayout({label:f,entries:[{binding:0,texture:{viewDimension:"2d-array"},visibility:GPUShaderStage.COMPUTE},{binding:1,storageTexture:{access:"write-only",viewDimension:"2d-array",format:h},visibility:GPUShaderStage.COMPUTE},{binding:2,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.COMPUTE}]}),w=e.createComputePipeline({label:f,layout:e.createPipelineLayout({label:f,bindGroupLayouts:[y]}),compute:{module:b,entryPoint:"main",constants:{STEPS:Math.ceil(c)}}});let x=t;if(!n){const n={width:p,height:p,depthOrArrayLayers:6};x=e.createTexture({label:r,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,dimension:"2d",format:h,mipLevelCount:v,size:n});const i=e.createCommandEncoder({label:`${f} copy encoder`});i.copyTextureToTexture({texture:t,mipLevel:0},{texture:x,mipLevel:0},n),e.queue.submit([i.finish()]),await e.queue.onSubmittedWorkDone()}const T=(0,a._b)(v,(e=>x.createView({label:`${f} mip view ${e}`,dimension:"2d-array",baseMipLevel:e,mipLevelCount:1}))),S=e.limits.maxComputeWorkgroupsPerDimension,P=Math.ceil(Math.log2(p)),C=Math.max(d/((1+2*c)**2*g)|0,1),O=new ArrayBuffer(4*(P+1)),A=new Uint32Array(O,0,1);new Float32Array(O,4,P).set((0,a._b)(P,(e=>{const t=p>>e;return Math.acos(1-function(e,t){const r=t>>1,n=r-Math.floor(e/4)-1,i=2/r*(n+.5)-1,a=1/r-1,o=1+i*i+a*a,s=2/t*(2*t-2*n-e-2+.5)-1,l=1/t-1,u=1+s*s+l*l,c=3/t-1,d=1+s*s+c*c,f=(s+i+l*a)/Math.sqrt(u*o),m=(s+i+c*a)/Math.sqrt(d*o);return Math.min(1-f,1-m)}(Math.min(t,c),t))/3})));const E=(0,i.Lr)(O,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,e);let U,F=0,M=0,L=0,G=0,D=0;return await async function t(){if(G>=L){if(F+=1,G=0,M=0,F>=v)return;const t=6*(p>>F)**2;L=Math.ceil(t/g),U=e.createBindGroup({layout:y,entries:[{binding:0,resource:T[F-1]},{binding:1,resource:T[F]},{binding:2,resource:{buffer:E}}]})}A[0]=G*g,e.queue.writeBuffer(E,0,A);const r=Math.min(L-G,C-D,S),n=`${f} mip ${F}, pass ${M}`,i=e.createCommandEncoder({label:n}),a=i.beginComputePass({label:n});a.setPipeline(w),a.setBindGroup(0,U),a.dispatchWorkgroups(r,1,1),a.end(),e.queue.submit([i.finish()]),G+=r,D+=r,M+=1,null!=m&&D>=C?(D=0,await e.queue.onSubmittedWorkDone(),m(t)):await t()}(),x}},2446:(e,t,r)=>{r.a(e,(async(e,n)=>{try{r.r(t),r.d(t,{default:()=>g});var i=r(2112),a=r(3803),o=r(1648),s=r(7815),l=r(9196),u=r(5605),c=r(2349),d=e([a]);a=(d.then?(await d)():d)[0];var f,m=function(e,t,r,n){if("a"===r&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?n:"a"===r?n.call(e):n?n.value:t.get(e)};const p=await h();async function h(){const e=await fetch("https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/model-index.json"),t=await e.text(),r=JSON.parse(t);if(!Array.isArray(r))throw new Error("could not load gtlf model index");const n=r.flatMap((e=>{if(!((0,c.Gv)(e)&&"label"in e&&"string"==typeof e.label&&"name"in e&&"string"==typeof e.name&&"variants"in e&&(0,c.Gv)(e.variants)&&"string"==typeof e.variants.glTF))return[];const{variants:{glTF:t},label:r,name:n}=e;return[[r,`https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/${n}/glTF/${t}`]]}));return Object.fromEntries(n)}class v{get depthTextureView(){return this.descriptorMap.gbuffer.depth.view}constructor(e){this.renderer=e,this.geometryPipelines={},f.set(this,(0,i.A)({skybox:(0,a.A)(this),model:{[i.t.$type]:"file",[i.t.$callback]:(e,t)=>{"value"===t&&null!=e&&("string"==typeof e||e instanceof File)&&this.setModel(e)},accept:".hdr",selection:{value:"Environment Test",initialValues:p},process:e=>e}})),this.settings=m(this,f,"f").publicSettings,this.priority=1e3,this.descriptorMap=new o.A(e.device,e.gbuffer,e.globals),this.device=e.device,this.renderer.addForwardPass(this)}async setSkybox(e){await(0,l.A)({texture:e,device:this.renderer.device,inPlace:!0,delayWork:requestAnimationFrame}),this.renderer.skybox=e}async setModel(e){const t={width:1,height:1},r=new Float32Array([1,1,1,1]),n=this.renderer.device.createTexture({size:t,format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});this.renderer.device.queue.writeTexture({texture:n},r,{},t);const i=this.renderer.device.createTexture({size:t,format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});r.set([.5,.5,1,1]),this.renderer.device.queue.writeTexture({texture:i},r,{},t);const a={addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"},o={baseColorTexture:n,baseColorFactor:[1,1,1,1],normalTexture:i,metallicRoughnessTexture:n,metallicFactor:1,roughnessFactor:1,baseColorSampler:a,normalSampler:a,metallicRoughnessSampler:a};this.geometryPipelines=await(0,u.A)(e,this.renderer.device,this.descriptorMap,o,v.goalLayout,{})}render({encoder:e,gbuffer:t,globals:r}){const n=e.beginRenderPass(t.passDescriptor);n.setBindGroup(0,r.bindgroup);for(const e of Object.values(this.geometryPipelines))e?.draw(n,this.renderer.device.queue);n.end()}}f=new WeakMap,v.title="glTF Model Viewer",v.description="",v.goalLayout=[{name:"POSITION",type:"VEC3",componentType:5126},{name:"TEXCOORD_0",type:"VEC2",componentType:5126},{name:"TANGENT",type:"VEC4",componentType:5126,depends:["NORMAL"],fill:[1,0,0,1]},{name:"NORMAL",type:"VEC3",componentType:5126,strip:!0,feature:s.Ot.VertexNormals},{name:"COLOR_0",type:"VEC4",componentType:5126,strip:!0,feature:s.Ot.VertexColors,fill:[1,1,1,1]}];const g=v;n()}catch(b){n(b)}}),1)},5605:(e,t,r)=>{r.d(t,{A:()=>L});var n=r(282),i=r(6730),a=r(7573),o=r(7740);class s{constructor(e){this.attributes=[];let t=0;for(const r of Object.values(e))t+=this.initAttribute(r);const r=t+3&-4;this.u8=new Uint8Array(r),this.u32=new Uint32Array(this.u8.buffer)}initAttribute(e){const t=e.data instanceof Uint8Array?e.data:new Uint8Array(e.data.buffer),r=e.bytesPerComponent*e.componentsPerElement;return this.attributes.push({u8:t,byteStride:r}),r}hash(e){let t=0;for(const{u8:r,byteStride:n}of this.attributes){for(let i=0;i<n;i+=1)this.u8[t+i]=r[e*n+i];t+=n}return this.murmurHash2()}equal(e,t){for(const{u8:r,byteStride:n}of this.attributes)for(let i=0;i<n;i+=1)if(r[e*n+i]!==r[t*n+i])return!1;return!0}hashLookup(e,t,r,n){const i=t-1;let a=this.hash(r)&i;for(let t=0;t<=i;t+=1){const o=e[a];if(o===n||this.equal(o,r))return a;a=a+t+1&i}throw new Error("Hash table full.")}murmurHash2(){const e=1540483477;let t=0;for(let r of this.u32)r=Math.imul(r,e)>>>0,r=(r^r>>24)>>>0,r=Math.imul(r,e)>>>0,t=Math.imul(t,e)>>>0,t=(t^r)>>>0;return t}}function l(e){const t=e.POSITION.count,r=new s(e),n=(i=t+t/4,2**Math.ceil(Math.log(i)/Math.LN2));var i;const a=t<65535,o=2**(a?16:32)-1,l=a?"uint16":"uint32",u=a?new Uint16Array(t):new Uint32Array(t),c=a?new Uint16Array(n):new Uint32Array(n);c.fill(o);let d=0;for(let e=0;e<t;e+=1){const t=r.hashLookup(c,n,e,o),i=c[t];i===o?(c[t]=e,u[e]=d,d+=1):u[e]=u[i]}for(const t of Object.values(e))t.remap(u,d);return{indexArray:u,indexFormat:l,vertexCount:d}}var u=r(7815),c=r(2323),d=r(3936);class f{constructor(e,t,r,n,i){if(this.instanceCount=0,this.dirty=!1,this.max=r,this.features=e.features,this.name=e.name??"mesh",this.vertexCount=e.vertexCount,e.vertexArray instanceof GPUBuffer?this.vertexBuffer=e.vertexArray:this.vertexBuffer=(0,d.Lr)(e.vertexArray,GPUBufferUsage.VERTEX,t,`${this.name} vertex buffer`),e.indexArray&&e.indexFormat){const{indexArray:r,indexFormat:n}=e;this.indexData={indexFormat:n,indexCount:r.byteLength/("uint16"===n?2:4),indexBuffer:(0,d.Lr)(e.indexArray,GPUBufferUsage.INDEX,t,`${this.name} index buffer`)}}this.instanceSize=c.vV.sizeofMat4x4f,this.features&u.Ot.VertexNormals&&(this.instanceSize+=48),this.instances=new ArrayBuffer(r*this.instanceSize),this.modelMatrices=new Array(r);for(let e=0;e<r;e+=1){const t=e*this.instanceSize;this.modelMatrices[e]=new Float32Array(this.instances,t,16)}if(this.features&u.Ot.VertexNormals){this.normalMatrices=new Array(r);for(let e=0;e<r;e+=1){const t=e*this.instanceSize+c.vV.sizeofMat4x4f;this.normalMatrices[e]=new Float32Array(this.instances,t,12)}}if(this.instanceBuffer=t.createBuffer({label:`${this.name} instance buffer`,size:this.instances.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.instanceBindGroup=t.createBindGroup({label:"PrimitiveDrawData instance bind group",layout:n.forwardBindgroupLayout,entries:[{binding:0,resource:{buffer:this.instanceBuffer}}]}),i)for(const e of i)this.addInstance(e)}draw(e,t){if(this.dirty&&(t.writeBuffer(this.instanceBuffer,0,this.instances),this.dirty=!1),e.setVertexBuffer(0,this.vertexBuffer),e.setBindGroup(2,this.instanceBindGroup),null!=this.indexData){const{indexBuffer:t,indexCount:r,indexFormat:n}=this.indexData;e.setIndexBuffer(t,n),e.drawIndexed(r,this.instanceCount)}else e.draw(this.vertexCount,this.instanceCount)}addInstance(e){this.instanceCount!==this.max&&(n.pB.copy(e,this.modelMatrices[this.instanceCount]),this.calculateNormalMatrix(this.instanceCount),this.instanceCount+=1,this.dirty=!0)}calculateNormalMatrix(e){if(!(this.features&u.Ot.VertexNormals))return;const t=this.normalMatrices[e];n.w0.fromMat4(this.modelMatrices[e],t),n.w0.invert(t,t),n.w0.transpose(t,t)}}const m={0:u.Ot.PointList,1:u.Ot.LineList,4:u.Ot.TriangleList};class p{constructor(e,t){if(this.unwelded=!1,e instanceof Float32Array)this.data=e,this.componentsPerElement=t,this.count=e.length/t,this.processed=!0,this.bytesPerComponent=4,this.copyFrom=this.copyProcessed.bind(this);else{switch(this.data=e.value,this.componentsPerElement=e.components,this.count=e.count,this.bytesPerComponent=e.bytesPerComponent,this.processed=!1,this.view=new DataView(this.data.buffer),this.copyFrom=this.copyUnprocessed.bind(this),e.componentType){case 5120:this.at=(e,t)=>this.view.getInt8(e*this.componentsPerElement+t);break;case 5121:this.at=(e,t)=>this.view.getUint8(e*this.componentsPerElement+t);break;case 5122:this.at=(e,t)=>{const r=2*(e*this.componentsPerElement+t);return this.view.getInt16(r,!0)};break;case 5123:this.at=(e,t)=>{const r=2*(e*this.componentsPerElement+t);return this.view.getUint16(r,!0)};break;case 5125:this.at=(e,t)=>{const r=4*(e*this.componentsPerElement+t);return this.view.getUint32(r,!0)};break;case 5126:this.at=(e,t)=>{const r=4*(e*this.componentsPerElement+t);return this.view.getFloat32(r,!0)};break;default:throw new Error(`gltf importer -- invalid componentType ${e.componentType}`)}if(e.normalized){let t;switch(e.componentType){case 5121:t=255;break;case 5120:t=127;break;case 5123:t=65535;break;case 5122:t=32767;break;case 5125:t=4294967295;break;default:throw new Error(`gltf importer -- invalid componentType ${e.componentType}`)}this.at=(e,r)=>this.at(e,r)/t}}}get array(){return this.processed||this.process(),this.data}copyProcessed(e,t,r){for(let n=0;n<this.componentsPerElement;n+=1)r[t+n]=this.data[e*this.componentsPerElement+n]}copyUnprocessed(e,t,r){for(let n=0;n<this.componentsPerElement;n+=1)r[t+n]=this.at(e,n)}markProcessed(){this.processed=!0,this.copyFrom=this.copyProcessed.bind(this),delete this.view,delete this.at}process(){if(this.processed)return;const e=new Float32Array(this.count*this.componentsPerElement);for(let t=0;t<this.count;t+=1)this.copyFrom(t,t*this.componentsPerElement,e);this.data=e,this.markProcessed()}unweld(e){if(this.unwelded)return;this.unwelded=!0;const t=new Float32Array(e.length*this.componentsPerElement);for(let r=0;r<e.length;r+=1)this.copyFrom(e[r],r*this.componentsPerElement,t);this.count=e.length,this.data=t,this.markProcessed()}remap(e,t){const r=new Float32Array(t*this.componentsPerElement),n=new Uint8Array(t);for(let t=0;t<this.count;t+=1){const i=e[t];n[i]||(this.copyFrom(t,i*this.componentsPerElement,r),n[i]=1)}this.data=r,this.markProcessed()}}var h=r(2349);const v=r.e(451).then(r.bind(r,1451)).then((e=>e.generateTangents));function g(e){switch(e.bytesPerComponent){case 2:return{indexArray:new Uint16Array(e.value.buffer),indexFormat:"uint16"};case 4:return{indexArray:new Uint32Array(e.value.buffer),indexFormat:"uint32"};default:return{indexArray:new Uint16Array(e.value),indexFormat:"uint16"}}}async function b(e,t,r,i,a){const o=t.attributes;if(null==o.POSITION)return{};const{indices:s}=t,c=(0,h.LG)(o,(e=>new p(e)));let d,b,{mode:y}=t,w=o.POSITION.count;if(null!=s&&(({indexArray:d,indexFormat:b}=g(s)),0!==y&&1!==y&&4!==y&&({indexArray:d,indexFormat:b,mode:y}=function(e,t){switch(t){case 2:case 3:case 6:case 5:throw new Error("Topology currently unsupported");default:return{...g(e),mode:4}}}(s,y))),null!=c.NORMAL&&null==c.TANGENT)if(null!=c.TEXCOORD_0){if(null!=d){w=d.length;for(const e of Object.values(c))e.unweld(d)}const e=Date.now(),t=await v.then((e=>e(c.POSITION.array,c.NORMAL.array,c.TEXCOORD_0.array)));for(let e=3;e<t.length;e+=4)t[e]*=-1;console.log("tangents generated in "+(Date.now()-e)),c.TANGENT=new p(t,4),({indexArray:d,indexFormat:b,vertexCount:w}=l(c)),y=4}else{const e=new Float32Array(4*w);for(let t=0;t<w;t+=1)e.set([1,0,0,1],4*t);c.TANGENT=new p(e,4)}const{vertexArray:x,vertexFeatures:T}=function(e,t){let r=u.Ot.Defaults,n=5;null!=e.NORMAL&&(n+=7),null!=e.COLOR_0&&(n+=4);const i=new ArrayBuffer(n*t*4),a=new Float32Array(i);for(let r=0;r<t;r+=1)e.POSITION?.copyFrom(r,n*r,a);const o=e.TEXCOORD_0??new p(new Float32Array(2*t),2);for(let e=0;e<t;e+=1)o.copyFrom(e,e*n+3,a);if(null!=e.NORMAL&&null!=e.TANGENT){r|=u.Ot.VertexNormals;for(let r=0;r<t;r+=1)e.TANGENT.copyFrom(r,r*n+5,a);for(let r=0;r<t;r+=1)e.NORMAL.copyFrom(r,r*n+9,a)}if(null!=e.COLOR_0){r|=u.Ot.VertexColors;const i=null!=e.NORMAL?12:5;for(let r=0;r<t;r+=1)e.COLOR_0.copyFrom(r,r*n+i,a),a[r*n+i+3]=1}return{vertexArray:i,vertexFeatures:r}}(c,w);let S=function(e){let t;for(let r=0;r<e.length;r+=1){const i=n.pB.determinant(e[r]),a=Math.sign(i);if(t??=a,a!==t)return u.Ot.DoubleSided}return null==t||t>0?u.Ot.Defaults:u.Ot.ClockwiseWinding}(r)|T;null!=y&&(S|=m[y]||0);const P=new f({features:S,indexArray:d,indexFormat:b,vertexCount:w,vertexArray:x},a,r.length,i,r);return{material:t.material,drawData:P}}var y=r(4802);const w=0,x=1,T={9728:"nearest",9729:"linear",9984:"nearest",9985:"linear",9986:"nearest",9987:"linear"},S={9984:"nearest",9985:"nearest",9986:"linear",9987:"linear"},P={33071:"clamp-to-edge",33648:"mirror-repeat",10497:"repeat"};function C(e){const{magFilter:t,minFilter:r,wrapS:n,wrapT:i}=e;return{addressModeU:P[n??10497],addressModeV:P[i??10497],minFilter:T[r??9987],magFilter:T[t??9729],mipmapFilter:S[r??9987]??"linear"}}function O(e){const{source:t,sampler:r}=e;if(null==t)return{};const n=t.image.data??t.bufferView?.data;return null==n?{}:{data:n,mimeType:t.mimeType,sampler:r}}async function A(e,t,r){const i={};if(null!=e.pbrMetallicRoughness){const{baseColorFactor:t,baseColorTexture:n,metallicFactor:a,metallicRoughnessTexture:o,roughnessFactor:s}=e.pbrMetallicRoughness;if(null==o?.texture.source)null==a&&(i.metallicFactor=w),null==s&&(i.roughnessFactor=x);else{const{data:t,mimeType:n,sampler:a}=O(o.texture);null!=t&&(i.metallicRoughnessTexture=await(0,y.u)({label:`${e.id} mr texture`,data:t,mimeType:n,usage:GPUTextureUsage.TEXTURE_BINDING,device:r}),a&&(i.metallicRoughnessSampler=C(a)))}if(null!=n?.texture.source){const{data:t,mimeType:a,sampler:o}=O(n.texture);null!=t&&(i.baseColorTexture=await(0,y.u)({label:`${e.id} mr texture`,data:t,mimeType:a,usage:GPUTextureUsage.TEXTURE_BINDING,device:r,srgbToLinear:!0}),o&&(i.baseColorSampler=C(o)))}null!=t&&(i.baseColorFactor=t),null!=a&&(i.metallicFactor=a),null!=s&&(i.metallicFactor=s)}else i.metallicFactor=w,i.roughnessFactor=x;if(null!=e.normalTexture?.texture.source){const{data:t,mimeType:n,sampler:a}=O(e.normalTexture.texture);null!=t&&(i.normalTexture=await(0,y.u)({label:`${e.id} mr texture`,data:t,mimeType:n,usage:GPUTextureUsage.TEXTURE_BINDING,device:r}),a&&(i.normalSampler=C(a)))}const{emissiveFactor:a,emissiveTexture:o}=e,s=e.extensions?.KHR_materials_emissive_strength?.emissiveStrength;if(null!=o||a?.some((e=>e>0))){if(i.emissiveFactor=a??[1,1,1],i.emissiveSampler={magFilter:"linear",minFilter:"linear"},null!=o?.texture.source){const{data:t,mimeType:n,sampler:a}=O(o.texture);null!=t&&(i.emissiveTexture=await(0,y.u)({label:`${e.id} mr texture`,data:t,mimeType:n,usage:GPUTextureUsage.TEXTURE_BINDING,device:r,srgbToLinear:!0}),a&&(i.emissiveSampler=C(a)))}else i.emissiveTexture=t.baseColorTexture;null!=s&&"number"==typeof s&&n.eR.scale(i.emissiveFactor,s,i.emissiveFactor)}return e.doubleSided&&(i.doubleSided=!0),"MASK"===e.alphaMode&&(i.alphaCutoff=e.alphaCutoff??.5),{...t,...i}}class E{constructor(e,t,r,n,i){this.primitives=[],this.features=n,e.doubleSided&&(this.features|=u.Ot.DoubleSided);const a=new Float32Array(12);a.set(e.baseColorFactor),a[4]=e.metallicFactor,a[5]=e.roughnessFactor,null!=e.alphaCutoff&&(this.features|=u.Ot.AlphaCutoff,a[6]=e.alphaCutoff),null!=e.emissiveFactor&&a.set(e.emissiveFactor,8),this.propertiesBuffer=(0,d.Lr)(a,GPUBufferUsage.UNIFORM,t);const o=[{binding:0,resource:{buffer:this.propertiesBuffer}},{binding:1,resource:r.getSampler(e.baseColorSampler)},{binding:2,resource:e.baseColorTexture.createView({dimension:"2d"})},{binding:3,resource:r.getSampler(e.normalSampler)},{binding:4,resource:e.normalTexture.createView({dimension:"2d"})},{binding:5,resource:r.getSampler(e.metallicRoughnessSampler)},{binding:6,resource:e.metallicRoughnessTexture.createView({dimension:"2d"})}];null!=e.emissiveTexture&&(this.features|=u.Ot.Emissive,o.push({binding:7,resource:r.getSampler(e.emissiveSampler??{})}),o.push({binding:8,resource:e.emissiveTexture.createView({dimension:"2d"})})),this.layout=r.getMaterialBindGroup(this.features),this.matData=e,this.bindGroup=t.createBindGroup({label:(0,u.UZ)(this.features),layout:this.layout,entries:o}),null!=i&&this.addPrimitives(...i)}draw(e,t){if(0!==this.primitives.length){e.setBindGroup(1,this.bindGroup);for(const r of this.primitives)r.draw(e,t)}}addPrimitives(...e){const t=e.filter((e=>(e.features&this.features)===e.features||(console.warn(`invalid primitive added to material: \nprimitive: ${e.name}\nprimitive features: ${(0,u.UZ)(e.features).toString()}\nmaterial: ${this.matData.name}\nmaterial features: ${(0,u.UZ)(this.features).toString()}`),!1)));this.primitives.push(...t)}}class U{constructor(e,t){this.materials=[],this.features=(0,u.P7)(e);const r=t.getShaderModule(e);this.pipeline=t.device.createRenderPipeline({label:(0,u.UZ)(e),layout:t.getForwardPipelineLayout(e),primitive:t.getPrimitiveState(e),vertex:{entryPoint:"vs",buffers:[t.getVertexLayout(e)],module:r},fragment:{entryPoint:"fs",module:r,targets:t.gbuffer.targets},depthStencil:{depthWriteEnabled:!0,depthCompare:"less-equal",format:t.gbuffer.depth.format}})}addMaterials(...e){if(e.some((e=>e.features!==this.features)))throw new Error("invalid primitive added to material");this.materials.push(...e)}draw(e,t){e.setPipeline(this.pipeline);for(const r of this.materials)r.draw(e,t)}}const F=[{name:"POSITION",type:"VEC3",componentType:5126},{name:"TEXCOORD_0",type:"VEC2",componentType:5126},{name:"TANGENT",type:"VEC4",componentType:5126,depends:["NORMAL"],fill:[1,0,0,1]},{name:"NORMAL",type:"VEC3",componentType:5126,strip:!0,feature:u.Ot.VertexNormals},{name:"COLOR_0",type:"VEC4",componentType:5126,strip:!0,feature:u.Ot.VertexColors,fill:[1,1,1,1]}],M=(e,t)=>r=>{const i=r.matrix??n.pB.identity();if(null==r.matrix){if(r.scale&&n.pB.scaling(r.scale,i),r.rotation){const{axis:e,angle:t}=n.Yu.toAxisAngle(r.rotation);n.pB.rotate(i,e,t,i)}null!=r.translation&&n.pB.setTranslation(i,r.translation,i)}n.pB.mul(e,i,i),null!=r.mesh&&(t.has(r.mesh)||t.set(r.mesh,[]),t.get(r.mesh).push(i)),r.children?.forEach(M(i,t))};async function L(e,t,r,s,l=F,u={},c=console.log){c("starting import");const d=Date.now(),f=await(0,i.H)(e,a.B);c("finished loading: "+(Date.now()-d));const{scene:m}=(0,o.R)(f);if(null==m?.nodes)return u;c("finished processing: "+(Date.now()-d));const p=new Map;m.nodes.forEach(M(n.pB.identity(),p)),c("finished creating instances: "+(Date.now()-d));const h=Array.from(p.entries()).flatMap((([{primitives:e},n])=>e.map((e=>b(0,e,n,r,t))))),v=await Promise.all(h);c("finished creating primitives: "+(Date.now()-d));const g=new Map,y={};for(const{material:e,drawData:r}of v){if(null==r)continue;const n={materialId:e?.id,features:r.features};g.has(n)||g.set(n,[]),g.get(n).push(r),null!=e&&(y[e.id]=A(e,s,t))}const w=Object.entries(y).map((async([e,t])=>[e,await t])),x=Object.fromEntries(await Promise.all(w));c("finished creating material descriptors: "+(Date.now()-d));const T={...s,metallicFactor:0};for(const[{features:e,materialId:n},i]of g.entries()){const a=null!=n?x[n]:T,o=new E(a,t,r,e,i),{features:s}=o;u[s]??=new U(s,r),u[s].addMaterials(o)}return c("finished: "+(Date.now()-d)),u}},3803:(e,t,r)=>{r.a(e,(async(e,n)=>{try{r.d(t,{A:()=>c});var i=r(4802),a=r(2965),o=r(2112);const s=await fetch("https://api.github.com/repos/KhronosGroup/glTF-Sample-Environments/contents?ref=low_resolution_hdrs",{headers:{"Content-Type":"application/vnd.github.object+json"}}).then((e=>e.json())),l=Object.fromEntries(s.flatMap((({name:e,download_url:t})=>"string"==typeof e&&"string"==typeof t&&t.endsWith(".hdr")?[[e,t]]:[])));async function u(e,t){let r;if(t instanceof ArrayBuffer)r=t;else if(t instanceof File)r=await t.arrayBuffer();else{const e=await fetch(t);r=await e.arrayBuffer()}const n=(0,i.y)(r);return(0,a.l3)(e,n,{format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC})}function c(e){return{[o.t.$type]:"file",[o.t.$callback]:async(t,r)=>{if("value"===r&&null!=t&&("string"==typeof t||t instanceof File)){const r=await u(e.device,t),n=e.setSkybox(r);n instanceof Promise&&await n}},accept:".hdr",selection:{value:Object.keys(l)[0],initialValues:l},process:e=>e}}n()}catch(d){n(d)}}),1)},4581:(e,t,r)=>{r.d(t,{A:()=>n});const n="\n    struct VertOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n    }\n\n    @vertex\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\n        const pos = array(\n            vec2f(-1,  3),\n            vec2f(3, -1),\n            vec2f(-1, -1),\n        );\n        var res: VertOut;\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\n        return res;\n    }\n"},5753:(e,t,r)=>{r.d(t,{V:()=>n,X:()=>i});const n="\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n",i="\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n"},3936:(e,t,r)=>{r.d(t,{Lr:()=>n});r(2323);function n(e,t,r,n,i=4){const a=i-1,o=r.createBuffer({label:n,usage:t,size:e.byteLength+a&~a,mappedAtCreation:!0}),s=new Uint8Array(o.getMappedRange()),l=e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength);return s.set(l),o.unmap(),o}},4802:(e,t,r)=>{r.d(t,{u:()=>c,y:()=>d});const{baseTable:n,shiftTable:i}=(()=>{const e=new Uint32Array(256),t=new Uint32Array(256);for(let r=0;r<255;++r){const n=r-127;n<-27?(e[r]=0,t[r]=24):n<-14?(e[r]=1024>>-n-14,t[r]=-n-1):n<=15?(e[r]=n+15<<10,t[r]=13):(e[r]=31744,t[r]=24)}return e[255]=31744,t[255]=13,{baseTable:e,shiftTable:t}})(),a=new ArrayBuffer(4),o=new Float32Array(a),s=new Uint32Array(a);function l(e){o[0]=e;const t=s[0],r=t>>23&511,a=255&r,l=(8388607&t)>>i[a];return((256&r)<<7)+n[a]+l}var u=r(2965);async function c({device:e,data:t,mimeType:r,usage:n=GPUTextureUsage.TEXTURE_BINDING,mips:i=!0,format:a="rgba8unorm",colorSpace:o="srgb",label:s="",srgbToLinear:l}){let c;if(t instanceof ImageBitmap)c=t;else{const e=t instanceof Blob||t instanceof File?t:new Blob([t],{type:r});c=await createImageBitmap(e,{colorSpaceConversion:"none"})}const d={width:c.width,height:c.height},f=e.createTexture({label:s,format:a,size:d,usage:n|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:i?1+(0|Math.log2(Math.max(c.width,c.height))):1});return e.queue.copyExternalImageToTexture({source:c},{texture:f,colorSpace:o},d),l&&(0,u.sP)(e,f),i&&(0,u.fF)(e,f),f}function d(e){const t=new TextDecoder,r=e instanceof Uint8Array?e:new Uint8Array(e);let n=0;const i=(e=1024)=>{const i=Math.min(r.length,e+n),a=r.subarray(n,i),o=a.indexOf(10)+1;return n+=o,0===o?void 0:t.decode(a.subarray(0,o))},a=e=>new Error("HDR Import Error: "+e),o=i();if(null==o)throw a("no header found");if(!/^#\?(\S+)/.test(o))throw a("bad initial token");const s=new RegExp(`^\\s*(${[/FORMAT=(?<format>\S+)/,/-Y\s+(?<Y>\d+)\s+\+X\s+(?<X>\d+)/,/EXPOSURE\s*=\s*(?<exposure>\d+(\.\d+)?)/,/GAMMA\s*=\s*(?<gamma>\d+(\.\d+)?)/].map((({source:e})=>`(${e})`)).join("|")})\\s*$`);let u,c,d,f=!0,m=1,p=1;for(let e=i();null!=e;e=null==u?i():void 0){const t=e.match(s)?.groups;null!=t&&(null!=t.format?f=!1:null!=t.X&&null!=t.Y?(u=parseInt(t.X),c=parseInt(t.Y)):null!=t.gamma?m=parseFloat(t.gamma):null!=t.exposure&&(p=parseFloat(t.exposure)))}if(f)throw a("missing format specifier");if(null==u||null==c)throw a("missing image size specifier");const h=u<8||u>32767,v=2!==r[n]||2!==r[n+1]||!!(128&r[n+2]);if(h||v)d=r.subarray(n);else{d=new Uint8Array(u*c*4);const e=4*u,t=new Uint8Array(e),i=r.byteLength;for(let o=0,s=0;o<c&&n<i;o++){if(n+4>i)throw a("file ended durning scanline");if(2!=r[n++]||2!=r[n++]||(r[n++]<<8|r[n++])!=u)throw a("bad rgbe scanline format");let o;for(let s=0;s<e&&n<i;s+=o){o=r[n++];const i=o>128;if(i&&(o-=128),0==o||s+o>e)throw a("bad scanline data");i?(t.fill(r[n],s,s+o),n+=1):(t.set(r.subarray(n,n+o),s),n+=o)}for(let r=0;r<u;r++)for(let n=0;n<e;n+=u)d[s++]=t[r+n]}}const g=new Uint16Array(d.length),b=l(1);for(let e=0;e<u*c*4;e+=4){const t=d[e+3],r=Math.pow(2,t-128)/255;for(let t=0;t<3;t+=1)g[e+t]=l(Math.min(d[e+t]*r,65504));g[e+3]=b}return{data:g,width:u,height:c,gamma:m,exposure:p}}},2965:(e,t,r)=>{r.d(t,{fF:()=>l,l3:()=>s,sP:()=>u});var n=r(4581),i=r(5753),a=r(3936),o=r(2349);async function s(e,{data:t,width:r,height:s,gamma:l=1,exposure:u=1},c){const d=`\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${n.A}\n        ${i.V}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;let f,m=0;t instanceof GPUTexture?f=t:(m=1,f=e.createTexture({label:`${c.label} equirectangular`,dimension:"2d",format:"rgba16float",size:{width:r,height:s},usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING}),e.queue.writeTexture({texture:f,mipLevel:0},t,{bytesPerRow:2*r*4},{width:r,height:s,depthOrArrayLayers:1}),await e.queue.onSubmittedWorkDone());const p=f.height>>1,h=c;h.mipLevelCount??=0|Math.log2(p),h.size={width:p,height:p,depthOrArrayLayers:6},h.dimension="2d",h.usage|=GPUTextureUsage.RENDER_ATTACHMENT;const v=e.createTexture(h),g=o.OY`hdr copy${c.label}`,b=e.createBindGroupLayout({label:g,entries:[{binding:0,texture:{},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT},{binding:2,buffer:{},visibility:GPUShaderStage.FRAGMENT}]}),y=e.createShaderModule({label:g,code:d}),w=e.createSampler({label:g,minFilter:"linear",magFilter:"linear"}),x=new Uint32Array(1),T=(0,a.Lr)(x,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,e,g),S=e.createBindGroup({label:g,layout:b,entries:[{binding:0,resource:f.createView()},{binding:1,resource:w},{binding:2,resource:{buffer:T}}]}),P=e.createPipelineLayout({label:g,bindGroupLayouts:[b]}),C=e.createRenderPipeline({label:g,layout:P,vertex:{module:y},fragment:{module:y,targets:[{format:v.format}],constants:{GAMMA:l,EXPOSURE:u,FLIP_Y:m}}});for(let t=0;t<6;t+=1){x[0]=t,e.queue.writeBuffer(T,0,x,0,1);const r=v.createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:t,mipLevelCount:1}),n=e.createCommandEncoder(),i=n.beginRenderPass({label:g,colorAttachments:[{view:r,loadOp:"clear",storeOp:"store"}]});i.setPipeline(C),i.setBindGroup(0,S),i.draw(3),i.end(),e.queue.submit([n.finish()])}return v}async function l(e,t){const r=`\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${n.A}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `,i=o.OY`mip generation${t.label}`,a=e.createBindGroupLayout({label:i,entries:[{binding:0,texture:{viewDimension:"2d",sampleType:"float"},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT}]}),s={view:void 0,loadOp:"clear",storeOp:"store"},l=e.createSampler({minFilter:"linear",magFilter:"linear"}),u=e.createShaderModule({label:i,code:r}),c=e.createPipelineLayout({label:i,bindGroupLayouts:[a]}),d=e.createRenderPipeline({label:i,layout:c,vertex:{entryPoint:"vs",module:u},fragment:{entryPoint:"fs",targets:[{format:t.format}],module:u}});s.view=t.createView({mipLevelCount:1,baseMipLevel:0}),await e.queue.onSubmittedWorkDone();for(let r=1;r<t.mipLevelCount;r+=1){const n=e.createBindGroup({label:i,layout:a,entries:[{binding:0,resource:s.view},{binding:1,resource:l}]});s.view=t.createView({mipLevelCount:1,baseMipLevel:r});const o=e.createCommandEncoder(),u=o.beginRenderPass({label:i,colorAttachments:[s]});u.setPipeline(d),u.setBindGroup(0,n),u.draw(3),u.end(),e.queue.submit([o.finish()]),await e.queue.onSubmittedWorkDone()}}function u(e,t){const r=`\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${n.A}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `,i=o.OY`srgb to linear${t.label}`,a={width:t.width,height:t.height},s=e.createTexture({format:t.format,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,size:a}),l=e.createBindGroupLayout({label:i,entries:[{binding:0,texture:{},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT}]}),u=e.createSampler({minFilter:"linear",magFilter:"linear"}),c=e.createShaderModule({label:i,code:r}),d=e.createPipelineLayout({label:i,bindGroupLayouts:[l]}),f=e.createRenderPipeline({label:i,layout:d,vertex:{entryPoint:"vs",module:c},fragment:{entryPoint:"fs",targets:[{format:t.format}],module:c}}),m=e.createBindGroup({label:i,layout:l,entries:[{binding:0,resource:s.createView()},{binding:1,resource:u}]}),p=e.createCommandEncoder();p.copyTextureToTexture({texture:t},{texture:s},a);const h=p.beginRenderPass({label:i,colorAttachments:[{view:t.createView({mipLevelCount:1,baseMipLevel:0}),loadOp:"clear",storeOp:"store"}]});h.setPipeline(f),h.setBindGroup(0,m),h.draw(3),h.end(),e.queue.submit([p.finish()])}}}]);
//# sourceMappingURL=446.bundle.js.map