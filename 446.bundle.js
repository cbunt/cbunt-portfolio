/*! For license information see: https://cbunt.ing/oss-licenses.json */
"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[446],{3421:(e,t,r)=>{r.d(t,{A:()=>c});var n,i,a,o=r(282),s=r(2323),l=function(e,t,r,n){if("a"===r&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?n:"a"===r?n.call(e):n?n.value:t.get(e)};class u{constructor(e={}){n.add(this),this.buffer=new ArrayBuffer(i.bufferLength),this.worldToView=new Float32Array(this.buffer,i.worldToViewOffset,s.vV.mat4x4Count),this.viewToClip=new Float32Array(this.buffer,i.viewToClipOffset,s.vV.mat4x4Count),this.worldToClip=new Float32Array(this.buffer,i.worldToClipOffset,s.vV.mat4x4Count),this.viewToWorld=new Float32Array(this.buffer,i.viewToWorldOffset,s.vV.mat4x4Count),this.clipToView=new Float32Array(this.buffer,i.clipToViewOffset,s.vV.mat4x4Count),this.clipToWorld=new Float32Array(this.buffer,i.clipToWorldOffset,s.vV.mat4x4Count),this.location=new Float32Array([0,0,0]),this.rotation=new Float32Array([0,0,0,1]),this.params={nearPlane:.01,farPlane:500,fov:40,width:1920,height:1080,projection:"perspective"},this.updateParams(e)}updateParams(e){this.params={...this.params,...e},l(this,n,"m",a).call(this)}cacheView(){o.pB.fromQuat(this.rotation,this.viewToWorld),o.pB.setTranslation(this.viewToWorld,this.location,this.viewToWorld),o.pB.invert(this.viewToWorld,this.worldToView),o.pB.mul(this.viewToClip,this.worldToView,this.worldToClip),o.pB.mul(this.viewToWorld,this.clipToView,this.clipToWorld)}}i=u,n=new WeakSet,a=function(){if("perspective"===this.params.projection)o.pB.perspective(this.params.fov*(Math.PI/180),this.params.width/this.params.height,this.params.nearPlane,this.params.farPlane,this.viewToClip);else{const e=this.params.width/2,t=this.params.height/2;o.pB.ortho(-e,e,-t,t,this.params.nearPlane,this.params.farPlane,this.viewToClip)}o.pB.invert(this.viewToClip,this.clipToView)},u.worldToViewOffset=0,u.viewToClipOffset=i.worldToViewOffset+s.vV.sizeofMat4x4f,u.worldToClipOffset=i.viewToClipOffset+s.vV.sizeofMat4x4f,u.viewToWorldOffset=i.worldToClipOffset+s.vV.sizeofMat4x4f,u.clipToViewOffset=i.viewToWorldOffset+s.vV.sizeofMat4x4f,u.clipToWorldOffset=i.clipToViewOffset+s.vV.sizeofMat4x4f,u.bufferLength=i.clipToWorldOffset+s.vV.sizeofMat4x4f;const c=u},2323:(e,t,r)=>{r.d(t,{vV:()=>i});var n=r(9253);const i={mat4x4Count:16,sizeofMat4x4f:16*Float32Array.BYTES_PER_ELEMENT},a={[n.VIE]:"r8unorm",[n.B7n]:"r8snorm",[n.W_U]:"r8uint",[n.YeG]:"r8sint",[n.HYY]:"r16uint",[n.brc]:"r16sint",[n.eLQ]:"r16float",[n.sk6]:"rg8unorm",[n.aiL]:"rg8snorm",[n.xWH]:"rg8uint",[n.$Kq]:"rg8sint",[n.nR0]:"r32uint",[n.rwM]:"r32sint",[n.e4n]:"r32float",[n.P1c]:"rg16uint",[n.bc6]:"rg16sint",[n.cps]:"rg16float",[n.tsP]:"rgba8unorm",[n.Wm_]:"rgba8unorm-srgb",[n.zqn]:"rgba8snorm",[n.MZV]:"rgba8uint",[n._Je]:"rgba8sint",[n.J6Z]:"bgra8unorm",[n.mIY]:"bgra8unorm-srgb",[n.KIZ]:"rgb9e5ufloat",[n.eAA]:"rgb10a2uint",[n.fJh]:"rgb10a2unorm",[n.kot]:"rg11b10ufloat",[n.nlo]:"rg32uint",[n.x9e]:"rg32sint",[n.yAK]:"rg32float",[n.CSc]:"rgba16uint",[n.GF$]:"rgba16sint",[n.l2T]:"rgba16float",[n.KMX]:"rgba32uint",[n.KBq]:"rgba32sint",[n.Ze1]:"rgba32float",[n.QFs]:"bc1-rgba-unorm",[n.bOE]:"bc1-rgba-unorm-srgb",[n.wt4]:"bc2-rgba-unorm",[n.ZBp]:"bc2-rgba-unorm-srgb",[n.D_t]:"bc3-rgba-unorm",[n.elk]:"bc3-rgba-unorm-srgb",[n.ydS]:"bc4-r-unorm",[n.iIv]:"bc4-r-snorm",[n.LHP]:"bc5-rg-unorm",[n.xXb]:"bc5-rg-snorm",[n.mQu]:"bc6h-rgb-ufloat",[n.CpY]:"bc6h-rgb-float",[n.FD_]:"bc7-rgba-unorm",[n.GJu]:"bc7-rgba-unorm-srgb"};Object.fromEntries(Object.entries(a).map((([e,t])=>[t,parseInt(e,10)])))},1648:(e,t,r)=>{r.d(t,{A:()=>c});var n=r(7815);function i(e){return"string"==typeof e?e:e()}class a{constructor(e,t){this.else=e=>this.res??i(e),this.toString=()=>this.res??"",e&&(this.res=i(t))}elif(e,t){return e&&(this.res??=i(t)),this}get[Symbol.toStringTag](){return this.toString()}}function o(e,t=0){return()=>e(t++)}var s=r(5701);function l(e){const{ifdef:t}=function(e){return{ifdef:(t,r)=>new a((e&t)===t,r),ifndef:(t,r)=>new a((e&t)!==t,r)}}(e),r=o((e=>`@location(${e})`)),i=o((e=>`@location(${e})`)),l=o((e=>`\n        @group(1) @binding(${e})\n    `)),u=`\n        ${i()} pos: vec3f,\n        ${i()} camPos: vec3f,\n        ${i()} uv: vec2f,\n\n        ${t(n.Ot.VertexNormals,(()=>`\n            ${i()} tangent: vec4f,\n            ${i()} normal: vec3f,\n        `))}\n\n        ${t(n.Ot.VertexColors,(()=>`\n            ${i()} color: vec4f,\n        `))}\n    `;return`\n        ${s.A.code(0)}\n\n        struct ForwardOut {\n            @location(0) normal: vec4f,\n            @location(1) albedo: vec4f,\n            @location(2) emission: vec4f,\n            @location(3) metallicRoughness: vec4f,\n        }\n\n        struct MaterialProperties {\n            baseColorFactor: vec4f,\n            metallicFactor: f32,\n            roughnessFactor: f32,\n\n            ${t(n.Ot.AlphaCutoff,"alphaCutoff: f32,")}\n            ${t(n.Ot.Emissive,"emissiveFactor: vec3f,")}\n        }\n\n        ${l()} var<uniform> material: MaterialProperties;\n\n        ${l()} var baseColorSampler: sampler;\n        ${l()} var baseColorTexture: texture_2d<f32>;\n\n        ${l()} var normalSampler: sampler;\n        ${l()} var normalTexture: texture_2d<f32>;\n\n        ${l()} var metallicRoughnessSampler: sampler;\n        ${l()} var metallicRoughnessTexture: texture_2d<f32>;\n\n        ${t(n.Ot.Emissive,(()=>`\n            ${l()} var emissionSampler: sampler;\n            ${l()} var emissionTexture: texture_2d<f32>;\n        `))}\n\n        struct ModelProperties {\n            modelToWorldMatrix: mat4x4f,\n\n            ${t(n.Ot.VertexNormals,"normalMatrix: mat3x3f,")}\n        }\n\n        @group(2) @binding(0) var<storage, read> instances : array<ModelProperties>;\n\n        struct VertIn {\n            @builtin(instance_index) instance: u32,\n            ${r()} pos: vec3f,\n            ${r()} uv: vec2f,\n\n            ${t(n.Ot.VertexNormals,(()=>`\n                ${r()} tangent: vec4f,\n                ${r()} normal: vec3f,\n            `))}\n\n            ${t(n.Ot.VertexColors,(()=>`\n                ${r()} color: vec4f,\n            `))}\n        }\n\n        struct VertOut {\n            ${u}\n            @builtin(position) Position: vec4f,\n        }\n\n        struct FragIn {\n            ${u}\n\n            ${t(n.Ot.VertexNormals|n.Ot.DoubleSided,"\n                @builtin(front_facing) front_facing: bool,\n            ")}\n        }\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @vertex \n        fn vs(inData: VertIn) -> VertOut {\n            var vsOut: VertOut;\n            let instance = instances[inData.instance];\n            let worldPos = instance.modelToWorldMatrix * vec4f(inData.pos, 1);\n            vsOut.pos = worldPos.xyz;\n            vsOut.Position = globals.worldToClip * worldPos;\n            vsOut.camPos = globals.inverseWorldToView[3].xyz;\n            vsOut.uv = inData.uv;\n\n            ${t(n.Ot.VertexNormals,"\n                vsOut.normal = normalize(instance.normalMatrix * inData.normal);\n                let wsTangent = normalize((instance.modelToWorldMatrix * vec4(inData.tangent.xyz, 0.0)).xyz);\n                vsOut.tangent = vec4(wsTangent, inData.tangent.w);\n            ")}\n\n            return vsOut;\n        }\n\n        // much of this code is adapted from https://learnopengl.com/PBR\n        @fragment\n        fn fs(inData: FragIn) -> ForwardOut {\n            var out: ForwardOut;\n            let rawColor = textureSample(baseColorTexture, baseColorSampler, inData.uv);\n\n            ${t(n.Ot.AlphaCutoff,`\n                var alpha = rawColor.a * material.baseColorFactor.a;\n\n                ${t(n.Ot.VertexColors,"\n                    alpha *= inData.color.a;\n                ")}\n\n                if (alpha <= material.alphaCutoff) { \n                    discard;\n                }\n            `)}\n\n            out.albedo = vec4f(rawColor.rgb * material.baseColorFactor.rgb, 1);\n\n            ${t(n.Ot.VertexColors,"\n                out.albedo *= vec4f(inData.color.rgb, 1);\n            ")}\n\n            let metallicRoughness = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, inData.uv);\n            out.metallicRoughness.r = saturate(metallicRoughness.b * material.metallicFactor);\n            out.metallicRoughness.g = saturate(metallicRoughness.g * material.roughnessFactor);\n\n            ${t(n.Ot.VertexNormals,`\n                let normalSample = textureSample(normalTexture, normalSampler, inData.uv).xyz;\n                let tangentNormal = normalize(normalSample * 2.0 - 1.0);\n                let bitangent =inData.tangent.w * cross(inData.normal, inData.tangent.xyz);\n                let tbn = mat3x3f(normalize(inData.tangent.xyz), bitangent, normalize(inData.normal));\n                var normal = normalize(tbn * tangentNormal);\n\n                ${t(n.Ot.DoubleSided,"\n                    if (!inData.front_facing) { normal *= -1.0; }\n                ")}\n            `).else("\n                let fdx = dpdx(inData.pos);\n                let fdy = dpdy(inData.pos);\n                let normal = normalize(cross(fdy, fdx));\n            ")}\n\n            out.normal = vec4f(normal, 1);\n\n            ${t(n.Ot.Emissive,"\n                let emission = textureSample(emissionTexture, emissionSampler, inData.uv).rgb;\n                out.emission = vec4f(emission, 1);\n            ")}\n\n            return out;\n        }\n    `}class u{constructor(e,t,r){this.device=e,this.gbuffer=t,this.globals=r,this.pipelineLayouts={},this.primitiveStates={},this.vertexLayouts={},this.shaderModules={},this.bindgroupLayouts={},this.samplers={},this.forwardBindgroupLayout=this.device.createBindGroupLayout({label:"forward material",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]})}getSampler(e){const t=JSON.stringify(e);return this.samplers[t]??=this.device.createSampler(e),this.samplers[t]}getVertexLayout(e){const t=e&n.V3;if(null==this.vertexLayouts[t]){const e=[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"}];let r=20,i=2;t&n.Ot.VertexNormals&&(e.push({shaderLocation:i,offset:r,format:"float32x4"}),e.push({shaderLocation:i+1,offset:r+16,format:"float32x3"}),i+=2,r+=28),t&n.Ot.VertexColors&&(e.push({shaderLocation:i,offset:r,format:"float32x4"}),r+=16),this.vertexLayouts[t]={attributes:e,arrayStride:r,stepMode:"vertex"}}return this.vertexLayouts[t]}getForwardPipelineLayout(e){const t=e&n.FO;return this.pipelineLayouts[t]??=this.device.createPipelineLayout({label:n.UZ(t),bindGroupLayouts:[this.globals.bindGroupLayout,this.getMaterialBindGroup(e),this.forwardBindgroupLayout]}),this.pipelineLayouts[t]}getShaderModule(e){const t=e&n.Q7;return this.shaderModules[t]??=this.device.createShaderModule({label:n.UZ(t),code:l(t)}),this.shaderModules[t]}getPrimitiveState(e){const t=e&n.XY;return this.primitiveStates[t]??={topology:u.flagToTopology[e&n.Py],cullMode:t&n.Ot.DoubleSided?"none":"back",frontFace:t&n.Ot.ClockwiseWinding?"cw":"ccw"},this.primitiveStates[t]}getMaterialBindGroup(e){const t=e&n.Wq;return this.bindgroupLayouts[t]??=this.device.createBindGroupLayout(function(e){const t=[];function r(e){t.push({...e,binding:t.length,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.VERTEX})}return r({buffer:{type:"uniform"}}),r({sampler:{}}),r({texture:{viewDimension:"2d"}}),r({sampler:{}}),r({texture:{viewDimension:"2d"}}),r({sampler:{}}),r({texture:{viewDimension:"2d"}}),e&n.Ot.Emissive&&(r({sampler:{}}),r({texture:{viewDimension:"2d"}})),{label:(0,n.UZ)(e),entries:t}}(t)),this.bindgroupLayouts[t]}}u.flagToTopology={[n.Ot.TriangleList]:"triangle-list",[n.Ot.TriangleStrip]:"triangle-strip",[n.Ot.PointList]:"point-list",[n.Ot.LineList]:"line-list",[n.Ot.LineStrip]:"line-strip"};const c=u},7815:(e,t,r)=>{var n;r.d(t,{FO:()=>c,Ot:()=>n,P7:()=>m,Py:()=>i,Q7:()=>o,UZ:()=>f,V3:()=>l,Wq:()=>u,XY:()=>a}),function(e){e[e.Defaults=0]="Defaults",e[e.VertexNormals=1]="VertexNormals",e[e.VertexColors=2]="VertexColors",e[e.AlphaCutoff=4]="AlphaCutoff",e[e.Emissive=8]="Emissive",e[e.DoubleSided=16]="DoubleSided",e[e.ClockwiseWinding=32]="ClockwiseWinding",e[e.TriangleList=0]="TriangleList",e[e.TriangleStrip=64]="TriangleStrip",e[e.PointList=128]="PointList",e[e.LineList=192]="LineList",e[e.LineStrip=256]="LineStrip",e[e.Unindexed=320]="Unindexed"}(n||(n={}));const i=17472,a=i|n.DoubleSided|n.ClockwiseWinding,o=~(i|n.ClockwiseWinding),s=n.VertexNormals,l=n.VertexNormals|n.VertexColors,u=n.AlphaCutoff|n.Emissive,c=s|(u|n.DoubleSided);function f(e){return function(e){return Object.entries(n).flatMap((([t,r])=>"number"==typeof r&&r&e?t:[]))}(e).toString()}function m(e){let t=e;return t&n.DoubleSided&&(t&=~n.ClockwiseWinding),t}},5701:(e,t,r)=>{r.d(t,{A:()=>o});var n=r(3421);const i="global uniforms";class a{constructor(e){this.deviceBuffer=e.createBuffer(a.bufferDescriptor),this.bindGroupLayout=e.createBindGroupLayout(a.layoutDescriptor),this.bindGroupDescriptor={label:i,layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:this.deviceBuffer,offset:0,size:a.bufferSize}}]},this.bindgroup=e.createBindGroup(this.bindGroupDescriptor)}updateDeviceBuffer(e,t){t.cacheView(),e.writeBuffer(this.deviceBuffer,0,t.buffer)}}a.code=e=>`\n        struct GlobalUniforms {\n            worldToView: mat4x4f,\n            viewToClip: mat4x4f,\n            worldToClip: mat4x4f,\n            inverseWorldToView: mat4x4f,\n            inverseViewToClip: mat4x4f,\n            inverseWorldToClip: mat4x4f,\n        }\n\n        @group(${e}) @binding(0) var<uniform> globals: GlobalUniforms;\n    `,a.bufferSize=n.A.bufferLength,a.layoutDescriptor={label:i,entries:[{binding:0,buffer:{minBindingSize:a.bufferSize},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}]},a.bufferDescriptor={label:i,size:a.bufferSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};const o=a},2446:(e,t,r)=>{r.a(e,(async(e,n)=>{try{r.r(t),r.d(t,{default:()=>b});var i=r(2112),a=r(3803),o=r(1648),s=r(7815),l=r(9196),u=r(5605),c=r(2349),f=e([a]);a=(f.then?(await f)():f)[0];var m,d=function(e,t,r,n){if("a"===r&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?n:"a"===r?n.call(e):n?n.value:t.get(e)};const p=await h();async function h(){const e=await fetch("https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/model-index.json"),t=await e.text(),r=JSON.parse(t);if(!Array.isArray(r))throw new Error("Could not load index for glTF sample models.");const n=r.flatMap((e=>{if(!((0,c.Gv)(e)&&"label"in e&&"string"==typeof e.label&&"name"in e&&"string"==typeof e.name&&"variants"in e&&(0,c.Gv)(e.variants)&&"string"==typeof e.variants.glTF))return[];const{variants:{glTF:t},label:r,name:n}=e;return[[r,`https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/${n}/glTF/${t}`]]}));return Object.fromEntries(n)}class g{get depthTextureView(){return this.descriptorMap.gbuffer.depth.view}constructor(e){this.renderer=e,this.geometryPipelines={},m.set(this,(0,i.A)({skybox:(0,a.A)(this),model:{[i.t.$type]:"file",[i.t.$callback]:(e,t)=>{"value"===t&&null!=e&&("string"==typeof e||e instanceof File)&&this.setModel(e)},accept:".hdr",selection:{value:"Environment Test",initialValues:p},process:e=>e}})),this.settings=d(this,m,"f").publicSettings,this.priority=1e3,this.descriptorMap=new o.A(e.device,e.gbuffer,e.globals),this.device=e.device,this.renderer.addForwardPass(this)}async setSkybox(e){await(0,l.A)({texture:e,device:this.renderer.device,inPlace:!0,delayWork:requestAnimationFrame}),this.renderer.skybox=e}async setModel(e){const t={width:1,height:1},r=new Float32Array([1,1,1,1]),n=this.renderer.device.createTexture({size:t,format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});this.renderer.device.queue.writeTexture({texture:n},r,{},t);const i=this.renderer.device.createTexture({size:t,format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});r.set([.5,.5,1,1]),this.renderer.device.queue.writeTexture({texture:i},r,{},t);const a={addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"},o={baseColorTexture:n,baseColorFactor:[1,1,1,1],normalTexture:i,metallicRoughnessTexture:n,metallicFactor:1,roughnessFactor:1,baseColorSampler:a,normalSampler:a,metallicRoughnessSampler:a};this.geometryPipelines=await(0,u.A)(e,this.renderer.device,this.descriptorMap,o,g.goalLayout,{})}render({encoder:e,gbuffer:t,globals:r}){const n=e.beginRenderPass(t.passDescriptor);n.setBindGroup(0,r.bindgroup);for(const e of Object.values(this.geometryPipelines))e?.draw(n,this.renderer.device.queue);n.end()}}m=new WeakMap,g.goalLayout=[{name:"POSITION",type:"VEC3",componentType:5126},{name:"TEXCOORD_0",type:"VEC2",componentType:5126},{name:"TANGENT",type:"VEC4",componentType:5126,depends:["NORMAL"],fill:[1,0,0,1]},{name:"NORMAL",type:"VEC3",componentType:5126,strip:!0,feature:s.Ot.VertexNormals},{name:"COLOR_0",type:"VEC4",componentType:5126,strip:!0,feature:s.Ot.VertexColors,fill:[1,1,1,1]}];const b=g;n()}catch(v){n(v)}}),1)},5605:(e,t,r)=>{r.d(t,{A:()=>G});var n=r(282),i=r(6730),a=r(7573),o=r(7740);class s{constructor(e){this.attributes=[];let t=0;for(const r of Object.values(e))t+=this.initAttribute(r);const r=t+3&-4;this.u8=new Uint8Array(r),this.u32=new Uint32Array(this.u8.buffer)}initAttribute(e){const t=e.data instanceof Uint8Array?e.data:new Uint8Array(e.data.buffer),r=e.bytesPerComponent*e.componentsPerElement;return this.attributes.push({u8:t,byteStride:r}),r}hash(e){let t=0;for(const{u8:r,byteStride:n}of this.attributes){for(let i=0;i<n;i+=1)this.u8[t+i]=r[e*n+i];t+=n}return this.murmurHash2()}equal(e,t){for(const{u8:r,byteStride:n}of this.attributes)for(let i=0;i<n;i+=1)if(r[e*n+i]!==r[t*n+i])return!1;return!0}hashLookup(e,t,r,n){const i=t-1;let a=this.hash(r)&i;for(let t=0;t<=i;t+=1){const o=e[a];if(o===n||this.equal(o,r))return a;a=a+t+1&i}throw new Error("Hash table full.")}murmurHash2(){const e=1540483477;let t=0;for(let r of this.u32)r=Math.imul(r,e)>>>0,r=(r^r>>24)>>>0,r=Math.imul(r,e)>>>0,t=Math.imul(t,e)>>>0,t=(t^r)>>>0;return t}}function l(e){const t=e.POSITION.count,r=new s(e),n=(i=t+t/4,2**Math.ceil(Math.log(i)/Math.LN2));var i;const a=t<65535,o=2**(a?16:32)-1,l=a?"uint16":"uint32",u=a?new Uint16Array(t):new Uint32Array(t),c=a?new Uint16Array(n):new Uint32Array(n);c.fill(o);let f=0;for(let e=0;e<t;e+=1){const t=r.hashLookup(c,n,e,o),i=c[t];i===o?(c[t]=e,u[e]=f,f+=1):u[e]=u[i]}for(const t of Object.values(e))t.remap(u,f);return{indexArray:u,indexFormat:l,vertexCount:f}}var u=r(7815),c=r(2323),f=r(3936);class m{constructor(e,t,r,n,i){if(this.instanceCount=0,this.dirty=!1,this.max=r,this.features=e.features,this.name=e.name??"mesh",this.vertexCount=e.vertexCount,e.vertexArray instanceof GPUBuffer?this.vertexBuffer=e.vertexArray:this.vertexBuffer=(0,f.Lr)(e.vertexArray,GPUBufferUsage.VERTEX,t,`${this.name} vertex buffer`),e.indexArray&&e.indexFormat){const{indexArray:r,indexFormat:n}=e;this.indexData={indexFormat:n,indexCount:r.byteLength/("uint16"===n?2:4),indexBuffer:(0,f.Lr)(e.indexArray,GPUBufferUsage.INDEX,t,`${this.name} index buffer`)}}this.instanceSize=c.vV.sizeofMat4x4f,this.features&u.Ot.VertexNormals&&(this.instanceSize+=48),this.instances=new ArrayBuffer(r*this.instanceSize),this.modelMatrices=new Array(r);for(let e=0;e<r;e+=1){const t=e*this.instanceSize;this.modelMatrices[e]=new Float32Array(this.instances,t,16)}if(this.features&u.Ot.VertexNormals){this.normalMatrices=new Array(r);for(let e=0;e<r;e+=1){const t=e*this.instanceSize+c.vV.sizeofMat4x4f;this.normalMatrices[e]=new Float32Array(this.instances,t,12)}}if(this.instanceBuffer=t.createBuffer({label:`${this.name} instance buffer`,size:this.instances.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.instanceBindGroup=t.createBindGroup({label:"PrimitiveDrawData instance bind group",layout:n.forwardBindgroupLayout,entries:[{binding:0,resource:{buffer:this.instanceBuffer}}]}),i)for(const e of i)this.addInstance(e)}draw(e,t){if(this.dirty&&(t.writeBuffer(this.instanceBuffer,0,this.instances),this.dirty=!1),e.setVertexBuffer(0,this.vertexBuffer),e.setBindGroup(2,this.instanceBindGroup),null!=this.indexData){const{indexBuffer:t,indexCount:r,indexFormat:n}=this.indexData;e.setIndexBuffer(t,n),e.drawIndexed(r,this.instanceCount)}else e.draw(this.vertexCount,this.instanceCount)}addInstance(e){this.instanceCount!==this.max&&(n.pB.copy(e,this.modelMatrices[this.instanceCount]),this.calculateNormalMatrix(this.instanceCount),this.instanceCount+=1,this.dirty=!0)}calculateNormalMatrix(e){if(!(this.features&u.Ot.VertexNormals))return;const t=this.normalMatrices[e];n.w0.fromMat4(this.modelMatrices[e],t),n.w0.invert(t,t),n.w0.transpose(t,t)}}const d={0:u.Ot.PointList,1:u.Ot.LineList,4:u.Ot.TriangleList};class p{constructor(e,t){if(this.unwelded=!1,e instanceof Float32Array)this.data=e,this.componentsPerElement=t,this.count=e.length/t,this.processed=!0,this.bytesPerComponent=4,this.copyFrom=this.copyProcessed.bind(this);else{switch(this.data=e.value,this.componentsPerElement=e.components,this.count=e.count,this.bytesPerComponent=e.bytesPerComponent,this.processed=!1,this.view=new DataView(this.data.buffer),this.copyFrom=this.copyUnprocessed.bind(this),e.componentType){case 5120:this.at=(e,t)=>this.view.getInt8(e*this.componentsPerElement+t);break;case 5121:this.at=(e,t)=>this.view.getUint8(e*this.componentsPerElement+t);break;case 5122:this.at=(e,t)=>{const r=2*(e*this.componentsPerElement+t);return this.view.getInt16(r,!0)};break;case 5123:this.at=(e,t)=>{const r=2*(e*this.componentsPerElement+t);return this.view.getUint16(r,!0)};break;case 5125:this.at=(e,t)=>{const r=4*(e*this.componentsPerElement+t);return this.view.getUint32(r,!0)};break;case 5126:this.at=(e,t)=>{const r=4*(e*this.componentsPerElement+t);return this.view.getFloat32(r,!0)};break;default:throw new Error(`gltf importer -- invalid componentType ${e.componentType}`)}if(e.normalized){let t;switch(e.componentType){case 5121:t=255;break;case 5120:t=127;break;case 5123:t=65535;break;case 5122:t=32767;break;case 5125:t=4294967295;break;default:throw new Error(`gltf importer -- invalid componentType ${e.componentType}`)}this.at=(e,r)=>this.at(e,r)/t}}}get array(){return this.processed||this.process(),this.data}copyProcessed(e,t,r){for(let n=0;n<this.componentsPerElement;n+=1)r[t+n]=this.data[e*this.componentsPerElement+n]}copyUnprocessed(e,t,r){for(let n=0;n<this.componentsPerElement;n+=1)r[t+n]=this.at(e,n)}markProcessed(){this.processed=!0,this.copyFrom=this.copyProcessed.bind(this),delete this.view,delete this.at}process(){if(this.processed)return;const e=new Float32Array(this.count*this.componentsPerElement);for(let t=0;t<this.count;t+=1)this.copyFrom(t,t*this.componentsPerElement,e);this.data=e,this.markProcessed()}unweld(e){if(this.unwelded)return;this.unwelded=!0;const t=new Float32Array(e.length*this.componentsPerElement);for(let r=0;r<e.length;r+=1)this.copyFrom(e[r],r*this.componentsPerElement,t);this.count=e.length,this.data=t,this.markProcessed()}remap(e,t){const r=new Float32Array(t*this.componentsPerElement),n=new Uint8Array(t);for(let t=0;t<this.count;t+=1){const i=e[t];n[i]||(this.copyFrom(t,i*this.componentsPerElement,r),n[i]=1)}this.data=r,this.markProcessed()}}var h=r(2349);const g=r.e(451).then(r.bind(r,1451)).then((e=>e.generateTangents));function b(e){switch(e.bytesPerComponent){case 2:return{indexArray:new Uint16Array(e.value.buffer),indexFormat:"uint16"};case 4:return{indexArray:new Uint32Array(e.value.buffer),indexFormat:"uint32"};default:return{indexArray:new Uint16Array(e.value),indexFormat:"uint16"}}}async function v(e,t,r,i,a){const o=t.attributes;if(null==o.POSITION)return{};const{indices:s}=t,c=(0,h.LG)(o,(e=>new p(e)));let f,v,{mode:y}=t,w=o.POSITION.count;if(null!=s&&(({indexArray:f,indexFormat:v}=b(s)),0!==y&&1!==y&&4!==y&&({indexArray:f,indexFormat:v,mode:y}=function(e,t){switch(t){case 2:case 3:case 6:case 5:throw new Error("Topology currently unsupported");default:return{...b(e),mode:4}}}(s,y))),null!=c.NORMAL&&null==c.TANGENT)if(null!=c.TEXCOORD_0){if(null!=f){w=f.length;for(const e of Object.values(c))e.unweld(f)}const e=Date.now(),t=await g.then((e=>e(c.POSITION.array,c.NORMAL.array,c.TEXCOORD_0.array)));for(let e=3;e<t.length;e+=4)t[e]*=-1;console.log("tangents generated in "+(Date.now()-e)),c.TANGENT=new p(t,4),({indexArray:f,indexFormat:v,vertexCount:w}=l(c)),y=4}else{const e=new Float32Array(4*w);for(let t=0;t<w;t+=1)e.set([1,0,0,1],4*t);c.TANGENT=new p(e,4)}const{vertexArray:x,vertexFeatures:T}=function(e,t){let r=u.Ot.Defaults,n=5;null!=e.NORMAL&&(n+=7),null!=e.COLOR_0&&(n+=4);const i=new ArrayBuffer(n*t*4),a=new Float32Array(i);for(let r=0;r<t;r+=1)e.POSITION?.copyFrom(r,n*r,a);const o=e.TEXCOORD_0??new p(new Float32Array(2*t),2);for(let e=0;e<t;e+=1)o.copyFrom(e,e*n+3,a);if(null!=e.NORMAL&&null!=e.TANGENT){r|=u.Ot.VertexNormals;for(let r=0;r<t;r+=1)e.TANGENT.copyFrom(r,r*n+5,a);for(let r=0;r<t;r+=1)e.NORMAL.copyFrom(r,r*n+9,a)}if(null!=e.COLOR_0){r|=u.Ot.VertexColors;const i=null!=e.NORMAL?12:5;for(let r=0;r<t;r+=1)e.COLOR_0.copyFrom(r,r*n+i,a),a[r*n+i+3]=1}return{vertexArray:i,vertexFeatures:r}}(c,w);let O=function(e){let t;for(let r=0;r<e.length;r+=1){const i=n.pB.determinant(e[r]),a=Math.sign(i);if(t??=a,a!==t)return u.Ot.DoubleSided}return null==t||t>0?u.Ot.Defaults:u.Ot.ClockwiseWinding}(r)|T;null!=y&&(O|=d[y]||0);const P=new m({features:O,indexArray:f,indexFormat:v,vertexCount:w,vertexArray:x},a,r.length,i,r);return{material:t.material,drawData:P}}var y=r(4883);const w=0,x=1,T={9728:"nearest",9729:"linear",9984:"nearest",9985:"linear",9986:"nearest",9987:"linear"},O={9984:"nearest",9985:"nearest",9986:"linear",9987:"linear"},P={33071:"clamp-to-edge",33648:"mirror-repeat",10497:"repeat"};function S(e){const{magFilter:t,minFilter:r,wrapS:n,wrapT:i}=e;return{addressModeU:P[n??10497],addressModeV:P[i??10497],minFilter:T[r??9987],magFilter:T[t??9729],mipmapFilter:O[r??9987]??"linear"}}function A(e){const{source:t,sampler:r}=e;if(null==t)return{};const n=t.image.data??t.bufferView?.data;return null==n?{}:{data:n,mimeType:t.mimeType,sampler:r}}async function C(e,t,r){const i={};if(null!=e.pbrMetallicRoughness){const{baseColorFactor:t,baseColorTexture:n,metallicFactor:a,metallicRoughnessTexture:o,roughnessFactor:s}=e.pbrMetallicRoughness;if(null==o?.texture.source)null==a&&(i.metallicFactor=w),null==s&&(i.roughnessFactor=x);else{const{data:t,mimeType:n,sampler:a}=A(o.texture);null!=t&&(i.metallicRoughnessTexture=await(0,y.u)({label:`${e.id} mr texture`,data:t,mimeType:n,usage:GPUTextureUsage.TEXTURE_BINDING,device:r}),a&&(i.metallicRoughnessSampler=S(a)))}if(null!=n?.texture.source){const{data:t,mimeType:a,sampler:o}=A(n.texture);null!=t&&(i.baseColorTexture=await(0,y.u)({label:`${e.id} mr texture`,data:t,mimeType:a,usage:GPUTextureUsage.TEXTURE_BINDING,device:r,srgbToLinear:!0}),o&&(i.baseColorSampler=S(o)))}null!=t&&(i.baseColorFactor=t),null!=a&&(i.metallicFactor=a),null!=s&&(i.metallicFactor=s)}else i.metallicFactor=w,i.roughnessFactor=x;if(null!=e.normalTexture?.texture.source){const{data:t,mimeType:n,sampler:a}=A(e.normalTexture.texture);null!=t&&(i.normalTexture=await(0,y.u)({label:`${e.id} mr texture`,data:t,mimeType:n,usage:GPUTextureUsage.TEXTURE_BINDING,device:r}),a&&(i.normalSampler=S(a)))}const{emissiveFactor:a,emissiveTexture:o}=e,s=e.extensions?.KHR_materials_emissive_strength?.emissiveStrength;if(null!=o||a?.some((e=>e>0))){if(i.emissiveFactor=a??[1,1,1],i.emissiveSampler={magFilter:"linear",minFilter:"linear"},null!=o?.texture.source){const{data:t,mimeType:n,sampler:a}=A(o.texture);null!=t&&(i.emissiveTexture=await(0,y.u)({label:`${e.id} mr texture`,data:t,mimeType:n,usage:GPUTextureUsage.TEXTURE_BINDING,device:r,srgbToLinear:!0}),a&&(i.emissiveSampler=S(a)))}else i.emissiveTexture=t.baseColorTexture;null!=s&&"number"==typeof s&&n.eR.scale(i.emissiveFactor,s,i.emissiveFactor)}return e.doubleSided&&(i.doubleSided=!0),"MASK"===e.alphaMode&&(i.alphaCutoff=e.alphaCutoff??.5),{...t,...i}}class F{constructor(e,t,r,n,i){this.primitives=[],this.features=n,e.doubleSided&&(this.features|=u.Ot.DoubleSided);const a=new Float32Array(12);a.set(e.baseColorFactor),a[4]=e.metallicFactor,a[5]=e.roughnessFactor,null!=e.alphaCutoff&&(this.features|=u.Ot.AlphaCutoff,a[6]=e.alphaCutoff),null!=e.emissiveFactor&&a.set(e.emissiveFactor,8),this.propertiesBuffer=(0,f.Lr)(a,GPUBufferUsage.UNIFORM,t);const o=[{binding:0,resource:{buffer:this.propertiesBuffer}},{binding:1,resource:r.getSampler(e.baseColorSampler)},{binding:2,resource:e.baseColorTexture.createView({dimension:"2d"})},{binding:3,resource:r.getSampler(e.normalSampler)},{binding:4,resource:e.normalTexture.createView({dimension:"2d"})},{binding:5,resource:r.getSampler(e.metallicRoughnessSampler)},{binding:6,resource:e.metallicRoughnessTexture.createView({dimension:"2d"})}];null!=e.emissiveTexture&&(this.features|=u.Ot.Emissive,o.push({binding:7,resource:r.getSampler(e.emissiveSampler??{})}),o.push({binding:8,resource:e.emissiveTexture.createView({dimension:"2d"})})),this.layout=r.getMaterialBindGroup(this.features),this.matData=e,this.bindGroup=t.createBindGroup({label:(0,u.UZ)(this.features),layout:this.layout,entries:o}),null!=i&&this.addPrimitives(...i)}draw(e,t){if(0!==this.primitives.length){e.setBindGroup(1,this.bindGroup);for(const r of this.primitives)r.draw(e,t)}}addPrimitives(...e){const t=e.filter((e=>(e.features&this.features)===e.features||(console.warn(`invalid primitive added to material: \nprimitive: ${e.name}\nprimitive features: ${(0,u.UZ)(e.features).toString()}\nmaterial: ${this.matData.name}\nmaterial features: ${(0,u.UZ)(this.features).toString()}`),!1)));this.primitives.push(...t)}}class E{constructor(e,t){this.materials=[],this.features=(0,u.P7)(e);const r=t.getShaderModule(e);this.pipeline=t.device.createRenderPipeline({label:(0,u.UZ)(e),layout:t.getForwardPipelineLayout(e),primitive:t.getPrimitiveState(e),vertex:{entryPoint:"vs",buffers:[t.getVertexLayout(e)],module:r},fragment:{entryPoint:"fs",module:r,targets:t.gbuffer.targets},depthStencil:{depthWriteEnabled:!0,depthCompare:"less-equal",format:t.gbuffer.depth.format}})}addMaterials(...e){if(e.some((e=>e.features!==this.features)))throw new Error("invalid primitive added to material");this.materials.push(...e)}draw(e,t){e.setPipeline(this.pipeline);for(const r of this.materials)r.draw(e,t)}}const M=[{name:"POSITION",type:"VEC3",componentType:5126},{name:"TEXCOORD_0",type:"VEC2",componentType:5126},{name:"TANGENT",type:"VEC4",componentType:5126,depends:["NORMAL"],fill:[1,0,0,1]},{name:"NORMAL",type:"VEC3",componentType:5126,strip:!0,feature:u.Ot.VertexNormals},{name:"COLOR_0",type:"VEC4",componentType:5126,strip:!0,feature:u.Ot.VertexColors,fill:[1,1,1,1]}],U=(e,t)=>r=>{const i=r.matrix??n.pB.identity();if(null==r.matrix){if(r.scale&&n.pB.scaling(r.scale,i),r.rotation){const{axis:e,angle:t}=n.Yu.toAxisAngle(r.rotation);n.pB.rotate(i,e,t,i)}null!=r.translation&&n.pB.setTranslation(i,r.translation,i)}n.pB.mul(e,i,i),null!=r.mesh&&(t.has(r.mesh)||t.set(r.mesh,[]),t.get(r.mesh).push(i)),r.children?.forEach(U(i,t))};async function G(e,t,r,s,l=M,u={},c=console.log){c("starting import");const f=Date.now(),m=await(0,i.H)(e,a.B);c("finished loading: "+(Date.now()-f));const{scene:d}=(0,o.R)(m);if(null==d?.nodes)return u;c("finished processing: "+(Date.now()-f));const p=new Map;d.nodes.forEach(U(n.pB.identity(),p)),c("finished creating instances: "+(Date.now()-f));const h=Array.from(p.entries()).flatMap((([{primitives:e},n])=>e.map((e=>v(0,e,n,r,t))))),g=await Promise.all(h);c("finished creating primitives: "+(Date.now()-f));const b=new Map,y={};for(const{material:e,drawData:r}of g){if(null==r)continue;const n={materialId:e?.id,features:r.features};b.has(n)||b.set(n,[]),b.get(n).push(r),null!=e&&(y[e.id]=C(e,s,t))}const w=Object.entries(y).map((async([e,t])=>[e,await t])),x=Object.fromEntries(await Promise.all(w));c("finished creating material descriptors: "+(Date.now()-f));const T={...s,metallicFactor:0};for(const[{features:e,materialId:n},i]of b.entries()){const a=null!=n?x[n]:T,o=new F(a,t,r,e,i),{features:s}=o;u[s]??=new E(s,r),u[s].addMaterials(o)}return c("finished: "+(Date.now()-f)),u}},3936:(e,t,r)=>{r.d(t,{Lr:()=>n});r(2323);function n(e,t,r,n,i=4){const a=i-1,o=r.createBuffer({label:n,usage:t,size:e.byteLength+a&~a,mappedAtCreation:!0}),s=new Uint8Array(o.getMappedRange()),l=e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength);return s.set(l),o.unmap(),o}},4883:(e,t,r)=>{r.d(t,{u:()=>a,y:()=>o});var n=r(1485),i=r(2965);async function a({device:e,data:t,mimeType:r,usage:n=GPUTextureUsage.TEXTURE_BINDING,mips:a=!0,format:o="rgba8unorm",colorSpace:s="srgb",label:l="",srgbToLinear:u}){let c;if(t instanceof ImageBitmap)c=t;else{const e=t instanceof Blob||t instanceof File?t:new Blob([t],{type:r});c=await createImageBitmap(e,{colorSpaceConversion:"none"})}const f={width:c.width,height:c.height},m=e.createTexture({label:l,format:o,size:f,usage:n|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:a?1+(0|Math.log2(Math.max(c.width,c.height))):1});return e.queue.copyExternalImageToTexture({source:c},{texture:m,colorSpace:s},f),u&&(0,i.sP)(e,m),a&&(0,i.fF)(e,m),m}function o(e){const t=new TextDecoder,r=e instanceof Uint8Array?e:new Uint8Array(e);let i=0;const a=(e=1024)=>{const n=Math.min(r.length,e+i),a=r.subarray(i,n),o=a.indexOf(10)+1;return i+=o,0===o?void 0:t.decode(a.subarray(0,o))},o=e=>new Error("HDR Import Error: "+e),s=a();if(null==s)throw o("no header found");if(!/^#\?(\S+)/.test(s))throw o("bad initial token");const l=new RegExp(`^\\s*(${[/FORMAT=(?<format>\S+)/,/-Y\s+(?<Y>\d+)\s+\+X\s+(?<X>\d+)/,/EXPOSURE\s*=\s*(?<exposure>\d+(\.\d+)?)/,/GAMMA\s*=\s*(?<gamma>\d+(\.\d+)?)/].map((({source:e})=>`(${e})`)).join("|")})\\s*$`);let u,c,f,m=!0,d=1,p=1;for(let e=a();null!=e;e=null==u?a():void 0){const t=e.match(l)?.groups;null!=t&&(null!=t.format?m=!1:null!=t.X&&null!=t.Y?(u=parseInt(t.X),c=parseInt(t.Y)):null!=t.gamma?d=parseFloat(t.gamma):null!=t.exposure&&(p=parseFloat(t.exposure)))}if(m)throw o("missing format specifier");if(null==u||null==c)throw o("missing image size specifier");const h=u<8||u>32767,g=2!==r[i]||2!==r[i+1]||!!(128&r[i+2]);if(h||g)f=r.subarray(i);else{f=new Uint8Array(u*c*4);const e=4*u,t=new Uint8Array(e),n=r.byteLength;for(let a=0,s=0;a<c&&i<n;a++){if(i+4>n)throw o("file ended durning scanline");if(2!=r[i++]||2!=r[i++]||(r[i++]<<8|r[i++])!=u)throw o("bad rgbe scanline format");let a;for(let s=0;s<e&&i<n;s+=a){a=r[i++];const n=a>128;if(n&&(a-=128),0==a||s+a>e)throw o("bad scanline data");n?(t.fill(r[i],s,s+a),i+=1):(t.set(r.subarray(i,i+a),s),i+=a)}for(let r=0;r<u;r++)for(let n=0;n<e;n+=u)f[s++]=t[r+n]}}const b=new Uint16Array(f.length),v=(0,n.Q)(1);for(let e=0;e<u*c*4;e+=4){const t=f[e+3],r=Math.pow(2,t-128)/255;for(let t=0;t<3;t+=1)b[e+t]=(0,n.Q)(Math.min(f[e+t]*r,65504));b[e+3]=v}return{data:b,width:u,height:c,gamma:d,exposure:p}}},2965:(e,t,r)=>{r.d(t,{fF:()=>l,l3:()=>s,sP:()=>u});var n=r(4581),i=r(5753),a=r(3936),o=r(2349);async function s(e,{data:t,width:r,height:s,gamma:l=1,exposure:u=1},c){const f=`\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${n.A}\n        ${i.V}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;let m,d=0;t instanceof GPUTexture?m=t:(d=1,m=e.createTexture({label:`${c.label} equirectangular`,dimension:"2d",format:"rgba16float",size:{width:r,height:s},usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING}),e.queue.writeTexture({texture:m,mipLevel:0},t,{bytesPerRow:2*r*4},{width:r,height:s,depthOrArrayLayers:1}),await e.queue.onSubmittedWorkDone());const p=m.height>>1,h=c;h.mipLevelCount??=0|Math.log2(p),h.size={width:p,height:p,depthOrArrayLayers:6},h.dimension="2d",h.usage|=GPUTextureUsage.RENDER_ATTACHMENT;const g=e.createTexture(h),b=o.OY`hdr copy${c.label}`,v=e.createBindGroupLayout({label:b,entries:[{binding:0,texture:{},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT},{binding:2,buffer:{},visibility:GPUShaderStage.FRAGMENT}]}),y=e.createShaderModule({label:b,code:f}),w=e.createSampler({label:b,minFilter:"linear",magFilter:"linear"}),x=new Uint32Array(1),T=(0,a.Lr)(x,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,e,b),O=e.createBindGroup({label:b,layout:v,entries:[{binding:0,resource:m.createView()},{binding:1,resource:w},{binding:2,resource:{buffer:T}}]}),P=e.createPipelineLayout({label:b,bindGroupLayouts:[v]}),S=e.createRenderPipeline({label:b,layout:P,vertex:{module:y},fragment:{module:y,targets:[{format:g.format}],constants:{GAMMA:l,EXPOSURE:u,FLIP_Y:d}}});for(let t=0;t<6;t+=1){x[0]=t,e.queue.writeBuffer(T,0,x,0,1);const r=g.createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:t,mipLevelCount:1}),n=e.createCommandEncoder(),i=n.beginRenderPass({label:b,colorAttachments:[{view:r,loadOp:"clear",storeOp:"store"}]});i.setPipeline(S),i.setBindGroup(0,O),i.draw(3),i.end(),e.queue.submit([n.finish()])}return g}async function l(e,t){const r=`\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${n.A}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `,i=o.OY`mip generation${t.label}`,a=e.createBindGroupLayout({label:i,entries:[{binding:0,texture:{viewDimension:"2d",sampleType:"float"},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT}]}),s={view:void 0,loadOp:"clear",storeOp:"store"},l=e.createSampler({minFilter:"linear",magFilter:"linear"}),u=e.createShaderModule({label:i,code:r}),c=e.createPipelineLayout({label:i,bindGroupLayouts:[a]}),f=e.createRenderPipeline({label:i,layout:c,vertex:{entryPoint:"vs",module:u},fragment:{entryPoint:"fs",targets:[{format:t.format}],module:u}});s.view=t.createView({mipLevelCount:1,baseMipLevel:0}),await e.queue.onSubmittedWorkDone();for(let r=1;r<t.mipLevelCount;r+=1){const n=e.createBindGroup({label:i,layout:a,entries:[{binding:0,resource:s.view},{binding:1,resource:l}]});s.view=t.createView({mipLevelCount:1,baseMipLevel:r});const o=e.createCommandEncoder(),u=o.beginRenderPass({label:i,colorAttachments:[s]});u.setPipeline(f),u.setBindGroup(0,n),u.draw(3),u.end(),e.queue.submit([o.finish()]),await e.queue.onSubmittedWorkDone()}}function u(e,t){const r=`\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${n.A}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `,i=o.OY`srgb to linear${t.label}`,a={width:t.width,height:t.height},s=e.createTexture({format:t.format,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING,size:a}),l=e.createBindGroupLayout({label:i,entries:[{binding:0,texture:{},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT}]}),u=e.createSampler({minFilter:"linear",magFilter:"linear"}),c=e.createShaderModule({label:i,code:r}),f=e.createPipelineLayout({label:i,bindGroupLayouts:[l]}),m=e.createRenderPipeline({label:i,layout:f,vertex:{entryPoint:"vs",module:c},fragment:{entryPoint:"fs",targets:[{format:t.format}],module:c}}),d=e.createBindGroup({label:i,layout:l,entries:[{binding:0,resource:s.createView()},{binding:1,resource:u}]}),p=e.createCommandEncoder();p.copyTextureToTexture({texture:t},{texture:s},a);const h=p.beginRenderPass({label:i,colorAttachments:[{view:t.createView({mipLevelCount:1,baseMipLevel:0}),loadOp:"clear",storeOp:"store"}]});h.setPipeline(m),h.setBindGroup(0,d),h.draw(3),h.end(),e.queue.submit([p.finish()])}},2349:(e,t,r)=>{function n(e,t){const r=Object.entries(e).map((([e,r])=>[e,t(r)]));return Object.fromEntries(r)}function i(e,t,r){return Math.max(t,Math.min(r,e))}function a(e,...t){const r=[e[0]];return t.forEach(((t,n)=>{return r.push(null==(i=t)||""===i?"":` ${i}`,e[n+1]);var i})),r.join("")}function o(e,t){return function(e){return[...Array(e).keys()]}(e).map(t)}function s(e,t){let r;return function(...n){const i=self;null!=r&&clearTimeout(r),r=setTimeout((()=>{e.apply(i,n)}),t)}}function l(e,t,r,n=0,i=e.length-1){if(i-n<=1)r(t,e[n]??t)<0?e.splice(n,0,t):r(t,e[i]??t)>0?e.splice(i+1,0,t):e.splice(i,0,t);else{const a=Math.floor((i-n)/2)+n;r(t,e[a])<0?l(e,t,r,n,a):l(e,t,r,a,i)}}function u(e){return"object"==typeof e&&null!=e}r.d(t,{Gv:()=>u,LG:()=>n,OY:()=>a,_b:()=>o,nn:()=>l,qE:()=>i,sg:()=>s})}}]);
//# sourceMappingURL=446.bundle.js.map