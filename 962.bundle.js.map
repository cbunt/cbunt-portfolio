{"version":3,"file":"962.bundle.js","mappings":";4KAEO,MAAMA,EAAY,CACrBC,YAAa,GACbC,cAAe,GAAKC,aAAaC,mBAGxBC,EAAiE,CAE1E,CAAC,OAA0B,UAC3B,CAAC,OAA0B,UAC3B,CAAC,OAAyB,SAC1B,CAAC,OAAyB,SAE1B,CAAC,OAA0B,UAC3B,CAAC,OAA0B,UAC3B,CAAC,OAA4B,WAC7B,CAAC,OAA4B,WAC7B,CAAC,OAA4B,WAC7B,CAAC,OAA2B,UAC5B,CAAC,OAA2B,UAE5B,CAAC,OAA0B,UAC3B,CAAC,OAA0B,UAC3B,CAAC,OAA4B,WAC7B,CAAC,OAA6B,WAC9B,CAAC,OAA6B,WAC9B,CAAC,OAA+B,YAChC,CAAC,OAAgC,aACjC,CAAC,OAA+B,kBAChC,CAAC,OAAgC,aACjC,CAAC,OAA+B,YAChC,CAAC,OAA+B,YAChC,CAAC,OAAgC,aACjC,CAAC,OAA+B,kBAEhC,CAAC,OAAwC,eACzC,CAAC,OAAyC,cAC1C,CAAC,OAA0C,eAC3C,CAAC,OAAyC,gBAE1C,CAAC,OAA6B,WAC9B,CAAC,OAA6B,WAC9B,CAAC,OAA+B,YAChC,CAAC,OAAmC,aACpC,CAAC,OAAmC,aACpC,CAAC,OAAqC,cAEtC,CAAC,OAAmC,aACpC,CAAC,OAAmC,aACpC,CAAC,OAAqC,cAGtC,CAAC,OAAsC,iBACvC,CAAC,OAAqC,sBACtC,CAAC,OAAiC,iBAClC,CAAC,OAAgC,sBACjC,CAAC,OAAiC,iBAClC,CAAC,OAAgC,sBACjC,CAAC,OAAiC,cAClC,CAAC,OAAiC,cAClC,CAAC,OAAiC,eAClC,CAAC,OAAiC,eAClC,CAAC,OAAmC,kBACpC,CAAC,OAAmC,iBACpC,CAAC,OAAiC,iBAClC,CAAC,OAAgC,uBA6CxBC,EAAiE,CAE1EC,QAAS,EACTC,QAAS,EACTC,OAAQ,EACRC,OAAQ,EAERC,QAAS,EACTC,QAAS,EACTC,SAAU,EACVC,SAAU,EACVC,SAAU,EACVC,QAAS,EACTC,QAAS,EAETC,QAAS,EACTC,QAAS,EACTC,SAAU,EACVC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,WAAY,EACZ,kBAAmB,EACnBC,WAAY,EACZC,UAAW,EACXC,UAAW,EACXC,WAAY,EACZ,kBAAmB,EAEnBC,aAAc,EACdC,YAAa,EACbC,aAAc,EACdC,cAAe,EAEfC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,WAAY,EACZC,WAAY,EACZC,YAAa,EAEbC,WAAY,GACZC,WAAY,GACZC,YAAa,IAGJC,EAAwE,CAEjFnC,QAAS,EACTC,QAAS,EACTC,OAAQ,EACRC,OAAQ,EAERC,QAAS,EACTC,QAAS,EACTC,SAAU,EACVC,SAAU,EACVC,SAAU,EACVC,QAAS,EACTC,QAAS,EAETC,QAAS,EACTC,QAAS,EACTC,SAAU,EACVC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,WAAY,EACZ,kBAAmB,EACnBC,WAAY,EACZC,UAAW,EACXC,UAAW,EACXC,WAAY,EACZ,kBAAmB,EAEnBC,aAAc,EACdC,YAAa,EACbC,aAAc,EACdC,cAAe,EAEfC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,WAAY,EACZC,WAAY,EACZC,YAAa,EAEbC,WAAY,EACZC,WAAY,EACZC,YAAa,GAGJE,EAAmBC,OAAOC,YACnCD,OAAOE,QAAQzC,GAAkB0C,KAAI,EAAEC,EAAIC,KAAU,CAACA,EAAMC,SAASF,EAAI,+KCjMxEG,6SAAL,SAAKA,GAAY,mBAAM,mBAAM,kBAAM,CAAnC,CAAKA,IAAAA,EAAS,KAEd,MAAqBC,EA+CjB,WAAAC,CAAmBC,GAAA,KAAAA,SAAAA,EA1CnB,KAAAC,MAAmBJ,EAAUK,KAEpB,YAAY,OAAiB,CAClCC,cAAe,CACX,CAAC,IAAaC,OAAQ,WACtB,CAAC,IAAaC,WAAaC,IACJ,kBAARA,IAAmBC,KAAKP,SAASQ,WAAWC,iBAAmBH,EAAG,EAEjFI,OAAO,EACPC,YAAa,2CAEjBC,SAAU,CACN,CAAC,IAAaR,OAAQ,SACtB,CAAC,IAAaC,WAAaK,IACF,iBAAVA,IAAoBH,KAAKP,SAASQ,WAAWI,SAAWF,EAAK,EAE5EA,MAAO,EACPG,IAAK,EACLC,IAAK,EACLC,KAAM,GACNJ,YAAa,kHAEjBK,eAAgB,CACZ,CAAC,IAAaZ,OAAQ,SACtB,CAAC,IAAaC,WAAYE,KAAKU,OAAOC,KAAKX,MAC3CG,MAAO,EACPI,IAAK,GACLD,IAAK,EACLE,KAAM,GACNJ,YAAa,sCAEjBQ,QAAQ,OAAiBZ,MACzB,kBAAmB,CACf,CAAC,IAAaH,OAAQ,SACtBgB,QAAS,KAAab,KAAKc,UAAU,MAIpC,KAAAC,SAAW,EAAAf,KAAI,OAAWgB,eAC1B,KAAAC,SAAW,EAIhBxB,EAASyB,eAAelB,MACxBA,KAAKmB,OAAS1B,EAAS0B,MAC3B,CAEA,SAAAC,CAAUR,GACNZ,KAAKY,OAASA,EACd,EAAAZ,KAAI,OAAWqB,gBAAgBhB,SAASE,IAAMP,KAAKY,OAAOU,cAAgB,EAC1E,EAAAtB,KAAI,OAAWqB,gBAAgBhB,SAASF,MAAQ,EAChDH,KAAKP,SAASQ,WAAWI,SAAW,EAEpCL,KAAKuB,UACAvB,KAAKU,QACd,CAEA,OAAAc,GACIxB,KAAKuB,UACL,MAAME,EAAYzB,KAAKN,MACvBM,KAAKN,MAAQJ,EAAUK,KACnB8B,IAAcnC,EAAUoC,MAAW1B,KAAKU,QAChD,CAEA,YAAMA,GACiB,MAAfV,KAAKY,QAAkBZ,KAAKN,QAAUJ,EAAUoC,OAEhD1B,KAAKN,QAAUJ,EAAUqC,MAK7B3B,KAAKN,MAAQJ,EAAUqC,WAEjB,OAAuB,CACzBR,OAAQnB,KAAKP,SAAS0B,OACtBS,QAAS5B,KAAKY,OACdiB,MAAO7B,KAAKe,SAASN,eAAeN,MACpC2B,SAAS,EACTC,UAAWC,wBAGfhC,KAAKwB,WAdDxB,KAAKN,MAAQJ,EAAUoC,KAe/B,CAEA,OAAAH,GACuB,MAAfvB,KAAKY,SACTZ,KAAKP,SAASQ,WAAWgC,WAAajC,KAAKY,OAAOsB,WAAW,CAAEC,UAAW,SAC9E,CAEA,cAAMrB,GACF,GAAmB,MAAfd,KAAKY,OACT,IACI,MAAMwB,EAAQC,QAAQC,IAAI,EACtB,QAAatC,KAAKP,SAAS0B,OAAQnB,KAAKY,QAAQ,GAC3C2B,MAAMC,GAAS,IAAIC,KAAK,CAACD,GAAO,CAAEE,KAAM,kBAC7C,QAAmB,CACfC,MAAO,CAAC,CAAEC,OAAQ,CAAE,aAAc,CAAC,YACnCC,cAAe,wBAChBN,MAAMO,GAAWA,EAAOC,eAAe,CAAEC,kBAAkB,SAG3DC,EAAMC,SAAgBd,QACvBa,EAAKC,SAASC,OAAOD,EAC/B,CAAE,MAAOE,GACLC,QAAQC,KAAKF,EACjB,CACJ,CAEA,MAAAG,EAAO,QAAEC,EAAO,QAAEC,IACdD,EAAQE,gBAAgB,CACpBC,iBAAkB,GAClBC,uBAAwB,CACpBC,gBAAiB,EACjBC,YAAa,QACbC,aAAc,QACdC,KAAMP,EAAQQ,MAAMD,QAEzBE,KACP,gBA3HO,EAAAC,MAAQ,GACR,EAAA/D,YAAc,sGCLzB,MAAMgE,EAAkB,UAElBC,EAAoB,CACtBC,EACAC,IACW,SACT,YACA,kRAa4CA,kHAKnBD,ssDA8IhBE,eAAeC,GAAuB,OACjDtD,EAAM,QACNS,EAAO,mBACP8C,EAAkB,QAClB5C,GAAU,EAAK,SACf6C,EAAW,EAAC,MACZ9C,EAAQ,EAAC,cACT+C,EAAgBR,EAAe,MAC/BS,EAAQJ,EAAuBK,KAAI,UACnC/C,IAEA,MAAM,MAAEgD,EAAK,OAAER,GAAW3C,EACpBN,EAAgBQ,EAChBF,EAAQN,cACP0D,KAAKC,KAAKF,GAASC,KAAKC,KAAKN,GAAY,EAEhD,GAAIrD,GAAiB,EAAG,OAAOM,EAE/B,MAAM0C,EAASU,KAAK1E,IAChBa,EAAO+D,OAAOC,yBACdhE,EAAO+D,OAAOE,mCAGZC,EAASlE,EAAOmE,mBAAmB,CACrCT,QACAU,KAAMlB,EAAkBC,EAAQC,KAG9BiB,EAAkBrE,EAAOsE,sBAAsB,CACjDZ,QACA5F,QAAS,CACL,CACIyG,QAAS,EACT9D,QAAS,CAAE+D,cAAe,YAC1BC,WAAYC,eAAeC,SAE/B,CACIJ,QAAS,EACTK,eAAgB,CACZC,OAAQ,aACRL,cAAe,WACfpB,UAEJqB,WAAYC,eAAeC,SAE/B,CACIJ,QAAS,EACTO,OAAQ,CAAEvD,KAAM,qBAChBkD,WAAYC,eAAeC,YAKjCI,EAAW/E,EAAOgF,sBAAsB,CAC1CtB,QACAuB,OAAQjF,EAAOkF,qBAAqB,CAChCxB,QACAyB,iBAAkB,CAACd,KAEvBe,QAAS,CACLC,OAAQnB,EACRoB,WAAY,OACZC,UAAW,CAAEC,MAAO3B,KAAK4B,KAAK/E,OAItC,IAAIgF,EAAkBjF,EACtB,IAAKE,EAAS,CACV,MAAMgF,EAAO,CAAE/B,QAAOgC,OAAQhC,EAAOiC,mBAAoB,GAEzDH,EAAkB1F,EAAO8F,cAAc,CACnCpC,MAAOH,EACPwC,MAAOC,gBAAgBC,gBACjBD,gBAAgBE,gBAChBF,gBAAgBG,SAChBH,gBAAgBI,SACtBpF,UAAW,KACXoC,SACAjD,gBACAwF,SAGJ,MAAMU,EAAcrG,EAAOsG,qBAAqB,CAC5C5C,MAAO,GAAGA,mBAGd2C,EAAYE,qBACR,CAAE9F,UAASvB,SAAU,GACrB,CAAEuB,QAASiF,EAAiBxG,SAAU,GACtCyG,GAGJ3F,EAAOwG,MAAMC,OAAO,CAACJ,EAAYK,iBAC3B1G,EAAOwG,MAAMG,qBACvB,CAEA,MAAMC,GAAW,QAASzG,GAAgB0G,GAAMnB,EAAgB3E,WAAW,CACvE2C,MAAO,GAAGA,cAAkBmD,IAC5B7F,UAAW,WACX8F,aAAcD,EACd1G,cAAe,MAGb4G,EAAgB/G,EAAO+D,OAAOiD,iCAC9BC,EAAYpD,KAAK4B,KAAK5B,KAAKC,KAAKF,IAChCsD,EAAgBrD,KAAKzE,IACtBqE,IAAmB,EAAa,EAAR/C,IAAe,EAAKyC,GAAW,EACxD,GAGEgE,EAAgB,IAAIC,YAA8B,GAAjBH,EAAY,IAC7CI,EAAS,IAAIC,YAAYH,EAAe,EAAG,GAClC,IAAIhM,aAAagM,EAAe,EAAGF,GAE3CM,KAAI,QAASN,GAAYJ,IAC5B,MAAMW,EAAI5D,GAASiD,EACnB,OAAOhD,KAAK4D,KAAK,EA3MzB,SAAyB/G,EAAekD,GAQpC,MAAM8D,EAAe9D,GAAS,EACxB+D,EAAQD,EAAe7D,KAAK+D,MAAMlH,EAAQ,GAAK,EAC/CmH,EAAU,EAAIH,GAAiBC,EAAQ,IAAO,EAC9CG,EAAU,EAAIJ,EAAgB,EAC9BK,EAAW,EAAIF,EAASA,EAASC,EAASA,EAG1CE,EAAU,EAAIpE,GADN,EAAIA,EAAiB,EAAR+D,EAAajH,EAAQ,EACV,IAAO,EACvCuH,EAAW,EAAIrE,EAAS,EACxBsE,EAAY,EAAIF,EAASA,EAASC,EAAUA,EAC5CE,EAAW,EAAIvE,EAAS,EACxBwE,EAAY,EAAIJ,EAASA,EAASG,EAAUA,EAE5CE,GAAQL,EAASH,EAASI,EAAUH,GACpCjE,KAAKyE,KAAKJ,EAAYH,GAEtBQ,GAAQP,EAASH,EAASM,EAAUL,GACpCjE,KAAKyE,KAAKF,EAAYL,GAE5B,OAAOlE,KAAK1E,IAAI,EAAIkJ,EAAM,EAAIE,EAClC,CA+K6BC,CAAgB3E,KAAK1E,IAAIqI,EAAG9G,GAAQ8G,IAAM,CAAC,KAGpE,MAAMiB,GAAiB,QACnBtB,EACAuB,eAAeC,QAAUD,eAAetC,SACxCpG,GAGJ,IAKI4I,EALA1J,EAAW,EACX2J,EAAY,EACZC,EAAwB,EACxBC,EAAuB,EACvBC,EAAkB,EAsEtB,aAnEA3F,eAAe4F,IACX,GAAIF,GAAwBD,EAAuB,CAK/C,GAJA5J,GAAY,EACZ6J,EAAuB,EACvBF,EAAY,EAER3J,GAAYiB,EACZ,OAGJ,MAAM+I,EAAY,GAAMtF,GAAS1E,IAAa,EAC9C4J,EAAwBjF,KAAK4B,KAAKyD,EAAY/F,GAE9CyF,EAAY5I,EAAOmJ,gBAAgB,CAC/BlE,OAAQZ,EACRvG,QAAS,CACL,CACIyG,QAAS,EACT6E,SAAUxC,EAAS1H,EAAW,IAElC,CACIqF,QAAS,EACT6E,SAAUxC,EAAS1H,IAEvB,CACIqF,QAAS,EACT6E,SAAU,CAAEtE,OAAQ2D,MAIpC,CAEApB,EAAO,GAAK0B,EAAuB5F,EACnCnD,EAAOwG,MAAM6C,YAAYZ,EAAgB,EAAGpB,GAE5C,MAAMiC,EAAiBzF,KAAK1E,IACxB2J,EAAwBC,EACxB7B,EAAgB8B,EAChBjC,GAGEwC,EAAY,GAAG7F,SAAaxE,WAAkB2J,IAC9CxG,EAAUrC,EAAOsG,qBAAqB,CAAE5C,MAAO6F,IAC/CC,EAAOnH,EAAQoH,iBAAiB,CAAE/F,MAAO6F,IAE/CC,EAAKE,YAAY3E,GACjByE,EAAKG,aAAa,EAAGf,GACrBY,EAAKI,mBAAmBN,EAAgB,EAAG,GAC3CE,EAAKzG,MAEL/C,EAAOwG,MAAMC,OAAO,CAACpE,EAAQqE,WAE7BqC,GAAwBO,EACxBN,GAAmBM,EACnBT,GAAa,EAEI,MAAbjI,GAAqBoI,GAAmB9B,GACxC8B,EAAkB,QACZhJ,EAAOwG,MAAMG,sBACnB/F,EAAUqI,UAEJA,GAEd,CAEMA,GAECvD,CACX,6FCrXA,MAAMmE,QAAoBC,MAAM,sGAAgB,CAAEC,QAAS,CAAE,eAAgB,wCACxE3I,MAAM4I,GAAQA,EAAIC,SAEVC,EAAOtM,OAAOC,YAAYgM,EAAYM,SAAQ,EAAGxG,OAAMyG,kBAAmC,iBAATzG,GAA6C,iBAAjByG,GAA6BA,EAAaC,SAAS,QAAU,CAAC,CAAC1G,EAAMyG,IAAiB,MAEhN/G,eAAeiH,EAActK,EAAmBuK,GAC5C,IAAIzF,EACJ,GAAIyF,aAAgBnD,YAChBtC,EAASyF,OACN,GAAIA,aAAgBC,KACvB1F,QAAeyF,EAAKE,kBACjB,CACH,MAAMT,QAAYF,MAAMS,GACxBzF,QAAekF,EAAIS,aACvB,CAEA,MAAMC,GAAM,OAAS5F,GAErB,OAAO,QACH9E,EACA0K,EACA,CACItH,OAAQ,cACR2C,MAAOC,gBAAgBE,gBAAkBF,gBAAgBC,gBAAkBD,gBAAgBG,UAGvG,CAIe,SAASwE,EAAiBC,GACrC,MAAO,CACH,CAAC,IAAalM,OAAQ,OACtB,CAAC,IAAaC,WAAY0E,MAAOzE,EAAciM,KAC3C,GAAY,UAARA,GAA0B,MAAPjM,IACJ,iBAARA,GAAoBA,aAAe4L,MAAM,CAChD,MAAM/J,QAAgB6J,EAAcM,EAAO5K,OAAQpB,GAC7CoL,EAAMY,EAAO3K,UAAUQ,GACzBuJ,aAAe9I,eAAe8I,CACtC,GAEJvI,OAAQ,OACRqJ,UAAW,CACP9L,MAAOpB,OAAOmN,KAAKb,GAAM,GACzBc,cAAed,GAEnBe,QAAUV,GAAeA,EAEjC,0DCpDA,QAAyB,ifCAlB,MAAMW,EAA+B,6mCAqC/BC,EAA6C,izJChCnD,SAASC,EACZC,EACAtF,EACA/F,EACA0D,EACA4H,EAAY,GAEZ,MAAMC,EAAMD,EAAY,EAClBxG,EAAS9E,EAAOwL,aAAa,CAC/B9H,QACAqC,QACAJ,KAAO0F,EAAII,WAAaF,GAAQA,EAChCG,kBAAkB,IAGhBC,EAAa,IAAIC,WAAW9G,EAAO+G,kBACnCC,EAAYT,aAAejE,YAC3B,IAAIwE,WAAWP,GACf,IAAIO,WAAWP,EAAIvG,OAAQuG,EAAIU,WAAYV,EAAII,YAKrD,OAHAE,EAAWpE,IAAIuE,GACfhH,EAAOkH,QAEAlH,CACX,CAoDOzB,eAAe4I,GAAqB,OACvCjM,EAAM,QACNS,EAAO,SACPvB,EAAW,EAAC,aACZgN,EAAY,cACZC,EAAa,aACbC,EAAY,YACZnN,IAEA,MAAMoN,EAAY,KAAoB5L,EAAQ2C,QACxCkJ,EAAkB,IAAW,gBAAgBrN,GAAe,KAAKwB,EAAQiD,YAE/E,GAAiB,MAAb2I,EACA,MAAM,IAAIE,MAAM,GAAGD,YAA0B7L,EAAQ2C,sBAGzD,MAAMQ,EAAQnD,EAAQmD,OAAS1E,EACzB0G,EAASnF,EAAQmF,QAAU1G,EAC3BsN,EAAiB5I,EAAQyI,EACzBI,EAAc5I,KAAKzE,IAAIoN,EAAgB,KACvCE,EAAe9G,EACf+G,EAAWD,EAAeD,EAAchM,EAAQoF,mBAChD+G,EAAaJ,EAAiB5G,EAASnF,EAAQoF,mBAErD,GAAoB,MAAhBuG,GAAwBA,EAAaX,WAAakB,EAClD,MAAM,IAAIJ,MAAM,GAAGD,2CACzBF,EAAaX,gBAAgBkB,KAG3B,GAAqB,MAAjBR,GAAyBA,EAAcxG,KAAOgH,EAC9C,MAAM,IAAIJ,MAAM,GAAGD,6CACzBH,EAAcxG,UAAUgH,KAGtB,MAAME,EAAgBnE,eAAetC,SAAWsC,eAAeoE,SAE/D,GAAqB,MAAjBX,IAA0BA,EAAcpG,MAAQ8G,KAAmBA,EACnE,MAAM,IAAIN,MAAM,GAAGD,8DAClBH,EAAcpG,oBACX8G,KAGR,IAAIE,EAAYX,GAAgB,IAAIR,WAAWe,GAC/C,MAAMK,EAAUb,GAAiBnM,EAAOwL,aAAa,CACjD9H,MAAO,GAAG4I,mBACV3G,KAAMgH,EACN5G,MAAO8G,IAGLxK,EAAUrC,EAAOsG,qBAAqB,CAAE5C,MAAO,GAAG4I,cACxDjK,EAAQ4K,oBACJ,CAAExM,UAASvB,YACX,CAAE4F,OAAQkI,EAASN,eAAcD,eACjC,CAAE7I,QAAOgC,SAAQC,mBAAoBpF,EAAQoF,qBAEjD7F,EAAOwG,MAAMC,OAAO,CAACpE,EAAQqE,iBAEvBxF,QAAQC,IAAI,CACd6L,EAAQE,SAASC,WAAWC,KAAM,EAAGT,GACrC3M,EAAOwG,MAAMG,wBAGjB,MAAM0G,EAASL,EAAQnB,eAAe,EAAGc,GAIzC,GAHAI,EAAUxF,IAAI,IAAIqE,WAAWyB,IAC7BL,EAAQhB,QAEJS,EAAcD,EAAgB,CAC9B,IAAK,IAAIc,EAAI,EAAGA,EAAI1H,EAASnF,EAAQoF,mBAAoByH,GAAK,EAC1D,IAAK,IAAI9F,EAAI,EAAGA,EAAIgF,EAAgBhF,GAAK,EACrCuF,EAAUvF,EAAI8F,EAAId,GAAkBO,EAAUvF,EAAI8F,EAAIb,GAG9DM,EAAYA,EAAUQ,MAAM,EAAGX,EACnC,CAEA,MAAO,CACHG,YACAZ,cAAeD,EAAec,OAAUQ,EAEhD,CAEOnK,eAAeoK,EAAazN,EAAmBS,EAAqBiN,GAAO,GAC9E,MAAMrB,EAAY,KAAoB5L,EAAQ2C,QACxCuK,EAAW,KAA2BlN,EAAQ2C,QAEpD,GAAiB,MAAbiJ,GAAiC,MAAZsB,EACrB,MAAM,IAAIpB,MAAM,0BAA0B9L,EAAQ2C,aAAa3C,EAAQiD,qBAG3E,MAAMkK,EAAY,IAAI,MACtBA,EAAUC,WAAapN,EAAQmD,MAC/BgK,EAAUE,YAAcrN,EAAQmF,OAChCgI,EAAUG,SAAW,KAAiBtN,EAAQ2C,QAC9CwK,EAAUD,SAAWA,SACdC,EAAUI,SAASC,WAE1B,MAAMC,EAAaN,EAAUO,qBAAqB,GAclD,GAbAD,EAAWE,WAAa,MACxBF,EAAWG,iBAAmB,MAC9BH,EAAWI,WAAW,GAAKjC,EAE3B6B,EAAWK,SAAU,QAAS,GAAI1H,IAAM,CACpC2H,YAAa,CAAC,IAAK,IAAK,IAAK,KAAK3H,GAClC4H,eAAgB,CAAC,EAAG,EAAG,EAAG,GAC1BC,UAAgC,EAArBd,EAAUD,SAAe,EACpCgB,UAAgC,EAArBf,EAAUD,SAAe9G,EACpC+H,aAAc,WACdC,YAAa,eAGS,OAAtBpO,EAAQO,UACR4M,EAAUkB,UAAY,EACtBlB,EAAUmB,WAAatO,EAAQoF,wBAC5B,GAAI6H,EAAM,CACb,MAAMsB,EAAavO,EAAQoF,mBAAqB,EAChD+H,EAAUqB,WAA4B,IAAfD,EAAmB,EAAIA,EAC9CpB,EAAUkB,UAAY,CAC1B,MACIlB,EAAUqB,WAAaxO,EAAQoF,mBAC/B+H,EAAUkB,UAAY,EAG1B,IAAI3C,EACAY,EAEJ,IAAK,IAAIlG,EAAI,EAAGA,EAAIpG,EAAQN,cAAe0G,GAAK,IACzCkG,YAAWZ,uBAAwBF,EAAqB,CACvD/M,SAAU2H,EACVqF,cAAc,EACdlM,SACAS,UACA0L,mBAGJyB,EAAUsB,OAAOC,KAAK,CAClBC,UAAWrC,EACXsC,uBAAwBtC,EAAUtB,aAI1C,OAAO,MAAemC,EAC1B,mCC9NA,MAAM,UAAE0B,EAAS,WAAEC,GAAe,MAC9B,MAAMD,EAAY,IAAIhI,YAAY,KAC5BiI,EAAa,IAAIjI,YAAY,KAEnC,IAAK,IAAIT,EAAI,EAAGA,EAAI,MAAOA,EAAG,CAC1B,MAAM5E,EAAI4E,EAAI,IACV5E,GAAK,IACLqN,EAAUzI,GAAK,EACf0I,EAAW1I,GAAK,IACT5E,GAAK,IACZqN,EAAUzI,GAAK,OAAY5E,EAAI,GAC/BsN,EAAW1I,IAAM5E,EAAI,GACdA,GAAK,IACZqN,EAAUzI,GAAM5E,EAAI,IAAO,GAC3BsN,EAAW1I,GAAK,KAEhByI,EAAUzI,GAAK,MACf0I,EAAW1I,GAAK,GAExB,CAMA,OAHAyI,EAAU,KAAO,MACjBC,EAAW,KAAO,GAEX,CAAED,YAAWC,aACvB,EA1BiC,GA4B5BC,EAAmB,IAAIpI,YAAY,GACnCqI,EAAY,IAAItU,aAAaqU,GAC7BE,EAAW,IAAIpI,YAAYkI,GAE1B,SAASG,EAAe/Q,GAC3B6Q,EAAU,GAAK7Q,EACf,MAAMgR,EAAOF,EAAS,GAChBG,EAAYD,GAAQ,GAAM,IAC1BE,EAAiB,IAAXD,EAENE,GAAkB,QAAPH,IAAsBL,EAAWO,GAGlD,QAFyB,IAAXD,IAAqB,GAErBP,EAAUQ,GAAOC,CACnC,SCiBO,SAASC,EAASC,GACrB,MAAMC,EAAU,IAAIC,YACdrL,EAASmL,aAAkBrE,WAAaqE,EAAS,IAAIrE,WAAWqE,GACtE,IAAIG,EAAM,EAEV,MAAMC,EAAU,CAACC,EAAY,QACzB,MAAMC,EAAQ1M,KAAK1E,IAAI2F,EAAO0L,OAAQF,EAAYF,GAC5CK,EAAM3L,EAAO4L,SAASN,EAAKG,GAC3BxN,EAAM0N,EAAIE,QAAQ,IAAQ,EAEhC,OADAP,GAAOrN,EACQ,IAARA,OAAYyK,EAAY0C,EAAQU,OAAOH,EAAIC,SAAS,EAAG3N,GAAK,EAGjE8N,EAAeC,GAAgB,IAAIvE,MAAM,qBAAuBuE,GAIhEC,EAAiBV,IAEvB,GAAsB,MAAlBU,EAAwB,MAAMF,EAAY,mBAC9C,IAJwB,YAIHG,KAAKD,GAAiB,MAAMF,EAAY,qBAE7D,MAOMI,EAAY,IAAIC,OAAO,SAPV,CACf,wBACA,mCACA,0CACA,qCAIWnT,KAAI,EAAGoT,YAAa,IAAIA,OAAWC,KAAK,cAGvD,IAGIxN,EACAgC,EAuBAyL,EA3BAC,GAAW,EACXC,EAAQ,EACRC,EAAW,EAIf,IAAK,IAAIC,EAAOpB,IAAmB,MAARoB,EAAcA,EAAgB,MAAT7N,EAAgByM,SAAY7C,EAAW,CACnF,MAAMrK,EAASsO,EAAKC,MAAMT,IAAY9N,OACxB,MAAVA,IAEiB,MAAjBA,EAAOC,OACPkO,GAAW,EACQ,MAAZnO,EAAOwO,GAAyB,MAAZxO,EAAOyO,GAClChO,EAAQ1F,SAASiF,EAAOwO,GACxB/L,EAAS1H,SAASiF,EAAOyO,IACF,MAAhBzO,EAAOoO,MACdA,EAAQM,WAAW1O,EAAOoO,OACA,MAAnBpO,EAAOqO,WACdA,EAAWK,WAAW1O,EAAOqO,WAErC,CAEA,GAAIF,EAAU,MAAMT,EAAY,4BAChC,GAAa,MAATjN,GAA2B,MAAVgC,EAAgB,MAAMiL,EAAY,gCAKvD,MAAMiB,EAAclO,EAAQ,GAAKA,EAAQ,MACnCmO,EAA2B,IAAhBjN,EAAOsL,IAAkC,IAApBtL,EAAOsL,EAAM,OAA+B,IAAlBtL,EAAOsL,EAAM,IAE7E,GAAI0B,GAAeC,EACfV,EAAUvM,EAAO4L,SAASN,OACvB,CACHiB,EAAU,IAAIzF,WAAWhI,EAAQgC,EAAS,GAC1C,MAAM7C,EAAM,EAAIa,EACVoO,EAAkB,IAAIpG,WAAW7I,GACjCkP,EAAMnN,EAAO2G,WAEnB,IAAK,IAAIyG,EAAI,EAAG7K,EAAS,EAAG6K,EAAItM,GAAUwK,EAAM6B,EAAKC,IAAK,CACtD,GAAI9B,EAAM,EAAI6B,EACV,MAAMpB,EAAY,+BAEtB,GAAK,GAAK/L,EAAOsL,MAAY,GAAKtL,EAAOsL,OAActL,EAAOsL,MAAU,EAAKtL,EAAOsL,OAAWxM,EAC3F,MAAMiN,EAAY,4BAEtB,IAAIsB,EACJ,IAAK,IAAIC,EAAM,EAAGA,EAAMrP,GAAOqN,EAAM6B,EAAKG,GAAOD,EAAO,CACpDA,EAAQrN,EAAOsL,KACf,MAAMiC,EAAeF,EAAQ,IAG7B,GAFIE,IAAcF,GAAS,KAEd,GAATA,GAAcC,EAAMD,EAAQpP,EAC5B,MAAM8N,EAAY,qBAElBwB,GACAL,EAAgBM,KAAKxN,EAAOsL,GAAMgC,EAAKA,EAAMD,GAC7C/B,GAAO,IAEP4B,EAAgBzK,IAAIzC,EAAO4L,SAASN,EAAKA,EAAM+B,GAAQC,GACvDhC,GAAO+B,EAEf,CAEA,IAAK,IAAItL,EAAI,EAAGA,EAAIjD,EAAOiD,IACvB,IAAK,IAAI0L,EAAI,EAAGA,EAAIxP,EAAKwP,GAAK3O,EAC1ByN,EAAQhK,KAAY2K,EAAgBnL,EAAI0L,EACpD,CACJ,CAIA,MAAMC,EAAO,IAAIC,YAAYpB,EAAQb,QAC/BkC,EAAa/C,EAAe,GAElC,IAAK,IAAI9I,EAAI,EAAGA,EAAIjD,EAAQgC,EAAS,EAAGiB,GAAK,EAAG,CAC5C,MAAM8L,EAAQtB,EAAQxK,EAAI,GACpB+L,EAAQ/O,KAAKgP,IAAI,EAAKF,EAAQ,KAAS,IAE7C,IAAK,IAAIJ,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACxBC,EAAK3L,EAAI0L,GAAK5C,EAAe9L,KAAK1E,IAAIkS,EAAQxK,EAAI0L,GAAKK,EAAO,QAElEJ,EAAK3L,EAAI,GAAK6L,CAClB,CAGA,MAAO,CAAEF,OAAM5O,QAAOgC,SAAQ2L,QAAOC,WACzC,gFCtKOnO,eAAeyP,EAClB9S,GACA,KAAEwS,EAAI,MAAE5O,EAAK,OAAEgC,EAAM,MAAE2L,EAAQ,EAAC,SAAEC,EAAW,GAC7CuB,GAEA,MAAM3O,EAAkB,sjBAkBlB,gBACA,8iBAgBN,IACI4O,EADAC,EAAS,EAETT,aAAgBU,WAChBF,EAAkBR,GAElBS,EAAS,EACTD,EAAkBhT,EAAO8F,cAAc,CACnCpC,MAAO,GAAGqP,EAAiBrP,wBAC3B1C,UAAW,KACXoC,OAAQ,cACRuC,KAAM,CAAE/B,QAAOgC,UACfG,MAAOC,gBAAgBI,SAAWJ,gBAAgBE,kBAGtDlG,EAAOwG,MAAM2M,aACT,CAAE1S,QAASuS,EAAiB9T,SAAU,GACtCsT,EACA,CAAE/F,YAAqB,EAAR7I,EAAY,GAC3B,CAAEA,QAAOgC,SAAQC,mBAAoB,UAEnC7F,EAAOwG,MAAMG,uBAGvB,MAAMyM,EAAWJ,EAAgBpN,QAAU,EACrCyN,EAAoBN,EAC1BM,EAAkBlT,gBAAwC,EAAtB0D,KAAKC,KAAKsP,GAC9CC,EAAkB1N,KAAO,CAAE/B,MAAOwP,EAAUxN,OAAQwN,EAAUvN,mBAAoB,GAClFwN,EAAkBrS,UAAY,KAC9BqS,EAAkBtN,OAASC,gBAAgBsN,kBAC3C,MAAMC,EAAUvT,EAAO8F,cAAcuN,GAE/B3P,EAAQ,IAAW,WAAWqP,EAAiBrP,QAC/CW,EAAkBrE,EAAOsE,sBAAsB,CACjDZ,QACA5F,QAAS,CACL,CACIyG,QAAS,EACT9D,QAAS,CAAC,EACVgE,WAAYC,eAAe8O,UAE/B,CACIjP,QAAS,EACTkP,QAAS,CAAC,EACVhP,WAAYC,eAAe8O,UAE/B,CACIjP,QAAS,EACTO,OAAQ,CAAC,EACTL,WAAYC,eAAe8O,aAKjCnO,EAASrF,EAAOmE,mBAAmB,CAAET,QAAOU,SAC5CqP,EAAUzT,EAAO0T,cAAc,CAAEhQ,QAAOiQ,UAAW,SAAUC,UAAW,WACxEC,EAAS,IAAIvM,YAAY,GACzBwM,GAAc,QAAoBD,EAAQnL,eAAetC,SAAWsC,eAAeqL,QAAS/T,EAAQ0D,GAEpGkF,EAAY5I,EAAOmJ,gBAAgB,CACrCzF,QACAuB,OAAQZ,EACRvG,QAAS,CACL,CAAEyG,QAAS,EAAG6E,SAAU4J,EAAgBjS,cACxC,CAAEwD,QAAS,EAAG6E,SAAUqK,GACxB,CAAElP,QAAS,EAAG6E,SAAU,CAAEtE,OAAQgP,OAIpCE,EAAiBhU,EAAOkF,qBAAqB,CAC/CxB,QACAyB,iBAAkB,CAACd,KAGjBU,EAAW/E,EAAOiU,qBAAqB,CACzCvQ,QACAuB,OAAQ+O,EACRE,OAAQ,CAAE7O,UACV8O,SAAU,CACN9O,SACA+O,QAAS,CAAC,CAAEhR,OAAQmQ,EAAQnQ,SAC5BmC,UAAW,CACP8O,MAAO9C,EACP+C,SAAU9C,EACVyB,aAKZ,IAAK,IAAIpM,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC3BgN,EAAO,GAAKhN,EACZ7G,EAAOwG,MAAM6C,YAAYyK,EAAa,EAAGD,EAAQ,EAAG,GAEpD,MAAMhR,EAAO0Q,EAAQxS,WAAW,CAC5BC,UAAW,KACXuT,gBAAiB,EACjBC,eAAgB3N,EAChB1G,cAAe,IAGbkC,EAAUrC,EAAOsG,uBACjBkD,EAAOnH,EAAQE,gBAAgB,CACjCmB,QACAlB,iBAAkB,CAAC,CACfK,OACA4R,OAAQ,QACRC,QAAS,YAIjBlL,EAAKE,YAAY3E,GACjByE,EAAKG,aAAa,EAAGf,GACrBY,EAAKmL,KAAK,GACVnL,EAAKzG,MACL/C,EAAOwG,MAAMC,OAAO,CAACpE,EAAQqE,UACjC,CAEA,OAAO6M,CACX","sources":["webpack://cbunt-portfolio/./src/rendering/core/constants.ts","webpack://cbunt-portfolio/./src/rendering/samples/cubemap-blur/cubemap-blur-sample.ts","webpack://cbunt-portfolio/./src/rendering/samples/cubemap-blur/cubemap-guassian-pyramid.ts","webpack://cbunt-portfolio/./src/rendering/samples/settings/skybox-options.ts","webpack://cbunt-portfolio/./src/rendering/shaders/blit-vert.shader.ts","webpack://cbunt-portfolio/./src/rendering/shaders/cubemap-sampling.shader.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-copy.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-conversion.ts","webpack://cbunt-portfolio/./src/rendering/utils/texture-importing.ts","webpack://cbunt-portfolio/./src/rendering/utils/texture-processing.ts"],"sourcesContent":["import * as ktxp from 'ktx-parse';\r\n\r\nexport const TypeSizes = {\r\n    mat4x4Count: 16,\r\n    sizeofMat4x4f: 16 * Float32Array.BYTES_PER_ELEMENT,\r\n};\r\n\r\nexport const VkFormatToWebGPU: Record<number, GPUTextureFormat | undefined> = {\r\n    // 8-bit formats\r\n    [ktxp.VK_FORMAT_R8_UNORM]: 'r8unorm',\r\n    [ktxp.VK_FORMAT_R8_SNORM]: 'r8snorm',\r\n    [ktxp.VK_FORMAT_R8_UINT]: 'r8uint',\r\n    [ktxp.VK_FORMAT_R8_SINT]: 'r8sint',\r\n    // 16-bit formats\r\n    [ktxp.VK_FORMAT_R16_UINT]: 'r16uint',\r\n    [ktxp.VK_FORMAT_R16_SINT]: 'r16sint',\r\n    [ktxp.VK_FORMAT_R16_SFLOAT]: 'r16float',\r\n    [ktxp.VK_FORMAT_R8G8_UNORM]: 'rg8unorm',\r\n    [ktxp.VK_FORMAT_R8G8_SNORM]: 'rg8snorm',\r\n    [ktxp.VK_FORMAT_R8G8_UINT]: 'rg8uint',\r\n    [ktxp.VK_FORMAT_R8G8_SINT]: 'rg8sint',\r\n    // 32-bit formats\r\n    [ktxp.VK_FORMAT_R32_UINT]: 'r32uint',\r\n    [ktxp.VK_FORMAT_R32_SINT]: 'r32sint',\r\n    [ktxp.VK_FORMAT_R32_SFLOAT]: 'r32float',\r\n    [ktxp.VK_FORMAT_R16G16_UINT]: 'rg16uint',\r\n    [ktxp.VK_FORMAT_R16G16_SINT]: 'rg16sint',\r\n    [ktxp.VK_FORMAT_R16G16_SFLOAT]: 'rg16float',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UNORM]: 'rgba8unorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SRGB]: 'rgba8unorm-srgb',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SNORM]: 'rgba8snorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UINT]: 'rgba8uint',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SINT]: 'rgba8sint',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_UNORM]: 'bgra8unorm',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_SRGB]: 'bgra8unorm-srgb',\r\n    // Packed 32-bit formats\r\n    [ktxp.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32]: 'rgb9e5ufloat',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UINT_PACK32]: 'rgb10a2uint',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UNORM_PACK32]: 'rgb10a2unorm',\r\n    [ktxp.VK_FORMAT_B10G11R11_UFLOAT_PACK32]: 'rg11b10ufloat',\r\n    // 64-bit formats\r\n    [ktxp.VK_FORMAT_R32G32_UINT]: 'rg32uint',\r\n    [ktxp.VK_FORMAT_R32G32_SINT]: 'rg32sint',\r\n    [ktxp.VK_FORMAT_R32G32_SFLOAT]: 'rg32float',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_UINT]: 'rgba16uint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SINT]: 'rgba16sint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SFLOAT]: 'rgba16float',\r\n    // 128-bit formats\r\n    [ktxp.VK_FORMAT_R32G32B32A32_UINT]: 'rgba32uint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SINT]: 'rgba32sint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SFLOAT]: 'rgba32float',\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    [ktxp.VK_FORMAT_BC1_RGBA_UNORM_BLOCK]: 'bc1-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC1_RGBA_SRGB_BLOCK]: 'bc1-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC2_UNORM_BLOCK]: 'bc2-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC2_SRGB_BLOCK]: 'bc2-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC3_UNORM_BLOCK]: 'bc3-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC3_SRGB_BLOCK]: 'bc3-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC4_UNORM_BLOCK]: 'bc4-r-unorm',\r\n    [ktxp.VK_FORMAT_BC4_SNORM_BLOCK]: 'bc4-r-snorm',\r\n    [ktxp.VK_FORMAT_BC5_UNORM_BLOCK]: 'bc5-rg-unorm',\r\n    [ktxp.VK_FORMAT_BC5_SNORM_BLOCK]: 'bc5-rg-snorm',\r\n    [ktxp.VK_FORMAT_BC6H_UFLOAT_BLOCK]: 'bc6h-rgb-ufloat',\r\n    [ktxp.VK_FORMAT_BC6H_SFLOAT_BLOCK]: 'bc6h-rgb-float',\r\n    [ktxp.VK_FORMAT_BC7_UNORM_BLOCK]: 'bc7-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC7_SRGB_BLOCK]: 'bc7-rgba-unorm-srgb',\r\n    // Currently unsupported extension formats:\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"etc2-rgb8unorm\",\r\n    // \"etc2-rgb8unorm-srgb\",\r\n    // \"etc2-rgb8a1unorm\",\r\n    // \"etc2-rgb8a1unorm-srgb\",\r\n    // \"etc2-rgba8unorm\",\r\n    // \"etc2-rgba8unorm-srgb\",\r\n    // \"eac-r11unorm\",\r\n    // \"eac-r11snorm\",\r\n    // \"eac-rg11unorm\",\r\n    // \"eac-rg11snorm\",\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"astc-4x4-unorm\",\r\n    // \"astc-4x4-unorm-srgb\",\r\n    // \"astc-5x4-unorm\",\r\n    // \"astc-5x4-unorm-srgb\",\r\n    // \"astc-5x5-unorm\",\r\n    // \"astc-5x5-unorm-srgb\",\r\n    // \"astc-6x5-unorm\",\r\n    // \"astc-6x5-unorm-srgb\",\r\n    // \"astc-6x6-unorm\",\r\n    // \"astc-6x6-unorm-srgb\",\r\n    // \"astc-8x5-unorm\",\r\n    // \"astc-8x5-unorm-srgb\",\r\n    // \"astc-8x6-unorm\",\r\n    // \"astc-8x6-unorm-srgb\",\r\n    // \"astc-8x8-unorm\",\r\n    // \"astc-8x8-unorm-srgb\",\r\n    // \"astc-10x5-unorm\",\r\n    // \"astc-10x5-unorm-srgb\",\r\n    // \"astc-10x6-unorm\",\r\n    // \"astc-10x6-unorm-srgb\",\r\n    // \"astc-10x8-unorm\",\r\n    // \"astc-10x8-unorm-srgb\",\r\n    // \"astc-10x10-unorm\",\r\n    // \"astc-10x10-unorm-srgb\",\r\n    // \"astc-12x10-unorm\",\r\n    // \"astc-12x10-unorm-srgb\",\r\n    // \"astc-12x12-unorm\",\r\n};\r\n\r\nexport const TextureFormatToSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 2,\r\n    rg8snorm: 2,\r\n    rg8uint: 2,\r\n    rg8sint: 2,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 4,\r\n    rg16sint: 4,\r\n    rg16float: 4,\r\n    rgba8unorm: 4,\r\n    'rgba8unorm-srgb': 4,\r\n    rgba8snorm: 4,\r\n    rgba8uint: 4,\r\n    rgba8sint: 4,\r\n    bgra8unorm: 4,\r\n    'bgra8unorm-srgb': 4,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 8,\r\n    rg32sint: 8,\r\n    rg32float: 8,\r\n    rgba16uint: 8,\r\n    rgba16sint: 8,\r\n    rgba16float: 8,\r\n    // 128-bit formats\r\n    rgba32uint: 16,\r\n    rgba32sint: 16,\r\n    rgba32float: 16,\r\n};\r\n\r\nexport const TextureFormatToChannelSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 1,\r\n    rg8snorm: 1,\r\n    rg8uint: 1,\r\n    rg8sint: 1,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 2,\r\n    rg16sint: 2,\r\n    rg16float: 2,\r\n    rgba8unorm: 1,\r\n    'rgba8unorm-srgb': 1,\r\n    rgba8snorm: 1,\r\n    rgba8uint: 1,\r\n    rgba8sint: 1,\r\n    bgra8unorm: 1,\r\n    'bgra8unorm-srgb': 1,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 4,\r\n    rg32sint: 4,\r\n    rg32float: 4,\r\n    rgba16uint: 2,\r\n    rgba16sint: 2,\r\n    rgba16float: 2,\r\n    // 128-bit formats\r\n    rgba32uint: 4,\r\n    rgba32sint: 4,\r\n    rgba32float: 4,\r\n};\r\n\r\nexport const WebGPUToVkFormat = Object.fromEntries(\r\n    Object.entries(VkFormatToWebGPU).map(([vk, wgpu]) => [wgpu, parseInt(vk, 10)]),\r\n) as Record<GPUTextureFormat, ktxp.VKFormat>;\r\n\r\nexport const textureTypeToDimension: Record<string, GPUTextureViewDimension> = {\r\n    texture_cube: 'cube',\r\n    texture_3d: '3d',\r\n    texture_2d: '2d',\r\n};\r\n","import { showSaveFilePicker } from 'native-file-system-adapter';\n\nimport getSkyboxOptions from '../settings/skybox-options';\nimport { FullRenderModel } from '../settings/sample-spec';\nimport propertyListener, { ListenerSyms } from '../settings/property-listener';\n\nimport { textureToKTX } from '../../utils/data-copy';\nimport Renderer, { ForwardPassParams } from '../../core/renderer';\n\nimport cubemapGuassianPyramid from './cubemap-guassian-pyramid';\n\nenum BlurState { IDLE, BLUR, WAIT }\n\nexport default class CubemapBlurModel implements FullRenderModel {\n    static title = '';\n    static description = '';\n\n    skybox?: GPUTexture;\n    state: BlurState = BlurState.IDLE;\n\n    readonly #settings = propertyListener({\n        nearestSample: {\n            [ListenerSyms.$type]: 'checkbox' as const,\n            [ListenerSyms.$callback]: (val: unknown) => {\n                if (typeof val === 'boolean') this.renderer.skyboxPass.useNearestSample = val;\n            },\n            value: false,\n            description: 'Disables linear sampling in the viewer.',\n        },\n        mipLevel: {\n            [ListenerSyms.$type]: 'slider' as const,\n            [ListenerSyms.$callback]: (value: unknown) => {\n                if (typeof value === 'number') this.renderer.skyboxPass.mipLevel = value;\n            },\n            value: 0,\n            min: 0,\n            max: 1,\n            step: 0.1,\n            description: 'The mip level to display in the viewer. 0 is the original image, max is completely blurred with 1 pixel faces.',\n        },\n        filterDistance: {\n            [ListenerSyms.$type]: 'slider' as const,\n            [ListenerSyms.$callback]: this.reblur.bind(this) as () => void,\n            value: 8,\n            max: 64,\n            min: 0,\n            step: 0.1,\n            description: 'The number of pixels to blur from.',\n        },\n        skybox: getSkyboxOptions(this),\n        'Download Result': {\n            [ListenerSyms.$type]: 'button' as const,\n            onClick: () => { void this.saveFile(); },\n        },\n    });\n\n    readonly settings = this.#settings.publicSettings;\n    readonly priority = 0;\n    device: GPUDevice;\n\n    constructor(public renderer: Renderer) {\n        renderer.addForwardPass(this);\n        this.device = renderer.device;\n    }\n\n    setSkybox(skybox: GPUTexture) {\n        this.skybox = skybox;\n        this.#settings.privateSettings.mipLevel.max = this.skybox.mipLevelCount - 1;\n        this.#settings.privateSettings.mipLevel.value = 1;\n        this.renderer.skyboxPass.mipLevel = 1;\n\n        this.refresh();\n        void this.reblur();\n    }\n\n    resolve() {\n        this.refresh();\n        const lastState = this.state;\n        this.state = BlurState.IDLE;\n        if (lastState === BlurState.WAIT) void this.reblur();\n    }\n\n    async reblur() {\n        if (this.skybox == null || this.state === BlurState.WAIT) return;\n\n        if (this.state === BlurState.BLUR) {\n            this.state = BlurState.WAIT;\n            return;\n        }\n\n        this.state = BlurState.BLUR;\n\n        await cubemapGuassianPyramid({\n            device: this.renderer.device,\n            texture: this.skybox,\n            steps: this.settings.filterDistance.value,\n            inPlace: true,\n            delayWork: requestAnimationFrame,\n        });\n\n        this.resolve();\n    }\n\n    refresh() {\n        if (this.skybox == null) return;\n        this.renderer.skyboxPass.skyTexture = this.skybox.createView({ dimension: 'cube' });\n    }\n\n    async saveFile() {\n        if (this.skybox == null) return;\n        try {\n            const proms = Promise.all([\n                textureToKTX(this.renderer.device, this.skybox, true)\n                    .then((ktx2) => new Blob([ktx2], { type: 'image/ktx2' })),\n                showSaveFilePicker({\n                    types: [{ accept: { 'image/ktx2': ['.ktx2'] } }],\n                    suggestedName: 'blurred-skybox.ktx2',\n                }).then((handle) => handle.createWritable({ keepExistingData: false })),\n            ]);\n\n            const [blob, stream] = await proms;\n            await blob.stream().pipeTo(stream);\n        } catch (e) {\n            console.warn(e);\n        }\n    }\n\n    render({ encoder, gbuffer }: ForwardPassParams) {\n        encoder.beginRenderPass({\n            colorAttachments: [],\n            depthStencilAttachment: {\n                depthClearValue: 1,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n                view: gbuffer.depth.view,\n            },\n        }).end();\n    }\n}\n","/* eslint @stylistic/max-len: \"error\" */\r\n\r\nimport {\r\n    toWorldDir,\r\n    cubemapSampleConversions,\r\n} from '../../shaders/cubemap-sampling.shader';\r\n\r\nimport { createAndCopyBuffer } from '../../utils/data-copy';\r\nimport { mapRange } from '../../../utils/general';\r\n\r\nconst DEFAULT_MAX_OPS = 6 * ((17 * 256) ** 2);\r\n\r\nconst createMipBlurCode = (\r\n    groups: number,\r\n    format: GPUTextureFormat,\r\n) => /* wgsl */`\r\n    ${cubemapSampleConversions}\r\n    ${toWorldDir}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    struct Params {\r\n        offset: u32,\r\n        sigmas: array<f32>,\r\n    }\r\n\r\n    @group(0) @binding(0) \r\n    var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    @group(0) @binding(2) \r\n    var<storage> params: Params;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + params.offset;\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = toWorldDir(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&params.sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = params.sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = toWorldDir(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\r\n\r\n/**\r\n *  the minimum angular distance between any pixel on a cubemap\r\n *  of the given face width and any pixel lying on a perimeter\r\n *  the given number of steps away\r\n */\r\nfunction minStepDistance(steps: number, width: number) {\r\n    // the angular distance\r\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\r\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\r\n\r\n    // It's likely possible to programmatically determine whether the\r\n    // destination pixel should be v = 0 or v = 1, but checking both works fine\r\n\r\n    const nextMipWidth = width >> 1;\r\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\r\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\r\n    const baseUN = (1 / nextMipWidth) - 1;\r\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\r\n\r\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\r\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\r\n    const samp0VN = (1 / width) - 1;\r\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\r\n    const samp1VN = (3 / width) - 1;\r\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\r\n\r\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN)\r\n        / Math.sqrt(samp0Mag2 * baseMag2);\r\n\r\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN)\r\n        / Math.sqrt(samp1Mag2 * baseMag2);\r\n\r\n    return Math.min(1 - dot0, 1 - dot1);\r\n}\r\n\r\nexport type GaussianPyramidDescriptor = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    /**\r\n     * If the pyramid should overwrite the existing mips\r\n     * of the given texture\r\n     *\r\n     * @defaultValue `false`\r\n     */\r\n    inPlace?: boolean,\r\n    /**\r\n     * The maximum width of the smallest mip level.\r\n     *\r\n     * @defaultValue `8`\r\n     */\r\n    minWidth?: number,\r\n    /**\r\n     * The kernel extent distance, in pixels.\r\n     *\r\n     * @defaultValue `4`\r\n     */\r\n    steps?: number,\r\n    /**\r\n     * A function to delay the processing of additional pixels,\r\n     * e.g. `requestAnimationFrame`. Spaces work to allow additional\r\n     * rendering and interactivity during heavy blurring workloads.\r\n     *\r\n     * If undefined, all pixels are processed at once.\r\n     */\r\n    delayWork?: (fn: () => Promise<void> | void) => void,\r\n    /**\r\n     * The maximum number of pixels to process within a batch.\r\n     * Unused if `delayWork` is undefined.\r\n     *\r\n     * @defaultValue 6 * ((17 * 256) ** 2)\r\n     *\r\n     * @remarks\r\n     * Allowing cubemap 256 pixels in width with `steps = 8` to run\r\n     * in a single pass. This is a conservatively low default for\r\n     * compatibility with lower-end hardware.\r\n     */\r\n    maxOpsPerPass?: number,\r\n    /**\r\n     * A prefix string for error message thrown from the function\r\n     *\r\n     * @defaultValue `cubemapGuassianPyramid --`\r\n     */\r\n    label?: string,\r\n    /**\r\n     * The label to pass the output GPUTexture.\r\n     *\r\n     * @remarks\r\n     * Unused if `inPlace == true`\r\n     */\r\n    outputTextureLabel?: string,\r\n};\r\n\r\nexport default async function cubemapGuassianPyramid({\r\n    device,\r\n    texture,\r\n    outputTextureLabel,\r\n    inPlace = false,\r\n    minWidth = 8,\r\n    steps = 4,\r\n    maxOpsPerPass = DEFAULT_MAX_OPS,\r\n    label = cubemapGuassianPyramid.name,\r\n    delayWork,\r\n}: GaussianPyramidDescriptor) {\r\n    const { width, format } = texture;\r\n    const mipLevelCount = inPlace\r\n        ? texture.mipLevelCount\r\n        : (Math.log2(width) - Math.log2(minWidth) + 1);\r\n\r\n    if (mipLevelCount <= 1) return texture;\r\n\r\n    const groups = Math.min(\r\n        device.limits.maxComputeWorkgroupSizeX,\r\n        device.limits.maxComputeInvocationsPerWorkgroup,\r\n    );\r\n\r\n    const shader = device.createShaderModule({\r\n        label,\r\n        code: createMipBlurCode(groups, format),\r\n    });\r\n\r\n    const bindgroupLayout = device.createBindGroupLayout({\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                texture: { viewDimension: '2d-array' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 1,\r\n                storageTexture: {\r\n                    access: 'write-only',\r\n                    viewDimension: '2d-array',\r\n                    format,\r\n                },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 2,\r\n                buffer: { type: 'read-only-storage' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n        ],\r\n    });\r\n\r\n    const pipeline = device.createComputePipeline({\r\n        label,\r\n        layout: device.createPipelineLayout({\r\n            label,\r\n            bindGroupLayouts: [bindgroupLayout],\r\n        }),\r\n        compute: {\r\n            module: shader,\r\n            entryPoint: 'main',\r\n            constants: { STEPS: Math.ceil(steps) },\r\n        },\r\n    });\r\n\r\n    let gaussianPyramid = texture;\r\n    if (!inPlace) {\r\n        const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n        gaussianPyramid = device.createTexture({\r\n            label: outputTextureLabel,\r\n            usage: GPUTextureUsage.STORAGE_BINDING\r\n                | GPUTextureUsage.TEXTURE_BINDING\r\n                | GPUTextureUsage.COPY_SRC\r\n                | GPUTextureUsage.COPY_DST,\r\n            dimension: '2d',\r\n            format,\r\n            mipLevelCount,\r\n            size,\r\n        });\r\n\r\n        const copyEncoder = device.createCommandEncoder({\r\n            label: `${label} copy encoder`,\r\n        });\r\n\r\n        copyEncoder.copyTextureToTexture(\r\n            { texture, mipLevel: 0 },\r\n            { texture: gaussianPyramid, mipLevel: 0 },\r\n            size,\r\n        );\r\n\r\n        device.queue.submit([copyEncoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n\r\n    const mipViews = mapRange(mipLevelCount, (i) => gaussianPyramid.createView({\r\n        label: `${label} mip view ${i}`,\r\n        dimension: '2d-array',\r\n        baseMipLevel: i,\r\n        mipLevelCount: 1,\r\n    }));\r\n\r\n    const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\r\n    const maxLayers = Math.ceil(Math.log2(width));\r\n    const maxDispatches = Math.max(\r\n        (maxOpsPerPass / (((1 + (steps * 2)) ** 2) * groups)) | 0,\r\n        1,\r\n    );\r\n\r\n    const propertyArray = new ArrayBuffer((maxLayers + 1) * 4);\r\n    const offset = new Uint32Array(propertyArray, 0, 1);\r\n    const simgas = new Float32Array(propertyArray, 4, maxLayers);\r\n\r\n    simgas.set(mapRange(maxLayers, (i) => {\r\n        const w = width >> i;\r\n        return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\r\n    }));\r\n\r\n    const propertyBuffer = createAndCopyBuffer(\r\n        propertyArray,\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        device,\r\n    );\r\n\r\n    let mipLevel = 0;\r\n    let mipPasses = 0;\r\n    let requiredMipDispatches = 0;\r\n    let currentMipDispatches = 0;\r\n    let batchDispatches = 0;\r\n    let bindgroup: GPUBindGroup;\r\n\r\n    async function runPass() {\r\n        if (currentMipDispatches >= requiredMipDispatches) {\r\n            mipLevel += 1;\r\n            currentMipDispatches = 0;\r\n            mipPasses = 0;\r\n\r\n            if (mipLevel >= mipLevelCount) {\r\n                return;\r\n            }\r\n\r\n            const mipPixels = 6 * ((width >> mipLevel) ** 2);\r\n            requiredMipDispatches = Math.ceil(mipPixels / groups);\r\n\r\n            bindgroup = device.createBindGroup({\r\n                layout: bindgroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: mipViews[mipLevel - 1],\r\n                    },\r\n                    {\r\n                        binding: 1,\r\n                        resource: mipViews[mipLevel],\r\n                    },\r\n                    {\r\n                        binding: 2,\r\n                        resource: { buffer: propertyBuffer },\r\n                    },\r\n                ],\r\n            });\r\n        }\r\n\r\n        offset[0] = currentMipDispatches * groups;\r\n        device.queue.writeBuffer(propertyBuffer, 0, offset);\r\n\r\n        const passDispatches = Math.min(\r\n            requiredMipDispatches - currentMipDispatches,\r\n            maxDispatches - batchDispatches,\r\n            maxWorkgroups,\r\n        );\r\n\r\n        const passLabel = `${label} mip ${mipLevel}, pass ${mipPasses}`;\r\n        const encoder = device.createCommandEncoder({ label: passLabel });\r\n        const pass = encoder.beginComputePass({ label: passLabel });\r\n\r\n        pass.setPipeline(pipeline);\r\n        pass.setBindGroup(0, bindgroup);\r\n        pass.dispatchWorkgroups(passDispatches, 1, 1);\r\n        pass.end();\r\n\r\n        device.queue.submit([encoder.finish()]);\r\n\r\n        currentMipDispatches += passDispatches;\r\n        batchDispatches += passDispatches;\r\n        mipPasses += 1;\r\n\r\n        if (delayWork != null && batchDispatches >= maxDispatches) {\r\n            batchDispatches = 0;\r\n            await device.queue.onSubmittedWorkDone();\r\n            delayWork(runPass);\r\n        } else {\r\n            await runPass();\r\n        }\r\n    }\r\n\r\n    await runPass();\r\n\r\n    return gaussianPyramid;\r\n}\r\n","import { parseHDR } from '../../utils/texture-importing';\nimport { equirectangularToCubemap } from '../../utils/texture-processing';\nimport { ListenerSyms } from './property-listener';\n\nconst hdrPromises = await fetch(HDR_BASE_URL__, { headers: { 'Content-Type': 'application/vnd.github.object+json' } })\n    .then((res) => res.json()) as Record<string, unknown>[];\n\nexport const hdrs = Object.fromEntries(hdrPromises.flatMap(({ name, download_url }) => typeof name === 'string' && typeof download_url === 'string' && download_url.endsWith('.hdr') ? [[name, download_url]] : []));\n\nasync function processSkybox(device: GPUDevice, file: string | URL | File | ArrayBuffer) {\n    let buffer: ArrayBuffer;\n    if (file instanceof ArrayBuffer) {\n        buffer = file;\n    } else if (file instanceof File) {\n        buffer = await file.arrayBuffer();\n    } else {\n        const res = await fetch(file);\n        buffer = await res.arrayBuffer();\n    }\n\n    const hdr = parseHDR(buffer);\n\n    return equirectangularToCubemap(\n        device,\n        hdr,\n        {\n            format: 'rgba16float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        },\n    );\n}\n\nexport type SkyboxTarget = { device: GPUDevice, setSkybox: (resource: GPUTexture) => unknown };\n\nexport default function getSkyboxOptions(target: SkyboxTarget) {\n    return {\n        [ListenerSyms.$type]: 'file' as const,\n        [ListenerSyms.$callback]: async (val: unknown, key: PropertyKey) => {\n            if (key !== 'value' || val == null) return;\n            if (typeof val === 'string' || val instanceof File) {\n                const texture = await processSkybox(target.device, val);\n                const res = target.setSkybox(texture);\n                if (res instanceof Promise) await res;\n            }\n        },\n        accept: '.hdr',\n        selection: {\n            value: Object.keys(hdrs)[0],\n            initialValues: hdrs,\n        },\n        process: (file: File) => file,\n    };\n}\n","export default /* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`;\r\n","export const toWorldDir: string = /* wgsl */`\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nexport const cubemapSampleConversions: string = /* wgsl */`\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n","import * as ktxparse from 'ktx-parse';\r\n\r\nimport { TextureFormatToSize, TextureFormatToChannelSize, WebGPUToVkFormat } from '../core/constants';\r\nimport { mapRange, padTemplate } from '../../utils/general';\r\n\r\nexport function createAndCopyBuffer(\r\n    arr: ArrayBuffer | ArrayBufferView,\r\n    usage: GPUFlagsConstant,\r\n    device: GPUDevice,\r\n    label?: string,\r\n    alignment = 4,\r\n): GPUBuffer {\r\n    const pad = alignment - 1;\r\n    const buffer = device.createBuffer({\r\n        label,\r\n        usage,\r\n        size: (arr.byteLength + pad) & ~pad,\r\n        mappedAtCreation: true,\r\n    } as GPUBufferDescriptor);\r\n\r\n    const writeArray = new Uint8Array(buffer.getMappedRange());\r\n    const readArray = arr instanceof ArrayBuffer\r\n        ? new Uint8Array(arr)\r\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n\r\n    writeArray.set(readArray);\r\n    buffer.unmap();\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function createAndCopyCubemap(\r\n    device: GPUDevice,\r\n    data: ArrayBuffer,\r\n    format: GPUTextureFormat,\r\n    usage: number,\r\n    label?: string,\r\n) {\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\r\n    }\r\n\r\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\r\n    const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n    const texture = device.createTexture({\r\n        usage: usage | GPUTextureUsage.COPY_DST,\r\n        label,\r\n        format,\r\n        size,\r\n    });\r\n\r\n    device.queue.writeTexture(\r\n        { texture },\r\n        data,\r\n        { bytesPerRow: width * pixelSize, rowsPerImage: width },\r\n        size,\r\n    );\r\n\r\n    return texture;\r\n}\r\n\r\nexport type TextureToArrayBufferOptions = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    mipLevel?: number,\r\n    resultBuffer?: Uint8Array,\r\n    storageBuffer?: GPUBuffer,\r\n    returnBuffer?: boolean,\r\n    description?: string,\r\n};\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer?: false },\r\n): Promise<{ imageData: Uint8Array }>;\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer: true },\r\n): Promise<{ imageData: Uint8Array, storageBuffer: GPUBuffer }>;\r\n\r\nexport async function textureToArrayBuffer({\r\n    device,\r\n    texture,\r\n    mipLevel = 0,\r\n    returnBuffer,\r\n    storageBuffer,\r\n    resultBuffer,\r\n    description,\r\n}: TextureToArrayBufferOptions) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const fullDescription = padTemplate`[textureToKTX${description ?? ''}${texture.label}] --`;\r\n\r\n    if (pixelSize == null) {\r\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\r\n    }\r\n\r\n    const width = texture.width >> mipLevel;\r\n    const height = texture.height >> mipLevel;\r\n    const rawBytesPerRow = width * pixelSize;\r\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n    const rowsPerImage = height;\r\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\r\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\r\n\r\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\r\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\r\n    }\r\n\r\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\r\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\r\n    }\r\n\r\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\r\n\r\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\r\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\r\n    }\r\n\r\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\r\n    const storage = storageBuffer ?? device.createBuffer({\r\n        label: `${fullDescription} storage buffer`,\r\n        size: byteSize,\r\n        usage: requiredUsage,\r\n    });\r\n\r\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\r\n    encoder.copyTextureToBuffer(\r\n        { texture, mipLevel },\r\n        { buffer: storage, rowsPerImage, bytesPerRow },\r\n        { width, height, depthOrArrayLayers: texture.depthOrArrayLayers },\r\n    );\r\n    device.queue.submit([encoder.finish()]);\r\n\r\n    await Promise.all([\r\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\r\n        device.queue.onSubmittedWorkDone(),\r\n    ]);\r\n\r\n    const mapped = storage.getMappedRange(0, byteSize);\r\n    imageData.set(new Uint8Array(mapped));\r\n    storage.unmap();\r\n\r\n    if (bytesPerRow > rawBytesPerRow) {\r\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\r\n            }\r\n        }\r\n        imageData = imageData.slice(0, resultSize);\r\n    }\r\n\r\n    return {\r\n        imageData,\r\n        storageBuffer: returnBuffer ? storage : undefined,\r\n    };\r\n}\r\n\r\nexport async function textureToKTX(device: GPUDevice, texture: GPUTexture, cube = false) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const typeSize = TextureFormatToChannelSize[texture.format];\r\n\r\n    if (pixelSize == null || typeSize == null) {\r\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\r\n    }\r\n\r\n    const container = new ktxparse.KTX2Container();\r\n    container.pixelWidth = texture.width;\r\n    container.pixelHeight = texture.height;\r\n    container.vkFormat = WebGPUToVkFormat[texture.format];\r\n    container.typeSize = typeSize;\r\n    delete container.keyValue.KTXswizzle;\r\n\r\n    const dataFormat = container.dataFormatDescriptor[0];\r\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\r\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\r\n    dataFormat.bytesPlane[0] = pixelSize;\r\n\r\n    dataFormat.samples = mapRange(4, (i) => ({\r\n        channelType: [192, 193, 194, 207][i],\r\n        samplePosition: [0, 0, 0, 0],\r\n        bitLength: container.typeSize * 8 - 1,\r\n        bitOffset: container.typeSize * 8 * i,\r\n        sampleLower: -1082130432,\r\n        sampleUpper: 1065353216,\r\n    }));\r\n\r\n    if (texture.dimension === '3d') {\r\n        container.faceCount = 1;\r\n        container.pixelDepth = texture.depthOrArrayLayers;\r\n    } else if (cube) {\r\n        const cubeLayers = texture.depthOrArrayLayers / 6;\r\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\r\n        container.faceCount = 6;\r\n    } else {\r\n        container.layerCount = texture.depthOrArrayLayers;\r\n        container.faceCount = 1;\r\n    }\r\n\r\n    let storageBuffer: GPUBuffer | undefined;\r\n    let imageData: Uint8Array;\r\n\r\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\r\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\r\n            mipLevel: i,\r\n            returnBuffer: true,\r\n            device,\r\n            texture,\r\n            storageBuffer,\r\n        }));\r\n\r\n        container.levels.push({\r\n            levelData: imageData,\r\n            uncompressedByteLength: imageData.byteLength,\r\n        });\r\n    }\r\n\r\n    return ktxparse.write(container);\r\n}\r\n","const { baseTable, shiftTable } = (() => {\n    const baseTable = new Uint32Array(256);\n    const shiftTable = new Uint32Array(256);\n\n    for (let i = 0; i < 255; ++i) {\n        const e = i - 127;\n        if (e < -27) { // very small number (0, -0)\n            baseTable[i] = 0x0000;\n            shiftTable[i] = 24;\n        } else if (e < -14) { // small number (denorm)\n            baseTable[i] = 0x0400 >> (-e - 14);\n            shiftTable[i] = -e - 1;\n        } else if (e <= 15) { // normal number\n            baseTable[i] = (e + 15) << 10;\n            shiftTable[i] = 13;\n        } else { // e < 128, large number (Infinity, -Infinity)\n            baseTable[i] = 0x7c00;\n            shiftTable[i] = 24;\n        }\n    }\n\n    // e == 128, stay (NaN, Infinity, -Infinity)\n    baseTable[255] = 0x7c00;\n    shiftTable[255] = 13;\n\n    return { baseTable, shiftTable };\n})();\n\nconst conversionBuffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(conversionBuffer);\nconst uintView = new Uint32Array(conversionBuffer);\n\nexport function toFloat16Bytes(val: number) {\n    floatView[0] = val;\n    const bits = uintView[0];\n    const mantissa = (bits >> 23) & 0x1ff;\n    const idx = mantissa & 0xff;\n\n    const shifted = (bits & 0x007fffff) >> shiftTable[idx];\n    const sign = (mantissa & 0x100) << 7;\n\n    return sign + baseTable[idx] + shifted;\n}\n","import { toFloat16Bytes } from './data-conversion';\nimport { srgbTextureToLinear, generateMips } from './texture-processing';\n\nexport type imageToTextureDescriptor = {\n    device: GPUDevice,\n    data: Uint8Array | Blob | File | ImageBitmap,\n    mimeType?: string,\n    label?: string,\n    usage?: number,\n    format?: GPUTextureFormat,\n    mips?: boolean,\n    srgbToLinear?: boolean,\n    colorSpace?: PredefinedColorSpace,\n};\n\nexport async function imageToTexture({\n    device,\n    data,\n    mimeType,\n    usage = GPUTextureUsage.TEXTURE_BINDING,\n    mips = true,\n    format = 'rgba8unorm',\n    colorSpace = 'srgb',\n    label = '',\n    srgbToLinear,\n}: imageToTextureDescriptor) {\n    let bitmap: ImageBitmap;\n\n    if (data instanceof ImageBitmap) {\n        bitmap = data;\n    } else {\n        const blob = (data instanceof Blob || data instanceof File)\n            ? data\n            : new Blob([data], { type: mimeType });\n        bitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n    }\n\n    const size = { width: bitmap.width, height: bitmap.height };\n\n    const texture = device.createTexture({\n        label,\n        format,\n        size: size,\n        usage: usage | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: mips ? 1 + (Math.log2(Math.max(bitmap.width, bitmap.height)) | 0) : 1,\n    });\n\n    device.queue.copyExternalImageToTexture(\n        { source: bitmap },\n        { texture, colorSpace },\n        size,\n    );\n\n    if (srgbToLinear) srgbTextureToLinear(device, texture);\n    if (mips) void generateMips(device, texture);\n\n    return texture;\n}\n\nexport function parseHDR(inData: Uint8Array | ArrayBuffer) {\n    const decoder = new TextDecoder();\n    const buffer = inData instanceof Uint8Array ? inData : new Uint8Array(inData);\n    let pos = 0;\n\n    const getLine = (lineLimit = 1024) => {\n        const limit = Math.min(buffer.length, lineLimit + pos);\n        const sub = buffer.subarray(pos, limit);\n        const end = sub.indexOf(0x0A) + 1;\n        pos += end;\n        return end === 0 ? undefined : decoder.decode(sub.subarray(0, end));\n    };\n\n    const importError = (msg: string) => new Error('HDR Import Error: ' + msg);\n\n    // #region Read Header\n    const magicTokenRegex = /^#\\?(\\S+)/;\n    const magicTokenLine = getLine();\n\n    if (magicTokenLine == null) throw importError('no header found');\n    if (!magicTokenRegex.test(magicTokenLine)) throw importError('bad initial token');\n\n    const headerRegs = [\n        /FORMAT=(?<format>\\S+)/, // format\n        /-Y\\s+(?<Y>\\d+)\\s+\\+X\\s+(?<X>\\d+)/, // size\n        /EXPOSURE\\s*=\\s*(?<exposure>\\d+(\\.\\d+)?)/, // exposure\n        /GAMMA\\s*=\\s*(?<gamma>\\d+(\\.\\d+)?)/, // gamma\n    ];\n\n    const headerReg = new RegExp(`^\\\\s*(${\n        headerRegs.map(({ source }) => `(${source})`).join('|')\n    })\\\\s*$`);\n\n    let noFormat = true;\n    let gamma = 1; /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n    let exposure = 1; /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n    let width: number | undefined = undefined;\n    let height: number | undefined = undefined;\n\n    for (let line = getLine(); line != null; line = width == null ? getLine() : undefined) {\n        const groups = line.match(headerReg)?.groups as Partial<Record<string, string>> | undefined;\n        if (groups == null) continue;\n\n        if (groups.format != null) {\n            noFormat = false;\n        } else if (groups.X != null && groups.Y != null) {\n            width = parseInt(groups.X);\n            height = parseInt(groups.Y);\n        } else if (groups.gamma != null) {\n            gamma = parseFloat(groups.gamma);\n        } else if (groups.exposure != null) {\n            exposure = parseFloat(groups.exposure);\n        }\n    }\n\n    if (noFormat) throw importError('missing format specifier');\n    if (width == null || height == null) throw importError('missing image size specifier');\n    // #endregion\n\n    // #region Read Scanline Data\n    let rawData: Uint8Array;\n    const unencodable = width < 8 || width > 0x7fff;\n    const flatData = buffer[pos] !== 2 || buffer[pos + 1] !== 2 || (buffer[pos + 2] & 0x80) !== 0;\n\n    if (unencodable || flatData) {\n        rawData = buffer.subarray(pos);\n    } else {\n        rawData = new Uint8Array(width * height * 4);\n        const end = 4 * width;\n        const scanline_buffer = new Uint8Array(end);\n        const len = buffer.byteLength;\n\n        for (let k = 0, offset = 0; k < height && pos < len; k++) {\n            if (pos + 4 > len)\n                throw importError('file ended durning scanline');\n\n            if ((2 != buffer[pos++]) || (2 != buffer[pos++]) || (((buffer[pos++] << 8) | buffer[pos++]) != width))\n                throw importError('bad rgbe scanline format');\n\n            let count;\n            for (let ptr = 0; ptr < end && pos < len; ptr += count) {\n                count = buffer[pos++];\n                const isEncodedRun = count > 128;\n                if (isEncodedRun) count -= 128;\n\n                if (count == 0 || ptr + count > end)\n                    throw importError('bad scanline data');\n\n                if (isEncodedRun) {\n                    scanline_buffer.fill(buffer[pos], ptr, ptr + count);\n                    pos += 1;\n                } else {\n                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                    pos += count;\n                }\n            }\n\n            for (let i = 0; i < width; i++)\n                for (let j = 0; j < end; j += width)\n                    rawData[offset++] = scanline_buffer[i + j];\n        }\n    }\n    // #endregion\n\n    // #region Convert to Float16\n    const data = new Uint16Array(rawData.length);\n    const float16One = toFloat16Bytes(1);\n\n    for (let i = 0; i < width * height * 4; i += 4) {\n        const raw_e = rawData[i + 3];\n        const scale = Math.pow(2.0, raw_e - 128.0) / 255.0;\n\n        for (let j = 0; j < 3; j += 1) {\n            data[i + j] = toFloat16Bytes(Math.min(rawData[i + j] * scale, 65504));\n        }\n        data[i + 3] = float16One;\n    }\n    // #endregion\n\n    return { data, width, height, gamma, exposure };\n}\n","import blit from '../shaders/blit-vert.shader';\nimport { toWorldDir } from '../shaders/cubemap-sampling.shader';\nimport { createAndCopyBuffer } from './data-copy';\nimport { padTemplate } from '../../utils/general';\n\ntype EquirectangularDescriptor = {\n    data: SharedArrayBuffer | BufferSource | GPUTexture,\n    width: number,\n    height: number,\n    gamma?: number,\n    exposure?: number,\n};\n\nexport async function equirectangularToCubemap(\n    device: GPUDevice,\n    { data, width, height, gamma = 1, exposure = 1 }: EquirectangularDescriptor,\n    outputDescriptor: Omit<GPUTextureDescriptor, 'dimension' | 'size'>,\n) {\n    const code = /* wgsl */ `\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${blit}\n        ${toWorldDir}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;\n\n    let FLIP_Y = 0;\n    let equirectangular: GPUTexture;\n    if (data instanceof GPUTexture) {\n        equirectangular = data;\n    } else {\n        FLIP_Y = 1;\n        equirectangular = device.createTexture({\n            label: `${outputDescriptor.label} equirectangular`,\n            dimension: '2d',\n            format: 'rgba16float',\n            size: { width, height },\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        device.queue.writeTexture(\n            { texture: equirectangular, mipLevel: 0 },\n            data,\n            { bytesPerRow: width * 2 * 4 },\n            { width, height, depthOrArrayLayers: 1 },\n        );\n        await device.queue.onSubmittedWorkDone();\n    }\n\n    const faceSize = equirectangular.height >> 1;\n    const cubemapDescriptor = outputDescriptor as GPUTextureDescriptor;\n    cubemapDescriptor.mipLevelCount ??= Math.log2(faceSize) | 0;\n    cubemapDescriptor.size = { width: faceSize, height: faceSize, depthOrArrayLayers: 6 };\n    cubemapDescriptor.dimension = '2d';\n    cubemapDescriptor.usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    const cubemap = device.createTexture(cubemapDescriptor);\n\n    const label = padTemplate`hdr copy${outputDescriptor.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 2,\n                buffer: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const module = device.createShaderModule({ label, code });\n    const sampler = device.createSampler({ label, minFilter: 'linear', magFilter: 'linear' });\n    const params = new Uint32Array(1);\n    const paramBuffer = createAndCopyBuffer(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device, label);\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            { binding: 0, resource: equirectangular.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: paramBuffer } },\n        ],\n    });\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: { module },\n        fragment: {\n            module,\n            targets: [{ format: cubemap.format }],\n            constants: {\n                GAMMA: gamma,\n                EXPOSURE: exposure,\n                FLIP_Y,\n            },\n        },\n    });\n\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n\n        const view = cubemap.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n            mipLevelCount: 1,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [{\n                view,\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n\n    return cubemap;\n}\nexport async function generateMips(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${blit}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `;\n\n    const label = padTemplate`mip generation${texture.label}`;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d', sampleType: 'float' },\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const colorAttachment = {\n        view: undefined as GPUTextureView | undefined,\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: 0 });\n    await device.queue.onSubmittedWorkDone();\n\n    for (let i = 1; i < texture.mipLevelCount; i += 1) {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: colorAttachment.view,\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n\n        colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: i });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [colorAttachment as GPURenderPassColorAttachment],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n\n        device.queue.submit([encoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport function srgbTextureToLinear(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${blit}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `;\n\n    const label = padTemplate`srgb to linear${texture.label}`;\n\n    const size = { width: texture.width, height: texture.height };\n\n    const tempTexture = device.createTexture({\n        format: texture.format,\n        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        size,\n    });\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n\n    const module = device.createShaderModule({ label, code: code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: tempTexture.createView(),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n        ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n        { texture },\n        { texture: tempTexture },\n        size,\n    );\n\n    const pass = encoder.beginRenderPass({\n        label,\n        colorAttachments: [{\n            view: texture.createView({ mipLevelCount: 1, baseMipLevel: 0 }),\n            loadOp: 'clear',\n            storeOp: 'store',\n        }],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindgroup);\n    pass.draw(3);\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n}\n"],"names":["TypeSizes","mat4x4Count","sizeofMat4x4f","Float32Array","BYTES_PER_ELEMENT","VkFormatToWebGPU","TextureFormatToSize","r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","rgb9e5ufloat","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","TextureFormatToChannelSize","WebGPUToVkFormat","Object","fromEntries","entries","map","vk","wgpu","parseInt","BlurState","CubemapBlurModel","constructor","renderer","state","IDLE","nearestSample","$type","$callback","val","this","skyboxPass","useNearestSample","value","description","mipLevel","min","max","step","filterDistance","reblur","bind","skybox","onClick","saveFile","settings","publicSettings","priority","addForwardPass","device","setSkybox","privateSettings","mipLevelCount","refresh","resolve","lastState","WAIT","BLUR","texture","steps","inPlace","delayWork","requestAnimationFrame","skyTexture","createView","dimension","proms","Promise","all","then","ktx2","Blob","type","types","accept","suggestedName","handle","createWritable","keepExistingData","blob","stream","pipeTo","e","console","warn","render","encoder","gbuffer","beginRenderPass","colorAttachments","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","view","depth","end","title","DEFAULT_MAX_OPS","createMipBlurCode","groups","format","async","cubemapGuassianPyramid","outputTextureLabel","minWidth","maxOpsPerPass","label","name","width","Math","log2","limits","maxComputeWorkgroupSizeX","maxComputeInvocationsPerWorkgroup","shader","createShaderModule","code","bindgroupLayout","createBindGroupLayout","binding","viewDimension","visibility","GPUShaderStage","COMPUTE","storageTexture","access","buffer","pipeline","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","entryPoint","constants","STEPS","ceil","gaussianPyramid","size","height","depthOrArrayLayers","createTexture","usage","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","COPY_SRC","COPY_DST","copyEncoder","createCommandEncoder","copyTextureToTexture","queue","submit","finish","onSubmittedWorkDone","mipViews","i","baseMipLevel","maxWorkgroups","maxComputeWorkgroupsPerDimension","maxLayers","maxDispatches","propertyArray","ArrayBuffer","offset","Uint32Array","set","w","acos","nextMipWidth","baseV","floor","baseVN","baseUN","baseMag2","sampUN","samp0VN","samp0Mag2","samp1VN","samp1Mag2","dot0","sqrt","dot1","minStepDistance","propertyBuffer","GPUBufferUsage","STORAGE","bindgroup","mipPasses","requiredMipDispatches","currentMipDispatches","batchDispatches","runPass","mipPixels","createBindGroup","resource","writeBuffer","passDispatches","passLabel","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","hdrPromises","fetch","headers","res","json","hdrs","flatMap","download_url","endsWith","processSkybox","file","File","arrayBuffer","hdr","getSkyboxOptions","target","key","selection","keys","initialValues","process","toWorldDir","cubemapSampleConversions","createAndCopyBuffer","arr","alignment","pad","createBuffer","byteLength","mappedAtCreation","writeArray","Uint8Array","getMappedRange","readArray","byteOffset","unmap","textureToArrayBuffer","returnBuffer","storageBuffer","resultBuffer","pixelSize","fullDescription","Error","rawBytesPerRow","bytesPerRow","rowsPerImage","byteSize","resultSize","requiredUsage","MAP_READ","imageData","storage","copyTextureToBuffer","mapAsync","GPUMapMode","READ","mapped","h","slice","undefined","textureToKTX","cube","typeSize","container","pixelWidth","pixelHeight","vkFormat","keyValue","KTXswizzle","dataFormat","dataFormatDescriptor","colorModel","transferFunction","bytesPlane","samples","channelType","samplePosition","bitLength","bitOffset","sampleLower","sampleUpper","faceCount","pixelDepth","cubeLayers","layerCount","levels","push","levelData","uncompressedByteLength","baseTable","shiftTable","conversionBuffer","floatView","uintView","toFloat16Bytes","bits","mantissa","idx","shifted","parseHDR","inData","decoder","TextDecoder","pos","getLine","lineLimit","limit","length","sub","subarray","indexOf","decode","importError","msg","magicTokenLine","test","headerReg","RegExp","source","join","rawData","noFormat","gamma","exposure","line","match","X","Y","parseFloat","unencodable","flatData","scanline_buffer","len","k","count","ptr","isEncodedRun","fill","j","data","Uint16Array","float16One","raw_e","scale","pow","equirectangularToCubemap","outputDescriptor","equirectangular","FLIP_Y","GPUTexture","writeTexture","faceSize","cubemapDescriptor","RENDER_ATTACHMENT","cubemap","FRAGMENT","sampler","createSampler","minFilter","magFilter","params","paramBuffer","UNIFORM","pipelineLayout","createRenderPipeline","vertex","fragment","targets","GAMMA","EXPOSURE","arrayLayerCount","baseArrayLayer","loadOp","storeOp","draw"],"sourceRoot":""}