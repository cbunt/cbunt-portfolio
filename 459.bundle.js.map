{"version":3,"file":"459.bundle.js","mappings":";gJAEA,SAASA,EAAcC,GACnB,MAAyB,iBAAXA,EAAsBA,EAASA,GACjD,CAEA,MAAMC,EAGF,WAAAC,CAAYC,EAAeH,GAS3B,KAAAI,KAAQJ,GAAmBK,KAAKC,KAAOP,EAAcC,GAErD,KAAAO,SAAW,IAAMF,KAAKC,KAAO,GAVrBH,IAAME,KAAKC,IAAMP,EAAcC,GACvC,CAEA,IAAAQ,CAAKL,EAAeH,GAEhB,OADIG,IAAME,KAAKC,MAAQP,EAAcC,IAC9BK,IACX,CAMA,IAAKI,OAAOC,eAAiB,OAAOL,KAAKE,UAAY,EAclD,SAASI,EAAqBC,EAA4BC,EAAQ,GACrE,MAAO,IAAMD,EAAGC,IACpB,eCDe,SAASC,EAAQC,GAE5B,MAAM,MAAEC,GDdL,SAAuBD,GAC1B,MAAO,CACHC,MAAK,CAACC,EAAajB,IACR,IAAIC,GAAuBc,EAAQE,KAASA,EAAKjB,GAE5DkB,OAAM,CAACD,EAAajB,IACT,IAAIC,GAAuBc,EAAQE,KAASA,EAAKjB,GAGpE,CCKsBmB,CAAcJ,GAC1BK,EAAmBT,GAAmBU,GAAkB,aAAaA,OACrEC,EAAmBX,GAAmBU,GAAkB,aAAaA,OAErEE,EAAkBZ,GAAmBU,GAAkB,gCACpCA,aAGnBG,EAAqB,aACrBF,4BACAA,+BACAA,6BAEAN,EAAM,KAAqBS,eAAe,IAAgB,iBACtDH,oCACAA,+CAGJN,EAAM,KAAqBU,cAAc,IAAgB,iBACrDJ,wCAIV,MAAiB,aACX,IAAeK,KAAK,iYAchBX,EAAM,KAAqBY,YAAa,qCACxCZ,EAAM,KAAqBa,SAAU,mDAGzCN,6DAEAA,+CACAA,yDAEAA,4CACAA,sDAEAA,uDACAA,iEAEAP,EAAM,KAAqBa,UAAU,IAAgB,iBACjDN,kDACAA,wJAMAP,EAAM,KAAqBS,cAAe,6NAO1CL,gCACAA,iCAEAJ,EAAM,KAAqBS,eAAe,IAAgB,qBACtDL,wCACAA,uDAGJJ,EAAM,KAAqBU,cAAc,IAAgB,qBACrDN,2FAKJI,yGAKAA,oBAEAR,EAAM,KAAqBS,cAAgB,KAAqBK,YAAuB,kyBAuBvFd,EAAM,KAAqBS,cAAyB,2lBAepDT,EAAM,KAAqBY,YAAuB,6FAG9CZ,EAAM,KAAqBU,aAAwB,oSAWvDV,EAAM,KAAqBU,aAAwB,qZAQnDV,EAAM,KAAqBS,cAAyB,ocAOhDT,EAAM,KAAqBc,YAAuB,0GAGrD1B,KAAe,sOAQhBY,EAAM,KAAqBa,SAAoB,mNAQ7D,CC7MA,MAAqBE,EA0BjB,WAAA7B,CACoB8B,EACAC,EACAC,GAFA,KAAAF,OAAAA,EACA,KAAAC,QAAAA,EACA,KAAAC,QAAAA,EApBX,KAAAC,gBAAyD,CAAC,EAC1D,KAAAC,gBAAyD,CAAC,EAC1D,KAAAC,cAA2D,CAAC,EAC5D,KAAAC,cAAqD,CAAC,EACtD,KAAAC,iBAA2D,CAAC,EAE5D,KAAAC,SAAgD,CAAC,EAEjD,KAAAC,uBAAyBpC,KAAK2B,OAAOU,sBAAsB,CAChEC,MAAO,mBACPC,QAAS,CAAC,CACNC,QAAS,EACTC,WAAYC,eAAeC,OAASD,eAAeE,SACnDC,OAAQ,CAAEC,KAAM,wBAQpB,CAEJ,UAAAC,CAAWC,GACP,MAAMC,EAAMC,KAAKC,UAAUH,GAE3B,OADAhD,KAAKmC,SAASc,KAASjD,KAAK2B,OAAOyB,cAAcJ,GAC1ChD,KAAKmC,SAASc,EACzB,CAEA,eAAAI,CAAgB3C,GACZ,MAAM4C,EAA+B5C,EAAQ,KAE7C,GAAkC,MAA9BV,KAAKgC,cAAcsB,GAAiB,CACpC,MAAMC,EAAmC,CACrC,CAAEC,eAAgB,EAAGC,OAAQ,EAAGC,OAAQ,aACxC,CAAEF,eAAgB,EAAGC,OAAQ,GAAIC,OAAQ,cAG7C,IAAIC,EAAc,GACdH,EAAiB,EAEjBF,EAAS,KAAqBlC,gBAC9BmC,EAAWK,KAAK,CAAEJ,iBAAgBC,OAAQE,EAAaD,OAAQ,cAC/DH,EAAWK,KAAK,CAAEJ,eAAgBA,EAAiB,EAAGC,OAAQE,EAAc,GAAID,OAAQ,cACxFF,GAAkB,EAClBG,GAAe,IAGfL,EAAS,KAAqBjC,eAC9BkC,EAAWK,KAAK,CAAEJ,iBAAgBC,OAAQE,EAAaD,OAAQ,cAC/DC,GAAe,IAGnB3D,KAAKgC,cAAcsB,GAAU,CAAEC,aAAYI,cAAaE,SAAU,SACtE,CAEA,OAAO7D,KAAKgC,cAAcsB,EAC9B,CAEA,wBAAAQ,CAAyBpD,GACrB,MAAM4C,EAA+B5C,EAAQ,KAW7C,OATAV,KAAK8B,gBAAgBwB,KAAYtD,KAAK2B,OAAOoC,qBAAqB,CAC9DzB,MAAO,KAAsCgB,GAC7CU,iBAAkB,CACdhE,KAAK6B,QAAQoC,gBACbjE,KAAKkE,qBAAqBxD,GAC1BV,KAAKoC,0BAINpC,KAAK8B,gBAAgBwB,EAChC,CAEA,eAAAa,CAAgBzD,GACZ,MAAM4C,EAA+B5C,EAAQ,KAK7C,OAJAV,KAAKiC,cAAcqB,KAAYtD,KAAK2B,OAAOyC,mBAAmB,CAC1D9B,MAAO,KAAsCgB,GAC7ChC,KAAMb,EAAQ6C,KAEXtD,KAAKiC,cAAcqB,EAC9B,CAEA,iBAAAe,CAAkB3D,GACd,MAAM4C,EAAS5C,EAAQ,KAQvB,OANAV,KAAK+B,gBAAgBuB,KAAY,CAC7BgB,SAAU5C,EAAc6C,eAAgB7D,EAAQ,MAChD8D,SAAUlB,EAAS,KAAqB7B,YAAc,OAAS,OAC/DgD,UAAWnB,EAAS,KAAqBoB,iBAAmB,KAAO,OAGhE1E,KAAK+B,gBAAgBuB,EAChC,CAEA,oBAAAY,CAAqBxD,GACjB,MAAM4C,EAAS5C,EAAQ,KAEvB,OADAV,KAAKkC,iBAAiBoB,KAAYtD,KAAK2B,OAAOU,sBD5G/C,SAA0B3B,GAC7B,MAAM6B,EAAqC,GAE3C,SAASoC,EAASC,GACdrC,EAAQqB,KAAK,IAAKgB,EAAMpC,QAASD,EAAQsC,OAAQpC,WAAYC,eAAeE,SAAWF,eAAeC,QAC1G,CAkBA,OAhBAgC,EAAS,CAAE9B,OAAQ,CAAEC,KAAM,aAE3B6B,EAAS,CAAEG,QAAS,CAAC,IACrBH,EAAS,CAAEI,QAAS,CAAEC,cAAe,QAErCL,EAAS,CAAEG,QAAS,CAAC,IACrBH,EAAS,CAAEI,QAAS,CAAEC,cAAe,QAErCL,EAAS,CAAEG,QAAS,CAAC,IACrBH,EAAS,CAAEI,QAAS,CAAEC,cAAe,QAEjCtE,EAAQ,KAAqBc,WAC7BmD,EAAS,CAAEG,QAAS,CAAC,IACrBH,EAAS,CAAEI,QAAS,CAAEC,cAAe,SAGlC,CAAE1C,OAAO,QAAqB5B,GAAQ6B,UACjD,CCoF4E,CAAiBe,IAC9EtD,KAAKkC,iBAAiBoB,EACjC,EA3GgB,EAAAiB,eAA8E,CAC1F,CAAC,KAAqBU,cAAe,gBACrC,CAAC,KAAqBC,eAAgB,iBACtC,CAAC,KAAqBC,WAAY,aAClC,CAAC,KAAqBC,UAAW,YACjC,CAAC,KAAqBC,WAAY,wCCf1C,IAAYC,4FAAZ,SAAYA,GACR,2BAMA,qCAMA,mCAEA,iCACA,2BAEA,kCACA,4CAGA,mCACA,sCACA,+BACA,6BACA,+BACA,8BAGH,CA9BD,CAAYA,IAAAA,EAAoB,KAgCzB,MAAMC,EAAqB,MAErBC,EACTD,EACED,EAAqB7D,YACrB6D,EAAqBZ,iBAGde,IACTF,EACED,EAAqBZ,kBAGdgB,EACTJ,EAAkC,cAGzBK,EACTL,EAAqBlE,cACnBkE,EAAqBjE,aAOduE,EAHTN,EAAgC,YAK9BA,EAAqB9D,SAQdqE,EACTH,GALAE,EACEN,EAAqB7D,aAapB,SAASqE,EAAqBC,GACjC,OANG,SAA6BA,GAChC,OAAOC,OAAOzD,QAAQ+C,GACjBW,SAAQ,EAAEhD,EAAKiD,KAA0B,iBAATA,GAAsBA,EAAOH,EAAO9C,EAAM,IACnF,CAGWkD,CAAoBJ,GAAK7F,UACpC,CAEO,SAASkG,EAAsB1F,GAClC,IAAI4C,EAAS5C,EAEb,OADI4C,EAASgC,EAAqB7D,cAAa6B,IAAWgC,EAAqBZ,kBACxEpB,CACX,iDCpFA,MAAMhB,EAAQ,kBAEd,MAAqB+D,EAsCjB,WAAAxG,CAAY8B,GACR3B,KAAKsG,aAAe3E,EAAO4E,aAAaF,EAAeG,kBACvDxG,KAAKiE,gBAAkBtC,EAAOU,sBAAsBgE,EAAeI,kBAEnEzG,KAAK0G,oBAAsB,CACvBpE,QACAqE,OAAQ3G,KAAKiE,gBACb1B,QAAS,CACL,CACIC,QAAS,EACToE,SAAU,CACN/D,OAAQ7C,KAAKsG,aACb7C,OAAQ,EACRoD,KAAMR,EAAeS,eAMrC9G,KAAK+G,UAAYpF,EAAOqF,gBAAgBhH,KAAK0G,oBACjD,CAEA,kBAAAO,CAAmBC,EAAiBC,GAChCA,EAAOC,YACPF,EAAMG,YAAYrH,KAAKsG,aAAc,EAAGa,EAAOtE,OACnD,EA9DgB,EAAAvB,KAAQgG,GAA4B,uSAUvCA,6DAGG,EAAAR,WAAa,IAAOS,aAEpB,EAAAd,iBAAiD,CAC7DnE,QACAC,QAAS,CACL,CACIC,QAAS,EACTK,OAAQ,CAAE2E,eAAgBnB,EAAeS,YACzCrE,WAAYC,eAAeC,OAASD,eAAeE,YAK/C,EAAA4D,iBAAwC,CACpDlE,QACAuE,KAAMR,EAAeS,WACrBW,MAAOC,eAAeC,QAAUD,eAAeE,qFCxBvD,MAAMC,EAAoB,CACtBC,EACApE,IACW,SACT,YACA,4QAY4CA,sJAKnBoE,osDAkJhBC,eAAeC,GAAuB,OACjDrG,EAAM,QACNoD,EAAO,mBACPkD,EAAkB,QAClBC,GAAU,EAAK,SACfC,EAAW,EAAC,MACZC,EAAQ,EAAC,cACTC,EAAgB,UAAqB,MACrC/F,EAAQ0F,EAAuBM,KAAI,UACnCC,IAEA,MAAM,MAAEC,EAAK,OAAE9E,GAAWqB,EACpB0D,EAAgBP,EAChBnD,EAAQ0D,cACPC,KAAKC,KAAKH,GAASE,KAAKC,KAAKR,GAAY,EAEhD,GAAIM,GAAiB,EAAG,OAAO1D,EAE/B,MAAM+C,EAASY,KAAKE,IAChBjH,EAAOkH,OAAOC,yBACdnH,EAAOkH,OAAOE,mCAEZC,EAASrH,EAAOyC,mBAAmB,CACrC9B,QACAhB,KAAMuG,EAAkBC,EAAQpE,KAG9BuF,EAAkBtH,EAAOU,sBAAsB,CACjDC,QACAC,QAAS,CACL,CACIC,QAAS,EACTuC,QAAS,CAAEC,cAAe,YAC1BvC,WAAYC,eAAewG,SAE/B,CACI1G,QAAS,EACT2G,eAAgB,CACZC,OAAQ,aACRpE,cAAe,WACftB,UAEJjB,WAAYC,eAAewG,SAE/B,CACI1G,QAAS,EACTK,OAAQ,CAAEC,KAAM,qBAChBL,WAAYC,eAAewG,YAKjCG,EAAW1H,EAAO2H,sBAAsB,CAC1ChH,QACAqE,OAAQhF,EAAOoC,qBAAqB,CAChCzB,QACA0B,iBAAkB,CAACiF,KAEvBM,QAAS,CACLC,OAAQR,EACRS,WAAY,OACZC,UAAW,CAAEC,MAAOjB,KAAKkB,KAAKxB,OAItC,IAAIyB,EAAkB9E,EACtB,IAAKmD,EAAS,CACV,MAAMrB,EAAO,CAAE2B,QAAOsB,OAAQtB,EAAOuB,mBAAoB,GAEzDF,EAAkBlI,EAAOqI,cAAc,CACnC1H,MAAO2F,EACPR,MAAOwC,gBAAgBC,gBACjBD,gBAAgBE,gBAChBF,gBAAgBG,SAChBH,gBAAgBrC,SACtByC,UAAW,KACX3G,SACA+E,gBACA5B,SAGJ,MAAMyD,EAAc3I,EAAO4I,qBAAqB,CAC5CjI,MAAO,GAAGA,mBAGdgI,EAAYE,qBACR,CAAEzF,UAAS0F,SAAU,GACrB,CAAE1F,QAAS8E,EAAiBY,SAAU,GACtC5D,GAGJlF,EAAOuF,MAAMwD,OAAO,CAACJ,EAAYK,iBAC3BhJ,EAAOuF,MAAM0D,qBACvB,CAEA,MAAMC,GAAW,QAASpC,GAAgBqC,GAAMjB,EAAgBkB,WAAW,CACvEzI,MAAO,GAAGA,cAAkBwI,IAC5BT,UAAW,WACXW,aAAcF,EACdrC,cAAe,MAGbwC,EAAgBtJ,EAAOkH,OAAOqC,iCAC9BC,EAAYzC,KAAKkB,KAAKlB,KAAKC,KAAKH,IAChC4C,EAAgB1C,KAAK2C,IACtBhD,IAAmB,EAAa,EAARD,IAAe,EAAKN,GAAW,EACxD,GAGEwD,EAAgB,IAAIC,YAA8B,GAAjBJ,EAAY,IAC7C1H,EAAS,IAAI+H,YAAYF,EAAe,EAAG,GAClC,IAAIG,aAAaH,EAAe,EAAGH,GAE3CO,KAAI,QAASP,GAAYL,IAC5B,MAAMa,EAAInD,GAASsC,EACnB,OAAOpC,KAAKkD,KAAK,EA/MzB,SAAyBxD,EAAeI,GAQpC,MAAMqD,EAAerD,GAAS,EACxBsD,EAAQD,EAAenD,KAAKqD,MAAM3D,EAAQ,GAAK,EAC/C4D,EAAU,EAAIH,GAAiBC,EAAQ,IAAO,EAC9CG,EAAU,EAAIJ,EAAgB,EAC9BK,EAAW,EAAIF,EAASA,EAASC,EAASA,EAG1CE,EAAU,EAAI3D,GADN,EAAIA,EAAiB,EAARsD,EAAa1D,EAAQ,EACV,IAAO,EACvCgE,EAAW,EAAI5D,EAAS,EACxB6D,EAAY,EAAIF,EAASA,EAASC,EAAUA,EAC5CE,EAAW,EAAI9D,EAAS,EACxB+D,EAAY,EAAIJ,EAASA,EAASG,EAAUA,EAE5CE,GAAQL,EAASH,EAASI,EAAUH,GACpCvD,KAAK+D,KAAKJ,EAAYH,GAEtBQ,GAAQP,EAASH,EAASM,EAAUL,GACpCvD,KAAK+D,KAAKF,EAAYL,GAE5B,OAAOxD,KAAKE,IAAI,EAAI4D,EAAM,EAAIE,EAClC,CAmL6BC,CAAgBjE,KAAKE,IAAI+C,EAAGvD,GAAQuD,IAAM,CAAC,KAGpE,MAAMiB,GAAiB,QACnBtB,EACA5D,eAAemF,QAAUnF,eAAeE,SACxCjG,GAgFJ,aA7EM,IAAImL,SAAeC,IACrB,IAKIhG,EALA0D,EAAW,EACXuC,EAAY,EACZC,EAAwB,EACxBC,EAAuB,EACvBC,EAAkB,GAGtBpF,eAAeqF,IACX,GAAIF,GAAwBD,EAAuB,CAK/C,GAJAxC,GAAY,EACZyC,EAAuB,EACvBF,EAAY,EAERvC,GAAYhC,EAEZ,YADAsE,IAIJ,MAAMM,EAAY,GAAM7E,GAASiC,IAAa,EAC9CwC,EAAwBvE,KAAKkB,KAAKyD,EAAYvF,GAE9Cf,EAAYpF,EAAOqF,gBAAgB,CAC/BL,OAAQsC,EACR1G,QAAS,CACL,CACIC,QAAS,EACToE,SAAUiE,EAASJ,EAAW,IAElC,CACIjI,QAAS,EACToE,SAAUiE,EAASJ,IAEvB,CACIjI,QAAS,EACToE,SAAU,CAAE/D,OAAQ+J,MAIpC,CAEAnJ,EAAO,GAAKyJ,EAAuBpF,EACnCnG,EAAOuF,MAAMG,YAAYuF,EAAgB,EAAGnJ,GAE5C,MAAM6J,EAAiB5E,KAAKE,IACxBqE,EAAwBC,EACxB9B,EAAgB+B,EAChBlC,GAGEsC,EAAY,GAAGjL,SAAamI,WAAkBuC,IAC9CQ,EAAU7L,EAAO4I,qBAAqB,CAAEjI,MAAOiL,IAC/CE,EAAOD,EAAQE,iBAAiB,CAAEpL,MAAOiL,IAE/CE,EAAKE,YAAYtE,GACjBoE,EAAKG,aAAa,EAAG7G,GACrB0G,EAAKI,mBAAmBP,EAAgB,EAAG,GAC3CG,EAAKK,MAELnM,EAAOuF,MAAMwD,OAAO,CAAC8C,EAAQ7C,WAE7BuC,GAAwBI,EACxBH,GAAmBG,EACnBN,GAAa,EAEI,MAAbzE,GAAqB4E,GAAmB/B,GACxC+B,EAAkB,QACZxL,EAAOuF,MAAM0D,sBACnBrC,EAAU6E,IAELA,GAEb,CAEKA,EAAS,IAGXvD,CACX,qeC3WA,MAAMkE,QAAkBC,IAExBjG,eAAeiG,IACX,MACMC,QAAiBC,MADN,kGAEXC,QAAiBF,EAASG,OAC1BC,EAAYnL,KAAKoL,MAAMH,GAE7B,IAAKI,MAAMC,QAAQH,GACf,MAAM,IAAII,MAAM,mCAGpB,MAAMlM,EAA8B8L,EAAUpI,SAASyI,IACnD,MACK,QAASA,IACL,UAAWA,GACS,iBAAfA,EAAKpM,OACV,SAAUoM,GACS,iBAAdA,EAAKpG,MACV,aAAcoG,IACf,QAASA,EAAKC,WACe,iBAAvBD,EAAKC,SAASC,MAC1B,MAAO,GAET,MAAQD,UAAYC,KAAMC,GAAM,MAAEvM,EAAK,KAAEgG,GAASoG,EAElD,MAAO,CAAC,CAACpM,EADI,iFAAqBgG,UAAauG,KACzB,IAG1B,OAAO7I,OAAO8I,YAAYvM,EAC9B,CAEA,MAAqBwM,EA2CjB,oBAAIC,GACA,OAAOhP,KAAKiP,cAAcrN,QAAQsN,MAAMC,IAC5C,CAwBA,WAAAtP,CAAmBuP,GAAA,KAAAA,SAAAA,EA9BnB,KAAAC,kBAA+D,CAAC,EAQvD,YAAY,OAAiB,CAClCC,QAAQ,OAAiBtP,MACzBuP,MAAO,CACH,CAAC,IAAaC,OAAQ,OACtB,CAAC,IAAaC,WAAY,CAAC1J,EAAc9C,KACzB,UAARA,GAA0B,MAAP8C,IACJ,iBAARA,GAAoBA,aAAe2J,OACrC1P,KAAK2P,SAAS5J,EACvB,EAEJ6J,OAAQ,OACRC,UAAW,CACPC,MAAO,mBACPC,cAAehC,GAEnBiC,QAAUnB,GAAeA,MAIxB,KAAAoB,SAAW,EAAAjQ,KAAI,OAAWkQ,eAC1B,KAAAC,SAAW,IAGhBnQ,KAAKiP,cAAgB,IAAI,IAAcG,EAASzN,OAAQyN,EAASxN,QAASwN,EAASvN,SACnF7B,KAAK2B,OAASyN,EAASzN,OACvB3B,KAAKoP,SAASgB,eAAepQ,KACjC,CAEA,eAAMqQ,CAAUf,SACN,OAAuB,CACzBvK,QAASuK,EACT3N,OAAQ3B,KAAKoP,SAASzN,OACtBuG,SAAS,EACTK,UAAW+H,wBAGftQ,KAAKoP,SAASE,OAASA,CAC3B,CAEA,cAAMK,CAASY,GACX,MAAM1J,EAAO,CAAE2B,MAAO,EAAGsB,OAAQ,GAC3B0G,EAAa,IAAI/E,aAAa,CAAC,EAAG,EAAG,EAAG,IAExCgF,EAAczQ,KAAKoP,SAASzN,OAAOqI,cAAc,CACnDnD,OACAnD,OAAQ,cACR+D,MAAOwC,gBAAgBE,gBAAkBF,gBAAgBrC,WAE7D5H,KAAKoP,SAASzN,OAAOuF,MAAMwJ,aAAa,CAAE3L,QAAS0L,GAAeD,EAAY,CAAC,EAAG3J,GAElF,MAAM8J,EAAY3Q,KAAKoP,SAASzN,OAAOqI,cAAc,CACjDnD,OACAnD,OAAQ,cACR+D,MAAOwC,gBAAgBE,gBAAkBF,gBAAgBrC,WAE7D4I,EAAW9E,IAAI,CAAC,GAAK,GAAK,EAAG,IAC7B1L,KAAKoP,SAASzN,OAAOuF,MAAMwJ,aAAa,CAAE3L,QAAS4L,GAAaH,EAAY,CAAC,EAAG3J,GAEhF,MAAM/B,EAAU,CACZ8L,aAAc,SACdC,aAAc,SACdC,UAAW,SACXC,UAAW,SACXC,aAAc,UAGZC,EAA8B,CAChCC,iBAAkBT,EAClBU,gBAAiB,CAAC,EAAG,EAAG,EAAG,GAC3BC,cAAeT,EACfU,yBAA0BZ,EAC1Ba,eAAgB,EAChBC,gBAAiB,EACjBC,iBAAkB1M,EAClB2M,cAAe3M,EACf4M,yBAA0B5M,GAG9B9E,KAAKqP,wBAA0B,OAC3BkB,EACAvQ,KAAKoP,SAASzN,OACd3B,KAAKiP,cACLgC,EACAlC,EAAU4C,WACV,CAAC,EAET,CAEA,MAAAC,EAAO,QAAEpE,EAAO,QAAE5L,EAAO,QAAEC,IACvB,MAAM4L,EAAOD,EAAQqE,gBAAgBjQ,EAAQkQ,gBAC7CrE,EAAKG,aAAa,EAAG/L,EAAQkF,WAE7B,IAAK,MAAMsC,KAAYrD,OAAO+L,OAAO/R,KAAKqP,mBACtChG,GAAU2I,KAAKvE,EAAMzN,KAAKoP,SAASzN,OAAOuF,OAE9CuG,EAAKK,KACT,gBA9IgB,EAAAmE,MAAQ,oBACR,EAAAC,YAAc,GAEd,EAAAP,WAAiC,CAC7C,CACIrJ,KAAM,WACNxF,KAAM,OACNqP,cAAe,MAEnB,CACI7J,KAAM,aACNxF,KAAM,OACNqP,cAAe,MAEnB,CACI7J,KAAM,UACNxF,KAAM,OACNqP,cAAe,KACfC,QAAS,CAAC,UACVC,KAAM,CAAC,EAAG,EAAG,EAAG,IAEpB,CACI/J,KAAM,SACNxF,KAAM,OACNqP,cAAe,KACfG,OAAO,EACPC,QAAS,KAAqBnR,eAElC,CACIkH,KAAM,UACNxF,KAAM,OACNqP,cAAe,KACfG,OAAO,EACPC,QAAS,KAAqBlR,aAC9BgR,KAAM,CAAC,EAAG,EAAG,EAAG,iHC9E5B,MAAMG,EAKF,WAAA3S,CAAY4S,GAJJ,KAAAlP,WAAuD,GAK3D,IAAImP,EAAa,EACjB,IAAK,MAAMC,KAAa3M,OAAO+L,OAAOU,GAClCC,GAAc1S,KAAK4S,cAAcD,GAErC,MAAME,EAAoBH,EAAa,GAAK,EAC5C1S,KAAK8S,GAAK,IAAIC,WAAWF,GACzB7S,KAAKgT,IAAM,IAAIxH,YAAYxL,KAAK8S,GAAGjQ,OACvC,CAEQ,aAAA+P,CAAcD,GAClB,MAAMG,EAAKH,EAAUM,gBAAgBF,WAC/BJ,EAAUM,KACV,IAAIF,WAAWJ,EAAUM,KAAKpQ,QAC9B6P,EAAaC,EAAUO,kBAAoBP,EAAUQ,qBAE3D,OADAnT,KAAKuD,WAAWK,KAAK,CAAEkP,KAAIJ,eACpBA,CACX,CAEA,IAAAU,CAAKC,GACD,IAAIC,EAAa,EACjB,IAAK,MAAM,GAAER,EAAE,WAAEJ,KAAgB1S,KAAKuD,WAAY,CAC9C,IAAK,IAAIuH,EAAI,EAAGA,EAAI4H,EAAY5H,GAAK,EACjC9K,KAAK8S,GAAGQ,EAAaxI,GAAKgI,EAAGO,EAAQX,EAAa5H,GAEtDwI,GAAcZ,CAClB,CACA,OAAO1S,KAAKuT,aAChB,CAEA,KAAAC,CAAMC,EAAWC,GACb,IAAK,MAAM,GAAEZ,EAAE,WAAEJ,KAAgB1S,KAAKuD,WAClC,IAAK,IAAIoQ,EAAI,EAAGA,EAAIjB,EAAYiB,GAAK,EACjC,GAAIb,EAAGW,EAAIf,EAAaiB,KAAOb,EAAGY,EAAIhB,EAAaiB,GAC/C,OAAO,EAInB,OAAO,CACX,CAEA,UAAAC,CAAWC,EAAmBC,EAAiB7Q,EAAa8Q,GACxD,MAAMC,EAAUF,EAAU,EAE1B,IAAIG,EADYjU,KAAKoT,KAAKnQ,GACH+Q,EAEvB,IAAK,IAAIE,EAAQ,EAAGA,GAASF,EAASE,GAAS,EAAG,CAC9C,MAAMtP,EAAOiP,EAAMI,GAEnB,GAAIrP,IAASmP,GAAS/T,KAAKwT,MAAM5O,EAAM3B,GACnC,OAAOgR,EAGXA,EAAUA,EAASC,EAAQ,EAAKF,CACpC,CAEA,MAAM,IAAIvF,MAAM,mBACpB,CAOA,WAAA8E,GACI,MAAMY,EAAI,WAEV,IAAIC,EAAI,EAER,IAAK,IAAIC,KAAKrU,KAAKgT,IACfqB,EAAI3L,KAAK4L,KAAKD,EAAGF,KAAO,EACxBE,GAAKA,EAAKA,GALJ,MAKiB,EACvBA,EAAI3L,KAAK4L,KAAKD,EAAGF,KAAO,EAExBC,EAAI1L,KAAK4L,KAAKF,EAAGD,KAAO,EACxBC,GAAKA,EAAIC,KAAO,EAGpB,OAAOD,CACX,EAaW,SAASG,EAAK9B,GACzB,MAAM+B,EAAiB/B,EAAKgC,SAASC,MAC/BtB,EAAO,IAAIZ,EAAUC,GACrBkC,GAbc7E,EAaa0E,EAAkBA,EAAiB,EAZ7D,GAAK9L,KAAKkB,KAAKlB,KAAKkM,IAAI9E,GAASpH,KAAKmM,MADjD,IAAwB/E,EAcpB,MAAMgF,EAAUN,EAAiB,MAC3BT,EAAQ,IAAMe,EAAU,GAAK,IAAM,EACnCC,EAA8BD,EAAU,SAAW,SACnDE,EAAWF,EAAU,IAAIG,YAAYT,GAAkB,IAAIhJ,YAAYgJ,GACvEX,EAAQiB,EAAU,IAAIG,YAAYN,GAAa,IAAInJ,YAAYmJ,GACrEd,EAAMxB,KAAK0B,GAEX,IAAImB,EAAiB,EAErB,IAAK,IAAIpK,EAAI,EAAGA,EAAI0J,EAAgB1J,GAAK,EAAG,CACxC,MAAMqK,EAAY/B,EAAKQ,WAAWC,EAAOc,EAAW7J,EAAGiJ,GACjDqB,EAAWvB,EAAMsB,GAEnBC,IAAarB,GACbF,EAAMsB,GAAarK,EACnBkK,EAASlK,GAAKoK,EACdA,GAAkB,GAElBF,EAASlK,GAAKkK,EAASI,EAE/B,CAEA,IAAK,MAAMzC,KAAa3M,OAAO+L,OAAOU,GAClCE,EAAU0C,MAAML,EAAUE,GAK9B,MAAO,CAAEI,WAAYN,EAAUD,cAAaQ,YAAaL,EAC7D,iCCjHO,MAAMM,EAmBT,WAAA3V,CACI4V,EACA9T,EACA0J,EACA4D,EACAyG,GAkBA,GA1BJ,KAAAC,cAAwB,EACxB,KAAAC,OAAiB,EASb5V,KAAKqL,IAAMA,EACXrL,KAAK6V,SAAWJ,EAAUI,SAC1B7V,KAAKsI,KAAOmN,EAAUnN,MAAQ,OAC9BtI,KAAKuV,YAAcE,EAAUF,YAEzBE,EAAUK,uBAAuBC,UACjC/V,KAAKgW,aAAeP,EAAUK,YAE9B9V,KAAKgW,cAAe,QAChBP,EAAUK,YACVpO,eAAe/E,OACfhB,EACA,GAAG3B,KAAKsI,sBAIZmN,EAAUH,YAAcG,EAAUV,YAAa,CAC/C,MAAM,WAAEO,EAAU,YAAEP,GAAgBU,EACpCzV,KAAKiW,UAAY,CACblB,cACAmB,WAAYZ,EAAWa,YAA8B,WAAhBpB,EAA2B,EAAI,GACpEqB,aAAa,QACTX,EAAUH,WACV5N,eAAe2O,MACf1U,EACA,GAAG3B,KAAKsI,qBAGpB,CAEAtI,KAAKsW,aAAe,KAAUC,cAC1BvW,KAAK6V,SAAW,KAAqBzU,gBACrCpB,KAAKsW,cAAgB,IAGzBtW,KAAK0V,UAAY,IAAInK,YAAYF,EAAMrL,KAAKsW,cAC5CtW,KAAKwW,cAAgB,IAAIjI,MAAMlD,GAE/B,IAAK,IAAIP,EAAI,EAAGA,EAAIO,EAAKP,GAAK,EAAG,CAC7B,MAAMrH,EAASqH,EAAI9K,KAAKsW,aACxBtW,KAAKwW,cAAc1L,GAAK,IAAIW,aAAazL,KAAK0V,UAAWjS,EAAQ,GACrE,CAEA,GAAIzD,KAAK6V,SAAW,KAAqBzU,cAAe,CACpDpB,KAAKyW,eAAiB,IAAIlI,MAAMlD,GAEhC,IAAK,IAAIP,EAAI,EAAGA,EAAIO,EAAKP,GAAK,EAAG,CAC7B,MAAMrH,EAAUqH,EAAI9K,KAAKsW,aAAgB,KAAUC,cACnDvW,KAAKyW,eAAe3L,GAAK,IAAIW,aAAazL,KAAK0V,UAAWjS,EAAQ,GACtE,CACJ,CAiBA,GAfAzD,KAAK0W,eAAiB/U,EAAO4E,aAAa,CACtCjE,MAAO,GAAGtC,KAAKsI,uBACfzB,KAAM7G,KAAK0V,UAAUS,WACrB1O,MAAOC,eAAemF,QAAUnF,eAAeE,SAAWF,eAAeC,UAG7E3H,KAAK2W,kBAAoBhV,EAAOqF,gBAAgB,CAC5C1E,MAAO,wCACPqE,OAAQsI,EAAc7M,uBACtBG,QAAS,CAAC,CACNC,QAAS,EACToE,SAAU,CAAE/D,OAAQ7C,KAAK0W,oBAI7BhB,EACA,IAAK,MAAMkB,KAAYlB,EACnB1V,KAAK6W,YAAYD,EAG7B,CAEA,IAAA5E,CAAK8E,EAAmC5P,GASpC,GARIlH,KAAK4V,QACL1O,EAAMG,YAAYrH,KAAK0W,eAAgB,EAAG1W,KAAK0V,WAC/C1V,KAAK4V,OAAQ,GAGjBkB,EAAYC,gBAAgB,EAAG/W,KAAKgW,cACpCc,EAAYlJ,aAAa,EAAG5N,KAAK2W,mBAEX,MAAlB3W,KAAKiW,UAAmB,CACxB,MAAM,YAAEG,EAAW,WAAEF,EAAU,YAAEnB,GAAgB/U,KAAKiW,UACtDa,EAAYE,eAAeZ,EAAarB,GACxC+B,EAAYG,YAAYf,EAAYlW,KAAK2V,cAC7C,MACImB,EAAY9E,KAAKhS,KAAKuV,YAAavV,KAAK2V,cAEhD,CAEA,WAAAkB,CAAYK,GACJlX,KAAK2V,gBAAkB3V,KAAKqL,MAChC,KAAK8L,KAAKD,EAAWlX,KAAKwW,cAAcxW,KAAK2V,gBAC7C3V,KAAKoX,sBAAsBpX,KAAK2V,eAChC3V,KAAK2V,eAAiB,EACtB3V,KAAK4V,OAAQ,EACjB,CAEA,qBAAAwB,CAAsBpW,GAClB,KAAMhB,KAAK6V,SAAW,KAAqBzU,eAAgB,OAC3D,MAAMiW,EAAerX,KAAKyW,eAAezV,GACzC,KAAKsW,SAAStX,KAAKwW,cAAcxV,GAAMqW,GACvC,KAAKE,OAAOF,EAAcA,GAC1B,KAAKG,UAAUH,EAAcA,EACjC,ECrIG,MA6BMI,EAAsE,CAC/E,EAAuB,KAAqBtS,UAC5C,EAAyB,KAAqBC,SAG9C,EAA6B,KAAqBH,cCnDvC,MAAMyS,EAiBjB,WAAA7X,CAAY8X,EAAoDC,GAC5D,GANJ,KAAAC,UAAW,EAMHF,aAAoBlM,aACpBzL,KAAKiT,KAAO0E,EACZ3X,KAAKmT,qBAAuByE,EAC5B5X,KAAK0U,MAAQiD,EAAS9S,OAAS+S,EAC/B5X,KAAK8X,WAAY,EACjB9X,KAAKkT,kBAAoB,EACzBlT,KAAK+X,SAAW/X,KAAKgY,cAAcC,KAAKjY,UACrC,CASH,OARAA,KAAKiT,KAAO0E,EAAS7H,MACrB9P,KAAKmT,qBAAuBwE,EAASO,WACrClY,KAAK0U,MAAQiD,EAASjD,MACtB1U,KAAKkT,kBAAoByE,EAASzE,kBAClClT,KAAK8X,WAAY,EACjB9X,KAAKmP,KAAO,IAAIgJ,SAASnY,KAAKiT,KAAKpQ,QACnC7C,KAAK+X,SAAW/X,KAAKoY,gBAAgBH,KAAKjY,MAElC2X,EAASxF,eACb,KAAK,KACDnS,KAAKqY,GAAK,CAACvN,EAAG6I,IAAM3T,KAAKmP,KAAMmJ,QAAQxN,EAAI9K,KAAKmT,qBAAuBQ,GACvE,MAEJ,KAAK,KACD3T,KAAKqY,GAAK,CAACvN,EAAG6I,IAAM3T,KAAKmP,KAAMoJ,SAASzN,EAAI9K,KAAKmT,qBAAuBQ,GACxE,MAEJ,KAAK,KACD3T,KAAKqY,GAAK,CAACvN,EAAG6I,KACV,MAAMlQ,EAAS,GAAKqH,EAAI9K,KAAKmT,qBAAuBQ,GACpD,OAAO3T,KAAKmP,KAAMqJ,SAAS/U,GAAQ,EAAK,EAE5C,MAEJ,KAAK,KACDzD,KAAKqY,GAAK,CAACvN,EAAG6I,KACV,MAAMlQ,EAAS,GAAKqH,EAAI9K,KAAKmT,qBAAuBQ,GACpD,OAAO3T,KAAKmP,KAAMsJ,UAAUhV,GAAQ,EAAK,EAE7C,MAEJ,KAAK,KACDzD,KAAKqY,GAAK,CAACvN,EAAG6I,KACV,MAAMlQ,EAAS,GAAKqH,EAAI9K,KAAKmT,qBAAuBQ,GACpD,OAAO3T,KAAKmP,KAAMuJ,UAAUjV,GAAQ,EAAK,EAE7C,MAEJ,KAAK,KACDzD,KAAKqY,GAAK,CAACvN,EAAG6I,KACV,MAAMlQ,EAAS,GAAKqH,EAAI9K,KAAKmT,qBAAuBQ,GACpD,OAAO3T,KAAKmP,KAAMwJ,WAAWlV,GAAQ,EAAK,EAE9C,MAEJ,QAAS,MAAM,IAAIgL,MAAM,0CAA0CkJ,EAASxF,iBAGhF,GAAIwF,EAASiB,WAAY,CACrB,IAAI7S,EACJ,OAAQ4R,EAASxF,eACb,KAAK,KAAqBpM,EAAM,IAAK,MACrC,KAAK,KAAoBA,EAAM,IAAK,MACpC,KAAK,KAAsBA,EAAM,MAAO,MACxC,KAAK,KAAqBA,EAAM,MAAO,MACvC,KAAK,KAAsBA,EAAM,WAAY,MAC7C,QAAS,MAAM,IAAI0I,MAAM,0CAA0CkJ,EAASxF,iBAGhFnS,KAAKqY,GAAK,CAACvN,EAAG6I,IAAM3T,KAAKqY,GAAIvN,EAAG6I,GAAK5N,CACzC,CACJ,CACJ,CAEA,SAAI8S,GAEA,OADK7Y,KAAK8X,WAAW9X,KAAKgQ,UACnBhQ,KAAKiT,IAChB,CAEA,aAAA+E,CAAcc,EAAgBC,EAAgBC,GAC1C,IAAK,IAAIrF,EAAI,EAAGA,EAAI3T,KAAKmT,qBAAsBQ,GAAK,EAChDqF,EAAID,EAASpF,GAAK3T,KAAKiT,KAAM6F,EAAS9Y,KAAKmT,qBAAwBQ,EAE3E,CAEA,eAAAyE,CAAgBU,EAAgBC,EAAgBC,GAC5C,IAAK,IAAIrF,EAAI,EAAGA,EAAI3T,KAAKmT,qBAAsBQ,GAAK,EAChDqF,EAAID,EAASpF,GAAK3T,KAAKqY,GAAIS,EAAQnF,EAE3C,CAEA,aAAAsF,GACIjZ,KAAK8X,WAAY,EACjB9X,KAAK+X,SAAW/X,KAAKgY,cAAcC,KAAKjY,aACjCA,KAAKmP,YACLnP,KAAKqY,EAChB,CAEA,OAAArI,GACI,GAAIhQ,KAAK8X,UAAW,OACpB,MAAMoB,EAAU,IAAIzN,aAAazL,KAAK0U,MAAQ1U,KAAKmT,sBAEnD,IAAK,IAAIrI,EAAI,EAAGA,EAAI9K,KAAK0U,MAAO5J,GAAK,EACjC9K,KAAK+X,SAASjN,EAAGA,EAAI9K,KAAKmT,qBAAsB+F,GAGpDlZ,KAAKiT,KAAOiG,EACZlZ,KAAKiZ,eACT,CAEA,MAAAE,CAAO7D,GACH,GAAItV,KAAK6X,SAAU,OACnB7X,KAAK6X,UAAW,EAChB,MAAMqB,EAAU,IAAIzN,aAAa6J,EAAWzQ,OAAS7E,KAAKmT,sBAE1D,IAAK,IAAIrI,EAAI,EAAGA,EAAIwK,EAAWzQ,OAAQiG,GAAK,EACxC9K,KAAK+X,SAASzC,EAAWxK,GAAIA,EAAI9K,KAAKmT,qBAAsB+F,GAGhElZ,KAAK0U,MAAQY,EAAWzQ,OACxB7E,KAAKiT,KAAOiG,EACZlZ,KAAKiZ,eACT,CAEA,KAAA5D,CAAMA,EAAmB+D,GACrB,MAAMC,EAAW,IAAI5N,aAAa2N,EAAWpZ,KAAKmT,sBAC5CmG,EAAO,IAAIvG,WAAWqG,GAE5B,IAAK,IAAIG,EAAW,EAAGA,EAAWvZ,KAAK0U,MAAO6E,GAAY,EAAG,CACzD,MAAMnE,EAAWC,EAAMkE,GACnBD,EAAKlE,KACTpV,KAAK+X,SAASwB,EAAUnE,EAAWpV,KAAKmT,qBAAsBkG,GAC9DC,EAAKlE,GAAY,EACrB,CAEApV,KAAKiT,KAAOoG,EACZrZ,KAAKiZ,eACT,gBC9IJ,MAAMO,EAAwB,8BAAqBC,MAAMjQ,GAAWA,EAAOkQ,mBAE3E,SAASC,EAAYC,GACjB,OAAQA,EAAQ1G,mBACZ,KAAK,EAAG,MAAO,CACXoC,WAAY,IAAIL,YAAY2E,EAAQ9J,MAAMjN,QAC1CkS,YAAa,UAEjB,KAAK,EAAG,MAAO,CACXO,WAAY,IAAI9J,YAAYoO,EAAQ9J,MAAMjN,QAC1CkS,YAAa,UAGjB,QAAS,MAAO,CACZO,WAAY,IAAIL,YAAY2E,EAAQ9J,OACpCiF,YAAa,UAGzB,CA8CehN,eAAe8R,EAC1BlT,EACA8O,EACAC,EACAzG,EACAtN,GAEA,MAAM4B,EAAakS,EAAUlS,WAC7B,GAA2B,MAAvBA,EAAWkR,SAAkB,MAAO,CAAC,EAEzC,MAAM,QAAEmF,GAAYnE,EACdqE,GAAO,QAAUvW,GAAawW,GAAQ,IAAIrC,EAAiBqC,KACjE,IAEIzE,EACAP,GAHA,KAAEiF,GAASvE,EACXF,EAAchS,EAAWkR,SAASC,MAgBtC,GAZe,MAAXkF,MACGtE,aAAYP,eAAgB4E,EAAYC,IAG9B,IAATI,GACY,IAATA,GACS,IAATA,KAEA1E,aAAYP,cAAaiF,QArExC,SAAiBJ,EAAoCK,GACjD,OAAQA,GACJ,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EAED,MAAM,IAAIxL,MAAM,kCAEpB,QAAS,MAAO,IAAKkL,EAAYC,GAAUI,KAAM,GAEzD,CA0DiDE,CAAQN,EAASI,KAI3C,MAAfF,EAAKK,QAAkC,MAAhBL,EAAKM,QAE5B,GAAuB,MAAnBN,EAAKO,WAAoB,CACzB,GAAkB,MAAd/E,EAAoB,CACpBC,EAAcD,EAAWzQ,OACzB,IAAK,MAAMkV,KAAO/T,OAAO+L,OAAO+H,GAC5BC,EAAIZ,OAAO7D,EAEnB,CAEA,MAAM9U,EAAQ8Z,KAAKC,MAEbC,QAAgBhB,EAAsBC,MAAMgB,GAASA,EAEvDX,EAAKrF,SAAUoE,MAEfiB,EAAKK,OAAQtB,MACbiB,EAAKO,WAAWxB,SAGpB,IAAK,IAAI/N,EAAI,EAAGA,EAAI0P,EAAQ3V,OAAQiG,GAAK,EACrC0P,EAAQ1P,KAAO,EAEnB4P,QAAQ9F,IAAI,0BAAyB0F,KAAKC,MAAQ/Z,IAElDsZ,EAAKM,QAAU,IAAI1C,EAAiB8C,EAAS,KAE1ClF,aAAYP,cAAaQ,eAAgBhB,EAAKuF,IACjDE,EAAO,CACX,KAAO,CACH,MAAMQ,EAAU,IAAI/O,aAA2B,EAAd8J,GACjC,IAAK,IAAIzK,EAAI,EAAGA,EAAIyK,EAAazK,GAAK,EAClC0P,EAAQ9O,IAAI,CAAC,EAAG,EAAG,EAAG,GAAQ,EAAJZ,GAE9BgP,EAAKM,QAAU,IAAI1C,EAAiB8C,EAAS,EACjD,CAGJ,MAAM,YAAE1E,EAAW,eAAE6E,GC7GV,SACXpX,EACAmR,GAEA,IAAIiG,EAAuC,KAAqBC,SAC5DC,EAAS,EACY,MAArBtX,EAAW4W,SAAgBU,GAAU,GACf,MAAtBtX,EAAWuX,UAAiBD,GAAU,GAE1C,MAAM/E,EAAc,IAAIvK,YAAYsP,EAASnG,EAAQ,GAC/CqG,EAAa,IAAItP,aAAaqK,GAEpC,IAAK,IAAIhL,EAAI,EAAGA,EAAI4J,EAAO5J,GAAK,EAC5BvH,EAAWkR,UAAUsD,SAASjN,EAAG+P,EAAS/P,EAAGiQ,GAGjD,MAAMC,EAAKzX,EAAW8W,YAAc,IAAI3C,EAAiB,IAAIjM,aAAqB,EAARiJ,GAAY,GACtF,IAAK,IAAI5J,EAAI,EAAGA,EAAI4J,EAAO5J,GAAK,EAC5BkQ,EAAGjD,SAASjN,EAAGA,EAAI+P,EAAS,EAAGE,GAGnC,GAAyB,MAArBxX,EAAW4W,QAAwC,MAAtB5W,EAAW6W,QAAiB,CACzDO,GAAkB,KAAqBvZ,cAEvC,IAAK,IAAI0J,EAAI,EAAGA,EAAI4J,EAAO5J,GAAK,EAC5BvH,EAAW6W,QAAQrC,SAASjN,EAAGA,EAAI+P,EAAS,EAAGE,GAGnD,IAAK,IAAIjQ,EAAI,EAAGA,EAAI4J,EAAO5J,GAAK,EAC5BvH,EAAW4W,OAAOpC,SAASjN,EAAGA,EAAI+P,EAAS,EAAGE,EAEtD,CAEA,GAA0B,MAAtBxX,EAAWuX,QAAiB,CAC5BH,GAAkB,KAAqBtZ,aACvC,MAAM4Z,EAA4B,MAArB1X,EAAW4W,OAAiB,GAAK,EAC9C,IAAK,IAAIrP,EAAI,EAAGA,EAAI4J,EAAO5J,GAAK,EAC5BvH,EAAWuX,QAAQ/C,SAASjN,EAAGA,EAAI+P,EAASI,EAAMF,GAClDA,EAAWjQ,EAAI+P,EAASI,EAAO,GAAK,CAE5C,CAEA,MAAO,CAAEnF,cAAa6E,iBAC1B,CDkE4CO,CAAmBpB,EAAMvE,GACjE,IAAIM,EApFR,SAAqBsF,GACjB,IAAIC,EAEJ,IAAK,IAAItQ,EAAI,EAAGA,EAAIqQ,EAAiBtW,OAAQiG,GAAK,EAAG,CACjD,MAAMuQ,EAAM,KAAKC,YAAYH,EAAiBrQ,IACxCyQ,EAAO7S,KAAK6S,KAAKF,GAGvB,GAFAD,IAAgBG,EAEZA,IAASH,EAAa,OAAO,KAAqB3Z,WAC1D,CAEA,OAAuB,MAAf2Z,GAAuBA,EAAc,EACvC,KAAqBR,SACrB,KAAqBlW,gBAC/B,CAsEmB8W,CAAY9F,GAAaiF,EAC5B,MAARX,IAAcnE,GAAY4B,EAAeuC,IAAyB,GAEtE,MAAMyB,EAAW,IAAIjG,EAAkB,CACnCK,WACAP,aACAP,cACAQ,cACAO,eACDnU,EAAQ+T,EAAU7Q,OAAQoK,EAAeyG,GAE5C,MAAO,CAAEgG,SAAUjG,EAAUiG,SAAUD,WAC3C,eE1JA,MAAME,EAAmB,EACnBC,EAAoB,EAEpBC,EAAsD,CACxD,KAAM,UACN,KAAM,SACN,KAAM,UACN,KAAM,SACN,KAAM,UACN,KAAM,UAGJC,EAA+D,CACjE,KAAM,UACN,KAAM,UACN,KAAM,SACN,KAAM,UAGJC,EAAoD,CACtD,MAAO,gBACP,MAAO,gBACP,MAAO,UAGX,SAASC,EAAqBlX,GAC1B,MAAM,UAAEgM,EAAS,UAAEC,EAAS,MAAEkL,EAAK,MAAEC,GAAUpX,EAE/C,MAAO,CACH8L,aAAcmL,EAAkBE,GAAS,OACzCpL,aAAckL,EAAkBG,GAAS,OACzCnL,UAAW8K,EAAqB9K,GAAa,MAC7CD,UAAW+K,EAAqB/K,GAAa,MAC7CE,aAAc8K,EAAqB/K,GAAa,OAAS,SAEjE,CAEA,SAASoL,EAAaC,GAClB,MAAM,OAAEC,EAAM,QAAEvX,GAAYsX,EAC5B,GAAc,MAAVC,EAAgB,MAAO,CAAC,EAG5B,MAAMpJ,EAAOoJ,EAAOC,MAAMrJ,MAAQoJ,EAAOE,YAAYtJ,KAErD,OAAY,MAARA,EAAqB,CAAC,EAEnB,CAAEA,OAAMuJ,SAAUH,EAAOG,SAAU1X,UAC9C,CAEeiD,eAAe0U,EAC1Bf,EACAgB,EACA/a,GAEA,MAAMgb,EAAmC,CAAC,EAC1C,GAAqC,MAAjCjB,EAASkB,qBAA8B,CACvC,MAAM,gBACFzL,EAAe,iBACfD,EAAgB,eAChBI,EAAc,yBACdD,EAAwB,gBACxBE,GACAmK,EAASkB,qBAEb,GAAgD,MAA5CvL,GAA0BtM,QAAQsX,OACZ,MAAlB/K,IAAwBqL,EAAIrL,eAAiBqK,GAC1B,MAAnBpK,IAAyBoL,EAAIpL,gBAAkBqK,OAChD,CACH,MAAM,KAAE3I,EAAI,SAAEuJ,EAAQ,QAAE1X,GAAYqX,EAAa9K,EAAyBtM,SAC9D,MAARkO,IACA0J,EAAItL,+BAAiC,OAAe,CAChD/O,MAAO,GAAGoZ,EAASmB,gBACnB5J,OACAuJ,WACA/U,MAAOwC,gBAAgBE,gBACvBxI,WAEAmD,IAAS6X,EAAIjL,yBAA2BsK,EAAqBlX,IAEzE,CAEA,GAAwC,MAApCoM,GAAkBnM,QAAQsX,OAAgB,CAC1C,MAAM,KAAEpJ,EAAI,SAAEuJ,EAAQ,QAAE1X,GAAYqX,EAAajL,EAAiBnM,SACtD,MAARkO,IACA0J,EAAIzL,uBAAyB,OAAe,CACxC5O,MAAO,GAAGoZ,EAASmB,gBACnB5J,OACAuJ,WACA/U,MAAOwC,gBAAgBE,gBACvBxI,SACAmb,cAAc,IAEdhY,IAAS6X,EAAInL,iBAAmBwK,EAAqBlX,IAEjE,CAEuB,MAAnBqM,IAAyBwL,EAAIxL,gBAAkBA,GAC7B,MAAlBG,IAAwBqL,EAAIrL,eAAiBA,GAC1B,MAAnBC,IAAyBoL,EAAIrL,eAAiBC,EACtD,MACIoL,EAAIrL,eAAiBqK,EACrBgB,EAAIpL,gBAAkBqK,EAG1B,GAA8C,MAA1CF,EAAStK,eAAerM,QAAQsX,OAAgB,CAChD,MAAM,KAAEpJ,EAAI,SAAEuJ,EAAQ,QAAE1X,GAAYqX,EAAaT,EAAStK,cAAcrM,SAE5D,MAARkO,IACA0J,EAAIvL,oBAAsB,OAAe,CACrC9O,MAAO,GAAGoZ,EAASmB,gBACnB5J,OACAuJ,WACA/U,MAAOwC,gBAAgBE,gBACvBxI,WAEAmD,IAAS6X,EAAIlL,cAAgBuK,EAAqBlX,IAE9D,CAEA,MAAM,eAAEiY,EAAc,gBAAEC,GAAoBtB,EAGtCuB,EAAmBvB,EAASwB,YAAYC,iCAAiCF,iBAE/E,GAAuB,MAAnBD,GAA2BD,GAAgBK,MAAMC,GAAMA,EAAI,IAAI,CAI/D,GAHAV,EAAII,eAAiBA,GAAkB,CAAC,EAAG,EAAG,GAC9CJ,EAAIW,gBAAkB,CAAExM,UAAW,SAAUC,UAAW,UAEjB,MAAnCiM,GAAiBjY,QAAQsX,OAAgB,CACzC,MAAM,KAAEpJ,EAAI,SAAEuJ,EAAQ,QAAE1X,GAAYqX,EAAaa,EAAgBjY,SACrD,MAARkO,IACA0J,EAAIK,sBAAwB,OAAe,CACvC1a,MAAO,GAAGoZ,EAASmB,gBACnB5J,OACAuJ,WACA/U,MAAOwC,gBAAgBE,gBACvBxI,SACAmb,cAAc,IAEdhY,IAAS6X,EAAIW,gBAAkBtB,EAAqBlX,IAEhE,MACI6X,EAAIK,gBAAkBN,EAAgBxL,iBAGlB,MAApB+L,GAAwD,iBAArBA,GACnC,KAAKM,MAAMZ,EAAII,eAAgBE,EAAkBN,EAAII,eAE7D,CAKA,OAHIrB,EAAS8B,cAAab,EAAIa,aAAc,GACjB,SAAvB9B,EAAS+B,YAAsBd,EAAIe,YAAchC,EAASgC,aAAe,IAEtE,IAAKhB,KAAoBC,EACpC,CClIO,MAAMgB,EAQT,WAAA9d,CACIoT,EACAtR,EACAsN,EACA2O,EACAC,GAXJ,KAAAA,WAAkC,GAa9B7d,KAAK6V,SAAW+H,EACZ3K,EAAKuK,cAAaxd,KAAK6V,UAAY,KAAqBpU,aAG5D,MAAMqc,EAAa,IAAIrS,aAAa,IACpCqS,EAAWpS,IAAIuH,EAAK9B,iBACpB2M,EAAW,GAAK7K,EAAK3B,eACrBwM,EAAW,GAAK7K,EAAK1B,gBAEG,MAApB0B,EAAKyK,cACL1d,KAAK6V,UAAY,KAAqBtU,YACtCuc,EAAW,GAAK7K,EAAKyK,aAGE,MAAvBzK,EAAK8J,gBACLe,EAAWpS,IAAIuH,EAAK8J,eAAgB,GAGxC/c,KAAK+d,kBAAmB,QACpBD,EACApW,eAAeC,QACfhG,GAGJ,MAAMY,EAAU,CACZ,CAAEC,QAAS,EAAGoE,SAAU,CAAE/D,OAAQ7C,KAAK+d,mBACvC,CAAEvb,QAAS,EAAGoE,SAAUqI,EAAclM,WAAWkQ,EAAKzB,mBACtD,CAAEhP,QAAS,EAAGoE,SAAUqM,EAAK/B,iBAAiBnG,WAAW,CAAEV,UAAW,QACtE,CAAE7H,QAAS,EAAGoE,SAAUqI,EAAclM,WAAWkQ,EAAKxB,gBACtD,CAAEjP,QAAS,EAAGoE,SAAUqM,EAAK7B,cAAcrG,WAAW,CAAEV,UAAW,QACnE,CAAE7H,QAAS,EAAGoE,SAAUqI,EAAclM,WAAWkQ,EAAKvB,2BACtD,CAAElP,QAAS,EAAGoE,SAAUqM,EAAK5B,yBAAyBtG,WAAW,CAAEV,UAAW,SAGtD,MAAxB4I,EAAK+J,kBACLhd,KAAK6V,UAAY,KAAqBrU,SAEtCe,EAAQqB,KAAK,CACTpB,QAAS,EACToE,SAAUqI,EAAclM,WAAWkQ,EAAKqK,iBAAmB,CAAC,KAGhE/a,EAAQqB,KAAK,CACTpB,QAAS,EACToE,SAAUqM,EAAK+J,gBAAgBjS,WAAW,CAAEV,UAAW,UAI/DrK,KAAK2G,OAASsI,EAAc/K,qBAAqBlE,KAAK6V,UACtD7V,KAAKiR,QAAUgC,EACfjT,KAAKge,UAAYrc,EAAOqF,gBAAgB,CACpC1E,OAAO,QAAqBtC,KAAK6V,UACjClP,OAAQ3G,KAAK2G,OACbpE,YAGc,MAAdsb,GACA7d,KAAKie,iBAAiBJ,EAE9B,CAEA,IAAA7L,CAAK8E,EAAmC5P,GACpC,GAA+B,IAA3BlH,KAAK6d,WAAWhZ,OAApB,CAEAiS,EAAYlJ,aAAa,EAAG5N,KAAKge,WACjC,IAAK,MAAMvI,KAAazV,KAAK6d,WACzBpI,EAAUzD,KAAK8E,EAAa5P,EAJQ,CAM5C,CAEA,aAAA+W,IAAiBxC,GACb,MAAMyC,EAAWzC,EAAS0C,QAAQlL,IACzBA,EAAK4C,SAAW7V,KAAK6V,YAAc5C,EAAK4C,WAC7C6E,QAAQ0D,KAAK,qDACZnL,EAAK3K,8BACI,QAAqB2K,EAAK4C,UAAU3V,yBAC9CF,KAAKiR,QAAQ3I,6BACJ,QAAqBtI,KAAK6V,UAAU3V,eACtC,KAEXF,KAAK6d,WAAWja,QAAQsa,EAC5B,EC1HW,MAAMG,EAMjB,WAAAxe,CAAYgW,EAAgCyI,GAF5C,KAAAC,UAAgC,GAG5Bve,KAAK6V,UAAW,QAAsBA,GAEtC,MAAMrM,EAAS8U,EAAKna,gBAAgB0R,GAEpC7V,KAAKqJ,SAAWiV,EAAK3c,OAAO6c,qBAAqB,CAC7Clc,OAAO,QAAqBuT,GAC5BlP,OAAQ2X,EAAKxa,yBAAyB+R,GACtCJ,UAAW6I,EAAKja,kBAAkBwR,GAClC4I,OAAQ,CACJhV,WAAY,KACZiV,QAAS,CAACJ,EAAKjb,gBAAgBwS,IAC/BrM,UAEJmV,SAAU,CACNlV,WAAY,KACZD,SACAoV,QAASN,EAAK1c,QAAQgd,SAE1BC,aAAc,CACVC,mBAAmB,EACnBC,aAAc,aACdrb,OAAQ4a,EAAK1c,QAAQsN,MAAMxL,SAGvC,CAEA,YAAAsb,IAAgBT,GACZ,GAAIA,EAAUnB,MAAMnK,GAASA,EAAK4C,WAAa7V,KAAK6V,WAChD,MAAM,IAAIpH,MAAM,uCAEpBzO,KAAKue,UAAU3a,QAAQ2a,EAC3B,CAEA,IAAAvM,CAAK8E,EAAmC5P,GACpC4P,EAAYnJ,YAAY3N,KAAKqJ,UAC7B,IAAK,MAAMsT,KAAO3c,KAAKue,UACnB5B,EAAI3K,KAAK8E,EAAa5P,EAE9B,ECnCJ,MAAM+X,EAAoC,CACtC,CACI3W,KAAM,WACNxF,KAAM,OACNqP,cAAe,MAEnB,CACI7J,KAAM,aACNxF,KAAM,OACNqP,cAAe,MAEnB,CACI7J,KAAM,UACNxF,KAAM,OACNqP,cAAe,KACfC,QAAS,CAAC,UACVC,KAAM,CAAC,EAAG,EAAG,EAAG,IAEpB,CACI/J,KAAM,SACNxF,KAAM,OACNqP,cAAe,KACfG,OAAO,EACPC,QAAS,KAAqBnR,eAElC,CACIkH,KAAM,UACNxF,KAAM,OACNqP,cAAe,KACfG,OAAO,EACPC,QAAS,KAAqBlR,aAC9BgR,KAAM,CAAC,EAAG,EAAG,EAAG,KAIlB6M,EAAc,CAChBC,EACAC,IACEC,IACF,MAAMC,EAASD,EAAKC,QAAU,KAAKC,WAEnC,GAAmB,MAAfF,EAAKC,OAAgB,CAGrB,GAFID,EAAK9B,OAAO,KAAKiC,QAAQH,EAAK9B,MAAO+B,GAErCD,EAAKI,SAAU,CACf,MAAM,KAAEC,EAAI,MAAEC,GAAU,KAAKC,YAAYP,EAAKI,UAC9C,KAAKI,OAAOP,EAAQI,EAAMC,EAAOL,EACrC,CAEwB,MAApBD,EAAKS,aACL,KAAKC,eAAeT,EAAQD,EAAKS,YAAaR,EAEtD,CAEA,KAAKU,IAAIb,EAAcG,EAAQA,GAEd,MAAbD,EAAKY,OACAb,EAAOc,IAAIb,EAAKY,OAAOb,EAAO1T,IAAI2T,EAAKY,KAAM,IAClDb,EAAOe,IAAId,EAAKY,MAAOrc,KAAK0b,IAGhCD,EAAKe,UAAUC,QAAQnB,EAAYI,EAAQF,GAAQ,EAGxCrX,eAAeuY,EAC1BC,EACA5e,EACAsN,EACAyN,EACA/V,EAA6BsY,EAC7BuB,EAAuD,CAAC,EAExD5L,EAAgC8F,QAAQ9F,KAExCA,EAAI,mBAEJ,MAAMpU,EAAQ8Z,KAAKC,MACbkG,QAAwB,EAAAC,EAAA,GAAKH,EAAK,KACxC3L,EAAI,sBAAqB0F,KAAKC,MAAQ/Z,IAEtC,MAAM,MAAEmgB,IAAU,OAAgBF,GAClC,GAAoB,MAAhBE,GAAOC,MAAe,OAAOJ,EACjC5L,EAAI,yBAAwB0F,KAAKC,MAAQ/Z,IAEzC,MAAM4e,EAAS,IAAIyB,IACnBF,EAAMC,MAAMP,QAAQnB,EAAY,KAAKK,WAAYH,IACjDxK,EAAI,iCAAgC0F,KAAKC,MAAQ/Z,IAEjD,MACMsgB,EADcvS,MAAMwS,KAAK3B,EAAO7c,WACA0D,SAAQ,GAAI4X,cAAcnI,KAC5DmI,EAAWmD,KAAKvO,GAASoH,EACrBlT,EACA8L,EACAiD,EACAzG,EACAtN,OAIFsf,QAA6BnU,QAAQoU,IAAIJ,GAC/ClM,EAAI,kCAAiC0F,KAAKC,MAAQ/Z,IAGlD,MAAM2gB,EAAc,IAAIN,IAClBO,EAAgE,CAAC,EAEvE,IAAK,MAAM,SAAE1F,EAAQ,SAAED,KAAcwF,EAAsB,CACvD,GAAgB,MAAZxF,EAAkB,SAEtB,MAAMxY,EAAM,CAAEoe,WAAY3F,GAAUmB,GAAIhH,SAAU4F,EAAS5F,UACtDsL,EAAYjB,IAAIjd,IAAMke,EAAYzV,IAAIzI,EAAK,IAChDke,EAAYhB,IAAIld,GAAMW,KAAK6X,GAEX,MAAZC,IACA0F,EAAiB1F,EAASmB,IAAMJ,EAAaf,EAAUgB,EAAiB/a,GAEhF,CAEA,MAAM2f,EAAkBtb,OAAOzD,QAAQ6e,GAClCJ,KAAIjZ,OAAQ8U,EAAIF,KAAS,CAACE,QAAUF,KAEnC4E,EAAsBvb,OAAO8I,kBAAkBhC,QAAQoU,IAAII,IACjE1M,EAAI,4CAA2C0F,KAAKC,MAAQ/Z,IAE5D,MAAMghB,EAAqC,IAAK9E,EAAiBpL,eAAgB,GAEjF,IAAK,OAAO,SAAEuE,EAAQ,WAAEwL,GAAcI,KAAcN,EAAY5e,UAAW,CACvE,MAAMS,EAA2B,MAAdqe,EAAqBE,EAAoBF,GAAcG,EACpE7E,EAAM,IAAIgB,EAAiB3a,EAAYrB,EAAQsN,EAAe4G,EAAU4L,IACtE5L,SAAU6L,GAAM/E,EAExB6D,EAAUkB,KAAO,IAAIrD,EAAiBqD,EAAGzS,GACzCuR,EAAUkB,GAAG1C,aAAarC,EAC9B,CAGA,OADA/H,EAAI,cAAa0F,KAAKC,MAAQ/Z,IACvBggB,CACX,4FCnJA,MAAMmB,QAAoBzT,MAAM,sGAAgB,CAAE0T,QAAS,CAAE,eAAgB,wCACxEnI,MAAMxZ,GAAQA,EAAI4hB,SAEVC,EAAO9b,OAAO8I,YAAY6S,EAAY1b,SAAQ,EAAGqC,OAAMyZ,kBAAmC,iBAATzZ,GAA6C,iBAAjByZ,GAA6BA,EAAaC,SAAS,QAAU,CAAC,CAAC1Z,EAAMyZ,IAAiB,MAEhNha,eAAeka,EAActgB,EAAmBkN,GAC5C,IAAIhM,EACJ,GAAIgM,aAAgBtD,YAChB1I,EAASgM,OACN,GAAIA,aAAgBa,KACvB7M,QAAegM,EAAKqT,kBACjB,CACH,MAAMjiB,QAAYiO,MAAMW,GACxBhM,QAAe5C,EAAIiiB,aACvB,CAEA,MAAMC,GAAM,OAAStf,GAErB,OAAO,QACHlB,EACAwgB,EACA,CACIze,OAAQ,cACR+D,MAAOwC,gBAAgBE,gBAAkBF,gBAAgBC,gBAAkBD,gBAAgBG,UAGvG,CAIe,SAASgY,EAAiBC,GACrC,MAAO,CACH,CAAC,IAAa7S,OAAQ,OACtB,CAAC,IAAaC,WAAY1H,MAAOhC,EAAc9C,KAC3C,GAAY,UAARA,GAA0B,MAAP8C,IACJ,iBAARA,GAAoBA,aAAe2J,MAAM,CAChD,MAAM3K,QAAgBkd,EAAcI,EAAO1gB,OAAQoE,GAC7C9F,EAAMoiB,EAAOhS,UAAUtL,GACzB9E,aAAe6M,eAAe7M,CACtC,GAEJ2P,OAAQ,OACRC,UAAW,CACPC,MAAO9J,OAAOsc,KAAKR,GAAM,GACzB/R,cAAe+R,GAEnB9R,QAAUnB,GAAeA,EAEjC,0DCpDA,QAAyB,ifCAlB,MAAM0T,EAA+B,6mCAqC/BC,EAA6C,4wJChCnD,SAASC,EACZC,EACAjb,EACA9F,EACAW,EACAqgB,EAAY,GAEZ,MAAMC,EAAMD,EAAY,EAClB9f,EAASlB,EAAO4E,aAAa,CAC/BjE,QACAmF,QACAZ,KAAO6b,EAAIvM,WAAayM,GAAQA,EAChCC,kBAAkB,IAGhBC,EAAa,IAAI/P,WAAWlQ,EAAOkgB,kBACnCC,EAAYN,aAAenX,YAC3B,IAAIwH,WAAW2P,GACf,IAAI3P,WAAW2P,EAAI7f,OAAQ6f,EAAIpP,WAAYoP,EAAIvM,YAKrD,OAHA2M,EAAWpX,IAAIsX,GACfngB,EAAOogB,QAEApgB,CACX,2CC7BA,MAAM,UAAEqgB,EAAS,WAAEC,GAAe,MAC9B,MAAMD,EAAY,IAAI1X,YAAY,KAC5B2X,EAAa,IAAI3X,YAAY,KAEnC,IAAK,IAAIV,EAAI,EAAGA,EAAI,MAAOA,EAAG,CAC1B,MAAMsY,EAAItY,EAAI,IACVsY,GAAK,IACLF,EAAUpY,GAAK,EACfqY,EAAWrY,GAAK,IACTsY,GAAK,IACZF,EAAUpY,GAAK,OAAYsY,EAAI,GAC/BD,EAAWrY,IAAMsY,EAAI,GACdA,GAAK,IACZF,EAAUpY,GAAMsY,EAAI,IAAO,GAC3BD,EAAWrY,GAAK,KAEhBoY,EAAUpY,GAAK,MACfqY,EAAWrY,GAAK,GAExB,CAMA,OAHAoY,EAAU,KAAO,MACjBC,EAAW,KAAO,GAEX,CAAED,YAAWC,aACvB,EA1BiC,GA4B5BE,EAAmB,IAAI9X,YAAY,GACnC+X,EAAY,IAAI7X,aAAa4X,GAC7BE,EAAW,IAAI/X,YAAY6X,GAE1B,SAASG,EAAezd,GAC3Bud,EAAU,GAAKvd,EACf,MAAM2b,EAAI6B,EAAS,GACbH,EAAK1B,GAAK,GAAM,IAChB1gB,EAAU,IAAJoiB,EACZ,OAAOF,EAAUliB,KAAa,QAAJ0gB,IAAmByB,EAAWniB,MAAc,IAAJoiB,IAAc,EACpF,eCvBOrb,eAAe0b,GAAe,OACjC9hB,EAAM,KACNsR,EAAI,SACJuJ,EAAQ,MACR/U,EAAQwC,gBAAgBE,gBAAe,KACvCuZ,GAAO,EAAI,OACXhgB,EAAS,aAAY,WACrBigB,EAAa,OAAM,MACnBrhB,EAAQ,GAAE,aACVwa,IAEA,IAAI8G,EAEJ,GAAI3Q,aAAgB4Q,YAChBD,EAAS3Q,MACN,CACH,MAAM6Q,EAAQ7Q,aAAgB8Q,MAAQ9Q,aAAgBvD,KAChDuD,EACA,IAAI8Q,KAAK,CAAC9Q,GAAO,CAAEnQ,KAAM0Z,IAC/BoH,QAAeI,kBAAkBF,EAAM,CAAEG,qBAAsB,QACnE,CAEA,MAAMpd,EAAO,CAAE2B,MAAOob,EAAOpb,MAAOsB,OAAQ8Z,EAAO9Z,QAE7C/E,EAAUpD,EAAOqI,cAAc,CACjC1H,QACAoB,SACAmD,KAAMA,EACNY,MAAOA,EAAQwC,gBAAgBrC,SAAWqC,gBAAgBG,SAAWH,gBAAgBia,kBACrFzb,cAAeib,EAAO,GAAwD,EAAnDhb,KAAKC,KAAKD,KAAK2C,IAAIuY,EAAOpb,MAAOob,EAAO9Z,UAAgB,IAYvF,OATAnI,EAAOuF,MAAMid,2BACT,CAAE9H,OAAQuH,GACV,CAAE7e,UAAS4e,cACX9c,GAGAiW,IAAc,QAAoBnb,EAAQoD,GAC1C2e,IAAW,QAAa/hB,EAAQoD,GAE7BA,CACX,CAEO,SAASqf,EAASC,GACrB,MAAMC,EAAU,IAAIC,YACd1hB,EAASwhB,aAAkBtR,WAAasR,EAAS,IAAItR,WAAWsR,GACtE,IAAIG,EAAM,EAEV,MAAMC,EAAU,CAACC,EAAY,QACzB,MAAMC,EAAQjc,KAAKE,IAAI/F,EAAOgC,OAAQ6f,EAAYF,GAC5CI,EAAM/hB,EAAOgiB,SAASL,EAAKG,GAC3B7W,EAAM8W,EAAIE,QAAQ,IAAQ,EAEhC,OADAN,GAAO1W,EACQ,IAARA,OAAYiX,EAAYT,EAAQU,OAAOJ,EAAIC,SAAS,EAAG/W,GAAK,EAGjEmX,EAAeC,GAAgB,IAAIzW,MAAM,qBAAuByW,GAIhEC,EAAiBV,IAEvB,GAAsB,MAAlBU,EAAwB,MAAMF,EAAY,mBAC9C,IAJwB,YAIHG,KAAKD,GAAiB,MAAMF,EAAY,qBAE7D,MAOMI,EAAY,IAAIC,OAAO,SAPV,CACf,wBACA,mCACA,0CACA,qCAIWtE,KAAI,EAAG3E,YAAa,IAAIA,OAAWkJ,KAAK,cAGvD,IAGI/c,EACAsB,EAuBA0b,EA3BAC,GAAW,EACXC,EAAQ,EACRC,EAAW,EAIf,IAAK,IAAIC,EAAOnB,IAAmB,MAARmB,EAAcA,EAAgB,MAATpd,EAAgBic,SAAYM,EAAW,CACnF,MAAMjd,EAAS8d,EAAKC,MAAMR,IAAYvd,OACxB,MAAVA,IAEiB,MAAjBA,EAAOpE,OACP+hB,GAAW,EACQ,MAAZ3d,EAAOge,GAAyB,MAAZhe,EAAOie,GAClCvd,EAAQwd,SAASle,EAAOge,GACxBhc,EAASkc,SAASle,EAAOie,IACF,MAAhBje,EAAO4d,MACdA,EAAQO,WAAWne,EAAO4d,OACA,MAAnB5d,EAAO6d,WACdA,EAAWM,WAAWne,EAAO6d,WAErC,CAEA,GAAIF,EAAU,MAAMR,EAAY,4BAChC,GAAa,MAATzc,GAA2B,MAAVsB,EAAgB,MAAMmb,EAAY,gCAKvD,MAAMiB,EAAc1d,EAAQ,GAAKA,EAAQ,MACnC2d,EAA2B,IAAhBtjB,EAAO2hB,IAAkC,IAApB3hB,EAAO2hB,EAAM,OAA+B,IAAlB3hB,EAAO2hB,EAAM,IAE7E,GAAI0B,GAAeC,EACfX,EAAU3iB,EAAOgiB,SAASL,OACvB,CACHgB,EAAU,IAAIzS,WAAWvK,EAAQsB,EAAS,GAC1C,MAAMgE,EAAM,EAAItF,EACV4d,EAAkB,IAAIrT,WAAWjF,GACjCuY,EAAMxjB,EAAOsT,WAEnB,IAAK,IAAI9B,EAAI,EAAG5Q,EAAS,EAAG4Q,EAAIvK,GAAU0a,EAAM6B,EAAKhS,IAAK,CACtD,GAAImQ,EAAM,EAAI6B,EACV,MAAMpB,EAAY,+BAEtB,GAAK,GAAKpiB,EAAO2hB,MAAY,GAAK3hB,EAAO2hB,OAAc3hB,EAAO2hB,MAAU,EAAK3hB,EAAO2hB,OAAWhc,EAC3F,MAAMyc,EAAY,4BAEtB,IAAIvQ,EACJ,IAAK,IAAI4R,EAAM,EAAGA,EAAMxY,GAAO0W,EAAM6B,EAAKC,GAAO5R,EAAO,CACpDA,EAAQ7R,EAAO2hB,KACf,MAAM+B,EAAe7R,EAAQ,IAG7B,GAFI6R,IAAc7R,GAAS,KAEd,GAATA,GAAc4R,EAAM5R,EAAQ5G,EAC5B,MAAMmX,EAAY,qBAElBsB,GACAH,EAAgB/T,KAAKxP,EAAO2hB,GAAM8B,EAAKA,EAAM5R,GAC7C8P,GAAO,IAEP4B,EAAgB1a,IAAI7I,EAAOgiB,SAASL,EAAKA,EAAM9P,GAAQ4R,GACvD9B,GAAO9P,EAEf,CAEA,IAAK,IAAI5J,EAAI,EAAGA,EAAItC,EAAOsC,IACvB,IAAK,IAAI6I,EAAI,EAAGA,EAAI7F,EAAK6F,GAAKnL,EAC1Bgd,EAAQ/hB,KAAY2iB,EAAgBtb,EAAI6I,EACpD,CACJ,CAIA,MAAMV,EAAO,IAAIgC,YAAYuQ,EAAQ3gB,QAC/B2hB,EAAahD,EAAe,GAElC,IAAK,IAAI1Y,EAAI,EAAGA,EAAItC,EAAQsB,EAAS,EAAGgB,GAAK,EAAG,CAC5C,MAAM2b,EAAQjB,EAAQ1a,EAAI,GACpByS,EAAQ7U,KAAKge,IAAI,EAAKD,EAAQ,KAAS,IAE7C,IAAK,IAAI9S,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACxBV,EAAKnI,EAAI6I,GAAK6P,EAAe9a,KAAKE,IAAI4c,EAAQ1a,EAAI6I,GAAK4J,EAAO,QAElEtK,EAAKnI,EAAI,GAAK0b,CAClB,CAGA,MAAO,CAAEvT,OAAMzK,QAAOsB,SAAQ4b,QAAOC,WACzC,gGCtKO5d,eAAe4e,EAClBhlB,GACA,KAAEsR,EAAI,MAAEzK,EAAK,OAAEsB,EAAM,MAAE4b,EAAQ,EAAC,SAAEC,EAAW,GAC7CiB,GAEA,MAAMtlB,EAAkB,sjBAkBlB,gBACA,8iBAgBN,IACIulB,EADAC,EAAS,EAET7T,aAAgB8T,WAChBF,EAAkB5T,GAElB6T,EAAS,EACTD,EAAkBllB,EAAOqI,cAAc,CACnC1H,MAAO,GAAGskB,EAAiBtkB,wBAC3B+H,UAAW,KACX3G,OAAQ,cACRmD,KAAM,CAAE2B,QAAOsB,UACfrC,MAAOwC,gBAAgBrC,SAAWqC,gBAAgBE,kBAGtDxI,EAAOuF,MAAMwJ,aACT,CAAE3L,QAAS8hB,EAAiBpc,SAAU,GACtCwI,EACA,CAAE+T,YAAqB,EAARxe,EAAY,GAC3B,CAAEA,QAAOsB,SAAQC,mBAAoB,UAEnCpI,EAAOuF,MAAM0D,uBAGvB,MAAMqc,EAAWJ,EAAgB/c,QAAU,EACrCod,EAAoBN,EAC1BM,EAAkBze,gBAAwC,EAAtBC,KAAKC,KAAKse,GAC9CC,EAAkBrgB,KAAO,CAAE2B,MAAOye,EAAUnd,OAAQmd,EAAUld,mBAAoB,GAClFmd,EAAkB7c,UAAY,KAC9B6c,EAAkBzf,OAASwC,gBAAgBia,kBAC3C,MAAMiD,EAAUxlB,EAAOqI,cAAckd,GAE/B5kB,EAAQ,IAAW,WAAWskB,EAAiBtkB,QAC/C2G,EAAkBtH,EAAOU,sBAAsB,CACjDC,QACAC,QAAS,CACL,CACIC,QAAS,EACTuC,QAAS,CAAC,EACVtC,WAAYC,eAAeE,UAE/B,CACIJ,QAAS,EACTsC,QAAS,CAAC,EACVrC,WAAYC,eAAeE,UAE/B,CACIJ,QAAS,EACTK,OAAQ,CAAC,EACTJ,WAAYC,eAAeE,aAKjC4G,EAAS7H,EAAOyC,mBAAmB,CAAE9B,QAAOhB,SAC5CwD,EAAUnD,EAAOyB,cAAc,CAAEd,QAAOyO,UAAW,SAAUD,UAAW,WACxEsW,EAAS,IAAI5b,YAAY,GACzB6b,GAAc,QAAoBD,EAAQ1f,eAAeE,SAAWF,eAAeC,QAAShG,EAAQW,GAEpGyE,EAAYpF,EAAOqF,gBAAgB,CACrC1E,QACAqE,OAAQsC,EACR1G,QAAS,CACL,CAAEC,QAAS,EAAGoE,SAAUigB,EAAgB9b,cACxC,CAAEvI,QAAS,EAAGoE,SAAU9B,GACxB,CAAEtC,QAAS,EAAGoE,SAAU,CAAE/D,OAAQwkB,OAIpCC,EAAiB3lB,EAAOoC,qBAAqB,CAC/CzB,QACA0B,iBAAkB,CAACiF,KAGjBI,EAAW1H,EAAO6c,qBAAqB,CACzClc,QACAqE,OAAQ2gB,EACR7I,OAAQ,CAAEjV,UACVmV,SAAU,CACNnV,SACAoV,QAAS,CAAC,CAAElb,OAAQyjB,EAAQzjB,SAC5BgG,UAAW,CACP6d,MAAO7B,EACP8B,SAAU7B,EACVmB,aAKZ,IAAK,IAAIhc,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC3Bsc,EAAO,GAAKtc,EACZnJ,EAAOuF,MAAMG,YAAYggB,EAAa,EAAGD,EAAQ,EAAG,GAEpD,MAAMjY,EAAOgY,EAAQpc,WAAW,CAC5BV,UAAW,KACXod,gBAAiB,EACjBC,eAAgB5c,EAChBrC,cAAe,IAGb+E,EAAU7L,EAAO4I,uBACjBkD,EAAOD,EAAQqE,gBAAgB,CACjCvP,QACAqlB,iBAAkB,CAAC,CACfxY,OACAyY,OAAQ,QACRC,QAAS,YAIjBpa,EAAKE,YAAYtE,GACjBoE,EAAKG,aAAa,EAAG7G,GACrB0G,EAAKuE,KAAK,GACVvE,EAAKK,MACLnM,EAAOuF,MAAMwD,OAAO,CAAC8C,EAAQ7C,UACjC,CAEA,OAAOwc,CACX,CACOpf,eAAe+f,EAAanmB,EAAmBoD,GAClD,MAAMzD,EAAkB,kIAIlB,qKAQAgB,EAAQ,IAAW,iBAAiByC,EAAQzC,QAE5C2G,EAAkBtH,EAAOU,sBAAsB,CACjDC,QACAC,QAAS,CACL,CACIC,QAAS,EACTuC,QAAS,CAAEC,cAAe,KAAM+iB,WAAY,SAC5CtlB,WAAYC,eAAeE,UAE/B,CACIJ,QAAS,EACTsC,QAAS,CAAC,EACVrC,WAAYC,eAAeE,aAKjColB,EAAkB,CACpB7Y,UAAM4V,EACN6C,OAAQ,QACRC,QAAS,SAGP/iB,EAAUnD,EAAOyB,cAAc,CACjC2N,UAAW,SACXD,UAAW,WAETtH,EAAS7H,EAAOyC,mBAAmB,CAAE9B,QAAOhB,SAC5CgmB,EAAiB3lB,EAAOoC,qBAAqB,CAAEzB,QAAO0B,iBAAkB,CAACiF,KAEzEI,EAAW1H,EAAO6c,qBAAqB,CACzClc,QACAqE,OAAQ2gB,EACR7I,OAAQ,CACJhV,WAAY,KACZD,UAEJmV,SAAU,CACNlV,WAAY,KACZmV,QAAS,CAAC,CAAElb,OAAQqB,EAAQrB,SAC5B8F,YAIRwe,EAAgB7Y,KAAOpK,EAAQgG,WAAW,CAAEtC,cAAe,EAAGuC,aAAc,UACtErJ,EAAOuF,MAAM0D,sBAEnB,IAAK,IAAIE,EAAI,EAAGA,EAAI/F,EAAQ0D,cAAeqC,GAAK,EAAG,CAC/C,MAAM/D,EAAYpF,EAAOqF,gBAAgB,CACrC1E,QACAqE,OAAQsC,EACR1G,QAAS,CACL,CACIC,QAAS,EACToE,SAAUohB,EAAgB7Y,MAE9B,CACI3M,QAAS,EACToE,SAAU9B,MAKtBkjB,EAAgB7Y,KAAOpK,EAAQgG,WAAW,CAAEtC,cAAe,EAAGuC,aAAcF,IAC5E,MAAM0C,EAAU7L,EAAO4I,uBACjBkD,EAAOD,EAAQqE,gBAAgB,CACjCvP,QACAqlB,iBAAkB,CAACK,KAGvBva,EAAKE,YAAYtE,GACjBoE,EAAKG,aAAa,EAAG7G,GACrB0G,EAAKuE,KAAK,GACVvE,EAAKK,MAELnM,EAAOuF,MAAMwD,OAAO,CAAC8C,EAAQ7C,iBACvBhJ,EAAOuF,MAAM0D,qBACvB,CACJ,CAEO,SAASqd,EAAoBtmB,EAAmBoD,GACnD,MAAMzD,EAAkB,oIAIlB,mhBAkBAgB,EAAQ,IAAW,iBAAiByC,EAAQzC,QAE5CuE,EAAO,CAAE2B,MAAOzD,EAAQyD,MAAOsB,OAAQ/E,EAAQ+E,QAE/Coe,EAAcvmB,EAAOqI,cAAc,CACrCtG,OAAQqB,EAAQrB,OAChB+D,MAAOwC,gBAAgBrC,SAAWqC,gBAAgBE,gBAClDtD,SAGEoC,EAAkBtH,EAAOU,sBAAsB,CACjDC,QACAC,QAAS,CACL,CACIC,QAAS,EACTuC,QAAS,CAAC,EACVtC,WAAYC,eAAeE,UAE/B,CACIJ,QAAS,EACTsC,QAAS,CAAC,EACVrC,WAAYC,eAAeE,aAKjCkC,EAAUnD,EAAOyB,cAAc,CACjC2N,UAAW,SACXD,UAAW,WAGTtH,EAAS7H,EAAOyC,mBAAmB,CAAE9B,QAAOhB,KAAMA,IAClDgmB,EAAiB3lB,EAAOoC,qBAAqB,CAAEzB,QAAO0B,iBAAkB,CAACiF,KAEzEI,EAAW1H,EAAO6c,qBAAqB,CACzClc,QACAqE,OAAQ2gB,EACR7I,OAAQ,CACJhV,WAAY,KACZD,UAEJmV,SAAU,CACNlV,WAAY,KACZmV,QAAS,CAAC,CAAElb,OAAQqB,EAAQrB,SAC5B8F,YAIFzC,EAAYpF,EAAOqF,gBAAgB,CACrC1E,QACAqE,OAAQsC,EACR1G,QAAS,CACL,CACIC,QAAS,EACToE,SAAUshB,EAAYnd,cAE1B,CACIvI,QAAS,EACToE,SAAU9B,MAKhB0I,EAAU7L,EAAO4I,uBACvBiD,EAAQhD,qBACJ,CAAEzF,WACF,CAAEA,QAASmjB,GACXrhB,GAGJ,MAAM4G,EAAOD,EAAQqE,gBAAgB,CACjCvP,QACAqlB,iBAAkB,CAAC,CACfxY,KAAMpK,EAAQgG,WAAW,CAAEtC,cAAe,EAAGuC,aAAc,IAC3D4c,OAAQ,QACRC,QAAS,YAIjBpa,EAAKE,YAAYtE,GACjBoE,EAAKG,aAAa,EAAG7G,GACrB0G,EAAKuE,KAAK,GACVvE,EAAKK,MAELnM,EAAOuF,MAAMwD,OAAO,CAAC8C,EAAQ7C,UACjC","sources":["webpack://cbunt-portfolio/./src/utils/shader.ts","webpack://cbunt-portfolio/./src/shaders/forward.shader.ts","webpack://cbunt-portfolio/./src/rendering/default-forward-pass/descriptor-map.ts","webpack://cbunt-portfolio/./src/rendering/default-forward-pass/pipeline-feature-flags.ts","webpack://cbunt-portfolio/./src/rendering/global-uniforms.ts","webpack://cbunt-portfolio/./src/samples/cubemap-blur/cubemap-guassian-pyramid.ts","webpack://cbunt-portfolio/./src/samples/gltf-viewer/gltf-viewer-sample.ts","webpack://cbunt-portfolio/./src/samples/gltf-viewer/loader/weld.ts","webpack://cbunt-portfolio/./src/rendering/default-forward-pass/primitive-draw-data.ts","webpack://cbunt-portfolio/./src/samples/gltf-viewer/loader/type-conversions.ts","webpack://cbunt-portfolio/./src/samples/gltf-viewer/loader/attribute-wrapper.ts","webpack://cbunt-portfolio/./src/samples/gltf-viewer/loader/primitive-loader.ts","webpack://cbunt-portfolio/./src/samples/gltf-viewer/loader/interleave-vertices.ts","webpack://cbunt-portfolio/./src/samples/gltf-viewer/loader/material-loader.ts","webpack://cbunt-portfolio/./src/rendering/default-forward-pass/material-draw-data.ts","webpack://cbunt-portfolio/./src/rendering/default-forward-pass/geometry-pipeline.ts","webpack://cbunt-portfolio/./src/samples/gltf-viewer/loader/gltf-loader.ts","webpack://cbunt-portfolio/./src/samples/settings/skybox-options.ts","webpack://cbunt-portfolio/./src/shaders/blit-vert.shader.ts","webpack://cbunt-portfolio/./src/shaders/cubemap-sampling.shader.ts","webpack://cbunt-portfolio/./src/utils/data-copy.ts","webpack://cbunt-portfolio/./src/utils/data-conversion.ts","webpack://cbunt-portfolio/./src/utils/texture-importing.ts","webpack://cbunt-portfolio/./src/utils/texture-processing.ts"],"sourcesContent":["export type Branch = string | (() => string);\r\n\r\nfunction resolveBranch(branch: Branch) {\r\n    return typeof branch === 'string' ? branch : branch();\r\n}\r\n\r\nclass PreprocessorStatement {\r\n    res?: string;\r\n\r\n    constructor(cond: boolean, branch: Branch) {\r\n        if (cond) this.res = resolveBranch(branch);\r\n    }\r\n\r\n    elif(cond: boolean, branch: Branch) {\r\n        if (cond) this.res ??= resolveBranch(branch);\r\n        return this;\r\n    }\r\n\r\n    else = (branch: Branch) => this.res ?? resolveBranch(branch);\r\n\r\n    toString = () => this.res ?? '';\r\n\r\n    get [Symbol.toStringTag]() { return this.toString(); }\r\n}\r\n\r\nexport function preprocessors(flags: number) {\r\n    return {\r\n        ifdef(sym: number, branch: Branch) {\r\n            return new PreprocessorStatement((flags & sym) === sym, branch);\r\n        },\r\n        ifndef(sym: number, branch: Branch) {\r\n            return new PreprocessorStatement((flags & sym) !== sym, branch);\r\n        },\r\n    };\r\n}\r\n\r\nexport function wrapWithIncrement<T>(fn: (counter: number) => T, start = 0): () => T {\r\n    return () => fn(start++);\r\n}\r\n","/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\nimport { PipelineFeatureFlags, featureFlagsToString } from '../rendering/default-forward-pass/pipeline-feature-flags';\nimport { preprocessors, wrapWithIncrement } from '../utils/shader';\nimport GlobalUniforms from '../rendering/global-uniforms';\nimport { GBufferGroupIndices } from '../rendering/gbuffer';\n\nexport function getBindgroupInfo(flags: PipelineFeatureFlags): GPUBindGroupLayoutDescriptor {\n    const entries: GPUBindGroupLayoutEntry[] = [];\n\n    function pushItem(item: Omit<GPUBindGroupLayoutEntry, 'binding' | 'visibility'>) {\n        entries.push({ ...item, binding: entries.length, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX });\n    }\n\n    pushItem({ buffer: { type: 'uniform' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n\n    if (flags & PipelineFeatureFlags.Emissive) {\n        pushItem({ sampler: {} });\n        pushItem({ texture: { viewDimension: '2d' } });\n    }\n\n    return { label: featureFlagsToString(flags), entries };\n}\n\n/**\n * @param flags A flag enum containing the features this code should be generated for\n * @returns A string containing preprocessed wgsl shader code for the given features\n */\nexport default function include(flags: PipelineFeatureFlags) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { ifdef } = preprocessors(flags as number);\n    const vertexInLocation = wrapWithIncrement((idx) => /* wgsl */`@location(${idx})`);\n    const varyingsLocation = wrapWithIncrement((idx) => /* wgsl */`@location(${idx})`);\n\n    const materialBinding = wrapWithIncrement((idx) => /* wgsl */`\n        @group(1) @binding(${idx})\n    `);\n\n    const varyings = /* wgsl */`\n        ${varyingsLocation()} pos: vec3f,\n        ${varyingsLocation()} camPos: vec3f,\n        ${varyingsLocation()} uv: vec2f,\n\n        ${ifdef(PipelineFeatureFlags.VertexNormals, () => /* wgsl */`\n            ${varyingsLocation()} tangent: vec4f,\n            ${varyingsLocation()} normal: vec3f,\n        `)}\n\n        ${ifdef(PipelineFeatureFlags.VertexColors, () => /* wgsl */`\n            ${varyingsLocation()} color: vec4f,\n        `)}\n    `;\n\n    return /* wgsl */`\n        ${GlobalUniforms.code(0)}\n\n        struct ForwardOut {\n            @location(${GBufferGroupIndices.Normal}) normal: vec4f,\n            @location(${GBufferGroupIndices.Albedo}) albedo: vec4f,\n            @location(${GBufferGroupIndices.Emission}) emission: vec4f,\n            @location(${GBufferGroupIndices.MetallicRoughness}) metallicRoughness: vec4f,\n        }\n\n        struct MaterialProperties {\n            baseColorFactor: vec4f,\n            metallicFactor: f32,\n            roughnessFactor: f32,\n\n            ${ifdef(PipelineFeatureFlags.AlphaCutoff, 'alphaCutoff: f32,')}\n            ${ifdef(PipelineFeatureFlags.Emissive, 'emissiveFactor: vec3f,')}\n        }\n\n        ${materialBinding()} var<uniform> material: MaterialProperties;\n\n        ${materialBinding()} var baseColorSampler: sampler;\n        ${materialBinding()} var baseColorTexture: texture_2d<f32>;\n\n        ${materialBinding()} var normalSampler: sampler;\n        ${materialBinding()} var normalTexture: texture_2d<f32>;\n\n        ${materialBinding()} var metallicRoughnessSampler: sampler;\n        ${materialBinding()} var metallicRoughnessTexture: texture_2d<f32>;\n\n        ${ifdef(PipelineFeatureFlags.Emissive, () => /* wgsl */`\n            ${materialBinding()} var emissionSampler: sampler;\n            ${materialBinding()} var emissionTexture: texture_2d<f32>;\n        `)}\n\n        struct ModelProperties {\n            modelToWorldMatrix: mat4x4f,\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, 'normalMatrix: mat3x3f,')}\n        }\n\n        @group(2) @binding(0) var<storage, read> instances : array<ModelProperties>;\n\n        struct VertIn {\n            @builtin(instance_index) instance: u32,\n            ${vertexInLocation()} pos: vec3f,\n            ${vertexInLocation()} uv: vec2f,\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, () => /* wgsl */`\n                ${vertexInLocation()} tangent: vec4f,\n                ${vertexInLocation()} normal: vec3f,\n            `)}\n\n            ${ifdef(PipelineFeatureFlags.VertexColors, () => /* wgsl */`\n                ${vertexInLocation()} color: vec4f,\n            `)}\n        }\n\n        struct VertOut {\n            ${varyings}\n            @builtin(position) Position: vec4f,\n        }\n\n        struct FragIn {\n            ${varyings}\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals | PipelineFeatureFlags.DoubleSided, /* wgsl */`\n                @builtin(front_facing) front_facing: bool,\n            `)}\n        }\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @vertex \n        fn vs(inData: VertIn) -> VertOut {\n            var vsOut: VertOut;\n            let instance = instances[inData.instance];\n            let worldPos = instance.modelToWorldMatrix * vec4f(inData.pos, 1);\n            vsOut.pos = worldPos.xyz;\n            vsOut.Position = globals.worldToClip * worldPos;\n            vsOut.camPos = globals.inverseWorldToView[3].xyz;\n            vsOut.uv = inData.uv;\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, /* wgsl */`\n                vsOut.normal = normalize(instance.normalMatrix * inData.normal);\n                let wsTangent = normalize((instance.modelToWorldMatrix * vec4(inData.tangent.xyz, 0.0)).xyz);\n                vsOut.tangent = vec4(wsTangent, inData.tangent.w);\n            `)}\n\n            return vsOut;\n        }\n\n        // much of this code is adapted from https://learnopengl.com/PBR\n        @fragment\n        fn fs(inData: FragIn) -> ForwardOut {\n            var out: ForwardOut;\n            let rawColor = textureSample(baseColorTexture, baseColorSampler, inData.uv);\n\n            ${ifdef(PipelineFeatureFlags.AlphaCutoff, /* wgsl */`\n                var alpha = rawColor.a * material.baseColorFactor.a;\n\n                ${ifdef(PipelineFeatureFlags.VertexColors, /* wgsl */`\n                    alpha *= inData.color.a;\n                `)}\n\n                if (alpha <= material.alphaCutoff) { \n                    discard;\n                }\n            `)}\n\n            out.albedo = vec4f(rawColor.rgb * material.baseColorFactor.rgb, 1);\n\n            ${ifdef(PipelineFeatureFlags.VertexColors, /* wgsl */`\n                out.albedo *= vec4f(inData.color.rgb, 1);\n            `)}\n\n            let metallicRoughness = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, inData.uv);\n            out.metallicRoughness.r = saturate(metallicRoughness.b * material.metallicFactor);\n            out.metallicRoughness.g = saturate(metallicRoughness.g * material.roughnessFactor);\n\n            ${ifdef(PipelineFeatureFlags.VertexNormals, /* wgsl */`\n                let normalSample = textureSample(normalTexture, normalSampler, inData.uv).xyz;\n                let tangentNormal = normalize(normalSample * 2.0 - 1.0);\n                let bitangent =inData.tangent.w * cross(inData.normal, inData.tangent.xyz);\n                let tbn = mat3x3f(normalize(inData.tangent.xyz), bitangent, normalize(inData.normal));\n                var normal = normalize(tbn * tangentNormal);\n\n                ${ifdef(PipelineFeatureFlags.DoubleSided, /* wgsl */`\n                    if (!inData.front_facing) { normal *= -1.0; }\n                `)}\n            `).else(/* wgsl */`\n                let fdx = dpdx(inData.pos);\n                let fdy = dpdy(inData.pos);\n                let normal = normalize(cross(fdy, fdx));\n            `)}\n\n            out.normal = vec4f(normal, 1);\n\n            ${ifdef(PipelineFeatureFlags.Emissive, /* wgsl */`\n                let emission = textureSample(emissionTexture, emissionSampler, inData.uv).rgb;\n                out.emission = vec4f(emission, 1);\n            `)}\n\n            return out;\n        }\n    `;\n}\n","import { PipelineFeatureFlags } from './pipeline-feature-flags';\nimport * as PipelineFeatures from './pipeline-feature-flags';\nimport include, { getBindgroupInfo as getBindGroupInfo } from '../../shaders/forward.shader';\n\nimport GBuffer from '../gbuffer';\nimport GlobalUniforms from '../global-uniforms';\n\ntype PipelineFeatureMap<T> = Partial<Record<number, T>>;\n\nexport default class DescriptorMap {\n    static readonly flagToTopology: Partial<Record<PipelineFeatureFlags, GPUPrimitiveTopology>> = {\n        [PipelineFeatureFlags.TriangleList]: 'triangle-list',\n        [PipelineFeatureFlags.TriangleStrip]: 'triangle-strip',\n        [PipelineFeatureFlags.PointList]: 'point-list',\n        [PipelineFeatureFlags.LineList]: 'line-list',\n        [PipelineFeatureFlags.LineStrip]: 'line-strip',\n    };\n\n    readonly pipelineLayouts: PipelineFeatureMap<GPUPipelineLayout> = {};\n    readonly primitiveStates: PipelineFeatureMap<GPUPrimitiveState> = {};\n    readonly vertexLayouts: PipelineFeatureMap<GPUVertexBufferLayout> = {};\n    readonly shaderModules: PipelineFeatureMap<GPUShaderModule> = {};\n    readonly bindgroupLayouts: PipelineFeatureMap<GPUBindGroupLayout> = {};\n\n    readonly samplers: Partial<Record<string, GPUSampler>> = {};\n\n    readonly forwardBindgroupLayout = this.device.createBindGroupLayout({\n        label: `forward material`,\n        entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n            buffer: { type: 'read-only-storage' },\n        }],\n    });\n\n    constructor(\n        public readonly device: GPUDevice,\n        public readonly gbuffer: GBuffer,\n        public readonly globals: GlobalUniforms,\n    ) { }\n\n    getSampler(descriptor: GPUSamplerDescriptor) {\n        const key = JSON.stringify(descriptor);\n        this.samplers[key] ??= this.device.createSampler(descriptor);\n        return this.samplers[key];\n    }\n\n    getVertexLayout(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.VertexBufferLayoutMask;\n\n        if (this.vertexLayouts[masked] == null) {\n            const attributes: GPUVertexAttribute[] = [\n                { shaderLocation: 0, offset: 0, format: 'float32x3' }, // position\n                { shaderLocation: 1, offset: 12, format: 'float32x2' }, // uv\n            ];\n\n            let arrayStride = 20;\n            let shaderLocation = 2;\n\n            if (masked & PipelineFeatureFlags.VertexNormals) {\n                attributes.push({ shaderLocation, offset: arrayStride, format: 'float32x4' }); // tangent\n                attributes.push({ shaderLocation: shaderLocation + 1, offset: arrayStride + 16, format: 'float32x3' }); // normal\n                shaderLocation += 2;\n                arrayStride += 28;\n            }\n\n            if (masked & PipelineFeatureFlags.VertexColors) {\n                attributes.push({ shaderLocation, offset: arrayStride, format: 'float32x4' }); // color\n                arrayStride += 16;\n            }\n\n            this.vertexLayouts[masked] = { attributes, arrayStride, stepMode: 'vertex' };\n        }\n\n        return this.vertexLayouts[masked];\n    }\n\n    getForwardPipelineLayout(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.PipelineLayoutMask;\n\n        this.pipelineLayouts[masked] ??= this.device.createPipelineLayout({\n            label: PipelineFeatures.featureFlagsToString(masked),\n            bindGroupLayouts: [\n                this.globals.bindGroupLayout,\n                this.getMaterialBindGroup(flags),\n                this.forwardBindgroupLayout,\n            ],\n        });\n\n        return this.pipelineLayouts[masked];\n    }\n\n    getShaderModule(flags: PipelineFeatureFlags) {\n        const masked: PipelineFeatureFlags = flags & PipelineFeatures.CodeMask;\n        this.shaderModules[masked] ??= this.device.createShaderModule({\n            label: PipelineFeatures.featureFlagsToString(masked),\n            code: include(masked),\n        });\n        return this.shaderModules[masked];\n    }\n\n    getPrimitiveState(flags: PipelineFeatureFlags) {\n        const masked = flags & PipelineFeatures.PrimitiveStateMask;\n\n        this.primitiveStates[masked] ??= {\n            topology: DescriptorMap.flagToTopology[(flags & PipelineFeatures.TopologyFormatMask) as PipelineFeatureFlags],\n            cullMode: masked & PipelineFeatureFlags.DoubleSided ? 'none' : 'back',\n            frontFace: masked & PipelineFeatureFlags.ClockwiseWinding ? 'cw' : 'ccw',\n        };\n\n        return this.primitiveStates[masked];\n    }\n\n    getMaterialBindGroup(flags: PipelineFeatureFlags) {\n        const masked = flags & PipelineFeatures.MaterialBindgroupLayoutMask;\n        this.bindgroupLayouts[masked] ??= this.device.createBindGroupLayout(getBindGroupInfo(masked));\n        return this.bindgroupLayouts[masked];\n    }\n}\n","export enum PipelineFeatureFlags {\n    Defaults = 0,\n\n    /**\n     * If the meshes have vertex normals.\n     * If absent, meshes are shaded with flat normals.\n    */\n    VertexNormals = 1 << 0,\n\n    /**\n     * If the meshes have vertex colors.\n     * If absent, mesh is shaded with a base color texture.\n    */\n    VertexColors = 1 << 1,\n\n    AlphaCutoff = 1 << 2,\n    Emissive = 1 << 3,\n\n    DoubleSided = 1 << 4,\n    ClockwiseWinding = 1 << 5,\n\n    // Topology formats\n    TriangleList = 0 << 6,\n    TriangleStrip = 1 << 6,\n    PointList = 2 << 6,\n    LineList = 3 << 6,\n    LineStrip = 4 << 6,\n    Unindexed = 5 << 6,\n    // LINE_LOOP (currently unsupported by webgpu)\n    // TRIANGLE_FAN (currently unsupported by webgpu)\n}\n\nexport const TopologyFormatMask = 0x111 << 6;\n\nexport const PrimitiveStateMask = (\n    TopologyFormatMask\n    | PipelineFeatureFlags.DoubleSided\n    | PipelineFeatureFlags.ClockwiseWinding\n);\n\nexport const CodeMask = ~(\n    TopologyFormatMask\n    | PipelineFeatureFlags.ClockwiseWinding\n);\n\nexport const InstanceBufferLayoutMask = (\n    PipelineFeatureFlags.VertexNormals\n);\n\nexport const VertexBufferLayoutMask = (\n    PipelineFeatureFlags.VertexNormals\n    | PipelineFeatureFlags.VertexColors\n);\n\nexport const MaterialBufferLayoutMask = (\n    PipelineFeatureFlags.AlphaCutoff\n);\n\nexport const MaterialBindgroupLayoutMask = (\n    MaterialBufferLayoutMask\n    | PipelineFeatureFlags.Emissive\n);\n\nexport const MaterialMask = (\n    MaterialBindgroupLayoutMask\n    | PipelineFeatureFlags.DoubleSided\n);\n\nexport const PipelineLayoutMask = (\n    InstanceBufferLayoutMask\n    | MaterialMask\n);\n\nexport function featureFlagsToNames(val: number) {\n    return Object.entries(PipelineFeatureFlags)\n        .flatMap(([key, flag]) => typeof flag === 'number' && (flag & val) ? key : []);\n}\n\nexport function featureFlagsToString(val: number) {\n    return featureFlagsToNames(val).toString();\n}\n\nexport function maskRedundantFeatures(flags: PipelineFeatureFlags) {\n    let masked = flags;\n    if (masked & PipelineFeatureFlags.DoubleSided) masked &= ~PipelineFeatureFlags.ClockwiseWinding;\n    return masked;\n}\n","import Camera from './camera/camera';\r\n\r\nconst label = 'global uniforms';\r\n\r\nexport default class GlobalUniforms {\r\n    static readonly code = (group: number) => /* wgsl */`\r\n        struct GlobalUniforms {\r\n            worldToView: mat4x4f,\r\n            viewToClip: mat4x4f,\r\n            worldToClip: mat4x4f,\r\n            inverseWorldToView: mat4x4f,\r\n            inverseViewToClip: mat4x4f,\r\n            inverseWorldToClip: mat4x4f,\r\n        }\r\n\r\n        @group(${group}) @binding(0) var<uniform> globals: GlobalUniforms;\r\n    `;\r\n\r\n    static readonly bufferSize = Camera.bufferLength;\r\n\r\n    static readonly layoutDescriptor: GPUBindGroupLayoutDescriptor = {\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                buffer: { minBindingSize: GlobalUniforms.bufferSize },\r\n                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\r\n            },\r\n        ],\r\n    };\r\n\r\n    static readonly bufferDescriptor: GPUBufferDescriptor = {\r\n        label,\r\n        size: GlobalUniforms.bufferSize,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    };\r\n\r\n    deviceBuffer: GPUBuffer;\r\n    bindGroupLayout: GPUBindGroupLayout;\r\n    bindGroupDescriptor!: GPUBindGroupDescriptor;\r\n    bindgroup!: GPUBindGroup;\r\n\r\n    constructor(device: GPUDevice) {\r\n        this.deviceBuffer = device.createBuffer(GlobalUniforms.bufferDescriptor);\r\n        this.bindGroupLayout = device.createBindGroupLayout(GlobalUniforms.layoutDescriptor);\r\n\r\n        this.bindGroupDescriptor = {\r\n            label,\r\n            layout: this.bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.deviceBuffer,\r\n                        offset: 0,\r\n                        size: GlobalUniforms.bufferSize,\r\n                    },\r\n                },\r\n            ],\r\n        };\r\n\r\n        this.bindgroup = device.createBindGroup(this.bindGroupDescriptor);\r\n    }\r\n\r\n    updateDeviceBuffer(queue: GPUQueue, camera: Camera) {\r\n        camera.cacheView();\r\n        queue.writeBuffer(this.deviceBuffer, 0, camera.buffer);\r\n    }\r\n}\r\n","/* eslint @stylistic/max-len: \"error\" */\r\n\r\nimport {\r\n    toWorldDir,\r\n    cubemapSampleConversions,\r\n} from '../../shaders/cubemap-sampling.shader';\r\n\r\nimport { createAndCopyBuffer } from '../../utils/data-copy';\r\nimport { mapRange } from '../../utils/general';\r\n\r\nconst createMipBlurCode = (\r\n    groups: number,\r\n    format: GPUTextureFormat,\r\n) => /* wgsl */`\r\n    ${cubemapSampleConversions}\r\n    ${toWorldDir}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    struct Params {\r\n        offset: u32,\r\n        sigmas: array<f32>,\r\n    }\r\n\r\n    @group(0) @binding(0) var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    // sigma[0] reserved for work offset\r\n    @group(0) @binding(2) var<storage> params: Params;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + params.offset;\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = toWorldDir(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&params.sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = params.sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = toWorldDir(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\r\n\r\n/**\r\n *  the minimum angular distance between any pixel on a cubemap\r\n *  of the given face width and any pixel lying on a perimeter\r\n *  the given number of steps away\r\n */\r\nfunction minStepDistance(steps: number, width: number) {\r\n    // the angular distance\r\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\r\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\r\n\r\n    // It's likely possible to programmatically determine whether the\r\n    // destination pixel should be v = 0 or v = 1, but checking both works fine\r\n\r\n    const nextMipWidth = width >> 1;\r\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\r\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\r\n    const baseUN = (1 / nextMipWidth) - 1;\r\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\r\n\r\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\r\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\r\n    const samp0VN = (1 / width) - 1;\r\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\r\n    const samp1VN = (3 / width) - 1;\r\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\r\n\r\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN)\r\n        / Math.sqrt(samp0Mag2 * baseMag2);\r\n\r\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN)\r\n        / Math.sqrt(samp1Mag2 * baseMag2);\r\n\r\n    return Math.min(1 - dot0, 1 - dot1);\r\n}\r\n\r\nexport type GaussianPyramidDescriptor = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n\r\n    /**\r\n     *  If the pyramid should overwrite the existing mips\r\n     *  of the given texture\r\n     *\r\n     *  @defaultValue `false`\r\n     */\r\n    inPlace?: boolean,\r\n\r\n    /**\r\n     *  The maximum width of the smallest mip level.\r\n     *\r\n     *  @defaultValue `8`\r\n     */\r\n    minWidth?: number,\r\n\r\n    /**\r\n     *  The kernel extent distance, in pixels.\r\n     *\r\n     *  @defaultValue `4`\r\n     */\r\n    steps?: number,\r\n\r\n    /**\r\n     *  A function to delay the processing of additional pixels,\r\n     *  e.g. `requestAnimationFrame`. Spaces work to allow additional\r\n     *  rendering and interactivity during heavy blurring workloads.\r\n     *\r\n     *  If undefined, all pixels are processed at once.\r\n     */\r\n    delayWork?: (fn: () => Promise<void> | void) => void,\r\n\r\n    /**\r\n     *  The maximum number of pixels to process within a batch.\r\n     *  Unused if `delayWork` is undefined.\r\n     *\r\n     *  @defaultValue 6 * ((17 * 256) ** 2)\r\n     *\r\n     *  Allowing cubemap 256 pixels in width with `steps = 8` to run\r\n     *  in a single pass. This is a conservatively low default for\r\n     *  compatibility with lower-end hardware.\r\n     */\r\n    maxOpsPerPass?: number,\r\n\r\n    /**\r\n     *  A prefix string for error message thrown from the function\r\n     *\r\n     *  @defaultValue `cubemapGuassianPyramid --`\r\n     */\r\n    label?: string,\r\n\r\n    /**\r\n     *  The label to pass the output GPUTexture.\r\n     *\r\n     *  Unused if `inPlace == true`\r\n     */\r\n    outputTextureLabel?: string,\r\n};\r\n\r\nexport default async function cubemapGuassianPyramid({\r\n    device,\r\n    texture,\r\n    outputTextureLabel,\r\n    inPlace = false,\r\n    minWidth = 8,\r\n    steps = 4,\r\n    maxOpsPerPass = 6 * ((17 * 256) ** 2),\r\n    label = cubemapGuassianPyramid.name,\r\n    delayWork,\r\n}: GaussianPyramidDescriptor) {\r\n    const { width, format } = texture;\r\n    const mipLevelCount = inPlace\r\n        ? texture.mipLevelCount\r\n        : (Math.log2(width) - Math.log2(minWidth) + 1);\r\n\r\n    if (mipLevelCount <= 1) return texture;\r\n\r\n    const groups = Math.min(\r\n        device.limits.maxComputeWorkgroupSizeX,\r\n        device.limits.maxComputeInvocationsPerWorkgroup,\r\n    );\r\n    const shader = device.createShaderModule({\r\n        label,\r\n        code: createMipBlurCode(groups, format),\r\n    });\r\n\r\n    const bindgroupLayout = device.createBindGroupLayout({\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                texture: { viewDimension: '2d-array' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 1,\r\n                storageTexture: {\r\n                    access: 'write-only',\r\n                    viewDimension: '2d-array',\r\n                    format,\r\n                },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 2,\r\n                buffer: { type: 'read-only-storage' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n        ],\r\n    });\r\n\r\n    const pipeline = device.createComputePipeline({\r\n        label,\r\n        layout: device.createPipelineLayout({\r\n            label,\r\n            bindGroupLayouts: [bindgroupLayout],\r\n        }),\r\n        compute: {\r\n            module: shader,\r\n            entryPoint: 'main',\r\n            constants: { STEPS: Math.ceil(steps) },\r\n        },\r\n    });\r\n\r\n    let gaussianPyramid = texture;\r\n    if (!inPlace) {\r\n        const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n        gaussianPyramid = device.createTexture({\r\n            label: outputTextureLabel,\r\n            usage: GPUTextureUsage.STORAGE_BINDING\r\n                | GPUTextureUsage.TEXTURE_BINDING\r\n                | GPUTextureUsage.COPY_SRC\r\n                | GPUTextureUsage.COPY_DST,\r\n            dimension: '2d',\r\n            format,\r\n            mipLevelCount,\r\n            size,\r\n        });\r\n\r\n        const copyEncoder = device.createCommandEncoder({\r\n            label: `${label} copy encoder`,\r\n        });\r\n\r\n        copyEncoder.copyTextureToTexture(\r\n            { texture, mipLevel: 0 },\r\n            { texture: gaussianPyramid, mipLevel: 0 },\r\n            size,\r\n        );\r\n\r\n        device.queue.submit([copyEncoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n\r\n    const mipViews = mapRange(mipLevelCount, (i) => gaussianPyramid.createView({\r\n        label: `${label} mip view ${i}`,\r\n        dimension: '2d-array',\r\n        baseMipLevel: i,\r\n        mipLevelCount: 1,\r\n    }));\r\n\r\n    const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\r\n    const maxLayers = Math.ceil(Math.log2(width));\r\n    const maxDispatches = Math.max(\r\n        (maxOpsPerPass / (((1 + (steps * 2)) ** 2) * groups)) | 0,\r\n        1,\r\n    );\r\n\r\n    const propertyArray = new ArrayBuffer((maxLayers + 1) * 4);\r\n    const offset = new Uint32Array(propertyArray, 0, 1);\r\n    const simgas = new Float32Array(propertyArray, 4, maxLayers);\r\n\r\n    simgas.set(mapRange(maxLayers, (i) => {\r\n        const w = width >> i;\r\n        return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\r\n    }));\r\n\r\n    const propertyBuffer = createAndCopyBuffer(\r\n        propertyArray,\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        device,\r\n    );\r\n\r\n    await new Promise<void>((resolve) => {\r\n        let mipLevel = 0;\r\n        let mipPasses = 0;\r\n        let requiredMipDispatches = 0;\r\n        let currentMipDispatches = 0;\r\n        let batchDispatches = 0;\r\n        let bindgroup: GPUBindGroup;\r\n\r\n        async function runPass() {\r\n            if (currentMipDispatches >= requiredMipDispatches) {\r\n                mipLevel += 1;\r\n                currentMipDispatches = 0;\r\n                mipPasses = 0;\r\n\r\n                if (mipLevel >= mipLevelCount) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n\r\n                const mipPixels = 6 * ((width >> mipLevel) ** 2);\r\n                requiredMipDispatches = Math.ceil(mipPixels / groups);\r\n\r\n                bindgroup = device.createBindGroup({\r\n                    layout: bindgroupLayout,\r\n                    entries: [\r\n                        {\r\n                            binding: 0,\r\n                            resource: mipViews[mipLevel - 1],\r\n                        },\r\n                        {\r\n                            binding: 1,\r\n                            resource: mipViews[mipLevel],\r\n                        },\r\n                        {\r\n                            binding: 2,\r\n                            resource: { buffer: propertyBuffer },\r\n                        },\r\n                    ],\r\n                });\r\n            }\r\n\r\n            offset[0] = currentMipDispatches * groups;\r\n            device.queue.writeBuffer(propertyBuffer, 0, offset);\r\n\r\n            const passDispatches = Math.min(\r\n                requiredMipDispatches - currentMipDispatches,\r\n                maxDispatches - batchDispatches,\r\n                maxWorkgroups,\r\n            );\r\n\r\n            const passLabel = `${label} mip ${mipLevel}, pass ${mipPasses}`;\r\n            const encoder = device.createCommandEncoder({ label: passLabel });\r\n            const pass = encoder.beginComputePass({ label: passLabel });\r\n\r\n            pass.setPipeline(pipeline);\r\n            pass.setBindGroup(0, bindgroup);\r\n            pass.dispatchWorkgroups(passDispatches, 1, 1);\r\n            pass.end();\r\n\r\n            device.queue.submit([encoder.finish()]);\r\n\r\n            currentMipDispatches += passDispatches;\r\n            batchDispatches += passDispatches;\r\n            mipPasses += 1;\r\n\r\n            if (delayWork != null && batchDispatches >= maxDispatches) {\r\n                batchDispatches = 0;\r\n                await device.queue.onSubmittedWorkDone();\r\n                delayWork(runPass);\r\n            } else {\r\n                void runPass();\r\n            }\r\n        }\r\n\r\n        void runPass();\r\n    });\r\n\r\n    return gaussianPyramid;\r\n}\r\n","import { FullRenderModel } from '../settings/sample-spec';\nimport propertyListener, { ListenerSyms } from '../settings/property-listener';\nimport getSkyboxOptions from '../settings/skybox-options';\n\nimport GeometryPipeline from '../../rendering/default-forward-pass/geometry-pipeline';\nimport DescriptorMap from '../../rendering/default-forward-pass/descriptor-map';\nimport Renderer, { ForwardPassParams } from '../../rendering/renderer';\nimport { MaterialDescriptor } from '../../rendering/default-forward-pass/material-draw-data';\nimport { PipelineFeatureFlags } from '../../rendering/default-forward-pass/pipeline-feature-flags';\n\nimport cubemapGuassianPyramid from '../cubemap-blur/cubemap-guassian-pyramid';\n\nimport { AttributeDetails, ComponentType } from './loader/type-conversions';\nimport importGltf from './loader/gltf-loader';\nimport { DataType } from '@loaders.gl/core';\nimport { isObject } from '../../utils/general';\n\nconst gltfIndex = await getGltfIndex();\n\nasync function getGltfIndex() {\n    const indexUrl = GLTF_BASE_URL__ + GLTF_INDEX_FILE__;\n    const indexRes = await fetch(indexUrl);\n    const indexStr = await indexRes.text();\n    const indexJson = JSON.parse(indexStr) as unknown;\n\n    if (!Array.isArray(indexJson)) {\n        throw new Error('could not load gtlf model index');\n    }\n\n    const entries: [string, string][] = indexJson.flatMap((gltf: unknown) => {\n        if (\n            !isObject(gltf)\n            || !('label' in gltf)\n            || typeof gltf.label !== 'string'\n            || !('name' in gltf)\n            || typeof gltf.name !== 'string'\n            || !('variants' in gltf)\n            || !isObject(gltf.variants)\n            || typeof gltf.variants.glTF !== 'string'\n        ) return [];\n\n        const { variants: { glTF: file }, label, name } = gltf;\n        const path = `${GLTF_BASE_URL__}${name}/glTF/${file}`;\n        return [[label, path]];\n    });\n\n    return Object.fromEntries(entries);\n}\n\nexport default class GltfModel implements FullRenderModel {\n    static readonly title = 'glTF Model Viewer';\n    static readonly description = '';\n\n    static readonly goalLayout: AttributeDetails[] = [\n        {\n            name: 'POSITION',\n            type: 'VEC3',\n            componentType: ComponentType.float32,\n        },\n        {\n            name: 'TEXCOORD_0',\n            type: 'VEC2',\n            componentType: ComponentType.float32,\n        },\n        {\n            name: 'TANGENT',\n            type: 'VEC4',\n            componentType: ComponentType.float32,\n            depends: ['NORMAL'],\n            fill: [1, 0, 0, 1],\n        },\n        {\n            name: 'NORMAL',\n            type: 'VEC3',\n            componentType: ComponentType.float32,\n            strip: true,\n            feature: PipelineFeatureFlags.VertexNormals,\n        },\n        {\n            name: 'COLOR_0',\n            type: 'VEC4',\n            componentType: ComponentType.float32,\n            strip: true,\n            feature: PipelineFeatureFlags.VertexColors,\n            fill: [1, 1, 1, 1],\n        },\n    ];\n\n    geometryPipelines: Partial<Record<number, GeometryPipeline>> = {};\n    descriptorMap: DescriptorMap;\n    device: GPUDevice;\n\n    get depthTextureView() {\n        return this.descriptorMap.gbuffer.depth.view;\n    }\n\n    readonly #settings = propertyListener({\n        skybox: getSkyboxOptions(this),\n        model: {\n            [ListenerSyms.$type]: 'file' as const,\n            [ListenerSyms.$callback]: (val: unknown, key: PropertyKey) => {\n                if (key !== 'value' || val == null) return;\n                if (typeof val === 'string' || val instanceof File) {\n                    void this.setModel(val);\n                }\n            },\n            accept: '.hdr',\n            selection: {\n                value: 'Environment Test',\n                initialValues: gltfIndex,\n            },\n            process: (file: File) => file,\n        },\n    });\n\n    readonly settings = this.#settings.publicSettings;\n    readonly priority = 1000;\n\n    constructor(public renderer: Renderer) {\n        this.descriptorMap = new DescriptorMap(renderer.device, renderer.gbuffer, renderer.globals);\n        this.device = renderer.device;\n        this.renderer.addForwardPass(this);\n    }\n\n    async setSkybox(skybox: GPUTexture) {\n        await cubemapGuassianPyramid({\n            texture: skybox,\n            device: this.renderer.device,\n            inPlace: true,\n            delayWork: requestAnimationFrame,\n        });\n\n        this.renderer.skybox = skybox;\n    }\n\n    async setModel(modelPath: string | DataType) {\n        const size = { width: 1, height: 1 };\n        const colorArray = new Float32Array([1, 1, 1, 1]);\n\n        const opaqueWhite = this.renderer.device.createTexture({\n            size,\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        this.renderer.device.queue.writeTexture({ texture: opaqueWhite }, colorArray, {}, size);\n\n        const normalMap = this.renderer.device.createTexture({\n            size,\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        colorArray.set([0.5, 0.5, 1, 1]);\n        this.renderer.device.queue.writeTexture({ texture: normalMap }, colorArray, {}, size);\n\n        const sampler = {\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'linear',\n            mipmapFilter: 'linear',\n        } as GPUSamplerDescriptor;\n\n        const matData: MaterialDescriptor = {\n            baseColorTexture: opaqueWhite,\n            baseColorFactor: [1, 1, 1, 1],\n            normalTexture: normalMap,\n            metallicRoughnessTexture: opaqueWhite,\n            metallicFactor: 1,\n            roughnessFactor: 1,\n            baseColorSampler: sampler,\n            normalSampler: sampler,\n            metallicRoughnessSampler: sampler,\n        };\n\n        this.geometryPipelines = await importGltf(\n            modelPath,\n            this.renderer.device,\n            this.descriptorMap,\n            matData,\n            GltfModel.goalLayout,\n            {},\n        );\n    }\n\n    render({ encoder, gbuffer, globals }: ForwardPassParams) {\n        const pass = encoder.beginRenderPass(gbuffer.passDescriptor);\n        pass.setBindGroup(0, globals.bindgroup);\n\n        for (const pipeline of Object.values(this.geometryPipelines)) {\n            pipeline?.draw(pass, this.renderer.device.queue);\n        }\n        pass.end();\n    }\n}\n","import AttributeWrapper from './attribute-wrapper';\n\n/**\n * Adapted from gltf-transform's version:\n * github.com/donmccurdy/glTF-Transform/blob/main/packages/functions/src/weld.ts\n */\nclass HashTable {\n    private attributes: { u8: Uint8Array, byteStride: number }[] = [];\n    private u8: Uint8Array;\n    private u32: Uint32Array;\n\n    constructor(prim: Record<string, AttributeWrapper>) {\n        let byteStride = 0;\n        for (const attribute of Object.values(prim)) {\n            byteStride += this.initAttribute(attribute);\n        }\n        const paddedByteStride = (byteStride + 3) & ~3;\n        this.u8 = new Uint8Array(paddedByteStride);\n        this.u32 = new Uint32Array(this.u8.buffer);\n    }\n\n    private initAttribute(attribute: AttributeWrapper): number {\n        const u8 = attribute.data instanceof Uint8Array\n            ? attribute.data\n            : new Uint8Array(attribute.data.buffer);\n        const byteStride = attribute.bytesPerComponent * attribute.componentsPerElement;\n        this.attributes.push({ u8, byteStride });\n        return byteStride;\n    }\n\n    hash(index: number): number {\n        let byteOffset = 0;\n        for (const { u8, byteStride } of this.attributes) {\n            for (let i = 0; i < byteStride; i += 1) {\n                this.u8[byteOffset + i] = u8[index * byteStride + i];\n            }\n            byteOffset += byteStride;\n        }\n        return this.murmurHash2();\n    }\n\n    equal(a: number, b: number): boolean {\n        for (const { u8, byteStride } of this.attributes) {\n            for (let j = 0; j < byteStride; j += 1) {\n                if (u8[a * byteStride + j] !== u8[b * byteStride + j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    hashLookup(table: TypedArray, buckets: number, key: number, empty: number): number {\n        const hashmod = buckets - 1;\n        const hashval = this.hash(key);\n        let bucket = hashval & hashmod;\n\n        for (let probe = 0; probe <= hashmod; probe += 1) {\n            const item = table[bucket];\n\n            if (item === empty || this.equal(item, key)) {\n                return bucket;\n            }\n\n            bucket = (bucket + probe + 1) & hashmod; // Hash collision.\n        }\n\n        throw new Error('Hash table full.');\n    }\n\n    /**\n     * References:\n     * - https://github.com/mikolalysenko/murmurhash-js/blob/f19136e9f9c17f8cddc216ca3d44ec7c5c502f60/murmurhash2_gc.js#L14\n     * - https://github.com/zeux/meshoptimizer/blob/e47e1be6d3d9513153188216455bdbed40a206ef/src/indexgenerator.cpp#L12\n     */\n    murmurHash2(): number {\n        const m = 0x5bd1e995;\n        const r = 24;\n        let h = 0;\n\n        for (let k of this.u32) {\n            k = Math.imul(k, m) >>> 0;\n            k = (k ^ (k >> r)) >>> 0;\n            k = Math.imul(k, m) >>> 0;\n\n            h = Math.imul(h, m) >>> 0;\n            h = (h ^ k) >>> 0;\n        }\n\n        return h;\n    }\n}\n\nfunction ceilPowerOfTwo(value: number): number {\n    return 2 ** Math.ceil(Math.log(value) / Math.LN2);\n}\n\n/**\n * Weld and merge, combining vertices that are bitwise-equal.\n *\n * Adapted from gltf-transform's _weldPrimitiveStrict:\n * github.com/donmccurdy/glTF-Transform/blob/main/packages/functions/src/weld.ts#L193\n */\nexport default function weld(prim: Record<string, AttributeWrapper>) {\n    const srcVertexCount = prim.POSITION.count;\n    const hash = new HashTable(prim);\n    const tableSize = ceilPowerOfTwo(srcVertexCount + (srcVertexCount / 4));\n    const is16Bit = srcVertexCount < (2 ** 16 - 1);\n    const empty = 2 ** (is16Bit ? 16 : 32) - 1;\n    const indexFormat: GPUIndexFormat = is16Bit ? 'uint16' : 'uint32';\n    const writeMap = is16Bit ? new Uint16Array(srcVertexCount) : new Uint32Array(srcVertexCount);\n    const table = is16Bit ? new Uint16Array(tableSize) : new Uint32Array(tableSize);\n    table.fill(empty);\n\n    let dstVertexCount = 0;\n\n    for (let i = 0; i < srcVertexCount; i += 1) {\n        const hashIndex = hash.hashLookup(table, tableSize, i, empty);\n        const dstIndex = table[hashIndex];\n\n        if (dstIndex === empty) {\n            table[hashIndex] = i;\n            writeMap[i] = dstVertexCount;\n            dstVertexCount += 1;\n        } else {\n            writeMap[i] = writeMap[dstIndex];\n        }\n    }\n\n    for (const attribute of Object.values(prim)) {\n        attribute.remap(writeMap, dstVertexCount);\n    }\n\n    // The gltf-transform version checks for degenerate triangles to remove.\n    // This is omitted here.\n    return { indexArray: writeMap, indexFormat, vertexCount: dstVertexCount };\n}\n","import { mat3, mat4, Mat3, Mat4 } from 'wgpu-matrix';\n\nimport { TypeSizes } from '../constants';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\nimport { PipelineFeatureFlags } from './pipeline-feature-flags';\nimport DescriptorMap from './descriptor-map';\n\nexport type PrimitiveDescriptor = {\n    name?: string,\n    // vertexBufferLayouts: GPUVertexBufferLayout;\n    features: PipelineFeatureFlags,\n    vertexCount: number,\n    vertexArray: ArrayBuffer | TypedArray | GPUBuffer,\n    indexArray?: ArrayBuffer | TypedArray,\n    indexFormat?: GPUIndexFormat,\n};\n\nexport type IndexData = {\n    indexBuffer: GPUBuffer,\n    indexCount: number,\n    indexFormat: GPUIndexFormat,\n};\n\nexport class PrimitiveDrawData {\n    name: string;\n    vertexBuffer: GPUBuffer;\n    indexData?: IndexData;\n    instanceBuffer: GPUBuffer;\n    instanceBindGroup: GPUBindGroup;\n    vertexCount: number;\n    features: number;\n\n    instanceSize: number;\n\n    instances: ArrayBuffer;\n    modelMatrices: Mat4[];\n    normalMatrices!: Mat3[];\n    max: number;\n\n    instanceCount: number = 0;\n    dirty: boolean = false;\n\n    constructor(\n        primitive: PrimitiveDescriptor,\n        device: GPUDevice,\n        max: number,\n        descriptorMap: DescriptorMap,\n        instances?: Mat4[],\n    ) {\n        this.max = max;\n        this.features = primitive.features;\n        this.name = primitive.name ?? 'mesh';\n        this.vertexCount = primitive.vertexCount;\n\n        if (primitive.vertexArray instanceof GPUBuffer) {\n            this.vertexBuffer = primitive.vertexArray;\n        } else {\n            this.vertexBuffer = createAndCopyBuffer(\n                primitive.vertexArray,\n                GPUBufferUsage.VERTEX,\n                device,\n                `${this.name} vertex buffer`,\n            );\n        }\n\n        if (primitive.indexArray && primitive.indexFormat) {\n            const { indexArray, indexFormat } = primitive;\n            this.indexData = {\n                indexFormat,\n                indexCount: indexArray.byteLength / (indexFormat === 'uint16' ? 2 : 4),\n                indexBuffer: createAndCopyBuffer(\n                    primitive.indexArray,\n                    GPUBufferUsage.INDEX,\n                    device,\n                    `${this.name} index buffer`,\n                ),\n            };\n        }\n\n        this.instanceSize = TypeSizes.sizeofMat4x4f;\n        if (this.features & PipelineFeatureFlags.VertexNormals) {\n            this.instanceSize += 12 * 4;\n        }\n\n        this.instances = new ArrayBuffer(max * this.instanceSize);\n        this.modelMatrices = new Array(max) as Float32Array[];\n\n        for (let i = 0; i < max; i += 1) {\n            const offset = i * this.instanceSize;\n            this.modelMatrices[i] = new Float32Array(this.instances, offset, 16);\n        }\n\n        if (this.features & PipelineFeatureFlags.VertexNormals) {\n            this.normalMatrices = new Array(max) as Float32Array[];\n\n            for (let i = 0; i < max; i += 1) {\n                const offset = (i * this.instanceSize) + TypeSizes.sizeofMat4x4f;\n                this.normalMatrices[i] = new Float32Array(this.instances, offset, 12);\n            }\n        }\n\n        this.instanceBuffer = device.createBuffer({\n            label: `${this.name} instance buffer`,\n            size: this.instances.byteLength,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        });\n\n        this.instanceBindGroup = device.createBindGroup({\n            label: `PrimitiveDrawData instance bind group`,\n            layout: descriptorMap.forwardBindgroupLayout,\n            entries: [{\n                binding: 0,\n                resource: { buffer: this.instanceBuffer },\n            }],\n        });\n\n        if (instances) {\n            for (const instance of instances) {\n                this.addInstance(instance);\n            }\n        }\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        if (this.dirty) {\n            queue.writeBuffer(this.instanceBuffer, 0, this.instances);\n            this.dirty = false;\n        }\n\n        passEncoder.setVertexBuffer(0, this.vertexBuffer);\n        passEncoder.setBindGroup(2, this.instanceBindGroup);\n\n        if (this.indexData != null) {\n            const { indexBuffer, indexCount, indexFormat } = this.indexData;\n            passEncoder.setIndexBuffer(indexBuffer, indexFormat);\n            passEncoder.drawIndexed(indexCount, this.instanceCount);\n        } else {\n            passEncoder.draw(this.vertexCount, this.instanceCount);\n        }\n    }\n\n    addInstance(transform: Mat4) {\n        if (this.instanceCount === this.max) return;\n        mat4.copy(transform, this.modelMatrices[this.instanceCount]);\n        this.calculateNormalMatrix(this.instanceCount);\n        this.instanceCount += 1;\n        this.dirty = true;\n    }\n\n    calculateNormalMatrix(idx: number) {\n        if (!(this.features & PipelineFeatureFlags.VertexNormals)) return;\n        const normalMatrix = this.normalMatrices[idx];\n        mat3.fromMat4(this.modelMatrices[idx], normalMatrix);\n        mat3.invert(normalMatrix, normalMatrix);\n        mat3.transpose(normalMatrix, normalMatrix);\n    }\n}\n","import type { GLTF } from '../../../include/gltf';\nimport { PipelineFeatureFlags } from '../../../rendering/default-forward-pass/pipeline-feature-flags';\n\nexport type AttributeDetails = {\n    name: string,\n    type: GLTF.AccessorType,\n    componentType: GLTF.AccessorComponentType,\n    strip?: boolean,\n    depends?: string[],\n    feature?: PipelineFeatureFlags,\n    fill?: number[],\n};\n\nexport const enum ComponentType {\n    int8 = 5120,\n    uint8 = 5121,\n    int16 = 5122,\n    uint16 = 5123,\n    uint32 = 5125,\n    float32 = 5126,\n}\n\nexport const typeToElementCount: Record<GLTF.AccessorType, number> = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 12,\n    MAT4: 16,\n};\n\nexport const componentToSize: Record<ComponentType, number> = {\n    [ComponentType.int8]: 1,\n    [ComponentType.uint8]: 1,\n    [ComponentType.int16]: 2,\n    [ComponentType.uint16]: 2,\n    [ComponentType.uint32]: 4,\n    [ComponentType.float32]: 4,\n};\n\nexport const enum TopologyMode {\n    Points = 0,\n    LineList = 1,\n    LineLoop = 2,\n    LineStrip = 3,\n    TriangleList = 4,\n    TriangleStrip = 5,\n    TriangleFan = 6,\n}\n\nexport const modeToTopology: Partial<Record<TopologyMode, PipelineFeatureFlags>> = {\n    [TopologyMode.Points]: PipelineFeatureFlags.PointList, // POINTS\n    [TopologyMode.LineList]: PipelineFeatureFlags.LineList, // LINES\n    // 2: LINE_LOOP (unsupported by webgpu)\n    // 3: PipelineFeatureFlags.LineStrip, // LINE_STRIP\n    [TopologyMode.TriangleList]: PipelineFeatureFlags.TriangleList, // TRIANGLES\n    // 5: PipelineFeatureFlags.TriangleStrip, // TRIANGLE_STRIP\n    // 6: TRIANGLE_FAN (unsupported by webgpu)\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\nimport { GLTFAccessorPostprocessed } from '@loaders.gl/gltf';\nimport { ComponentType } from './type-conversions';\n\nexport default class AttributeWrapper {\n    data: TypedArray;\n    processed: boolean;\n    componentsPerElement: number;\n    bytesPerComponent: number;\n    count: number;\n\n    copyFrom: (srcIdx: number, dstIdx: number, dst: Float32Array) => void;\n\n    at?: (i: number, j: number) => number;\n    view?: DataView;\n\n    unwelded = false;\n\n    constructor(accessor: GLTFAccessorPostprocessed);\n    constructor(array: Float32Array, componentCount: number);\n\n    constructor(accessor: GLTFAccessorPostprocessed | Float32Array, componentCount?: number) {\n        if (accessor instanceof Float32Array) {\n            this.data = accessor;\n            this.componentsPerElement = componentCount!;\n            this.count = accessor.length / componentCount!;\n            this.processed = true;\n            this.bytesPerComponent = 4;\n            this.copyFrom = this.copyProcessed.bind(this);\n        } else {\n            this.data = accessor.value;\n            this.componentsPerElement = accessor.components;\n            this.count = accessor.count;\n            this.bytesPerComponent = accessor.bytesPerComponent;\n            this.processed = false;\n            this.view = new DataView(this.data.buffer);\n            this.copyFrom = this.copyUnprocessed.bind(this);\n\n            switch (accessor.componentType as ComponentType) {\n                case ComponentType.int8: {\n                    this.at = (i, j) => this.view!.getInt8(i * this.componentsPerElement + j);\n                    break;\n                }\n                case ComponentType.uint8: {\n                    this.at = (i, j) => this.view!.getUint8(i * this.componentsPerElement + j);\n                    break;\n                }\n                case ComponentType.int16: {\n                    this.at = (i, j) => {\n                        const offset = 2 * (i * this.componentsPerElement + j);\n                        return this.view!.getInt16(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.uint16: {\n                    this.at = (i, j) => {\n                        const offset = 2 * (i * this.componentsPerElement + j);\n                        return this.view!.getUint16(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.uint32: {\n                    this.at = (i, j) => {\n                        const offset = 4 * (i * this.componentsPerElement + j);\n                        return this.view!.getUint32(offset, true);\n                    };\n                    break;\n                }\n                case ComponentType.float32: {\n                    this.at = (i, j) => {\n                        const offset = 4 * (i * this.componentsPerElement + j);\n                        return this.view!.getFloat32(offset, true);\n                    };\n                    break;\n                }\n                default: throw new Error(`gltf importer -- invalid componentType ${accessor.componentType}`);\n            }\n\n            if (accessor.normalized) {\n                let val: number;\n                switch (accessor.componentType as ComponentType) {\n                    case ComponentType.uint8: val = 255; break;\n                    case ComponentType.int8: val = 127; break;\n                    case ComponentType.uint16: val = 65535; break;\n                    case ComponentType.int16: val = 32767; break;\n                    case ComponentType.uint32: val = 4294967295; break;\n                    default: throw new Error(`gltf importer -- invalid componentType ${accessor.componentType}`);\n                }\n\n                this.at = (i, j) => this.at!(i, j) / val;\n            }\n        }\n    }\n\n    get array(): Float32Array {\n        if (!this.processed) this.process();\n        return this.data as Float32Array;\n    }\n\n    copyProcessed(srcIdx: number, dstIdx: number, dst: Float32Array) {\n        for (let j = 0; j < this.componentsPerElement; j += 1) {\n            dst[dstIdx + j] = this.data[(srcIdx * this.componentsPerElement) + j];\n        }\n    }\n\n    copyUnprocessed(srcIdx: number, dstIdx: number, dst: Float32Array) {\n        for (let j = 0; j < this.componentsPerElement; j += 1) {\n            dst[dstIdx + j] = this.at!(srcIdx, j);\n        }\n    }\n\n    markProcessed() {\n        this.processed = true;\n        this.copyFrom = this.copyProcessed.bind(this);\n        delete this.view;\n        delete this.at;\n    }\n\n    process() {\n        if (this.processed) return;\n        const newView = new Float32Array(this.count * this.componentsPerElement);\n\n        for (let i = 0; i < this.count; i += 1) {\n            this.copyFrom(i, i * this.componentsPerElement, newView);\n        }\n\n        this.data = newView;\n        this.markProcessed();\n    }\n\n    unweld(indexArray: TypedArray): void {\n        if (this.unwelded) return;\n        this.unwelded = true;\n        const newView = new Float32Array(indexArray.length * this.componentsPerElement);\n\n        for (let i = 0; i < indexArray.length; i += 1) {\n            this.copyFrom(indexArray[i], i * this.componentsPerElement, newView);\n        }\n\n        this.count = indexArray.length;\n        this.data = newView;\n        this.markProcessed();\n    }\n\n    remap(remap: TypedArray, dstCount: number): void {\n        const dstArray = new Float32Array(dstCount * this.componentsPerElement);\n        const done = new Uint8Array(dstCount);\n\n        for (let srcIndex = 0; srcIndex < this.count; srcIndex += 1) {\n            const dstIndex = remap[srcIndex];\n            if (done[dstIndex]) continue;\n            this.copyFrom(srcIndex, dstIndex * this.componentsPerElement, dstArray);\n            done[dstIndex] = 1;\n        }\n\n        this.data = dstArray;\n        this.markProcessed();\n    }\n}\n","import { Mat4, mat4 } from 'wgpu-matrix';\nimport { GLTFAccessorPostprocessed, GLTFMaterialPostprocessed, GLTFMeshPrimitivePostprocessed } from '@loaders.gl/gltf';\n\nimport weld from './weld';\nimport { PipelineFeatureFlags } from '../../../rendering/default-forward-pass/pipeline-feature-flags';\nimport { PrimitiveDrawData } from '../../../rendering/default-forward-pass/primitive-draw-data';\nimport { AttributeDetails, TopologyMode, modeToTopology } from './type-conversions';\nimport DescriptorMap from '../../../rendering/default-forward-pass/descriptor-map';\nimport AttributeWrapper from './attribute-wrapper';\nimport interleaveVertices from './interleave-vertices';\nimport { mapValues } from '../../../utils/general';\n\nexport type NamedAttribute = 'POSITION' | 'NORMAL' | 'TANGENT';\nexport type NumberedAttribute = 'TEXCOORD' | 'COLOR' | 'JOINTS' | 'WEIGHTS';\nexport type PrimitiveAttributeKey = NamedAttribute | `${NumberedAttribute}_${number}` | `_${string}`;\n\nconst generateTangentsAsync = import('mikktspace').then((module) => module.generateTangents);\n\nfunction wrapIndices(indices: GLTFAccessorPostprocessed) {\n    switch (indices.bytesPerComponent) {\n        case 2: return {\n            indexArray: new Uint16Array(indices.value.buffer),\n            indexFormat: 'uint16' as GPUIndexFormat,\n        };\n        case 4: return {\n            indexArray: new Uint32Array(indices.value.buffer),\n            indexFormat: 'uint32' as GPUIndexFormat,\n        };\n        case 1:\n        default: return {\n            indexArray: new Uint16Array(indices.value),\n            indexFormat: 'uint16' as GPUIndexFormat,\n        };\n    }\n}\n\nfunction reindex(indices: GLTFAccessorPostprocessed, originalMode?: number) {\n    switch (originalMode) {\n        case TopologyMode.LineLoop:\n        case TopologyMode.LineStrip:\n        case TopologyMode.TriangleFan:\n        case TopologyMode.TriangleStrip: {\n            // TODO: convert non-list topologies into lists.\n            throw new Error('Topology currently unsupported');\n        }\n        default: return { ...wrapIndices(indices), mode: TopologyMode.TriangleList };\n    }\n}\n\n/**\n * Checks the determinant of each given matrix and returns a culling mode such that\n * a primitive will render correctly for all nodes containing it, using 'none'\n * for primitive which are rendered both inverted and normally.\n *\n * @param instanceMatrices the instance matrices to render the primitive with\n * @returns The cull mode to use on the primitive.\n *\n * @remarks\n * The glFT spec determines the winding direction of a model by the\n * determinant of the transform of the node which uses it, allowing\n * inversion through negative scale. Changing cullMode instead\n * more easily integrates with instanced rendering, although comes\n * at a performance cost.\n */\nfunction getCullMode(instanceMatrices: Mat4[]) {\n    let overallSign: number | undefined;\n\n    for (let i = 0; i < instanceMatrices.length; i += 1) {\n        const det = mat4.determinant(instanceMatrices[i]);\n        const sign = Math.sign(det);\n        overallSign ??= sign;\n\n        if (sign !== overallSign) return PipelineFeatureFlags.DoubleSided;\n    }\n\n    return (overallSign == null || overallSign > 0)\n        ? PipelineFeatureFlags.Defaults\n        : PipelineFeatureFlags.ClockwiseWinding;\n}\n\nexport default async function loadPrimitive(\n    layout: AttributeDetails[],\n    primitive: GLTFMeshPrimitivePostprocessed,\n    instances: Mat4[],\n    descriptorMap: DescriptorMap,\n    device: GPUDevice,\n): Promise<{ drawData?: PrimitiveDrawData, material?: GLTFMaterialPostprocessed }> {\n    const attributes = primitive.attributes as Partial<Record<PrimitiveAttributeKey, GLTFAccessorPostprocessed>>;\n    if (attributes.POSITION == null) return {};\n\n    const { indices } = primitive;\n    const atrs = mapValues(attributes, (atr) => new AttributeWrapper(atr as GLTFAccessorPostprocessed));\n    let { mode } = primitive;\n    let vertexCount = attributes.POSITION.count;\n    let indexArray: TypedArray | undefined;\n    let indexFormat: GPUIndexFormat | undefined;\n\n    if (indices != null) {\n        ({ indexArray, indexFormat } = wrapIndices(indices));\n\n        if (\n            mode !== TopologyMode.Points\n            && mode !== TopologyMode.LineList\n            && mode !== TopologyMode.TriangleList\n        ) {\n            ({ indexArray, indexFormat, mode } = reindex(indices, mode));\n        }\n    }\n\n    if (atrs.NORMAL != null && atrs.TANGENT == null) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (atrs.TEXCOORD_0 != null) {\n            if (indexArray != null) {\n                vertexCount = indexArray.length;\n                for (const atr of Object.values(atrs)) {\n                    atr.unweld(indexArray);\n                }\n            }\n\n            const start = Date.now();\n\n            const tangent = await generateTangentsAsync.then((func) => func(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                atrs.POSITION!.array,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                atrs.NORMAL!.array,\n                atrs.TEXCOORD_0.array,\n            ));\n\n            for (let i = 3; i < tangent.length; i += 4) {\n                tangent[i] *= -1;\n            }\n            console.log(`tangents generated in ${Date.now() - start}`);\n\n            atrs.TANGENT = new AttributeWrapper(tangent, 4);\n\n            ({ indexArray, indexFormat, vertexCount } = weld(atrs));\n            mode = TopologyMode.TriangleList;\n        } else {\n            const tangent = new Float32Array(vertexCount * 4);\n            for (let i = 0; i < vertexCount; i += 1) {\n                tangent.set([1, 0, 0, 1], i * 4);\n            }\n            atrs.TANGENT = new AttributeWrapper(tangent, 4);\n        }\n    }\n\n    const { vertexArray, vertexFeatures } = interleaveVertices(atrs, vertexCount);\n    let features = getCullMode(instances) | vertexFeatures;\n    if (mode != null) features |= modeToTopology[mode as TopologyMode] || 0;\n\n    const drawData = new PrimitiveDrawData({\n        features,\n        indexArray,\n        indexFormat,\n        vertexCount,\n        vertexArray,\n    }, device, instances.length, descriptorMap, instances);\n\n    return { material: primitive.material, drawData };\n}\n","import AttributeWrapper from './attribute-wrapper';\nimport { PipelineFeatureFlags } from '../../../rendering/default-forward-pass/pipeline-feature-flags';\n\n// const goalLayout: AttributeDetails[] = [\n//     {\n//         name: 'POSITION',\n//         type: 'VEC3',\n//         componentType: ComponentType.float32,\n//     },\n//     {\n//         name: 'TEXCOORD_0',\n//         type: 'VEC2',\n//         componentType: ComponentType.float32,\n//     },\n//     {\n//         name: 'TANGENT',\n//         type: 'VEC4',\n//         componentType: ComponentType.float32,\n//         depends: ['NORMAL'],\n//         fill: [1, 0, 0, 1],\n//     },\n//     {\n//         name: 'NORMAL',\n//         type: 'VEC3',\n//         componentType: ComponentType.float32,\n//         strip: true,\n//         feature: PipelineFeatureFlags.VertexNormals,\n//     },\n//     {\n//         name: 'COLOR_0',\n//         type: 'VEC4',\n//         componentType: ComponentType.float32,\n//         strip: true,\n//         feature: PipelineFeatureFlags.VertexColors,\n//         fill: [1, 1, 1, 1],\n//     },\n// ];\n\nexport default function interleaveVertices(\n    attributes: Partial<Record<string, AttributeWrapper>>,\n    count: number,\n) {\n    let vertexFeatures: PipelineFeatureFlags = PipelineFeatureFlags.Defaults;\n    let stride = 5;\n    if (attributes.NORMAL != null) stride += 7;\n    if (attributes.COLOR_0 != null) stride += 4;\n\n    const vertexArray = new ArrayBuffer(stride * count * 4);\n    const vertexView = new Float32Array(vertexArray);\n\n    for (let i = 0; i < count; i += 1) {\n        attributes.POSITION?.copyFrom(i, stride * i, vertexView);\n    }\n\n    const uv = attributes.TEXCOORD_0 ?? new AttributeWrapper(new Float32Array(count * 2), 2);\n    for (let i = 0; i < count; i += 1) {\n        uv.copyFrom(i, i * stride + 3, vertexView);\n    }\n\n    if (attributes.NORMAL != null && attributes.TANGENT != null) {\n        vertexFeatures |= PipelineFeatureFlags.VertexNormals;\n\n        for (let i = 0; i < count; i += 1) {\n            attributes.TANGENT.copyFrom(i, i * stride + 5, vertexView);\n        }\n\n        for (let i = 0; i < count; i += 1) {\n            attributes.NORMAL.copyFrom(i, i * stride + 9, vertexView);\n        }\n    }\n\n    if (attributes.COLOR_0 != null) {\n        vertexFeatures |= PipelineFeatureFlags.VertexColors;\n        const step = attributes.NORMAL != null ? 12 : 5;\n        for (let i = 0; i < count; i += 1) {\n            attributes.COLOR_0.copyFrom(i, i * stride + step, vertexView);\n            vertexView[i * stride + step + 3] = 1;\n        }\n    }\n\n    return { vertexArray, vertexFeatures };\n}\n","import { GLTFMaterialPostprocessed, GLTFSampler, GLTFTexturePostprocessed } from '@loaders.gl/gltf';\n\nimport { vec3 } from 'wgpu-matrix';\nimport { MaterialDescriptor } from '../../../rendering/default-forward-pass/material-draw-data';\nimport { imageToTexture } from '../../../utils/texture-importing';\n\nconst DEFAULT_METALLIC = 0.0;\nconst DEFAULT_ROUGHNESS = 1.0;\n\nconst gltfToMagDescription: Record<number, GPUFilterMode> = {\n    9728: 'nearest',\n    9729: 'linear',\n    9984: 'nearest', // NEAREST_MIPMAP_NEAREST\n    9985: 'linear', // LINEAR_MIPMAP_NEAREST\n    9986: 'nearest', // NEAREST_MIPMAP_LINEAR\n    9987: 'linear', // LINEAR_MIPMAP_LINEAR\n};\n\nconst gltfToMipDescription: Partial<Record<number, GPUFilterMode>> = {\n    9984: 'nearest', // NEAREST_MIPMAP_NEAREST\n    9985: 'nearest', // LINEAR_MIPMAP_NEAREST\n    9986: 'linear', // NEAREST_MIPMAP_LINEAR\n    9987: 'linear', // LINEAR_MIPMAP_LINEAR\n};\n\nconst gltfToAddressMode: Record<number, GPUAddressMode> = {\n    33071: 'clamp-to-edge', // CLAMP_TO_EDGE\n    33648: 'mirror-repeat', // MIRRORED_REPEAT\n    10497: 'repeat', // REPEAT\n};\n\nfunction toSamplerDescription(sampler: GLTFSampler): GPUSamplerDescriptor {\n    const { magFilter, minFilter, wrapS, wrapT } = sampler;\n\n    return {\n        addressModeU: gltfToAddressMode[wrapS ?? 10497],\n        addressModeV: gltfToAddressMode[wrapT ?? 10497],\n        minFilter: gltfToMagDescription[minFilter ?? 9987],\n        magFilter: gltfToMagDescription[magFilter ?? 9729],\n        mipmapFilter: gltfToMipDescription[minFilter ?? 9987] ?? 'linear',\n    };\n}\n\nfunction getImageData(handle: GLTFTexturePostprocessed) {\n    const { source, sampler } = handle;\n    if (source == null) return {};\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const data = source.image.data ?? source.bufferView?.data;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (data == null) return {};\n\n    return { data, mimeType: source.mimeType, sampler };\n}\n\nexport default async function loadMaterial(\n    material: GLTFMaterialPostprocessed,\n    defaultMaterial: MaterialDescriptor,\n    device: GPUDevice,\n): Promise<MaterialDescriptor> {\n    const mat: Partial<MaterialDescriptor> = {};\n    if (material.pbrMetallicRoughness != null) {\n        const {\n            baseColorFactor,\n            baseColorTexture,\n            metallicFactor,\n            metallicRoughnessTexture,\n            roughnessFactor,\n        } = material.pbrMetallicRoughness;\n\n        if (metallicRoughnessTexture?.texture.source == null) {\n            if (metallicFactor == null) mat.metallicFactor = DEFAULT_METALLIC;\n            if (roughnessFactor == null) mat.roughnessFactor = DEFAULT_ROUGHNESS;\n        } else {\n            const { data, mimeType, sampler } = getImageData(metallicRoughnessTexture.texture);\n            if (data != null) {\n                mat.metallicRoughnessTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                });\n                if (sampler) mat.metallicRoughnessSampler = toSamplerDescription(sampler);\n            }\n        }\n\n        if (baseColorTexture?.texture.source != null) {\n            const { data, mimeType, sampler } = getImageData(baseColorTexture.texture);\n            if (data != null) {\n                mat.baseColorTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                    srgbToLinear: true,\n                });\n                if (sampler) mat.baseColorSampler = toSamplerDescription(sampler);\n            }\n        }\n\n        if (baseColorFactor != null) mat.baseColorFactor = baseColorFactor;\n        if (metallicFactor != null) mat.metallicFactor = metallicFactor;\n        if (roughnessFactor != null) mat.metallicFactor = roughnessFactor;\n    } else {\n        mat.metallicFactor = DEFAULT_METALLIC;\n        mat.roughnessFactor = DEFAULT_ROUGHNESS;\n    }\n\n    if (material.normalTexture?.texture.source != null) {\n        const { data, mimeType, sampler } = getImageData(material.normalTexture.texture);\n\n        if (data != null) {\n            mat.normalTexture = await imageToTexture({\n                label: `${material.id} mr texture`,\n                data,\n                mimeType,\n                usage: GPUTextureUsage.TEXTURE_BINDING,\n                device,\n            });\n            if (sampler) mat.normalSampler = toSamplerDescription(sampler);\n        }\n    }\n\n    const { emissiveFactor, emissiveTexture } = material;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    const emissiveStrength = material.extensions?.KHR_materials_emissive_strength?.emissiveStrength;\n\n    if (emissiveTexture != null || emissiveFactor?.some((x) => x > 0)) {\n        mat.emissiveFactor = emissiveFactor ?? [1, 1, 1];\n        mat.emissiveSampler = { magFilter: 'linear', minFilter: 'linear' };\n\n        if (emissiveTexture?.texture.source != null) {\n            const { data, mimeType, sampler } = getImageData(emissiveTexture.texture);\n            if (data != null) {\n                mat.emissiveTexture = await imageToTexture({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                    srgbToLinear: true,\n                });\n                if (sampler) mat.emissiveSampler = toSamplerDescription(sampler);\n            }\n        } else {\n            mat.emissiveTexture = defaultMaterial.baseColorTexture;\n        }\n\n        if (emissiveStrength != null && typeof emissiveStrength === 'number') {\n            vec3.scale(mat.emissiveFactor, emissiveStrength, mat.emissiveFactor);\n        }\n    }\n\n    if (material.doubleSided) mat.doubleSided = true;\n    if (material.alphaMode === 'MASK') mat.alphaCutoff = material.alphaCutoff ?? 0.5;\n\n    return { ...defaultMaterial, ...mat };\n}\n","import { Vec3n, Vec4n } from 'wgpu-matrix';\nimport DescriptorMap from './descriptor-map';\nimport { featureFlagsToString, PipelineFeatureFlags } from './pipeline-feature-flags';\nimport { PrimitiveDrawData } from './primitive-draw-data';\nimport { createAndCopyBuffer } from '../../utils/data-copy';\n\nexport type MaterialDescriptor = {\n    name?: string,\n\n    baseColorFactor: Vec4n,\n    baseColorTexture: GPUTexture,\n    baseColorSampler: GPUSamplerDescriptor,\n\n    roughnessFactor: number,\n    metallicFactor: number,\n    metallicRoughnessTexture: GPUTexture,\n    metallicRoughnessSampler: GPUSamplerDescriptor,\n\n    normalTexture: GPUTexture,\n    normalSampler: GPUSamplerDescriptor,\n\n    alphaCutoff?: number,\n\n    emissiveFactor?: Vec3n,\n    emissiveTexture?: GPUTexture,\n    emissiveSampler?: GPUSamplerDescriptor,\n\n    doubleSided?: boolean,\n};\n\nexport class MaterialDrawData {\n    layout: GPUBindGroupLayout;\n    primitives: PrimitiveDrawData[] = [];\n    matData: MaterialDescriptor;\n    bindGroup: GPUBindGroup;\n    propertiesBuffer: GPUBuffer;\n    features: PipelineFeatureFlags;\n\n    constructor(\n        data: MaterialDescriptor,\n        device: GPUDevice,\n        descriptorMap: DescriptorMap,\n        primitiveFeatures: PipelineFeatureFlags,\n        primitives?: PrimitiveDrawData[],\n    ) {\n        this.features = primitiveFeatures;\n        if (data.doubleSided) this.features |= PipelineFeatureFlags.DoubleSided;\n\n        // TODO : don't hardcode the properties features\n        const properties = new Float32Array(12);\n        properties.set(data.baseColorFactor);\n        properties[4] = data.metallicFactor;\n        properties[5] = data.roughnessFactor;\n\n        if (data.alphaCutoff != null) {\n            this.features |= PipelineFeatureFlags.AlphaCutoff;\n            properties[6] = data.alphaCutoff;\n        }\n\n        if (data.emissiveFactor != null) {\n            properties.set(data.emissiveFactor, 8);\n        }\n\n        this.propertiesBuffer = createAndCopyBuffer(\n            properties,\n            GPUBufferUsage.UNIFORM,\n            device,\n        );\n\n        const entries = [\n            { binding: 0, resource: { buffer: this.propertiesBuffer } },\n            { binding: 1, resource: descriptorMap.getSampler(data.baseColorSampler) },\n            { binding: 2, resource: data.baseColorTexture.createView({ dimension: '2d' }) },\n            { binding: 3, resource: descriptorMap.getSampler(data.normalSampler) },\n            { binding: 4, resource: data.normalTexture.createView({ dimension: '2d' }) },\n            { binding: 5, resource: descriptorMap.getSampler(data.metallicRoughnessSampler) },\n            { binding: 6, resource: data.metallicRoughnessTexture.createView({ dimension: '2d' }) },\n        ];\n\n        if (data.emissiveTexture != null) {\n            this.features |= PipelineFeatureFlags.Emissive;\n\n            entries.push({\n                binding: 7,\n                resource: descriptorMap.getSampler(data.emissiveSampler ?? {}),\n            });\n\n            entries.push({\n                binding: 8,\n                resource: data.emissiveTexture.createView({ dimension: '2d' }),\n            });\n        }\n\n        this.layout = descriptorMap.getMaterialBindGroup(this.features);\n        this.matData = data;\n        this.bindGroup = device.createBindGroup({\n            label: featureFlagsToString(this.features),\n            layout: this.layout,\n            entries,\n        });\n\n        if (primitives != null) {\n            this.addPrimitives(...primitives);\n        }\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        if (this.primitives.length === 0) return;\n\n        passEncoder.setBindGroup(1, this.bindGroup);\n        for (const primitive of this.primitives) {\n            primitive.draw(passEncoder, queue);\n        }\n    }\n\n    addPrimitives(...drawData: PrimitiveDrawData[]) {\n        const filtered = drawData.filter((data) => {\n            if ((data.features & this.features) === data.features) return true;\n            console.warn(`invalid primitive added to material: \nprimitive: ${data.name}\nprimitive features: ${featureFlagsToString(data.features).toString()}\nmaterial: ${this.matData.name}\nmaterial features: ${featureFlagsToString(this.features).toString()}`);\n            return false;\n        });\n        this.primitives.push(...filtered);\n    }\n}\n","import DescriptorMap from './descriptor-map';\nimport { MaterialDrawData } from './material-draw-data';\nimport { PipelineFeatureFlags, featureFlagsToString, maskRedundantFeatures } from './pipeline-feature-flags';\n\nexport default class GeometryPipeline {\n    features: PipelineFeatureFlags;\n    pipeline: GPURenderPipeline;\n\n    materials: MaterialDrawData[] = [];\n\n    constructor(features: PipelineFeatureFlags, maps: DescriptorMap) {\n        this.features = maskRedundantFeatures(features);\n\n        const module = maps.getShaderModule(features);\n\n        this.pipeline = maps.device.createRenderPipeline({\n            label: featureFlagsToString(features),\n            layout: maps.getForwardPipelineLayout(features),\n            primitive: maps.getPrimitiveState(features),\n            vertex: {\n                entryPoint: 'vs',\n                buffers: [maps.getVertexLayout(features)],\n                module,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                module,\n                targets: maps.gbuffer.targets,\n            },\n            depthStencil: {\n                depthWriteEnabled: true,\n                depthCompare: 'less-equal',\n                format: maps.gbuffer.depth.format,\n            },\n        });\n    }\n\n    addMaterials(...materials: MaterialDrawData[]) {\n        if (materials.some((data) => data.features !== this.features)) {\n            throw new Error('invalid primitive added to material');\n        }\n        this.materials.push(...materials);\n    }\n\n    draw(passEncoder: GPURenderPassEncoder, queue: GPUQueue) {\n        passEncoder.setPipeline(this.pipeline);\n        for (const mat of this.materials) {\n            mat.draw(passEncoder, queue);\n        }\n    }\n}\n","import { Mat4, mat4, Mat4Arg, Mat4Type, quat } from 'wgpu-matrix';\nimport { DataType, load } from '@loaders.gl/core';\nimport { GLTFLoader, GLTFMeshPostprocessed, GLTFNodePostprocessed, postProcessGLTF } from '@loaders.gl/gltf';\n\nimport { ComponentType, AttributeDetails } from './type-conversions';\nimport loadPrimitive from './primitive-loader';\nimport loadMaterial from './material-loader';\n\nimport { MaterialDescriptor, MaterialDrawData } from '../../../rendering/default-forward-pass/material-draw-data';\nimport { PipelineFeatureFlags } from '../../../rendering/default-forward-pass/pipeline-feature-flags';\nimport { PrimitiveDrawData } from '../../../rendering/default-forward-pass/primitive-draw-data';\nimport DescriptorMap from '../../../rendering/default-forward-pass/descriptor-map';\nimport GeometryPipeline from '../../../rendering/default-forward-pass/geometry-pipeline';\n\nconst defaultLayout: AttributeDetails[] = [\n    {\n        name: 'POSITION',\n        type: 'VEC3',\n        componentType: ComponentType.float32,\n    },\n    {\n        name: 'TEXCOORD_0',\n        type: 'VEC2',\n        componentType: ComponentType.float32,\n    },\n    {\n        name: 'TANGENT',\n        type: 'VEC4',\n        componentType: ComponentType.float32,\n        depends: ['NORMAL'],\n        fill: [1, 0, 0, 1],\n    },\n    {\n        name: 'NORMAL',\n        type: 'VEC3',\n        componentType: ComponentType.float32,\n        strip: true,\n        feature: PipelineFeatureFlags.VertexNormals,\n    },\n    {\n        name: 'COLOR_0',\n        type: 'VEC4',\n        componentType: ComponentType.float32,\n        strip: true,\n        feature: PipelineFeatureFlags.VertexColors,\n        fill: [1, 1, 1, 1],\n    },\n];\n\nconst recurseNode = (\n    parentMatrix: Mat4Type<Mat4Arg>,\n    meshes: Map<GLTFMeshPostprocessed, Mat4Type<Mat4Arg>[]>,\n) => (node: GLTFNodePostprocessed) => {\n    const matrix = node.matrix ?? mat4.identity();\n\n    if (node.matrix == null) {\n        if (node.scale) mat4.scaling(node.scale, matrix);\n\n        if (node.rotation) {\n            const { axis, angle } = quat.toAxisAngle(node.rotation);\n            mat4.rotate(matrix, axis, angle, matrix);\n        }\n\n        if (node.translation != null) {\n            mat4.setTranslation(matrix, node.translation, matrix);\n        }\n    }\n\n    mat4.mul(parentMatrix, matrix, matrix);\n\n    if (node.mesh != null) {\n        if (!meshes.has(node.mesh)) meshes.set(node.mesh, []);\n        meshes.get(node.mesh)!.push(matrix); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    }\n\n    node.children?.forEach(recurseNode(matrix, meshes));\n};\n\nexport default async function importGltf(\n    url: string | DataType,\n    device: GPUDevice,\n    descriptorMap: DescriptorMap,\n    defaultMaterial: MaterialDescriptor,\n    layout: AttributeDetails[] = defaultLayout,\n    pipelines: Partial<Record<number, GeometryPipeline>> = {},\n    // eslint-disable-next-line no-console\n    log: ((msg: unknown) => void) = console.log,\n) {\n    log('starting import');\n\n    const start = Date.now();\n    const gltfWithBuffers = await load(url, GLTFLoader);\n    log(`finished loading: ${Date.now() - start}`);\n\n    const { scene } = postProcessGLTF(gltfWithBuffers);\n    if (scene?.nodes == null) return pipelines;\n    log(`finished processing: ${Date.now() - start}`);\n\n    const meshes = new Map<GLTFMeshPostprocessed, Mat4[]>();\n    scene.nodes.forEach(recurseNode(mat4.identity(), meshes));\n    log(`finished creating instances: ${Date.now() - start}`);\n\n    const meshEntries = Array.from(meshes.entries());\n    const primitivePromises = meshEntries.flatMap(([{ primitives }, instances]) =>\n        primitives.map((prim) => loadPrimitive(\n            layout,\n            prim,\n            instances,\n            descriptorMap,\n            device,\n        )),\n    );\n\n    const primitiveDescriptors = await Promise.all(primitivePromises);\n    log(`finished creating primitives: ${Date.now() - start}`);\n\n    type MaterialKey = { materialId?: string, features: number };\n    const materialMap = new Map<MaterialKey, PrimitiveDrawData[]>();\n    const materialPromises: Record<string, Promise<MaterialDescriptor>> = {};\n\n    for (const { material, drawData } of primitiveDescriptors) {\n        if (drawData == null) continue;\n\n        const key = { materialId: material?.id, features: drawData.features };\n        if (!materialMap.has(key)) materialMap.set(key, []);\n        materialMap.get(key)!.push(drawData); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n\n        if (material != null) {\n            materialPromises[material.id] = loadMaterial(material, defaultMaterial, device);\n        }\n    }\n\n    const materialEntries = Object.entries(materialPromises)\n        .map(async ([id, mat]) => [id, await mat]);\n\n    const materialDescriptors = Object.fromEntries(await Promise.all(materialEntries)) as Record<string, MaterialDescriptor>;\n    log(`finished creating material descriptors: ${Date.now() - start}`);\n\n    const fullDefaultMat: MaterialDescriptor = { ...defaultMaterial, metallicFactor: 0 };\n\n    for (const [{ features, materialId }, drawDatas] of materialMap.entries()) {\n        const descriptor = materialId != null ? materialDescriptors[materialId] : fullDefaultMat;\n        const mat = new MaterialDrawData(descriptor, device, descriptorMap, features, drawDatas);\n        const { features: f } = mat;\n\n        pipelines[f] ??= new GeometryPipeline(f, descriptorMap);\n        pipelines[f].addMaterials(mat);\n    }\n\n    log(`finished: ${Date.now() - start}`);\n    return pipelines;\n}\n","import { parseHDR } from '../../utils/texture-importing';\nimport { equirectangularToCubemap } from '../../utils/texture-processing';\nimport { ListenerSyms } from './property-listener';\n\nconst hdrPromises = await fetch(HDR_BASE_URL__, { headers: { 'Content-Type': 'application/vnd.github.object+json' } })\n    .then((res) => res.json()) as Record<string, unknown>[];\n\nexport const hdrs = Object.fromEntries(hdrPromises.flatMap(({ name, download_url }) => typeof name === 'string' && typeof download_url === 'string' && download_url.endsWith('.hdr') ? [[name, download_url]] : []));\n\nasync function processSkybox(device: GPUDevice, file: string | URL | File | ArrayBuffer) {\n    let buffer: ArrayBuffer;\n    if (file instanceof ArrayBuffer) {\n        buffer = file;\n    } else if (file instanceof File) {\n        buffer = await file.arrayBuffer();\n    } else {\n        const res = await fetch(file);\n        buffer = await res.arrayBuffer();\n    }\n\n    const hdr = parseHDR(buffer);\n\n    return equirectangularToCubemap(\n        device,\n        hdr,\n        {\n            format: 'rgba16float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        },\n    );\n}\n\nexport type SkyboxTarget = { device: GPUDevice, setSkybox: (resource: GPUTexture) => unknown };\n\nexport default function getSkyboxOptions(target: SkyboxTarget) {\n    return {\n        [ListenerSyms.$type]: 'file' as const,\n        [ListenerSyms.$callback]: async (val: unknown, key: PropertyKey) => {\n            if (key !== 'value' || val == null) return;\n            if (typeof val === 'string' || val instanceof File) {\n                const texture = await processSkybox(target.device, val);\n                const res = target.setSkybox(texture);\n                if (res instanceof Promise) await res;\n            }\n        },\n        accept: '.hdr',\n        selection: {\n            value: Object.keys(hdrs)[0],\n            initialValues: hdrs,\n        },\n        process: (file: File) => file,\n    };\n}\n","export default /* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`;\r\n","export const toWorldDir: string = /* wgsl */`\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nexport const cubemapSampleConversions: string = /* wgsl */`\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n","import * as ktxparse from 'ktx-parse';\r\n\r\nimport { VkFormatToWebGPU, TextureFormatToSize, TextureFormatToChannelSize, WebGPUToVkFormat } from '../rendering/constants';\r\nimport { padTemplate } from './general';\r\n\r\nexport function createAndCopyBuffer(\r\n    arr: ArrayBuffer | TypedArrayLike,\r\n    usage: GPUFlagsConstant,\r\n    device: GPUDevice,\r\n    label?: string,\r\n    alignment = 4,\r\n): GPUBuffer {\r\n    const pad = alignment - 1;\r\n    const buffer = device.createBuffer({\r\n        label,\r\n        usage,\r\n        size: (arr.byteLength + pad) & ~pad,\r\n        mappedAtCreation: true,\r\n    } as GPUBufferDescriptor);\r\n\r\n    const writeArray = new Uint8Array(buffer.getMappedRange());\r\n    const readArray = arr instanceof ArrayBuffer\r\n        ? new Uint8Array(arr)\r\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n\r\n    writeArray.set(readArray);\r\n    buffer.unmap();\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function createAndCopyCubemap(\r\n    device: GPUDevice,\r\n    data: ArrayBuffer,\r\n    format: GPUTextureFormat,\r\n    usage: number,\r\n    label?: string,\r\n) {\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\r\n    }\r\n\r\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\r\n    const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n    const texture = device.createTexture({\r\n        usage: usage | GPUTextureUsage.COPY_DST,\r\n        label,\r\n        format,\r\n        size,\r\n    });\r\n\r\n    device.queue.writeTexture(\r\n        { texture },\r\n        data,\r\n        { bytesPerRow: width * pixelSize, rowsPerImage: width },\r\n        size,\r\n    );\r\n\r\n    return texture;\r\n}\r\n\r\nexport type KTXImportOptions = {\r\n    label?: string,\r\n    mipLevelCount?: number | 'max' | 'default',\r\n    textureUsage?: number,\r\n    validate?: boolean,\r\n};\r\n\r\nexport function ktx2ToTexture(\r\n    buffer: ArrayBuffer,\r\n    device: GPUDevice,\r\n    options?: KTXImportOptions,\r\n) {\r\n    const arr = new Uint8Array(buffer);\r\n    const ktx = ktxparse.read(arr);\r\n    const format = VkFormatToWebGPU[ktx.vkFormat];\r\n\r\n    if (format == null) {\r\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not covert to webgpu`);\r\n    }\r\n\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not get pixel byte size`);\r\n    }\r\n\r\n    const size = {\r\n        width: ktx.pixelWidth,\r\n        height: ktx.pixelHeight,\r\n        depthOrArrayLayers: ktx.faceCount,\r\n    };\r\n\r\n    const maxMipCount = Math.ceil(Math.log2(Math.max(size.width, size.height))) + 1;\r\n    let mipLevelCount = ktx.levels.length;\r\n    if (options?.mipLevelCount === 'max') {\r\n        mipLevelCount = maxMipCount;\r\n    } else if (typeof options?.mipLevelCount === 'number') {\r\n        mipLevelCount = Math.min(maxMipCount, options.mipLevelCount);\r\n    }\r\n\r\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\r\n    if (options?.textureUsage) usage |= options.textureUsage;\r\n\r\n    const texture = device.createTexture({\r\n        label: options?.label,\r\n        size,\r\n        mipLevelCount,\r\n        format,\r\n        usage,\r\n    });\r\n\r\n    const mipCopies = Math.min(ktx.levels.length, mipLevelCount) - 1;\r\n\r\n    for (let mipLevel = mipCopies; mipLevel >= 0; mipLevel -= 1) {\r\n        const width = size.width >> mipLevel;\r\n        const height = size.height >> mipLevel;\r\n        const { levelData } = ktx.levels[mipLevel];\r\n\r\n        const rawBytesPerRow = width * pixelSize;\r\n        const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n        const rowsPerImage = height;\r\n        const bytesPerImage = rowsPerImage * bytesPerRow;\r\n\r\n        let imageData = levelData;\r\n        if (bytesPerRow > rawBytesPerRow) {\r\n            imageData = new Uint8Array(bytesPerImage * texture.depthOrArrayLayers);\r\n\r\n            for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n                for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                    imageData[w + h * bytesPerRow] = levelData[w + h * rawBytesPerRow];\r\n                }\r\n            }\r\n        }\r\n\r\n        const layerBatch = Math.min(\r\n            Math.floor(device.limits.maxBufferSize / bytesPerImage),\r\n            ktx.faceCount,\r\n        );\r\n        const layerCount = Math.ceil(ktx.faceCount / layerBatch);\r\n\r\n        for (let l = 0; l < layerCount; l += 1) {\r\n            const offset = l * layerBatch;\r\n            const count = Math.min(layerBatch, ktx.faceCount - offset);\r\n\r\n            const data = layerCount > 1\r\n                ? imageData.subarray(offset * bytesPerImage, (offset + count) * bytesPerImage)\r\n                : imageData;\r\n\r\n            device.queue.writeTexture(\r\n                { mipLevel, texture, origin: [0, 0, offset] },\r\n                data,\r\n                { bytesPerRow, rowsPerImage },\r\n                [width, height, count],\r\n            );\r\n        }\r\n    }\r\n\r\n    return texture;\r\n}\r\n\r\nexport type TextureToArrayBufferOptions = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    mipLevel?: number,\r\n    resultBuffer?: Uint8Array,\r\n    storageBuffer?: GPUBuffer,\r\n    returnBuffer?: boolean,\r\n    description?: string,\r\n};\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer?: false },\r\n): Promise<{ imageData: Uint8Array }>;\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer: true },\r\n): Promise<{ imageData: Uint8Array, storageBuffer: GPUBuffer }>;\r\n\r\nexport async function textureToArrayBuffer({\r\n    device,\r\n    texture,\r\n    mipLevel = 0,\r\n    returnBuffer,\r\n    storageBuffer,\r\n    resultBuffer,\r\n    description,\r\n}: TextureToArrayBufferOptions) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const fullDescription = padTemplate`[textureToKTX${description ?? ''}${texture.label}] --`;\r\n\r\n    if (pixelSize == null) {\r\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\r\n    }\r\n\r\n    const width = texture.width >> mipLevel;\r\n    const height = texture.height >> mipLevel;\r\n    const rawBytesPerRow = width * pixelSize;\r\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n    const rowsPerImage = height;\r\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\r\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\r\n\r\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\r\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\r\n    }\r\n\r\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\r\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\r\n    }\r\n\r\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\r\n\r\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\r\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\r\n    }\r\n\r\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\r\n    const storage = storageBuffer ?? device.createBuffer({\r\n        label: `${fullDescription} storage buffer`,\r\n        size: byteSize,\r\n        usage: requiredUsage,\r\n    });\r\n\r\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\r\n    encoder.copyTextureToBuffer(\r\n        { texture, mipLevel },\r\n        { buffer: storage, rowsPerImage, bytesPerRow },\r\n        { width, height, depthOrArrayLayers: texture.depthOrArrayLayers },\r\n    );\r\n    device.queue.submit([encoder.finish()]);\r\n\r\n    await Promise.all([\r\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\r\n        device.queue.onSubmittedWorkDone(),\r\n    ]);\r\n\r\n    const mapped = storage.getMappedRange(0, byteSize);\r\n    imageData.set(new Uint8Array(mapped));\r\n    storage.unmap();\r\n\r\n    if (bytesPerRow > rawBytesPerRow) {\r\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\r\n            }\r\n        }\r\n        imageData = imageData.slice(0, resultSize);\r\n    }\r\n\r\n    return {\r\n        imageData,\r\n        storageBuffer: returnBuffer ? storage : undefined,\r\n    };\r\n}\r\n\r\nexport async function textureToKTX(device: GPUDevice, texture: GPUTexture, cube = false) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const typeSize = TextureFormatToChannelSize[texture.format];\r\n\r\n    if (pixelSize == null || typeSize == null) {\r\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\r\n    }\r\n\r\n    const container = new ktxparse.KTX2Container();\r\n    container.pixelWidth = texture.width;\r\n    container.pixelHeight = texture.height;\r\n    container.vkFormat = WebGPUToVkFormat[texture.format];\r\n    container.typeSize = typeSize;\r\n    delete container.keyValue.KTXswizzle;\r\n\r\n    const dataFormat = container.dataFormatDescriptor[0];\r\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\r\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\r\n    dataFormat.bytesPlane[0] = pixelSize;\r\n\r\n    dataFormat.samples = [0, 1, 2, 3].map((i) => ({\r\n        channelType: [192, 193, 194, 207][i],\r\n        samplePosition: [0, 0, 0, 0],\r\n        bitLength: container.typeSize * 8 - 1,\r\n        bitOffset: container.typeSize * 8 * i,\r\n        sampleLower: -1082130432,\r\n        sampleUpper: 1065353216,\r\n    }));\r\n\r\n    if (texture.dimension === '3d') {\r\n        container.faceCount = 1;\r\n        container.pixelDepth = texture.depthOrArrayLayers;\r\n    } else if (cube) {\r\n        const cubeLayers = texture.depthOrArrayLayers / 6;\r\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\r\n        container.faceCount = 6;\r\n    } else {\r\n        container.layerCount = texture.depthOrArrayLayers;\r\n        container.faceCount = 1;\r\n    }\r\n\r\n    let storageBuffer: GPUBuffer | undefined;\r\n    let imageData: Uint8Array;\r\n\r\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\r\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\r\n            mipLevel: i,\r\n            returnBuffer: true,\r\n            device,\r\n            texture,\r\n            storageBuffer,\r\n        }));\r\n\r\n        container.levels.push({\r\n            levelData: imageData,\r\n            uncompressedByteLength: imageData.byteLength,\r\n        });\r\n    }\r\n\r\n    return ktxparse.write(container);\r\n}\r\n","const { baseTable, shiftTable } = (() => {\n    const baseTable = new Uint32Array(256);\n    const shiftTable = new Uint32Array(256);\n\n    for (let i = 0; i < 255; ++i) {\n        const e = i - 127;\n        if (e < -27) { // very small number (0, -0)\n            baseTable[i] = 0x0000;\n            shiftTable[i] = 24;\n        } else if (e < -14) { // small number (denorm)\n            baseTable[i] = 0x0400 >> (-e - 14);\n            shiftTable[i] = -e - 1;\n        } else if (e <= 15) { // normal number\n            baseTable[i] = (e + 15) << 10;\n            shiftTable[i] = 13;\n        } else { // e < 128, large number (Infinity, -Infinity)\n            baseTable[i] = 0x7c00;\n            shiftTable[i] = 24;\n        }\n    }\n\n    // e == 128, stay (NaN, Infinity, -Infinity)\n    baseTable[255] = 0x7c00;\n    shiftTable[255] = 13;\n\n    return { baseTable, shiftTable };\n})();\n\nconst conversionBuffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(conversionBuffer);\nconst uintView = new Uint32Array(conversionBuffer);\n\nexport function toFloat16Bytes(val: number) {\n    floatView[0] = val;\n    const f = uintView[0];\n    const e = (f >> 23) & 0x1ff;\n    const idx = e & 0xff;\n    return baseTable[idx] + ((f & 0x007fffff) >> shiftTable[idx]) + ((e & 0x100) << 7);\n}\n","import { toFloat16Bytes } from './data-conversion';\nimport { srgbTextureToLinear, generateMips } from './texture-processing';\n\nexport type imageToTextureDescriptor = {\n    device: GPUDevice,\n    data: Uint8Array | Blob | File | ImageBitmap,\n    mimeType?: string,\n    label?: string,\n    usage?: number,\n    format?: GPUTextureFormat,\n    mips?: boolean,\n    srgbToLinear?: boolean,\n    colorSpace?: PredefinedColorSpace,\n};\n\nexport async function imageToTexture({\n    device,\n    data,\n    mimeType,\n    usage = GPUTextureUsage.TEXTURE_BINDING,\n    mips = true,\n    format = 'rgba8unorm',\n    colorSpace = 'srgb',\n    label = '',\n    srgbToLinear,\n}: imageToTextureDescriptor) {\n    let bitmap: ImageBitmap;\n\n    if (data instanceof ImageBitmap) {\n        bitmap = data;\n    } else {\n        const blob = (data instanceof Blob || data instanceof File)\n            ? data\n            : new Blob([data], { type: mimeType });\n        bitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n    }\n\n    const size = { width: bitmap.width, height: bitmap.height };\n\n    const texture = device.createTexture({\n        label,\n        format,\n        size: size,\n        usage: usage | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: mips ? 1 + (Math.log2(Math.max(bitmap.width, bitmap.height)) | 0) : 1,\n    });\n\n    device.queue.copyExternalImageToTexture(\n        { source: bitmap },\n        { texture, colorSpace },\n        size,\n    );\n\n    if (srgbToLinear) srgbTextureToLinear(device, texture);\n    if (mips) void generateMips(device, texture);\n\n    return texture;\n}\n\nexport function parseHDR(inData: Uint8Array | ArrayBuffer) {\n    const decoder = new TextDecoder();\n    const buffer = inData instanceof Uint8Array ? inData : new Uint8Array(inData);\n    let pos = 0;\n\n    const getLine = (lineLimit = 1024) => {\n        const limit = Math.min(buffer.length, lineLimit + pos);\n        const sub = buffer.subarray(pos, limit);\n        const end = sub.indexOf(0x0A) + 1;\n        pos += end;\n        return end === 0 ? undefined : decoder.decode(sub.subarray(0, end));\n    };\n\n    const importError = (msg: string) => new Error('HDR Import Error: ' + msg);\n\n    // #region Read Header\n    const magicTokenRegex = /^#\\?(\\S+)/;\n    const magicTokenLine = getLine();\n\n    if (magicTokenLine == null) throw importError('no header found');\n    if (!magicTokenRegex.test(magicTokenLine)) throw importError('bad initial token');\n\n    const headerRegs = [\n        /FORMAT=(?<format>\\S+)/, // format\n        /-Y\\s+(?<Y>\\d+)\\s+\\+X\\s+(?<X>\\d+)/, // size\n        /EXPOSURE\\s*=\\s*(?<exposure>\\d+(\\.\\d+)?)/, // exposure\n        /GAMMA\\s*=\\s*(?<gamma>\\d+(\\.\\d+)?)/, // gamma\n    ];\n\n    const headerReg = new RegExp(`^\\\\s*(${\n        headerRegs.map(({ source }) => `(${source})`).join('|')\n    })\\\\s*$`);\n\n    let noFormat = true;\n    let gamma = 1; /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n    let exposure = 1; /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n    let width: number | undefined = undefined;\n    let height: number | undefined = undefined;\n\n    for (let line = getLine(); line != null; line = width == null ? getLine() : undefined) {\n        const groups = line.match(headerReg)?.groups as Partial<Record<string, string>> | undefined;\n        if (groups == null) continue;\n\n        if (groups.format != null) {\n            noFormat = false;\n        } else if (groups.X != null && groups.Y != null) {\n            width = parseInt(groups.X);\n            height = parseInt(groups.Y);\n        } else if (groups.gamma != null) {\n            gamma = parseFloat(groups.gamma);\n        } else if (groups.exposure != null) {\n            exposure = parseFloat(groups.exposure);\n        }\n    }\n\n    if (noFormat) throw importError('missing format specifier');\n    if (width == null || height == null) throw importError('missing image size specifier');\n    // #endregion\n\n    // #region Read Scanline Data\n    let rawData: Uint8Array;\n    const unencodable = width < 8 || width > 0x7fff;\n    const flatData = buffer[pos] !== 2 || buffer[pos + 1] !== 2 || (buffer[pos + 2] & 0x80) !== 0;\n\n    if (unencodable || flatData) {\n        rawData = buffer.subarray(pos);\n    } else {\n        rawData = new Uint8Array(width * height * 4);\n        const end = 4 * width;\n        const scanline_buffer = new Uint8Array(end);\n        const len = buffer.byteLength;\n\n        for (let k = 0, offset = 0; k < height && pos < len; k++) {\n            if (pos + 4 > len)\n                throw importError('file ended durning scanline');\n\n            if ((2 != buffer[pos++]) || (2 != buffer[pos++]) || (((buffer[pos++] << 8) | buffer[pos++]) != width))\n                throw importError('bad rgbe scanline format');\n\n            let count;\n            for (let ptr = 0; ptr < end && pos < len; ptr += count) {\n                count = buffer[pos++];\n                const isEncodedRun = count > 128;\n                if (isEncodedRun) count -= 128;\n\n                if (count == 0 || ptr + count > end)\n                    throw importError('bad scanline data');\n\n                if (isEncodedRun) {\n                    scanline_buffer.fill(buffer[pos], ptr, ptr + count);\n                    pos += 1;\n                } else {\n                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                    pos += count;\n                }\n            }\n\n            for (let i = 0; i < width; i++)\n                for (let j = 0; j < end; j += width)\n                    rawData[offset++] = scanline_buffer[i + j];\n        }\n    }\n    // #endregion\n\n    // #region Convert to Float16\n    const data = new Uint16Array(rawData.length);\n    const float16One = toFloat16Bytes(1);\n\n    for (let i = 0; i < width * height * 4; i += 4) {\n        const raw_e = rawData[i + 3];\n        const scale = Math.pow(2.0, raw_e - 128.0) / 255.0;\n\n        for (let j = 0; j < 3; j += 1) {\n            data[i + j] = toFloat16Bytes(Math.min(rawData[i + j] * scale, 65504));\n        }\n        data[i + 3] = float16One;\n    }\n    // #endregion\n\n    return { data, width, height, gamma, exposure };\n}\n","import blit from '../shaders/blit-vert.shader';\nimport { toWorldDir } from '../shaders/cubemap-sampling.shader';\nimport { createAndCopyBuffer } from './data-copy';\nimport { padTemplate } from './general';\n\ntype EquirectangularDescriptor = {\n    data: SharedArrayBuffer | BufferSource | GPUTexture,\n    width: number,\n    height: number,\n    gamma?: number,\n    exposure?: number,\n};\n\nexport async function equirectangularToCubemap(\n    device: GPUDevice,\n    { data, width, height, gamma = 1, exposure = 1 }: EquirectangularDescriptor,\n    outputDescriptor: Omit<GPUTextureDescriptor, 'dimension' | 'size'>,\n) {\n    const code = /* wgsl */ `\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${blit}\n        ${toWorldDir}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;\n\n    let FLIP_Y = 0;\n    let equirectangular: GPUTexture;\n    if (data instanceof GPUTexture) {\n        equirectangular = data;\n    } else {\n        FLIP_Y = 1;\n        equirectangular = device.createTexture({\n            label: `${outputDescriptor.label} equirectangular`,\n            dimension: '2d',\n            format: 'rgba16float',\n            size: { width, height },\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        device.queue.writeTexture(\n            { texture: equirectangular, mipLevel: 0 },\n            data,\n            { bytesPerRow: width * 2 * 4 },\n            { width, height, depthOrArrayLayers: 1 },\n        );\n        await device.queue.onSubmittedWorkDone();\n    }\n\n    const faceSize = equirectangular.height >> 1;\n    const cubemapDescriptor = outputDescriptor as GPUTextureDescriptor;\n    cubemapDescriptor.mipLevelCount ??= Math.log2(faceSize) | 0;\n    cubemapDescriptor.size = { width: faceSize, height: faceSize, depthOrArrayLayers: 6 };\n    cubemapDescriptor.dimension = '2d';\n    cubemapDescriptor.usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    const cubemap = device.createTexture(cubemapDescriptor);\n\n    const label = padTemplate`hdr copy${outputDescriptor.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 2,\n                buffer: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const module = device.createShaderModule({ label, code });\n    const sampler = device.createSampler({ label, minFilter: 'linear', magFilter: 'linear' });\n    const params = new Uint32Array(1);\n    const paramBuffer = createAndCopyBuffer(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device, label);\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            { binding: 0, resource: equirectangular.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: paramBuffer } },\n        ],\n    });\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: { module },\n        fragment: {\n            module,\n            targets: [{ format: cubemap.format }],\n            constants: {\n                GAMMA: gamma,\n                EXPOSURE: exposure,\n                FLIP_Y,\n            },\n        },\n    });\n\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n\n        const view = cubemap.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n            mipLevelCount: 1,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [{\n                view,\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n\n    return cubemap;\n}\nexport async function generateMips(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${blit}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `;\n\n    const label = padTemplate`mip generation${texture.label}`;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d', sampleType: 'float' },\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const colorAttachment = {\n        view: undefined as GPUTextureView | undefined,\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: 0 });\n    await device.queue.onSubmittedWorkDone();\n\n    for (let i = 1; i < texture.mipLevelCount; i += 1) {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: colorAttachment.view,\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n\n        colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: i });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [colorAttachment as GPURenderPassColorAttachment],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n\n        device.queue.submit([encoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport function srgbTextureToLinear(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${blit}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `;\n\n    const label = padTemplate`srgb to linear${texture.label}`;\n\n    const size = { width: texture.width, height: texture.height };\n\n    const tempTexture = device.createTexture({\n        format: texture.format,\n        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        size,\n    });\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n\n    const module = device.createShaderModule({ label, code: code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: tempTexture.createView(),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n        ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n        { texture },\n        { texture: tempTexture },\n        size,\n    );\n\n    const pass = encoder.beginRenderPass({\n        label,\n        colorAttachments: [{\n            view: texture.createView({ mipLevelCount: 1, baseMipLevel: 0 }),\n            loadOp: 'clear',\n            storeOp: 'store',\n        }],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindgroup);\n    pass.draw(3);\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n}\n"],"names":["resolveBranch","branch","PreprocessorStatement","constructor","cond","else","this","res","toString","elif","Symbol","toStringTag","wrapWithIncrement","fn","start","include","flags","ifdef","sym","ifndef","preprocessors","vertexInLocation","idx","varyingsLocation","materialBinding","varyings","VertexNormals","VertexColors","code","AlphaCutoff","Emissive","DoubleSided","DescriptorMap","device","gbuffer","globals","pipelineLayouts","primitiveStates","vertexLayouts","shaderModules","bindgroupLayouts","samplers","forwardBindgroupLayout","createBindGroupLayout","label","entries","binding","visibility","GPUShaderStage","VERTEX","FRAGMENT","buffer","type","getSampler","descriptor","key","JSON","stringify","createSampler","getVertexLayout","masked","attributes","shaderLocation","offset","format","arrayStride","push","stepMode","getForwardPipelineLayout","createPipelineLayout","bindGroupLayouts","bindGroupLayout","getMaterialBindGroup","getShaderModule","createShaderModule","getPrimitiveState","topology","flagToTopology","cullMode","frontFace","ClockwiseWinding","pushItem","item","length","sampler","texture","viewDimension","TriangleList","TriangleStrip","PointList","LineList","LineStrip","PipelineFeatureFlags","TopologyFormatMask","PrimitiveStateMask","CodeMask","InstanceBufferLayoutMask","VertexBufferLayoutMask","MaterialBindgroupLayoutMask","PipelineLayoutMask","featureFlagsToString","val","Object","flatMap","flag","featureFlagsToNames","maskRedundantFeatures","GlobalUniforms","deviceBuffer","createBuffer","bufferDescriptor","layoutDescriptor","bindGroupDescriptor","layout","resource","size","bufferSize","bindgroup","createBindGroup","updateDeviceBuffer","queue","camera","cacheView","writeBuffer","group","bufferLength","minBindingSize","usage","GPUBufferUsage","UNIFORM","COPY_DST","createMipBlurCode","groups","async","cubemapGuassianPyramid","outputTextureLabel","inPlace","minWidth","steps","maxOpsPerPass","name","delayWork","width","mipLevelCount","Math","log2","min","limits","maxComputeWorkgroupSizeX","maxComputeInvocationsPerWorkgroup","shader","bindgroupLayout","COMPUTE","storageTexture","access","pipeline","createComputePipeline","compute","module","entryPoint","constants","STEPS","ceil","gaussianPyramid","height","depthOrArrayLayers","createTexture","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","COPY_SRC","dimension","copyEncoder","createCommandEncoder","copyTextureToTexture","mipLevel","submit","finish","onSubmittedWorkDone","mipViews","i","createView","baseMipLevel","maxWorkgroups","maxComputeWorkgroupsPerDimension","maxLayers","maxDispatches","max","propertyArray","ArrayBuffer","Uint32Array","Float32Array","set","w","acos","nextMipWidth","baseV","floor","baseVN","baseUN","baseMag2","sampUN","samp0VN","samp0Mag2","samp1VN","samp1Mag2","dot0","sqrt","dot1","minStepDistance","propertyBuffer","STORAGE","Promise","resolve","mipPasses","requiredMipDispatches","currentMipDispatches","batchDispatches","runPass","mipPixels","passDispatches","passLabel","encoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","gltfIndex","getGltfIndex","indexRes","fetch","indexStr","text","indexJson","parse","Array","isArray","Error","gltf","variants","glTF","file","fromEntries","GltfModel","depthTextureView","descriptorMap","depth","view","renderer","geometryPipelines","skybox","model","$type","$callback","File","setModel","accept","selection","value","initialValues","process","settings","publicSettings","priority","addForwardPass","setSkybox","requestAnimationFrame","modelPath","colorArray","opaqueWhite","writeTexture","normalMap","addressModeU","addressModeV","magFilter","minFilter","mipmapFilter","matData","baseColorTexture","baseColorFactor","normalTexture","metallicRoughnessTexture","metallicFactor","roughnessFactor","baseColorSampler","normalSampler","metallicRoughnessSampler","goalLayout","render","beginRenderPass","passDescriptor","values","draw","title","description","componentType","depends","fill","strip","feature","HashTable","prim","byteStride","attribute","initAttribute","paddedByteStride","u8","Uint8Array","u32","data","bytesPerComponent","componentsPerElement","hash","index","byteOffset","murmurHash2","equal","a","b","j","hashLookup","table","buckets","empty","hashmod","bucket","probe","m","h","k","imul","weld","srcVertexCount","POSITION","count","tableSize","log","LN2","is16Bit","indexFormat","writeMap","Uint16Array","dstVertexCount","hashIndex","dstIndex","remap","indexArray","vertexCount","PrimitiveDrawData","primitive","instances","instanceCount","dirty","features","vertexArray","GPUBuffer","vertexBuffer","indexData","indexCount","byteLength","indexBuffer","INDEX","instanceSize","sizeofMat4x4f","modelMatrices","normalMatrices","instanceBuffer","instanceBindGroup","instance","addInstance","passEncoder","setVertexBuffer","setIndexBuffer","drawIndexed","transform","copy","calculateNormalMatrix","normalMatrix","fromMat4","invert","transpose","modeToTopology","AttributeWrapper","accessor","componentCount","unwelded","processed","copyFrom","copyProcessed","bind","components","DataView","copyUnprocessed","at","getInt8","getUint8","getInt16","getUint16","getUint32","getFloat32","normalized","array","srcIdx","dstIdx","dst","markProcessed","newView","unweld","dstCount","dstArray","done","srcIndex","generateTangentsAsync","then","generateTangents","wrapIndices","indices","loadPrimitive","atrs","atr","mode","originalMode","reindex","NORMAL","TANGENT","TEXCOORD_0","Date","now","tangent","func","console","vertexFeatures","Defaults","stride","COLOR_0","vertexView","uv","step","interleaveVertices","instanceMatrices","overallSign","det","determinant","sign","getCullMode","drawData","material","DEFAULT_METALLIC","DEFAULT_ROUGHNESS","gltfToMagDescription","gltfToMipDescription","gltfToAddressMode","toSamplerDescription","wrapS","wrapT","getImageData","handle","source","image","bufferView","mimeType","loadMaterial","defaultMaterial","mat","pbrMetallicRoughness","id","srgbToLinear","emissiveFactor","emissiveTexture","emissiveStrength","extensions","KHR_materials_emissive_strength","some","x","emissiveSampler","scale","doubleSided","alphaMode","alphaCutoff","MaterialDrawData","primitiveFeatures","primitives","properties","propertiesBuffer","bindGroup","addPrimitives","filtered","filter","warn","GeometryPipeline","maps","materials","createRenderPipeline","vertex","buffers","fragment","targets","depthStencil","depthWriteEnabled","depthCompare","addMaterials","defaultLayout","recurseNode","parentMatrix","meshes","node","matrix","identity","scaling","rotation","axis","angle","toAxisAngle","rotate","translation","setTranslation","mul","mesh","has","get","children","forEach","importGltf","url","pipelines","gltfWithBuffers","load","scene","nodes","Map","primitivePromises","from","map","primitiveDescriptors","all","materialMap","materialPromises","materialId","materialEntries","materialDescriptors","fullDefaultMat","drawDatas","f","hdrPromises","headers","json","hdrs","download_url","endsWith","processSkybox","arrayBuffer","hdr","getSkyboxOptions","target","keys","toWorldDir","cubemapSampleConversions","createAndCopyBuffer","arr","alignment","pad","mappedAtCreation","writeArray","getMappedRange","readArray","unmap","baseTable","shiftTable","e","conversionBuffer","floatView","uintView","toFloat16Bytes","imageToTexture","mips","colorSpace","bitmap","ImageBitmap","blob","Blob","createImageBitmap","colorSpaceConversion","RENDER_ATTACHMENT","copyExternalImageToTexture","parseHDR","inData","decoder","TextDecoder","pos","getLine","lineLimit","limit","sub","subarray","indexOf","undefined","decode","importError","msg","magicTokenLine","test","headerReg","RegExp","join","rawData","noFormat","gamma","exposure","line","match","X","Y","parseInt","parseFloat","unencodable","flatData","scanline_buffer","len","ptr","isEncodedRun","float16One","raw_e","pow","equirectangularToCubemap","outputDescriptor","equirectangular","FLIP_Y","GPUTexture","bytesPerRow","faceSize","cubemapDescriptor","cubemap","params","paramBuffer","pipelineLayout","GAMMA","EXPOSURE","arrayLayerCount","baseArrayLayer","colorAttachments","loadOp","storeOp","generateMips","sampleType","colorAttachment","srgbTextureToLinear","tempTexture"],"sourceRoot":""}