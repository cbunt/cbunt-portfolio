/*! For license information see: https://cbunt.ing/oss-licenses.json */
"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[739],{9739:(e,n,t)=>{t.a(e,(async(e,r)=>{try{t.r(n),t.d(n,{default:()=>p});var a=t(8777),i=t(4508),o=t(541),s=t(71),u=t(1447),c=e([i]);i=(c.then?(await c)():c)[0];var l,d,f=function(e,n,t,r){if("a"===t&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof n?e!==n||!r:!n.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===t?r:"a"===t?r.call(e):r?r.value:n.get(e)};!function(e){e[e.IDLE=0]="IDLE",e[e.BLUR=1]="BLUR",e[e.WAIT=2]="WAIT"}(d||(d={}));class v{constructor(e){this.renderer=e,this.state=d.IDLE,l.set(this,(0,o.A)({nearestSample:{[o.t.$type]:"checkbox",[o.t.$callback]:e=>{"boolean"==typeof e&&(this.renderer.skyboxPass.useNearestSample=e)},value:!1,description:"Disables linear sampling in the viewer."},mipLevel:{[o.t.$type]:"slider",[o.t.$callback]:e=>{"number"==typeof e&&(this.renderer.skyboxPass.mipLevel=e)},value:0,min:0,max:1,step:.1,description:"The mip level to display in the viewer. 0 is the original image, max is completely blurred with 1 pixel faces."},filterDistance:{[o.t.$type]:"slider",[o.t.$callback]:this.reblur.bind(this),value:2,max:64,min:0,step:.1,description:"The number of pixels to blur from."},skybox:(0,i.A)(this),"Download Result":{[o.t.$type]:"button",onClick:()=>{this.saveFile()}}})),this.settings=f(this,l,"f").publicSettings,this.priority=0,e.addForwardPass(this),this.device=e.device}setSkybox(e){this.skybox=e,f(this,l,"f").privateSettings.mipLevel.max=this.skybox.mipLevelCount-1,f(this,l,"f").privateSettings.mipLevel.value=1,this.renderer.skyboxPass.mipLevel=1,this.refresh(),this.reblur()}resolve(){this.refresh();const e=this.state;this.state=d.IDLE,e===d.WAIT&&this.reblur()}async reblur(){null!=this.skybox&&this.state!==d.WAIT&&(this.state!==d.BLUR?(this.state=d.BLUR,await(0,u.A)({device:this.renderer.device,texture:this.skybox,steps:this.settings.filterDistance.value,inPlace:!0,delayWork:requestAnimationFrame}),this.resolve()):this.state=d.WAIT)}refresh(){null!=this.skybox&&(this.renderer.skyboxPass.skyTexture=this.skybox.createView({dimension:"cube"}))}async saveFile(){if(null!=this.skybox)try{const e=Promise.all([(0,s.gU)(this.renderer.device,this.skybox,!0).then((e=>new Blob([e],{type:"image/ktx2"}))),(0,a.H1)({types:[{accept:{"image/ktx2":[".ktx2"]}}],suggestedName:"blurred-skybox.ktx2"}).then((e=>e.createWritable({keepExistingData:!1})))]),[n,t]=await e;await n.stream().pipeTo(t)}catch(e){console.warn(e)}}render({encoder:e,gbuffer:n}){e.beginRenderPass({colorAttachments:[],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",view:n.depth.view}}).end()}}l=new WeakMap,v.title="",v.description="";const p=v;r()}catch(e){r(e)}}))},1447:(e,n,t)=>{t.d(n,{A:()=>s});var r=t(7590),a=t(71),i=t(5225);const o=(e,n)=>`\n    ${r.X}\n    ${r.V}\n\n    override STEPS: i32 = 4;\n\n    struct Params {\n        offset: u32,\n        sigmas: array<f32>,\n    }\n\n    @group(0) @binding(0) var previousMip: texture_2d_array<f32>;\n\n    @group(0) @binding(1) \n    var outputTexture: texture_storage_2d_array<${n}, write>;\n\n    // sigma[0] reserved for work offset\n    @group(0) @binding(2) var<storage> params: Params;\n    \n    @compute @workgroup_size(${e}, 1, 1)\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\n        let mipSize = textureDimensions(outputTexture).x;\n\n        let idx = gid.x + params.offset;\n        let faceSize = mipSize * mipSize;\n        let faceIdx = idx % faceSize;\n        let coord = vec3u(\n            faceIdx % mipSize, \n            faceIdx / mipSize, \n            idx / faceSize,\n        ); \n\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \n            return; \n        }\n\n        let previousSize = textureDimensions(previousMip).x;\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\n        let pos = toWorldDir(vec3u(coord), mipSize);\n\n        let size = arrayLength(&params.sigmas);\n        let level = size - u32(ceil(log2(f32(previousSize))));\n        let sigma = params.sigmas[level];\n        let guassian_factor = -0.5 / (sigma * sigma);\n\n        var weight = 0.0;\n        var res = vec3(0.0);\n\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\n                if (sample.z == INVALID_FACE) { continue; }\n\n                let samplePos = toWorldDir(sample, previousSize);\n                let x = max(0.0, acos(dot(samplePos, pos)));\n                let w = exp(x * x * guassian_factor);\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\n\n                res += color.rgb * w;\n                weight += w;\n            }\n        }\n\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\n    }\n`;async function s({device:e,texture:n,outputTextureLabel:t,inPlace:r=!1,minWidth:u=8,steps:c=4,maxOpsPerPass:l=113639424,label:d=s.name,delayWork:f}){const{width:v,format:p}=n,m=r?n.mipLevelCount:Math.log2(v)-Math.log2(u)+1;if(m<=1)return n;const h=Math.min(e.limits.maxComputeWorkgroupSizeX,e.limits.maxComputeInvocationsPerWorkgroup),y=e.createShaderModule({label:d,code:o(h,p)}),g=e.createBindGroupLayout({label:d,entries:[{binding:0,texture:{viewDimension:"2d-array"},visibility:GPUShaderStage.COMPUTE},{binding:1,storageTexture:{access:"write-only",viewDimension:"2d-array",format:p},visibility:GPUShaderStage.COMPUTE},{binding:2,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.COMPUTE}]}),b=e.createComputePipeline({label:d,layout:e.createPipelineLayout({label:d,bindGroupLayouts:[g]}),compute:{module:y,entryPoint:"main",constants:{STEPS:Math.ceil(c)}}});let w=n;if(!r){const r={width:v,height:v,depthOrArrayLayers:6};w=e.createTexture({label:t,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,dimension:"2d",format:p,mipLevelCount:m,size:r});const a=e.createCommandEncoder({label:`${d} copy encoder`});a.copyTextureToTexture({texture:n,mipLevel:0},{texture:w,mipLevel:0},r),e.queue.submit([a.finish()]),await e.queue.onSubmittedWorkDone()}const x=(0,i._b)(m,(e=>w.createView({label:`${d} mip view ${e}`,dimension:"2d-array",baseMipLevel:e,mipLevelCount:1}))),A=e.limits.maxComputeWorkgroupsPerDimension,S=Math.ceil(Math.log2(v)),T=Math.max(l/((1+2*c)**2*h)|0,1),P=new ArrayBuffer(4*(S+1)),L=new Uint32Array(P,0,1);new Float32Array(P,4,S).set((0,i._b)(S,(e=>{const n=v>>e;return Math.acos(1-function(e,n){const t=n>>1,r=t-Math.floor(e/4)-1,a=2/t*(r+.5)-1,i=1/t-1,o=1+a*a+i*i,s=2/n*(2*n-2*r-e-2+.5)-1,u=1/n-1,c=1+s*s+u*u,l=3/n-1,d=1+s*s+l*l,f=(s+a+u*i)/Math.sqrt(c*o),v=(s+a+l*i)/Math.sqrt(d*o);return Math.min(1-f,1-v)}(Math.min(n,c),n))/3})));const U=(0,a.Lr)(P,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,e);return await new Promise((n=>{let t,r=0,a=0,i=0,o=0,s=0;!async function u(){if(o>=i){if(r+=1,o=0,a=0,r>=m)return void n();const s=6*(v>>r)**2;i=Math.ceil(s/h),t=e.createBindGroup({layout:g,entries:[{binding:0,resource:x[r-1]},{binding:1,resource:x[r]},{binding:2,resource:{buffer:U}}]})}L[0]=o*h,e.queue.writeBuffer(U,0,L);const c=Math.min(i-o,T-s,A),l=`${d} mip ${r}, pass ${a}`,p=e.createCommandEncoder({label:l}),y=p.beginComputePass({label:l});y.setPipeline(b),y.setBindGroup(0,t),y.dispatchWorkgroups(c,1,1),y.end(),e.queue.submit([p.finish()]),o+=c,s+=c,a+=1,null!=f&&s>=T?(s=0,await e.queue.onSubmittedWorkDone(),f(u)):u()}()})),w}},4508:(e,n,t)=>{t.a(e,(async(e,r)=>{try{t.d(n,{A:()=>l});var a=t(1299),i=t(1776),o=t(541);const s=await fetch("https://api.github.com/repos/KhronosGroup/glTF-Sample-Environments/contents?ref=low_resolution_hdrs",{headers:{"Content-Type":"application/vnd.github.object+json"}}).then((e=>e.json())),u=Object.fromEntries(s.flatMap((({name:e,download_url:n})=>"string"==typeof e&&"string"==typeof n&&n.endsWith(".hdr")?[[e,n]]:[])));async function c(e,n){let t;if(n instanceof ArrayBuffer)t=n;else if(n instanceof File)t=await n.arrayBuffer();else{const e=await fetch(n);t=await e.arrayBuffer()}const r=(0,a.y)(t);return(0,i.l3)(e,r,{format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC})}function l(e){return{[o.t.$type]:"file",[o.t.$callback]:async(n,t)=>{if("value"===t&&null!=n&&("string"==typeof n||n instanceof File)){const t=await c(e.device,n),r=e.setSkybox(t);r instanceof Promise&&await r}},accept:".hdr",selection:{value:Object.keys(u)[0],initialValues:u},process:e=>e}}r()}catch(d){r(d)}}),1)},9120:(e,n,t)=>{t.d(n,{A:()=>r});const r="\n    struct VertOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n    }\n\n    @vertex\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\n        const pos = array(\n            vec2f(-1,  3),\n            vec2f(3, -1),\n            vec2f(-1, -1),\n        );\n        var res: VertOut;\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\n        return res;\n    }\n"},7590:(e,n,t)=>{t.d(n,{V:()=>r,X:()=>a});const r="\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n",a="\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n"},71:(e,n,t)=>{t.d(n,{Lr:()=>o,gU:()=>u});var r=t(9253),a=t(2009),i=t(5225);function o(e,n,t,r,a=4){const i=a-1,o=t.createBuffer({label:r,usage:n,size:e.byteLength+i&~i,mappedAtCreation:!0}),s=new Uint8Array(o.getMappedRange()),u=e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength);return s.set(u),o.unmap(),o}async function s({device:e,texture:n,mipLevel:t=0,returnBuffer:r,storageBuffer:o,resultBuffer:s,description:u}){const c=a.T2[n.format],l=i.OY`[textureToKTX${u??""}${n.label}] --`;if(null==c)throw new Error(`${l} format ${n.format} unsupported`);const d=n.width>>t,f=n.height>>t,v=d*c,p=Math.max(v,256),m=f,h=m*p*n.depthOrArrayLayers,y=v*f*n.depthOrArrayLayers;if(null!=s&&s.byteLength<h)throw new Error(`${l} given result array not large enough.\n${s.byteLength} < ${h}`);if(null!=o&&o.size<h)throw new Error(`${l} given storage buffer not large enough.\n${o.size} < ${h}`);const g=GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ;if(null!=o&&(o.usage&g)!==g)throw new Error(`${l} given storage does not have correct usage flags.\nGiven: ${o.usage}\nRequired: ${g}`);let b=s??new Uint8Array(h);const w=o??e.createBuffer({label:`${l} storage buffer`,size:h,usage:g}),x=e.createCommandEncoder({label:`${l} encoder`});x.copyTextureToBuffer({texture:n,mipLevel:t},{buffer:w,rowsPerImage:m,bytesPerRow:p},{width:d,height:f,depthOrArrayLayers:n.depthOrArrayLayers}),e.queue.submit([x.finish()]),await Promise.all([w.mapAsync(GPUMapMode.READ,0,h),e.queue.onSubmittedWorkDone()]);const A=w.getMappedRange(0,h);if(b.set(new Uint8Array(A)),w.unmap(),p>v){for(let e=0;e<f*n.depthOrArrayLayers;e+=1)for(let n=0;n<v;n+=1)b[n+e*v]=b[n+e*p];b=b.slice(0,y)}return{imageData:b,storageBuffer:r?w:void 0}}async function u(e,n,t=!1){const i=a.T2[n.format],o=a.GE[n.format];if(null==i||null==o)throw new Error(`textureToKTX -- format ${n.format} of ${n.label} unsupported`);const u=new r.nYd;u.pixelWidth=n.width,u.pixelHeight=n.height,u.vkFormat=a.KO[n.format],u.typeSize=o,delete u.keyValue.KTXswizzle;const c=u.dataFormatDescriptor[0];if(c.colorModel=r.Tre,c.transferFunction=r.T5j,c.bytesPlane[0]=i,c.samples=[0,1,2,3].map((e=>({channelType:[192,193,194,207][e],samplePosition:[0,0,0,0],bitLength:8*u.typeSize-1,bitOffset:8*u.typeSize*e,sampleLower:-1082130432,sampleUpper:1065353216}))),"3d"===n.dimension)u.faceCount=1,u.pixelDepth=n.depthOrArrayLayers;else if(t){const e=n.depthOrArrayLayers/6;u.layerCount=1===e?0:e,u.faceCount=6}else u.layerCount=n.depthOrArrayLayers,u.faceCount=1;let l,d;for(let t=0;t<n.mipLevelCount;t+=1)({imageData:d,storageBuffer:l}=await s({mipLevel:t,returnBuffer:!0,device:e,texture:n,storageBuffer:l})),u.levels.push({levelData:d,uncompressedByteLength:d.byteLength});return r.M98(u)}},1299:(e,n,t)=>{t.d(n,{y:()=>c});const{baseTable:r,shiftTable:a}=(()=>{const e=new Uint32Array(256),n=new Uint32Array(256);for(let t=0;t<255;++t){const r=t-127;r<-27?(e[t]=0,n[t]=24):r<-14?(e[t]=1024>>-r-14,n[t]=-r-1):r<=15?(e[t]=r+15<<10,n[t]=13):(e[t]=31744,n[t]=24)}return e[255]=31744,n[255]=13,{baseTable:e,shiftTable:n}})(),i=new ArrayBuffer(4),o=new Float32Array(i),s=new Uint32Array(i);function u(e){o[0]=e;const n=s[0],t=n>>23&511,i=255&t;return r[i]+((8388607&n)>>a[i])+((256&t)<<7)}t(1776);function c(e){const n=new TextDecoder,t=e instanceof Uint8Array?e:new Uint8Array(e);let r=0;const a=(e=1024)=>{const a=Math.min(t.length,e+r),i=t.subarray(r,a),o=i.indexOf(10)+1;return r+=o,0===o?void 0:n.decode(i.subarray(0,o))},i=e=>new Error("HDR Import Error: "+e),o=a();if(null==o)throw i("no header found");if(!/^#\?(\S+)/.test(o))throw i("bad initial token");const s=new RegExp(`^\\s*(${[/FORMAT=(?<format>\S+)/,/-Y\s+(?<Y>\d+)\s+\+X\s+(?<X>\d+)/,/EXPOSURE\s*=\s*(?<exposure>\d+(\.\d+)?)/,/GAMMA\s*=\s*(?<gamma>\d+(\.\d+)?)/].map((({source:e})=>`(${e})`)).join("|")})\\s*$`);let c,l,d,f=!0,v=1,p=1;for(let e=a();null!=e;e=null==c?a():void 0){const n=e.match(s)?.groups;null!=n&&(null!=n.format?f=!1:null!=n.X&&null!=n.Y?(c=parseInt(n.X),l=parseInt(n.Y)):null!=n.gamma?v=parseFloat(n.gamma):null!=n.exposure&&(p=parseFloat(n.exposure)))}if(f)throw i("missing format specifier");if(null==c||null==l)throw i("missing image size specifier");const m=c<8||c>32767,h=2!==t[r]||2!==t[r+1]||!!(128&t[r+2]);if(m||h)d=t.subarray(r);else{d=new Uint8Array(c*l*4);const e=4*c,n=new Uint8Array(e),a=t.byteLength;for(let o=0,s=0;o<l&&r<a;o++){if(r+4>a)throw i("file ended durning scanline");if(2!=t[r++]||2!=t[r++]||(t[r++]<<8|t[r++])!=c)throw i("bad rgbe scanline format");let o;for(let s=0;s<e&&r<a;s+=o){o=t[r++];const a=o>128;if(a&&(o-=128),0==o||s+o>e)throw i("bad scanline data");a?(n.fill(t[r],s,s+o),r+=1):(n.set(t.subarray(r,r+o),s),r+=o)}for(let t=0;t<c;t++)for(let r=0;r<e;r+=c)d[s++]=n[t+r]}}const y=new Uint16Array(d.length),g=u(1);for(let e=0;e<c*l*4;e+=4){const n=d[e+3],t=Math.pow(2,n-128)/255;for(let n=0;n<3;n+=1)y[e+n]=u(Math.min(d[e+n]*t,65504));y[e+3]=g}return{data:y,width:c,height:l,gamma:v,exposure:p}}},1776:(e,n,t)=>{t.d(n,{l3:()=>s});var r=t(9120),a=t(7590),i=t(71),o=t(5225);async function s(e,{data:n,width:t,height:s,gamma:u=1,exposure:c=1},l){const d=`\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${r.A}\n        ${a.V}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;let f,v=0;n instanceof GPUTexture?f=n:(v=1,f=e.createTexture({label:`${l.label} equirectangular`,dimension:"2d",format:"rgba16float",size:{width:t,height:s},usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING}),e.queue.writeTexture({texture:f,mipLevel:0},n,{bytesPerRow:2*t*4},{width:t,height:s,depthOrArrayLayers:1}),await e.queue.onSubmittedWorkDone());const p=f.height>>1,m=l;m.mipLevelCount??=0|Math.log2(p),m.size={width:p,height:p,depthOrArrayLayers:6},m.dimension="2d",m.usage|=GPUTextureUsage.RENDER_ATTACHMENT;const h=e.createTexture(m),y=o.OY`hdr copy${l.label}`,g=e.createBindGroupLayout({label:y,entries:[{binding:0,texture:{},visibility:GPUShaderStage.FRAGMENT},{binding:1,sampler:{},visibility:GPUShaderStage.FRAGMENT},{binding:2,buffer:{},visibility:GPUShaderStage.FRAGMENT}]}),b=e.createShaderModule({label:y,code:d}),w=e.createSampler({label:y,minFilter:"linear",magFilter:"linear"}),x=new Uint32Array(1),A=(0,i.Lr)(x,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,e,y),S=e.createBindGroup({label:y,layout:g,entries:[{binding:0,resource:f.createView()},{binding:1,resource:w},{binding:2,resource:{buffer:A}}]}),T=e.createPipelineLayout({label:y,bindGroupLayouts:[g]}),P=e.createRenderPipeline({label:y,layout:T,vertex:{module:b},fragment:{module:b,targets:[{format:h.format}],constants:{GAMMA:u,EXPOSURE:c,FLIP_Y:v}}});for(let n=0;n<6;n+=1){x[0]=n,e.queue.writeBuffer(A,0,x,0,1);const t=h.createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:n,mipLevelCount:1}),r=e.createCommandEncoder(),a=r.beginRenderPass({label:y,colorAttachments:[{view:t,loadOp:"clear",storeOp:"store"}]});a.setPipeline(P),a.setBindGroup(0,S),a.draw(3),a.end(),e.queue.submit([r.finish()])}return h}}}]);
//# sourceMappingURL=739.bundle.js.map