{"version":3,"file":"645.bundle.js","mappings":"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","sources":["webpack://cbunt-portfolio/./src/rendering/utils/texture-importing.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-copy.ts","webpack://cbunt-portfolio/./src/rendering/samples/cubemap-blur/cubemap-blur-sample.ts","webpack://cbunt-portfolio/./src/utils/general.ts","webpack://cbunt-portfolio/./src/rendering/core/constants.ts","webpack://cbunt-portfolio/./src/rendering/utils/texture-processing.ts"],"sourcesContent":["import { toFloat16Bytes } from './data-conversion';\nimport { srgbTextureToLinear, generateMips } from './texture-processing';\n\nexport type imageToTextureDescriptor = {\n    device: GPUDevice,\n    data: Uint8Array | Blob | File | ImageBitmap,\n    mimeType?: string,\n    label?: string,\n    usage?: number,\n    format?: GPUTextureFormat,\n    mips?: boolean,\n    srgbToLinear?: boolean,\n    colorSpace?: PredefinedColorSpace,\n};\n\nexport async function imageToTexture({\n    device,\n    data,\n    mimeType,\n    usage = GPUTextureUsage.TEXTURE_BINDING,\n    mips = true,\n    format = 'rgba8unorm',\n    colorSpace = 'srgb',\n    label = '',\n    srgbToLinear,\n}: imageToTextureDescriptor) {\n    let bitmap: ImageBitmap;\n\n    if (data instanceof ImageBitmap) {\n        bitmap = data;\n    } else {\n        const blob = (data instanceof Blob || data instanceof File)\n            ? data\n            : new Blob([data], { type: mimeType });\n        bitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n    }\n\n    const size = { width: bitmap.width, height: bitmap.height };\n\n    const texture = device.createTexture({\n        label,\n        format,\n        size: size,\n        usage: usage | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: mips ? 1 + (Math.log2(Math.max(bitmap.width, bitmap.height)) | 0) : 1,\n    });\n\n    device.queue.copyExternalImageToTexture(\n        { source: bitmap },\n        { texture, colorSpace },\n        size,\n    );\n\n    if (srgbToLinear) srgbTextureToLinear(device, texture);\n    if (mips) void generateMips(device, texture);\n\n    return texture;\n}\n\nexport function parseHDR(inData: Uint8Array | ArrayBuffer) {\n    const decoder = new TextDecoder();\n    const buffer = inData instanceof Uint8Array ? inData : new Uint8Array(inData);\n    let pos = 0;\n\n    const getLine = (lineLimit = 1024) => {\n        const limit = Math.min(buffer.length, lineLimit + pos);\n        const sub = buffer.subarray(pos, limit);\n        const end = sub.indexOf(0x0A) + 1;\n        pos += end;\n        return end === 0 ? undefined : decoder.decode(sub.subarray(0, end));\n    };\n\n    const importError = (msg: string) => new Error('HDR Import Error: ' + msg);\n\n    // #region Read Header\n    const magicTokenRegex = /^#\\?(\\S+)/;\n    const magicTokenLine = getLine();\n\n    if (magicTokenLine == null) throw importError('no header found');\n    if (!magicTokenRegex.test(magicTokenLine)) throw importError('bad initial token');\n\n    const headerRegs = [\n        /FORMAT=(?<format>\\S+)/, // format\n        /-Y\\s+(?<Y>\\d+)\\s+\\+X\\s+(?<X>\\d+)/, // size\n        /EXPOSURE\\s*=\\s*(?<exposure>\\d+(\\.\\d+)?)/, // exposure\n        /GAMMA\\s*=\\s*(?<gamma>\\d+(\\.\\d+)?)/, // gamma\n    ];\n\n    const headerReg = new RegExp(`^\\\\s*(${\n        headerRegs.map(({ source }) => `(${source})`).join('|')\n    })\\\\s*$`);\n\n    let noFormat = true;\n    let gamma = 1; /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n    let exposure = 1; /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n    let width: number | undefined = undefined;\n    let height: number | undefined = undefined;\n\n    for (let line = getLine(); line != null; line = width == null ? getLine() : undefined) {\n        const groups = line.match(headerReg)?.groups as Partial<Record<string, string>> | undefined;\n        if (groups == null) continue;\n\n        if (groups.format != null) {\n            noFormat = false;\n        } else if (groups.X != null && groups.Y != null) {\n            width = parseInt(groups.X);\n            height = parseInt(groups.Y);\n        } else if (groups.gamma != null) {\n            gamma = parseFloat(groups.gamma);\n        } else if (groups.exposure != null) {\n            exposure = parseFloat(groups.exposure);\n        }\n    }\n\n    if (noFormat) throw importError('missing format specifier');\n    if (width == null || height == null) throw importError('missing image size specifier');\n    // #endregion\n\n    // #region Read Scanline Data\n    let rawData: Uint8Array;\n    const unencodable = width < 8 || width > 0x7fff;\n    const flatData = buffer[pos] !== 2 || buffer[pos + 1] !== 2 || (buffer[pos + 2] & 0x80) !== 0;\n\n    if (unencodable || flatData) {\n        rawData = buffer.subarray(pos);\n    } else {\n        rawData = new Uint8Array(width * height * 4);\n        const end = 4 * width;\n        const scanline_buffer = new Uint8Array(end);\n        const len = buffer.byteLength;\n\n        for (let k = 0, offset = 0; k < height && pos < len; k++) {\n            if (pos + 4 > len)\n                throw importError('file ended durning scanline');\n\n            if ((2 != buffer[pos++]) || (2 != buffer[pos++]) || (((buffer[pos++] << 8) | buffer[pos++]) != width))\n                throw importError('bad rgbe scanline format');\n\n            let count;\n            for (let ptr = 0; ptr < end && pos < len; ptr += count) {\n                count = buffer[pos++];\n                const isEncodedRun = count > 128;\n                if (isEncodedRun) count -= 128;\n\n                if (count == 0 || ptr + count > end)\n                    throw importError('bad scanline data');\n\n                if (isEncodedRun) {\n                    scanline_buffer.fill(buffer[pos], ptr, ptr + count);\n                    pos += 1;\n                } else {\n                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                    pos += count;\n                }\n            }\n\n            for (let i = 0; i < width; i++)\n                for (let j = 0; j < end; j += width)\n                    rawData[offset++] = scanline_buffer[i + j];\n        }\n    }\n    // #endregion\n\n    // #region Convert to Float16\n    const data = new Uint16Array(rawData.length);\n    const float16One = toFloat16Bytes(1);\n\n    for (let i = 0; i < width * height * 4; i += 4) {\n        const raw_e = rawData[i + 3];\n        const scale = Math.pow(2.0, raw_e - 128.0) / 255.0;\n\n        for (let j = 0; j < 3; j += 1) {\n            data[i + j] = toFloat16Bytes(Math.min(rawData[i + j] * scale, 65504));\n        }\n        data[i + 3] = float16One;\n    }\n    // #endregion\n\n    return { data, width, height, gamma, exposure };\n}\n","import * as ktxparse from 'ktx-parse';\r\n\r\nimport { TextureFormatToSize, TextureFormatToChannelSize, WebGPUToVkFormat } from '../core/constants';\r\nimport { mapRange, padTemplate } from '../../utils/general';\r\n\r\nexport function createAndCopyBuffer(\r\n    arr: ArrayBuffer | ArrayBufferView,\r\n    usage: GPUFlagsConstant,\r\n    device: GPUDevice,\r\n    label?: string,\r\n    alignment = 4,\r\n): GPUBuffer {\r\n    const pad = alignment - 1;\r\n    const buffer = device.createBuffer({\r\n        label,\r\n        usage,\r\n        size: (arr.byteLength + pad) & ~pad,\r\n        mappedAtCreation: true,\r\n    } as GPUBufferDescriptor);\r\n\r\n    const writeArray = new Uint8Array(buffer.getMappedRange());\r\n    const readArray = arr instanceof ArrayBuffer\r\n        ? new Uint8Array(arr)\r\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\n\r\n    writeArray.set(readArray);\r\n    buffer.unmap();\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function createAndCopyCubemap(\r\n    device: GPUDevice,\r\n    data: ArrayBuffer,\r\n    format: GPUTextureFormat,\r\n    usage: number,\r\n    label?: string,\r\n) {\r\n    const pixelSize = TextureFormatToSize[format];\r\n    if (pixelSize == null) {\r\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\r\n    }\r\n\r\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\r\n    const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n    const texture = device.createTexture({\r\n        usage: usage | GPUTextureUsage.COPY_DST,\r\n        label,\r\n        format,\r\n        size,\r\n    });\r\n\r\n    device.queue.writeTexture(\r\n        { texture },\r\n        data,\r\n        { bytesPerRow: width * pixelSize, rowsPerImage: width },\r\n        size,\r\n    );\r\n\r\n    return texture;\r\n}\r\n\r\nexport type TextureToArrayBufferOptions = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    mipLevel?: number,\r\n    resultBuffer?: Uint8Array,\r\n    storageBuffer?: GPUBuffer,\r\n    returnBuffer?: boolean,\r\n    description?: string,\r\n};\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer?: false },\r\n): Promise<{ imageData: Uint8Array }>;\r\n\r\nexport async function textureToArrayBuffer(\r\n    options: Omit<TextureToArrayBufferOptions, 'returnBuffer'> & { returnBuffer: true },\r\n): Promise<{ imageData: Uint8Array, storageBuffer: GPUBuffer }>;\r\n\r\nexport async function textureToArrayBuffer({\r\n    device,\r\n    texture,\r\n    mipLevel = 0,\r\n    returnBuffer,\r\n    storageBuffer,\r\n    resultBuffer,\r\n    description,\r\n}: TextureToArrayBufferOptions) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const fullDescription = padTemplate`[textureToKTX${description ?? ''}${texture.label}] --`;\r\n\r\n    if (pixelSize == null) {\r\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\r\n    }\r\n\r\n    const width = texture.width >> mipLevel;\r\n    const height = texture.height >> mipLevel;\r\n    const rawBytesPerRow = width * pixelSize;\r\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\r\n    const rowsPerImage = height;\r\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\r\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\r\n\r\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\r\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\r\n    }\r\n\r\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\r\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\r\n    }\r\n\r\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\r\n\r\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\r\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\r\n    }\r\n\r\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\r\n    const storage = storageBuffer ?? device.createBuffer({\r\n        label: `${fullDescription} storage buffer`,\r\n        size: byteSize,\r\n        usage: requiredUsage,\r\n    });\r\n\r\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\r\n    encoder.copyTextureToBuffer(\r\n        { texture, mipLevel },\r\n        { buffer: storage, rowsPerImage, bytesPerRow },\r\n        { width, height, depthOrArrayLayers: texture.depthOrArrayLayers },\r\n    );\r\n    device.queue.submit([encoder.finish()]);\r\n\r\n    await Promise.all([\r\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\r\n        device.queue.onSubmittedWorkDone(),\r\n    ]);\r\n\r\n    const mapped = storage.getMappedRange(0, byteSize);\r\n    imageData.set(new Uint8Array(mapped));\r\n    storage.unmap();\r\n\r\n    if (bytesPerRow > rawBytesPerRow) {\r\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\r\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\r\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\r\n            }\r\n        }\r\n        imageData = imageData.slice(0, resultSize);\r\n    }\r\n\r\n    return {\r\n        imageData,\r\n        storageBuffer: returnBuffer ? storage : undefined,\r\n    };\r\n}\r\n\r\nexport async function textureToKTX(device: GPUDevice, texture: GPUTexture, cube = false) {\r\n    const pixelSize = TextureFormatToSize[texture.format];\r\n    const typeSize = TextureFormatToChannelSize[texture.format];\r\n\r\n    if (pixelSize == null || typeSize == null) {\r\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\r\n    }\r\n\r\n    const container = ktxparse.createDefaultContainer();\r\n    container.pixelWidth = texture.width;\r\n    container.pixelHeight = texture.height;\r\n    container.vkFormat = WebGPUToVkFormat[texture.format];\r\n    container.typeSize = typeSize;\r\n    delete container.keyValue.KTXswizzle;\r\n\r\n    const dataFormat = container.dataFormatDescriptor[0];\r\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\r\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\r\n    dataFormat.bytesPlane[0] = pixelSize;\r\n\r\n    dataFormat.samples = mapRange(4, (i) => ({\r\n        channelType: [192, 193, 194, 207][i],\r\n        samplePosition: [0, 0, 0, 0],\r\n        bitLength: container.typeSize * 8 - 1,\r\n        bitOffset: container.typeSize * 8 * i,\r\n        sampleLower: -1082130432,\r\n        sampleUpper: 1065353216,\r\n    }));\r\n\r\n    if (texture.dimension === '3d') {\r\n        container.faceCount = 1;\r\n        container.pixelDepth = texture.depthOrArrayLayers;\r\n    } else if (cube) {\r\n        const cubeLayers = texture.depthOrArrayLayers / 6;\r\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\r\n        container.faceCount = 6;\r\n    } else {\r\n        container.layerCount = texture.depthOrArrayLayers;\r\n        container.faceCount = 1;\r\n    }\r\n\r\n    let storageBuffer: GPUBuffer | undefined;\r\n    let imageData: Uint8Array;\r\n\r\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\r\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\r\n            mipLevel: i,\r\n            returnBuffer: true,\r\n            device,\r\n            texture,\r\n            storageBuffer,\r\n        }));\r\n\r\n        container.levels.push({\r\n            levelData: imageData,\r\n            uncompressedByteLength: imageData.byteLength,\r\n        });\r\n    }\r\n\r\n    return ktxparse.write(container);\r\n}\r\n","import { showSaveFilePicker } from 'native-file-system-adapter';\n\nimport getSkyboxOptions from '../settings/skybox-options';\nimport { RenderModel } from '../settings/sample-spec';\nimport propertyListener, { ListenerSyms } from '../settings/property-listener';\n\nimport { textureToKTX } from '../../utils/data-copy';\nimport Renderer, { ForwardPassParams } from '../../core/renderer';\n\nimport cubemapGuassianPyramid from './cubemap-guassian-pyramid';\n\nenum BlurState { IDLE, BLUR, WAIT }\n\nexport default class CubemapBlurModel implements RenderModel {\n    skybox?: GPUTexture;\n    state: BlurState = BlurState.IDLE;\n\n    readonly #settings = propertyListener({\n        nearestSample: {\n            [ListenerSyms.$type]: 'checkbox' as const,\n            [ListenerSyms.$callback]: (val: unknown) => {\n                if (typeof val === 'boolean') this.renderer.skyboxPass.useNearestSample = val;\n            },\n            value: false,\n            description: 'Disables linear sampling in the viewer.',\n        },\n        mipLevel: {\n            [ListenerSyms.$type]: 'slider' as const,\n            [ListenerSyms.$callback]: (value: unknown) => {\n                if (typeof value === 'number') this.renderer.skyboxPass.mipLevel = value;\n            },\n            value: 0,\n            min: 0,\n            max: 1,\n            step: 0.1,\n            description: 'The mip level to display in the viewer. 0 is the original image, max is completely blurred with 1 pixel faces.',\n        },\n        filterDistance: {\n            [ListenerSyms.$type]: 'slider' as const,\n            [ListenerSyms.$callback]: this.reblur.bind(this) as () => void,\n            value: 8,\n            max: 64,\n            min: 0,\n            step: 0.1,\n            description: 'The number of pixels to blur from.',\n        },\n        skybox: getSkyboxOptions(this),\n        'Download Result': {\n            [ListenerSyms.$type]: 'button' as const,\n            onClick: () => { this.saveFile().catch(console.error); },\n        },\n    });\n\n    readonly settings = this.#settings.publicSettings;\n    readonly priority = 0;\n    device: GPUDevice;\n\n    constructor(public renderer: Renderer) {\n        renderer.addForwardPass(this);\n        this.device = renderer.device;\n    }\n\n    setSkybox(skybox: GPUTexture) {\n        this.skybox = skybox;\n        this.#settings.privateSettings.mipLevel.max = this.skybox.mipLevelCount - 1;\n        this.#settings.privateSettings.mipLevel.value = 1;\n        this.renderer.skyboxPass.mipLevel = 1;\n\n        this.refresh();\n        this.reblur().catch(console.error);\n    }\n\n    resolve() {\n        this.refresh();\n        const lastState = this.state;\n        this.state = BlurState.IDLE;\n        if (lastState === BlurState.WAIT) this.reblur().catch(console.error);\n    }\n\n    async reblur() {\n        if (this.skybox == null || this.state === BlurState.WAIT) return;\n\n        if (this.state === BlurState.BLUR) {\n            this.state = BlurState.WAIT;\n            return;\n        }\n\n        this.state = BlurState.BLUR;\n\n        await cubemapGuassianPyramid({\n            device: this.renderer.device,\n            texture: this.skybox,\n            steps: this.settings.filterDistance.value,\n            inPlace: true,\n            delayWork: requestAnimationFrame,\n        });\n\n        this.resolve();\n    }\n\n    refresh() {\n        if (this.skybox == null) return;\n        this.renderer.skyboxPass.skyTexture = this.skybox.createView({ dimension: 'cube' });\n    }\n\n    async saveFile() {\n        if (this.skybox == null) return;\n        const proms = Promise.all([\n            textureToKTX(this.renderer.device, this.skybox, true)\n                .then((ktx2) => new Blob([ktx2], { type: 'image/ktx2' })),\n            showSaveFilePicker({\n                types: [{ accept: { 'image/ktx2': ['.ktx2'] } }],\n                suggestedName: 'blurred-skybox.ktx2',\n            }).then((handle) => handle.createWritable({ keepExistingData: false })),\n        ]);\n\n        const [blob, stream] = await proms;\n        await blob.stream().pipeTo(stream);\n    }\n\n    render({ encoder, gbuffer }: ForwardPassParams) {\n        encoder.beginRenderPass({\n            colorAttachments: [],\n            depthStencilAttachment: {\n                depthClearValue: 1,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n                view: gbuffer.depth.view,\n            },\n        }).end();\n    }\n}\n","export type UnknownObject = Record<PropertyKey, unknown>;\r\n\r\nexport function mapValues<Input, ObjectType extends Partial<Record<keyof ObjectType, Input>>, Output>(\r\n    obj: ObjectType,\r\n    fn: (val: Input) => Output,\r\n) {\r\n    const entries = Object.entries(obj) as [keyof ObjectType, Input][];\r\n    const mapped = entries.map(([key, val]) => [key, fn(val)]);\r\n    return Object.fromEntries(mapped) as { [K in keyof ObjectType]: Output };\r\n}\r\n\r\nexport function clamp(num: number, min: number, max: number) {\r\n    return Math.max(min, Math.min(max, num));\r\n}\r\n\r\nexport function padCheck(str: string | undefined) {\r\n    return str == null || str === '' ? '' : ` ${str}`;\r\n}\r\n\r\nexport function padTemplate(strings: TemplateStringsArray, ...values: (string | undefined)[]) {\r\n    const result = [strings[0]];\r\n    values.forEach((key, i) => result.push(padCheck(key), strings[i + 1]));\r\n    return result.join('');\r\n}\r\n\r\nexport function range(n: number) {\r\n    return [...Array(n).keys()];\r\n}\r\n\r\nexport function mapRange<T>(n: number, fn: (i: number) => T) {\r\n    return range(n).map(fn);\r\n}\r\n\r\nexport function debounce<Args extends Array<unknown>>(callback: (...args: Args) => unknown, delay: number) {\r\n    let tid: ReturnType<typeof setTimeout> | undefined;\r\n    return function (...args: Args) {\r\n        const ctx = self;\r\n        if (tid != null) clearTimeout(tid);\r\n        tid = setTimeout(() => { callback.apply(ctx, args); }, delay);\r\n    };\r\n};\r\n\r\n// adapted from https://stackoverflow.com/a/60702475/17108769\r\nexport function binaryInsert<T>(\r\n    arr: T[],\r\n    element: T,\r\n    comparator: (a: T, b: T) => number,\r\n    left = 0,\r\n    right = arr.length - 1,\r\n) {\r\n    if (right - left <= 1) {\r\n        if (comparator(element, arr[left] ?? element) < 0) arr.splice(left, 0, element);\r\n        else if (comparator(element, arr[right] ?? element) > 0) arr.splice(right + 1, 0, element);\r\n        else arr.splice(right, 0, element);\r\n    } else {\r\n        const pivot = Math.floor((right - left) / 2) + left;\r\n        if (comparator(element, arr[pivot]) < 0) binaryInsert(arr, element, comparator, left, pivot);\r\n        else binaryInsert(arr, element, comparator, pivot, right);\r\n    }\r\n}\r\n\r\nexport function isObject(val: unknown): val is NonNullable<UnknownObject> {\r\n    return typeof val === 'object' && val != null;\r\n}\r\n","import * as ktxp from 'ktx-parse';\r\n\r\nexport const TypeSizes = {\r\n    mat4x4Count: 16,\r\n    sizeofMat4x4f: 16 * Float32Array.BYTES_PER_ELEMENT,\r\n};\r\n\r\nexport const VkFormatToWebGPU: Record<number, GPUTextureFormat | undefined> = {\r\n    // 8-bit formats\r\n    [ktxp.VK_FORMAT_R8_UNORM]: 'r8unorm',\r\n    [ktxp.VK_FORMAT_R8_SNORM]: 'r8snorm',\r\n    [ktxp.VK_FORMAT_R8_UINT]: 'r8uint',\r\n    [ktxp.VK_FORMAT_R8_SINT]: 'r8sint',\r\n    // 16-bit formats\r\n    [ktxp.VK_FORMAT_R16_UINT]: 'r16uint',\r\n    [ktxp.VK_FORMAT_R16_SINT]: 'r16sint',\r\n    [ktxp.VK_FORMAT_R16_SFLOAT]: 'r16float',\r\n    [ktxp.VK_FORMAT_R8G8_UNORM]: 'rg8unorm',\r\n    [ktxp.VK_FORMAT_R8G8_SNORM]: 'rg8snorm',\r\n    [ktxp.VK_FORMAT_R8G8_UINT]: 'rg8uint',\r\n    [ktxp.VK_FORMAT_R8G8_SINT]: 'rg8sint',\r\n    // 32-bit formats\r\n    [ktxp.VK_FORMAT_R32_UINT]: 'r32uint',\r\n    [ktxp.VK_FORMAT_R32_SINT]: 'r32sint',\r\n    [ktxp.VK_FORMAT_R32_SFLOAT]: 'r32float',\r\n    [ktxp.VK_FORMAT_R16G16_UINT]: 'rg16uint',\r\n    [ktxp.VK_FORMAT_R16G16_SINT]: 'rg16sint',\r\n    [ktxp.VK_FORMAT_R16G16_SFLOAT]: 'rg16float',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UNORM]: 'rgba8unorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SRGB]: 'rgba8unorm-srgb',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SNORM]: 'rgba8snorm',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_UINT]: 'rgba8uint',\r\n    [ktxp.VK_FORMAT_R8G8B8A8_SINT]: 'rgba8sint',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_UNORM]: 'bgra8unorm',\r\n    [ktxp.VK_FORMAT_B8G8R8A8_SRGB]: 'bgra8unorm-srgb',\r\n    // Packed 32-bit formats\r\n    [ktxp.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32]: 'rgb9e5ufloat',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UINT_PACK32]: 'rgb10a2uint',\r\n    [ktxp.VK_FORMAT_A2R10G10B10_UNORM_PACK32]: 'rgb10a2unorm',\r\n    [ktxp.VK_FORMAT_B10G11R11_UFLOAT_PACK32]: 'rg11b10ufloat',\r\n    // 64-bit formats\r\n    [ktxp.VK_FORMAT_R32G32_UINT]: 'rg32uint',\r\n    [ktxp.VK_FORMAT_R32G32_SINT]: 'rg32sint',\r\n    [ktxp.VK_FORMAT_R32G32_SFLOAT]: 'rg32float',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_UINT]: 'rgba16uint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SINT]: 'rgba16sint',\r\n    [ktxp.VK_FORMAT_R16G16B16A16_SFLOAT]: 'rgba16float',\r\n    // 128-bit formats\r\n    [ktxp.VK_FORMAT_R32G32B32A32_UINT]: 'rgba32uint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SINT]: 'rgba32sint',\r\n    [ktxp.VK_FORMAT_R32G32B32A32_SFLOAT]: 'rgba32float',\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    [ktxp.VK_FORMAT_BC1_RGBA_UNORM_BLOCK]: 'bc1-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC1_RGBA_SRGB_BLOCK]: 'bc1-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC2_UNORM_BLOCK]: 'bc2-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC2_SRGB_BLOCK]: 'bc2-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC3_UNORM_BLOCK]: 'bc3-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC3_SRGB_BLOCK]: 'bc3-rgba-unorm-srgb',\r\n    [ktxp.VK_FORMAT_BC4_UNORM_BLOCK]: 'bc4-r-unorm',\r\n    [ktxp.VK_FORMAT_BC4_SNORM_BLOCK]: 'bc4-r-snorm',\r\n    [ktxp.VK_FORMAT_BC5_UNORM_BLOCK]: 'bc5-rg-unorm',\r\n    [ktxp.VK_FORMAT_BC5_SNORM_BLOCK]: 'bc5-rg-snorm',\r\n    [ktxp.VK_FORMAT_BC6H_UFLOAT_BLOCK]: 'bc6h-rgb-ufloat',\r\n    [ktxp.VK_FORMAT_BC6H_SFLOAT_BLOCK]: 'bc6h-rgb-float',\r\n    [ktxp.VK_FORMAT_BC7_UNORM_BLOCK]: 'bc7-rgba-unorm',\r\n    [ktxp.VK_FORMAT_BC7_SRGB_BLOCK]: 'bc7-rgba-unorm-srgb',\r\n    // Currently unsupported extension formats:\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"etc2-rgb8unorm\",\r\n    // \"etc2-rgb8unorm-srgb\",\r\n    // \"etc2-rgb8a1unorm\",\r\n    // \"etc2-rgb8a1unorm-srgb\",\r\n    // \"etc2-rgba8unorm\",\r\n    // \"etc2-rgba8unorm-srgb\",\r\n    // \"eac-r11unorm\",\r\n    // \"eac-r11snorm\",\r\n    // \"eac-rg11unorm\",\r\n    // \"eac-rg11snorm\",\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    // \"astc-4x4-unorm\",\r\n    // \"astc-4x4-unorm-srgb\",\r\n    // \"astc-5x4-unorm\",\r\n    // \"astc-5x4-unorm-srgb\",\r\n    // \"astc-5x5-unorm\",\r\n    // \"astc-5x5-unorm-srgb\",\r\n    // \"astc-6x5-unorm\",\r\n    // \"astc-6x5-unorm-srgb\",\r\n    // \"astc-6x6-unorm\",\r\n    // \"astc-6x6-unorm-srgb\",\r\n    // \"astc-8x5-unorm\",\r\n    // \"astc-8x5-unorm-srgb\",\r\n    // \"astc-8x6-unorm\",\r\n    // \"astc-8x6-unorm-srgb\",\r\n    // \"astc-8x8-unorm\",\r\n    // \"astc-8x8-unorm-srgb\",\r\n    // \"astc-10x5-unorm\",\r\n    // \"astc-10x5-unorm-srgb\",\r\n    // \"astc-10x6-unorm\",\r\n    // \"astc-10x6-unorm-srgb\",\r\n    // \"astc-10x8-unorm\",\r\n    // \"astc-10x8-unorm-srgb\",\r\n    // \"astc-10x10-unorm\",\r\n    // \"astc-10x10-unorm-srgb\",\r\n    // \"astc-12x10-unorm\",\r\n    // \"astc-12x10-unorm-srgb\",\r\n    // \"astc-12x12-unorm\",\r\n};\r\n\r\nexport const TextureFormatToSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 2,\r\n    rg8snorm: 2,\r\n    rg8uint: 2,\r\n    rg8sint: 2,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 4,\r\n    rg16sint: 4,\r\n    rg16float: 4,\r\n    rgba8unorm: 4,\r\n    'rgba8unorm-srgb': 4,\r\n    rgba8snorm: 4,\r\n    rgba8uint: 4,\r\n    rgba8sint: 4,\r\n    bgra8unorm: 4,\r\n    'bgra8unorm-srgb': 4,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 8,\r\n    rg32sint: 8,\r\n    rg32float: 8,\r\n    rgba16uint: 8,\r\n    rgba16sint: 8,\r\n    rgba16float: 8,\r\n    // 128-bit formats\r\n    rgba32uint: 16,\r\n    rgba32sint: 16,\r\n    rgba32float: 16,\r\n};\r\n\r\nexport const TextureFormatToChannelSize: Partial<Record<GPUTextureFormat, number>> = {\r\n    // 8-bit formats\r\n    r8unorm: 1,\r\n    r8snorm: 1,\r\n    r8uint: 1,\r\n    r8sint: 1,\r\n    // 16-bit formats\r\n    r16uint: 2,\r\n    r16sint: 2,\r\n    r16float: 2,\r\n    rg8unorm: 1,\r\n    rg8snorm: 1,\r\n    rg8uint: 1,\r\n    rg8sint: 1,\r\n    // 32-bit formats\r\n    r32uint: 4,\r\n    r32sint: 4,\r\n    r32float: 4,\r\n    rg16uint: 2,\r\n    rg16sint: 2,\r\n    rg16float: 2,\r\n    rgba8unorm: 1,\r\n    'rgba8unorm-srgb': 1,\r\n    rgba8snorm: 1,\r\n    rgba8uint: 1,\r\n    rgba8sint: 1,\r\n    bgra8unorm: 1,\r\n    'bgra8unorm-srgb': 1,\r\n    // Packed 32-bit formats\r\n    rgb9e5ufloat: 4,\r\n    rgb10a2uint: 4,\r\n    rgb10a2unorm: 4,\r\n    rg11b10ufloat: 4,\r\n    // 64-bit formats\r\n    rg32uint: 4,\r\n    rg32sint: 4,\r\n    rg32float: 4,\r\n    rgba16uint: 2,\r\n    rgba16sint: 2,\r\n    rgba16float: 2,\r\n    // 128-bit formats\r\n    rgba32uint: 4,\r\n    rgba32sint: 4,\r\n    rgba32float: 4,\r\n};\r\n\r\nexport const WebGPUToVkFormat = Object.fromEntries(\r\n    Object.entries(VkFormatToWebGPU).map(([vk, wgpu]) => [wgpu, parseInt(vk, 10)]),\r\n) as Record<GPUTextureFormat, ktxp.VKFormat>;\r\n\r\nexport const textureTypeToDimension: Record<string, GPUTextureViewDimension> = {\r\n    texture_cube: 'cube',\r\n    texture_3d: '3d',\r\n    texture_2d: '2d',\r\n};\r\n","import blit from '../shaders/blit-vert.shader';\nimport { toWorldDir } from '../shaders/cubemap-sampling.shader';\nimport { createAndCopyBuffer } from './data-copy';\nimport { padTemplate } from '../../utils/general';\n\ntype EquirectangularDescriptor = {\n    data: SharedArrayBuffer | BufferSource | GPUTexture,\n    width: number,\n    height: number,\n    gamma?: number,\n    exposure?: number,\n};\n\nexport async function equirectangularToCubemap(\n    device: GPUDevice,\n    { data, width, height, gamma = 1, exposure = 1 }: EquirectangularDescriptor,\n    outputDescriptor: Omit<GPUTextureDescriptor, 'dimension' | 'size'>,\n) {\n    const code = /* wgsl */ `\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${blit}\n        ${toWorldDir}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;\n\n    let FLIP_Y = 0;\n    let equirectangular: GPUTexture;\n    if (data instanceof GPUTexture) {\n        equirectangular = data;\n    } else {\n        FLIP_Y = 1;\n        equirectangular = device.createTexture({\n            label: `${outputDescriptor.label} equirectangular`,\n            dimension: '2d',\n            format: 'rgba16float',\n            size: { width, height },\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        });\n\n        device.queue.writeTexture(\n            { texture: equirectangular, mipLevel: 0 },\n            data,\n            { bytesPerRow: width * 2 * 4 },\n            { width, height, depthOrArrayLayers: 1 },\n        );\n        await device.queue.onSubmittedWorkDone();\n    }\n\n    const faceSize = equirectangular.height >> 1;\n    const cubemapDescriptor = outputDescriptor as GPUTextureDescriptor;\n    cubemapDescriptor.mipLevelCount ??= Math.log2(faceSize) | 0;\n    cubemapDescriptor.size = { width: faceSize, height: faceSize, depthOrArrayLayers: 6 };\n    cubemapDescriptor.dimension = '2d';\n    cubemapDescriptor.usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    const cubemap = device.createTexture(cubemapDescriptor);\n\n    const label = padTemplate`hdr copy${outputDescriptor.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 2,\n                buffer: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const module = device.createShaderModule({ label, code });\n    const sampler = device.createSampler({ label, minFilter: 'linear', magFilter: 'linear' });\n    const params = new Uint32Array(1);\n    const paramBuffer = createAndCopyBuffer(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device, label);\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            { binding: 0, resource: equirectangular.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: paramBuffer } },\n        ],\n    });\n\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: { module },\n        fragment: {\n            module,\n            targets: [{ format: cubemap.format }],\n            constants: {\n                GAMMA: gamma,\n                EXPOSURE: exposure,\n                FLIP_Y,\n            },\n        },\n    });\n\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n\n        const view = cubemap.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n            mipLevelCount: 1,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [{\n                view,\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n\n    return cubemap;\n}\nexport async function generateMips(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${blit}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `;\n\n    const label = padTemplate`mip generation${texture.label}`;\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d', sampleType: 'float' },\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const colorAttachment = {\n        view: undefined as GPUTextureView | undefined,\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: 0 });\n    await device.queue.onSubmittedWorkDone();\n\n    for (let i = 1; i < texture.mipLevelCount; i += 1) {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: colorAttachment.view,\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n\n        colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: i });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [colorAttachment as GPURenderPassColorAttachment],\n        });\n\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n\n        device.queue.submit([encoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport function srgbTextureToLinear(device: GPUDevice, texture: GPUTexture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${blit}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `;\n\n    const label = padTemplate`srgb to linear${texture.label}`;\n\n    const size = { width: texture.width, height: texture.height };\n\n    const tempTexture = device.createTexture({\n        format: texture.format,\n        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        size,\n    });\n\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n\n    const module = device.createShaderModule({ label, code: code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: tempTexture.createView(),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n        ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n        { texture },\n        { texture: tempTexture },\n        size,\n    );\n\n    const pass = encoder.beginRenderPass({\n        label,\n        colorAttachments: [{\n            view: texture.createView({ mipLevelCount: 1, baseMipLevel: 0 }),\n            loadOp: 'clear',\n            storeOp: 'store',\n        }],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindgroup);\n    pass.draw(3);\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n}\n"],"names":["parseHDR","inData","decoder","TextDecoder","buffer","Uint8Array","pos","getLine","lineLimit","limit","Math","min","length","sub","subarray","end","indexOf","undefined","decode","importError","msg","Error","magicTokenLine","test","headerReg","RegExp","map","source","join","width","height","rawData","noFormat","gamma","exposure","line","groups","match","format","X","Y","parseInt","parseFloat","unencodable","flatData","scanline_buffer","len","byteLength","k","offset","count","ptr","isEncodedRun","fill","set","i","j","data","Uint16Array","float16One","raw_e","scale","pow","createAndCopyBuffer","arr","usage","device","label","alignment","pad","createBuffer","size","mappedAtCreation","writeArray","getMappedRange","readArray","ArrayBuffer","byteOffset","unmap","async","textureToArrayBuffer","texture","mipLevel","returnBuffer","storageBuffer","resultBuffer","description","pixelSize","fullDescription","rawBytesPerRow","bytesPerRow","max","rowsPerImage","byteSize","depthOrArrayLayers","resultSize","requiredUsage","GPUBufferUsage","COPY_DST","MAP_READ","imageData","storage","encoder","createCommandEncoder","copyTextureToBuffer","queue","submit","finish","Promise","all","mapAsync","GPUMapMode","READ","onSubmittedWorkDone","mapped","h","w","slice","textureToKTX","cube","typeSize","container","pixelWidth","pixelHeight","vkFormat","keyValue","KTXswizzle","dataFormat","dataFormatDescriptor","colorModel","transferFunction","bytesPlane","samples","channelType","samplePosition","bitLength","bitOffset","sampleLower","sampleUpper","dimension","faceCount","pixelDepth","cubeLayers","layerCount","mipLevelCount","levels","push","levelData","uncompressedByteLength","BlurState","CubemapBlurModel","constructor","renderer","state","IDLE","nearestSample","$type","$callback","val","this","skyboxPass","useNearestSample","value","step","filterDistance","reblur","bind","skybox","onClick","saveFile","catch","console","error","settings","publicSettings","priority","addForwardPass","setSkybox","privateSettings","refresh","resolve","lastState","WAIT","BLUR","steps","inPlace","delayWork","requestAnimationFrame","skyTexture","createView","proms","then","ktx2","Blob","type","types","accept","suggestedName","handle","createWritable","keepExistingData","blob","stream","pipeTo","render","gbuffer","beginRenderPass","colorAttachments","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","view","depth","mapValues","obj","fn","Object","entries","key","fromEntries","clamp","num","padTemplate","strings","values","result","forEach","str","mapRange","n","Array","keys","range","debounce","callback","delay","tid","args","ctx","self","clearTimeout","setTimeout","apply","binaryInsert","element","comparator","left","right","splice","pivot","floor","TypeSizes","mat4x4Count","sizeofMat4x4f","Float32Array","BYTES_PER_ELEMENT","VkFormatToWebGPU","TextureFormatToSize","r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","rgb9e5ufloat","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","TextureFormatToChannelSize","WebGPUToVkFormat","vk","wgpu","equirectangularToCubemap","outputDescriptor","code","equirectangular","FLIP_Y","GPUTexture","createTexture","GPUTextureUsage","TEXTURE_BINDING","writeTexture","faceSize","cubemapDescriptor","log2","RENDER_ATTACHMENT","cubemap","bindgroupLayout","createBindGroupLayout","binding","visibility","GPUShaderStage","FRAGMENT","sampler","module","createShaderModule","createSampler","minFilter","magFilter","params","Uint32Array","paramBuffer","UNIFORM","bindgroup","createBindGroup","layout","resource","pipelineLayout","createPipelineLayout","bindGroupLayouts","pipeline","createRenderPipeline","vertex","fragment","targets","constants","GAMMA","EXPOSURE","writeBuffer","arrayLayerCount","baseArrayLayer","pass","loadOp","storeOp","setPipeline","setBindGroup","draw"],"sourceRoot":""}