{"version":3,"file":"490.bundle.js","mappings":"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","sources":["webpack://cbunt-portfolio/./src/rendering/samples/cubemap-blur/cubemap-guassian-pyramid.ts","webpack://cbunt-portfolio/./src/rendering/samples/settings/property-listener.ts","webpack://cbunt-portfolio/./src/rendering/samples/settings/skybox-options.ts","webpack://cbunt-portfolio/./src/rendering/shaders/blit-vert.shader.ts","webpack://cbunt-portfolio/./src/rendering/shaders/cubemap-sampling.shader.ts","webpack://cbunt-portfolio/./src/rendering/utils/data-conversion.ts"],"sourcesContent":["/* eslint @stylistic/max-len: \"error\" */\r\n\r\nimport {\r\n    toWorldDir,\r\n    cubemapSampleConversions,\r\n} from '../../shaders/cubemap-sampling.shader';\r\n\r\nimport { createAndCopyBuffer } from '../../utils/data-copy';\r\nimport { mapRange } from '../../../utils/general';\r\n\r\nconst DEFAULT_MAX_OPS = 6 * ((17 * 256) ** 2);\r\n\r\nconst createMipBlurCode = (\r\n    groups: number,\r\n    format: GPUTextureFormat,\r\n) => /* wgsl */`\r\n    ${cubemapSampleConversions}\r\n    ${toWorldDir}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    struct Params {\r\n        offset: u32,\r\n        sigmas: array<f32>,\r\n    }\r\n\r\n    @group(0) @binding(0) \r\n    var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    @group(0) @binding(2) \r\n    var<storage> params: Params;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + params.offset;\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = toWorldDir(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&params.sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = params.sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = toWorldDir(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\r\n\r\n/**\r\n *  the minimum angular distance between any pixel on a cubemap\r\n *  of the given face width and any pixel lying on a perimeter\r\n *  the given number of steps away\r\n */\r\nfunction minStepDistance(steps: number, width: number) {\r\n    // the angular distance\r\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\r\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\r\n\r\n    // It's likely possible to programmatically determine whether the\r\n    // destination pixel should be v = 0 or v = 1, but checking both works fine\r\n\r\n    const nextMipWidth = width >> 1;\r\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\r\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\r\n    const baseUN = (1 / nextMipWidth) - 1;\r\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\r\n\r\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\r\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\r\n    const samp0VN = (1 / width) - 1;\r\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\r\n    const samp1VN = (3 / width) - 1;\r\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\r\n\r\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN)\r\n        / Math.sqrt(samp0Mag2 * baseMag2);\r\n\r\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN)\r\n        / Math.sqrt(samp1Mag2 * baseMag2);\r\n\r\n    return Math.min(1 - dot0, 1 - dot1);\r\n}\r\n\r\nexport type GaussianPyramidDescriptor = {\r\n    device: GPUDevice,\r\n    texture: GPUTexture,\r\n    /**\r\n     * If the pyramid should overwrite the existing mips\r\n     * of the given texture\r\n     *\r\n     * @defaultValue `false`\r\n     */\r\n    inPlace?: boolean,\r\n    /**\r\n     * The maximum width of the smallest mip level.\r\n     *\r\n     * @defaultValue `8`\r\n     */\r\n    minWidth?: number,\r\n    /**\r\n     * The kernel extent distance, in pixels.\r\n     *\r\n     * @defaultValue `4`\r\n     */\r\n    steps?: number,\r\n    /**\r\n     * A function to delay the processing of additional pixels,\r\n     * e.g. `requestAnimationFrame`. Spaces work to allow additional\r\n     * rendering and interactivity during heavy blurring workloads.\r\n     *\r\n     * If undefined, all pixels are processed at once.\r\n     */\r\n    delayWork?: (fn: () => Promise<void> | void) => void,\r\n    /**\r\n     * The maximum number of pixels to process within a batch.\r\n     * Unused if `delayWork` is undefined.\r\n     *\r\n     * @defaultValue 6 * ((17 * 256) ** 2)\r\n     *\r\n     * @remarks\r\n     * Allowing cubemap 256 pixels in width with `steps = 8` to run\r\n     * in a single pass. This is a conservatively low default for\r\n     * compatibility with lower-end hardware.\r\n     */\r\n    maxOpsPerPass?: number,\r\n    /**\r\n     * A prefix string for error message thrown from the function\r\n     *\r\n     * @defaultValue `cubemapGuassianPyramid --`\r\n     */\r\n    label?: string,\r\n    /**\r\n     * The label to pass the output GPUTexture.\r\n     *\r\n     * @remarks\r\n     * Unused if `inPlace == true`\r\n     */\r\n    outputTextureLabel?: string,\r\n};\r\n\r\nexport default async function cubemapGuassianPyramid({\r\n    device,\r\n    texture,\r\n    outputTextureLabel,\r\n    inPlace = false,\r\n    minWidth = 8,\r\n    steps = 4,\r\n    maxOpsPerPass = DEFAULT_MAX_OPS,\r\n    label = cubemapGuassianPyramid.name,\r\n    delayWork,\r\n}: GaussianPyramidDescriptor) {\r\n    const { width, format } = texture;\r\n    const mipLevelCount = inPlace\r\n        ? texture.mipLevelCount\r\n        : (Math.log2(width) - Math.log2(minWidth) + 1);\r\n\r\n    if (mipLevelCount <= 1) return texture;\r\n\r\n    const groups = Math.min(\r\n        device.limits.maxComputeWorkgroupSizeX,\r\n        device.limits.maxComputeInvocationsPerWorkgroup,\r\n    );\r\n\r\n    const shader = device.createShaderModule({\r\n        label,\r\n        code: createMipBlurCode(groups, format),\r\n    });\r\n\r\n    const bindgroupLayout = device.createBindGroupLayout({\r\n        label,\r\n        entries: [\r\n            {\r\n                binding: 0,\r\n                texture: { viewDimension: '2d-array' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 1,\r\n                storageTexture: {\r\n                    access: 'write-only',\r\n                    viewDimension: '2d-array',\r\n                    format,\r\n                },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n            {\r\n                binding: 2,\r\n                buffer: { type: 'read-only-storage' },\r\n                visibility: GPUShaderStage.COMPUTE,\r\n            },\r\n        ],\r\n    });\r\n\r\n    const pipeline = device.createComputePipeline({\r\n        label,\r\n        layout: device.createPipelineLayout({\r\n            label,\r\n            bindGroupLayouts: [bindgroupLayout],\r\n        }),\r\n        compute: {\r\n            module: shader,\r\n            entryPoint: 'main',\r\n            constants: { STEPS: Math.ceil(steps) },\r\n        },\r\n    });\r\n\r\n    let gaussianPyramid = texture;\r\n    if (!inPlace) {\r\n        const size = { width, height: width, depthOrArrayLayers: 6 };\r\n\r\n        gaussianPyramid = device.createTexture({\r\n            label: outputTextureLabel,\r\n            usage: GPUTextureUsage.STORAGE_BINDING\r\n                | GPUTextureUsage.TEXTURE_BINDING\r\n                | GPUTextureUsage.COPY_SRC\r\n                | GPUTextureUsage.COPY_DST,\r\n            dimension: '2d',\r\n            format,\r\n            mipLevelCount,\r\n            size,\r\n        });\r\n\r\n        const copyEncoder = device.createCommandEncoder({\r\n            label: `${label} copy encoder`,\r\n        });\r\n\r\n        copyEncoder.copyTextureToTexture(\r\n            { texture, mipLevel: 0 },\r\n            { texture: gaussianPyramid, mipLevel: 0 },\r\n            size,\r\n        );\r\n\r\n        device.queue.submit([copyEncoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n    }\r\n\r\n    const mipViews = mapRange(mipLevelCount, (i) => gaussianPyramid.createView({\r\n        label: `${label} mip view ${i}`,\r\n        dimension: '2d-array',\r\n        baseMipLevel: i,\r\n        mipLevelCount: 1,\r\n    }));\r\n\r\n    const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\r\n    const maxLayers = Math.ceil(Math.log2(width));\r\n    const maxDispatches = Math.max(\r\n        (maxOpsPerPass / (((1 + (steps * 2)) ** 2) * groups)) | 0,\r\n        1,\r\n    );\r\n\r\n    const propertyArray = new ArrayBuffer((maxLayers + 1) * 4);\r\n    const offset = new Uint32Array(propertyArray, 0, 1);\r\n    const simgas = new Float32Array(propertyArray, 4, maxLayers);\r\n\r\n    simgas.set(mapRange(maxLayers, (i) => {\r\n        const w = width >> i;\r\n        return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\r\n    }));\r\n\r\n    const propertyBuffer = createAndCopyBuffer(\r\n        propertyArray,\r\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        device,\r\n    );\r\n\r\n    let mipLevel = 0;\r\n    let mipPasses = 0;\r\n    let requiredMipDispatches = 0;\r\n    let currentMipDispatches = 0;\r\n    let batchDispatches = 0;\r\n    let bindgroup: GPUBindGroup;\r\n\r\n    async function runPass() {\r\n        if (currentMipDispatches >= requiredMipDispatches) {\r\n            mipLevel += 1;\r\n            currentMipDispatches = 0;\r\n            mipPasses = 0;\r\n\r\n            if (mipLevel >= mipLevelCount) {\r\n                return;\r\n            }\r\n\r\n            const mipPixels = 6 * ((width >> mipLevel) ** 2);\r\n            requiredMipDispatches = Math.ceil(mipPixels / groups);\r\n\r\n            bindgroup = device.createBindGroup({\r\n                layout: bindgroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: mipViews[mipLevel - 1],\r\n                    },\r\n                    {\r\n                        binding: 1,\r\n                        resource: mipViews[mipLevel],\r\n                    },\r\n                    {\r\n                        binding: 2,\r\n                        resource: { buffer: propertyBuffer },\r\n                    },\r\n                ],\r\n            });\r\n        }\r\n\r\n        offset[0] = currentMipDispatches * groups;\r\n        device.queue.writeBuffer(propertyBuffer, 0, offset);\r\n\r\n        const passDispatches = Math.min(\r\n            requiredMipDispatches - currentMipDispatches,\r\n            maxDispatches - batchDispatches,\r\n            maxWorkgroups,\r\n        );\r\n\r\n        const passLabel = `${label} mip ${mipLevel}, pass ${mipPasses}`;\r\n        const encoder = device.createCommandEncoder({ label: passLabel });\r\n        const pass = encoder.beginComputePass({ label: passLabel });\r\n\r\n        pass.setPipeline(pipeline);\r\n        pass.setBindGroup(0, bindgroup);\r\n        pass.dispatchWorkgroups(passDispatches, 1, 1);\r\n        pass.end();\r\n\r\n        device.queue.submit([encoder.finish()]);\r\n\r\n        currentMipDispatches += passDispatches;\r\n        batchDispatches += passDispatches;\r\n        mipPasses += 1;\r\n\r\n        if (delayWork != null && batchDispatches >= maxDispatches) {\r\n            batchDispatches = 0;\r\n            await device.queue.onSubmittedWorkDone();\r\n            delayWork(runPass);\r\n        } else {\r\n            await runPass();\r\n        }\r\n    }\r\n\r\n    await runPass();\r\n\r\n    return gaussianPyramid;\r\n}\r\n","import { UnknownObject, mapValues } from '../../../utils/general';\n\n// Unique symbols to avoid naming collisions with underlying types\nconst $type = Symbol('PropertyListener -- Type');\nconst $callback = Symbol('PropertyListener -- Callback');\nconst $listeners = Symbol('PropertyListener -- Listeners');\nexport const ListenerSyms = Object.freeze({ $type, $callback, $listeners });\n\ntype Syms = typeof $type | typeof $callback | typeof $listeners;\nexport type ValueKeyCallback<T extends object> = <K extends keyof T, V extends T[K]>(value: V, key: K) => void;\n\nexport type GuiSetting<T extends object = object, Tag extends string = string> = {\n    [$type]: Tag,\n    [$callback]?: ValueKeyCallback<T>,\n    [$listeners]: Set<ValueKeyCallback<T>>,\n} & T;\n\nexport type ListenerSpec<T extends object = object, Tag extends string = string> =\n    Omit<GuiSetting<T, Tag>, typeof $listeners>;\n\ntype MapSpec<T extends Record<PropertyKey, ListenerSpec>> = {\n    [K in keyof T]: T[K] extends ListenerSpec<object, infer Tag> & infer Rest\n        ? Rest extends object\n            ? GuiSetting<Omit<Rest, Syms>, Tag> : never : never\n};\n\nexport default function propertyListener<T extends Record<PropertyKey, ListenerSpec<UnknownObject>>>(specs: T) {\n    for (const spec of Object.values(specs) as GuiSetting[]) {\n        spec[$listeners] = new Set();\n    }\n\n    return {\n        publicSettings: mapValues(specs, (spec) => new Proxy(spec as GuiSetting<UnknownObject>, {\n            set(target, key, value: unknown) {\n                if (target[key] !== value) {\n                    target[key] = value;\n                    target[$callback]?.(value, key);\n                }\n                return true;\n            },\n        })) as MapSpec<T>,\n        privateSettings: mapValues(specs, (spec) => new Proxy(spec as GuiSetting<UnknownObject>, {\n            set(target, key, value: unknown) {\n                if (target[key] !== value) {\n                    target[key] = value;\n                    target[$listeners].forEach((fn) => { fn(value, key); });\n                }\n                return true;\n            },\n        })) as MapSpec<T>,\n    };\n}\n","import { parseHDR } from '../../utils/texture-importing';\nimport { equirectangularToCubemap } from '../../utils/texture-processing';\nimport { ListenerSyms } from './property-listener';\n\nconst hdrPromises = await fetch(HDR_BASE_URL__, { headers: { 'Content-Type': 'application/vnd.github.object+json' } })\n    .then((res) => res.json()) as Record<string, unknown>[];\n\nexport const hdrs = Object.fromEntries(hdrPromises.flatMap(({ name, download_url }) => typeof name === 'string' && typeof download_url === 'string' && download_url.endsWith('.hdr') ? [[name, download_url]] : []));\n\nasync function processSkybox(device: GPUDevice, file: string | URL | File | ArrayBuffer) {\n    let buffer: ArrayBuffer;\n    if (file instanceof ArrayBuffer) {\n        buffer = file;\n    } else if (file instanceof File) {\n        buffer = await file.arrayBuffer();\n    } else {\n        const res = await fetch(file);\n        buffer = await res.arrayBuffer();\n    }\n\n    const hdr = parseHDR(buffer);\n\n    return equirectangularToCubemap(\n        device,\n        hdr,\n        {\n            format: 'rgba16float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n        },\n    );\n}\n\nexport type SkyboxTarget = { device: GPUDevice, setSkybox: (resource: GPUTexture) => unknown };\n\nexport default function getSkyboxOptions(target: SkyboxTarget) {\n    return {\n        [ListenerSyms.$type]: 'file' as const,\n        [ListenerSyms.$callback]: async (val: unknown, key: PropertyKey) => {\n            if (key !== 'value' || val == null) return;\n            if (typeof val === 'string' || val instanceof File) {\n                const texture = await processSkybox(target.device, val);\n                const res = target.setSkybox(texture);\n                if (res instanceof Promise) await res;\n            }\n        },\n        accept: '.hdr',\n        selection: {\n            value: Object.keys(hdrs)[0],\n            initialValues: hdrs,\n        },\n        process: (file: File) => file,\n    };\n}\n","export default /* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`;\r\n","export const toWorldDir: string = /* wgsl */`\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nexport const cubemapSampleConversions: string = /* wgsl */`\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n","const { baseTable, shiftTable } = (() => {\n    const baseTable = new Uint32Array(256);\n    const shiftTable = new Uint32Array(256);\n\n    for (let i = 0; i < 255; ++i) {\n        const e = i - 127;\n        if (e < -27) { // very small number (0, -0)\n            baseTable[i] = 0x0000;\n            shiftTable[i] = 24;\n        } else if (e < -14) { // small number (denorm)\n            baseTable[i] = 0x0400 >> (-e - 14);\n            shiftTable[i] = -e - 1;\n        } else if (e <= 15) { // normal number\n            baseTable[i] = (e + 15) << 10;\n            shiftTable[i] = 13;\n        } else { // e < 128, large number (Infinity, -Infinity)\n            baseTable[i] = 0x7c00;\n            shiftTable[i] = 24;\n        }\n    }\n\n    // e == 128, stay (NaN, Infinity, -Infinity)\n    baseTable[255] = 0x7c00;\n    shiftTable[255] = 13;\n\n    return { baseTable, shiftTable };\n})();\n\nconst conversionBuffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(conversionBuffer);\nconst uintView = new Uint32Array(conversionBuffer);\n\nexport function toFloat16Bytes(val: number) {\n    floatView[0] = val;\n    const bits = uintView[0];\n    const mantissa = (bits >> 23) & 0x1ff;\n    const idx = mantissa & 0xff;\n\n    const shifted = (bits & 0x007fffff) >> shiftTable[idx];\n    const sign = (mantissa & 0x100) << 7;\n\n    return sign + baseTable[idx] + shifted;\n}\n"],"names":["DEFAULT_MAX_OPS","createMipBlurCode","groups","format","async","cubemapGuassianPyramid","device","texture","outputTextureLabel","inPlace","minWidth","steps","maxOpsPerPass","label","name","delayWork","width","mipLevelCount","Math","log2","min","limits","maxComputeWorkgroupSizeX","maxComputeInvocationsPerWorkgroup","shader","createShaderModule","code","bindgroupLayout","createBindGroupLayout","entries","binding","viewDimension","visibility","GPUShaderStage","COMPUTE","storageTexture","access","buffer","type","pipeline","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","entryPoint","constants","STEPS","ceil","gaussianPyramid","size","height","depthOrArrayLayers","createTexture","usage","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","COPY_SRC","COPY_DST","dimension","copyEncoder","createCommandEncoder","copyTextureToTexture","mipLevel","queue","submit","finish","onSubmittedWorkDone","mipViews","i","createView","baseMipLevel","maxWorkgroups","maxComputeWorkgroupsPerDimension","maxLayers","maxDispatches","max","propertyArray","ArrayBuffer","offset","Uint32Array","Float32Array","set","w","acos","nextMipWidth","baseV","floor","baseVN","baseUN","baseMag2","sampUN","samp0VN","samp0Mag2","samp1VN","samp1Mag2","dot0","sqrt","dot1","minStepDistance","propertyBuffer","GPUBufferUsage","STORAGE","bindgroup","mipPasses","requiredMipDispatches","currentMipDispatches","batchDispatches","runPass","mipPixels","createBindGroup","resource","writeBuffer","passDispatches","passLabel","encoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","$type","Symbol","$callback","$listeners","ListenerSyms","Object","freeze","propertyListener","specs","spec","values","Set","publicSettings","Proxy","target","key","value","privateSettings","forEach","fn","hdrPromises","fetch","headers","then","res","json","hdrs","fromEntries","flatMap","download_url","endsWith","processSkybox","file","File","arrayBuffer","hdr","getSkyboxOptions","val","setSkybox","Promise","accept","selection","keys","initialValues","process","toWorldDir","cubemapSampleConversions","baseTable","shiftTable","e","conversionBuffer","floatView","uintView","toFloat16Bytes","bits","mantissa","idx","shifted"],"sourceRoot":""}