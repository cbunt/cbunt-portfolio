"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[806],{360:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ descriptor_map)\n});\n\n// EXTERNAL MODULE: ./src/rendering/default-forward-pass/pipeline-feature-flags.ts\nvar pipeline_feature_flags = __webpack_require__(9274);\n;// ./src/utils/shader.ts\nfunction resolveBranch(branch) {\n    return typeof branch === 'string' ? branch : branch();\n}\nclass PreprocessorStatement {\n    constructor(cond, branch) {\n        this.else = (branch) => this.res ?? resolveBranch(branch);\n        this.toString = () => this.res ?? '';\n        if (cond)\n            this.res = resolveBranch(branch);\n    }\n    elif(cond, branch) {\n        if (cond)\n            this.res ??= resolveBranch(branch);\n        return this;\n    }\n    get [Symbol.toStringTag]() { return this.toString(); }\n}\nfunction preprocessors(flags) {\n    return {\n        ifdef(sym, branch) {\n            return new PreprocessorStatement((flags & sym) === sym, branch);\n        },\n        ifndef(sym, branch) {\n            return new PreprocessorStatement((flags & sym) !== sym, branch);\n        },\n    };\n}\nfunction wrapWithIncrement(fn, start = 0) {\n    return () => fn(start++);\n}\n\n// EXTERNAL MODULE: ./src/rendering/global-uniforms.ts\nvar global_uniforms = __webpack_require__(992);\n;// ./src/shaders/forward.shader.ts\n/* eslint-disable @typescript-eslint/indent */\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\n\n\nfunction getBindgroupInfo(flags) {\n    const entries = [];\n    function pushItem(item) {\n        entries.push({ ...item, binding: entries.length, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX });\n    }\n    pushItem({ buffer: { type: 'uniform' } });\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n    pushItem({ sampler: {} });\n    pushItem({ texture: { viewDimension: '2d' } });\n    if (flags & pipeline_feature_flags/* PipelineFeatureFlags */.Ot.Emissive) {\n        pushItem({ sampler: {} });\n        pushItem({ texture: { viewDimension: '2d' } });\n    }\n    return { label: (0,pipeline_feature_flags/* featureFlagsToString */.UZ)(flags), entries };\n}\n/**\n * @param flags A flag enum containing the features this code should be generated for\n * @returns A string containing preprocessed wgsl shader code for the given features\n */\nfunction include(flags) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { ifdef } = preprocessors(flags);\n    const vertexInLocation = wrapWithIncrement((idx) => /* wgsl */ `@location(${idx})`);\n    const varyingsLocation = wrapWithIncrement((idx) => /* wgsl */ `@location(${idx})`);\n    const materialBinding = wrapWithIncrement((idx) => /* wgsl */ `\n        @group(1) @binding(${idx})\n    `);\n    const varyings = /* wgsl */ `\n        ${varyingsLocation()} pos: vec3f,\n        ${varyingsLocation()} camPos: vec3f,\n        ${varyingsLocation()} uv: vec2f,\n\n        ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals, () => /* wgsl */ `\n            ${varyingsLocation()} tangent: vec4f,\n            ${varyingsLocation()} normal: vec3f,\n        `)}\n\n        ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexColors, () => /* wgsl */ `\n            ${varyingsLocation()} color: vec4f,\n        `)}\n    `;\n    return /* wgsl */ `\n        ${global_uniforms/* default */.A.code(0)}\n\n        struct ForwardOut {\n            @location(${0 /* GBufferGroupIndices.Normal */}) normal: vec4f,\n            @location(${1 /* GBufferGroupIndices.Albedo */}) albedo: vec4f,\n            @location(${2 /* GBufferGroupIndices.Emission */}) emission: vec4f,\n            @location(${3 /* GBufferGroupIndices.MetallicRoughness */}) metallicRoughness: vec4f,\n        }\n\n        struct MaterialProperties {\n            baseColorFactor: vec4f,\n            metallicFactor: f32,\n            roughnessFactor: f32,\n\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.AlphaCutoff, 'alphaCutoff: f32,')}\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.Emissive, 'emissiveFactor: vec3f,')}\n        }\n\n        ${materialBinding()} var<uniform> material: MaterialProperties;\n\n        ${materialBinding()} var baseColorSampler: sampler;\n        ${materialBinding()} var baseColorTexture: texture_2d<f32>;\n\n        ${materialBinding()} var normalSampler: sampler;\n        ${materialBinding()} var normalTexture: texture_2d<f32>;\n\n        ${materialBinding()} var metallicRoughnessSampler: sampler;\n        ${materialBinding()} var metallicRoughnessTexture: texture_2d<f32>;\n\n        ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.Emissive, () => /* wgsl */ `\n            ${materialBinding()} var emissionSampler: sampler;\n            ${materialBinding()} var emissionTexture: texture_2d<f32>;\n        `)}\n\n        struct ModelProperties {\n            modelToWorldMatrix: mat4x4f,\n\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals, 'normalMatrix: mat3x3f,')}\n        }\n\n        @group(2) @binding(0) var<storage, read> instances : array<ModelProperties>;\n\n        struct VertIn {\n            @builtin(instance_index) instance: u32,\n            ${vertexInLocation()} pos: vec3f,\n            ${vertexInLocation()} uv: vec2f,\n\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals, () => /* wgsl */ `\n                ${vertexInLocation()} tangent: vec4f,\n                ${vertexInLocation()} normal: vec3f,\n            `)}\n\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexColors, () => /* wgsl */ `\n                ${vertexInLocation()} color: vec4f,\n            `)}\n        }\n\n        struct VertOut {\n            ${varyings}\n            @builtin(position) Position: vec4f,\n        }\n\n        struct FragIn {\n            ${varyings}\n\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals | pipeline_feature_flags/* PipelineFeatureFlags */.Ot.DoubleSided, /* wgsl */ `\n                @builtin(front_facing) front_facing: bool,\n            `)}\n        }\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @vertex \n        fn vs(inData: VertIn) -> VertOut {\n            var vsOut: VertOut;\n            let instance = instances[inData.instance];\n            let worldPos = instance.modelToWorldMatrix * vec4f(inData.pos, 1);\n            vsOut.pos = worldPos.xyz;\n            vsOut.Position = globals.worldToClip * worldPos;\n            vsOut.camPos = globals.inverseWorldToView[3].xyz;\n            vsOut.uv = inData.uv;\n\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals, /* wgsl */ `\n                vsOut.normal = normalize(instance.normalMatrix * inData.normal);\n                let wsTangent = normalize((instance.modelToWorldMatrix * vec4(inData.tangent.xyz, 0.0)).xyz);\n                vsOut.tangent = vec4(wsTangent, inData.tangent.w);\n            `)}\n\n            return vsOut;\n        }\n\n        // much of this code is adapted from https://learnopengl.com/PBR\n        @fragment\n        fn fs(inData: FragIn) -> ForwardOut {\n            var out: ForwardOut;\n            let rawColor: vec4f = textureSample(baseColorTexture, baseColorSampler, inData.uv);\n\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.AlphaCutoff, /* wgsl */ `\n                var alpha = rawColor.a * material.baseColorFactor.a;\n\n                ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexColors, /* wgsl */ `\n                    alpha *= inData.color.a;\n                `)}\n\n                if (alpha <= material.alphaCutoff) { \n                    discard;\n                }\n            `)}\n\n            out.albedo = vec4f(rawColor.rgb * material.baseColorFactor.rgb, 1);\n\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexColors, /* wgsl */ `\n                out.albedo *= vec4f(inData.color.rgb, 1);\n            `)}\n\n            let metallicRoughness = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, inData.uv);\n            out.metallicRoughness.r = saturate(metallicRoughness.b * material.metallicFactor);\n            out.metallicRoughness.g = saturate(metallicRoughness.g * material.roughnessFactor);\n\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals, /* wgsl */ `\n                let normalSample = textureSample(normalTexture, normalSampler, inData.uv).xyz;\n                let tangentNormal = normalize(normalSample * 2.0 - 1.0);\n                let bitangent =inData.tangent.w * cross(inData.normal, inData.tangent.xyz);\n                let tbn = mat3x3f(normalize(inData.tangent.xyz), bitangent, normalize(inData.normal));\n                var normal = normalize(tbn * tangentNormal);\n\n                ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.DoubleSided, /* wgsl */ `\n                    if (!inData.front_facing) { normal *= -1.0; }\n                `)}\n            `).else(/* wgsl */ `\n                let fdx = dpdx(inData.pos);\n                let fdy = dpdy(inData.pos);\n                let normal = normalize(cross(fdx, fdy));\n            `)}\n\n            out.normal = vec4f(normal, 1);\n\n            ${ifdef(pipeline_feature_flags/* PipelineFeatureFlags */.Ot.Emissive, /* wgsl */ `\n                let emission = textureSample(emissionTexture, emissionSampler, inData.uv).rgb;\n                out.emission = vec4f(emission, 1);\n            `)}\n\n            return out;\n        }\n    `;\n}\n\n;// ./src/rendering/default-forward-pass/descriptor-map.ts\n\n\n\nclass DescriptorMap {\n    constructor(device, gbuffer, globals) {\n        this.device = device;\n        this.gbuffer = gbuffer;\n        this.globals = globals;\n        this.pipelineLayouts = {};\n        this.primitiveStates = {};\n        this.vertexLayouts = {};\n        this.shaderModules = {};\n        this.bindgroupLayouts = {};\n        this.samplers = {};\n        this.forwardBindgroupLayout = this.device.createBindGroupLayout({\n            label: `forward material`,\n            entries: [{\n                    binding: 0,\n                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n                    buffer: { type: 'read-only-storage' },\n                }],\n        });\n    }\n    getSampler(descriptor) {\n        const key = JSON.stringify(descriptor);\n        this.samplers[key] ??= this.device.createSampler(descriptor);\n        return this.samplers[key];\n    }\n    getVertexLayout(flags) {\n        const masked = flags & pipeline_feature_flags/* VertexBufferLayoutMask */.V3;\n        if (this.vertexLayouts[masked] == null) {\n            const attributes = [\n                { shaderLocation: 0, offset: 0, format: 'float32x3' }, // position\n                { shaderLocation: 1, offset: 12, format: 'float32x2' }, // uv\n            ];\n            let arrayStride = 20;\n            let shaderLocation = 2;\n            if (masked & pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals) {\n                attributes.push({ shaderLocation, offset: arrayStride, format: 'float32x4' }); // tangent\n                attributes.push({ shaderLocation: shaderLocation + 1, offset: arrayStride + 16, format: 'float32x3' }); // normal\n                shaderLocation += 2;\n                arrayStride += 28;\n            }\n            if (masked & pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexColors) {\n                attributes.push({ shaderLocation, offset: arrayStride, format: 'float32x4' }); // color\n                arrayStride += 16;\n            }\n            this.vertexLayouts[masked] = { attributes, arrayStride, stepMode: 'vertex' };\n        }\n        return this.vertexLayouts[masked];\n    }\n    getForwardPipelineLayout(flags) {\n        const masked = flags & pipeline_feature_flags/* PipelineLayoutMask */.FO;\n        this.pipelineLayouts[masked] ??= this.device.createPipelineLayout({\n            label: pipeline_feature_flags/* featureFlagsToString */.UZ(masked),\n            bindGroupLayouts: [\n                this.globals.bindGroupLayout,\n                this.getMaterialBindGroup(flags),\n                this.forwardBindgroupLayout,\n            ],\n        });\n        return this.pipelineLayouts[masked];\n    }\n    getShaderModule(flags) {\n        const masked = flags & pipeline_feature_flags/* CodeMask */.Q7;\n        this.shaderModules[masked] ??= this.device.createShaderModule({\n            label: pipeline_feature_flags/* featureFlagsToString */.UZ(masked),\n            code: include(masked),\n        });\n        return this.shaderModules[masked];\n    }\n    getPrimitiveState(flags) {\n        const masked = flags & pipeline_feature_flags/* PrimitiveStateMask */.XY;\n        this.primitiveStates[masked] ??= {\n            topology: DescriptorMap.flagToTopology[(flags & pipeline_feature_flags/* TopologyFormatMask */.Py)],\n            cullMode: masked & pipeline_feature_flags/* PipelineFeatureFlags */.Ot.DoubleSided ? 'none' : 'back',\n            frontFace: masked & pipeline_feature_flags/* PipelineFeatureFlags */.Ot.ClockwiseWinding ? 'cw' : 'ccw',\n        };\n        return this.primitiveStates[masked];\n    }\n    getMaterialBindGroup(flags) {\n        const masked = flags & pipeline_feature_flags/* MaterialBindgroupLayoutMask */.Wq;\n        this.bindgroupLayouts[masked] ??= this.device.createBindGroupLayout(getBindgroupInfo(masked));\n        return this.bindgroupLayouts[masked];\n    }\n}\nDescriptorMap.flagToTopology = {\n    [pipeline_feature_flags/* PipelineFeatureFlags */.Ot.TriangleList]: 'triangle-list',\n    [pipeline_feature_flags/* PipelineFeatureFlags */.Ot.TriangleStrip]: 'triangle-strip',\n    [pipeline_feature_flags/* PipelineFeatureFlags */.Ot.PointList]: 'point-list',\n    [pipeline_feature_flags/* PipelineFeatureFlags */.Ot.LineList]: 'line-list',\n    [pipeline_feature_flags/* PipelineFeatureFlags */.Ot.LineStrip]: 'line-strip',\n};\n/* harmony default export */ const descriptor_map = (DescriptorMap);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFjLEdBQWdFO0lBQzFGLENBQUMsbURBQW9CLENBQUMsWUFBWSxDQUFDLEVBQUUsZUFBZTtJQUNwRCxDQUFDLG1EQUFvQixDQUFDLGFBQWEsQ0FBQyxFQUFFLGdCQUFnQjtJQUN0RCxDQUFDLG1EQUFvQixDQUFDLFNBQVMsQ0FBQyxFQUFFLFlBQVk7SUFDOUMsQ0FBQyxtREFBb0IsQ0FBQyxRQUFRLENBQUMsRUFBRSxXQUFXO0lBQzVDLENBQUMsbURBQW9CLENBQUMsU0FBUyxDQUFDLEVBQUUsWUFBWTtDQUNqRCxDQUFDO3FEQVBlLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvdXRpbHMvc2hhZGVyLnRzP2ExYzAiLCJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3NoYWRlcnMvZm9yd2FyZC5zaGFkZXIudHM/MjI1YyIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL2Rlc2NyaXB0b3ItbWFwLnRzPzJmZjciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgQnJhbmNoID0gc3RyaW5nIHwgKCgpID0+IHN0cmluZyk7XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlQnJhbmNoKGJyYW5jaDogQnJhbmNoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGJyYW5jaCA9PT0gJ3N0cmluZycgPyBicmFuY2ggOiBicmFuY2goKTtcclxufVxyXG5cclxuY2xhc3MgUHJlcHJvY2Vzc29yU3RhdGVtZW50IHtcclxuICAgIHJlcz86IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25kOiBib29sZWFuLCBicmFuY2g6IEJyYW5jaCkge1xyXG4gICAgICAgIGlmIChjb25kKSB0aGlzLnJlcyA9IHJlc29sdmVCcmFuY2goYnJhbmNoKTtcclxuICAgIH1cclxuXHJcbiAgICBlbGlmKGNvbmQ6IGJvb2xlYW4sIGJyYW5jaDogQnJhbmNoKSB7XHJcbiAgICAgICAgaWYgKGNvbmQpIHRoaXMucmVzID8/PSByZXNvbHZlQnJhbmNoKGJyYW5jaCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZWxzZSA9IChicmFuY2g6IEJyYW5jaCkgPT4gdGhpcy5yZXMgPz8gcmVzb2x2ZUJyYW5jaChicmFuY2gpO1xyXG5cclxuICAgIHRvU3RyaW5nID0gKCkgPT4gdGhpcy5yZXMgPz8gJyc7XHJcblxyXG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkgeyByZXR1cm4gdGhpcy50b1N0cmluZygpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzb3JzKGZsYWdzOiBudW1iZXIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaWZkZWYoc3ltOiBudW1iZXIsIGJyYW5jaDogQnJhbmNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJlcHJvY2Vzc29yU3RhdGVtZW50KChmbGFncyAmIHN5bSkgPT09IHN5bSwgYnJhbmNoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlmbmRlZihzeW06IG51bWJlciwgYnJhbmNoOiBCcmFuY2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVwcm9jZXNzb3JTdGF0ZW1lbnQoKGZsYWdzICYgc3ltKSAhPT0gc3ltLCBicmFuY2gpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcFdpdGhJbmNyZW1lbnQ8VD4oZm46IChjb3VudGVyOiBudW1iZXIpID0+IFQsIHN0YXJ0ID0gMCk6ICgpID0+IFQge1xyXG4gICAgcmV0dXJuICgpID0+IGZuKHN0YXJ0KyspO1xyXG59XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9pbmRlbnQgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucyAqL1xuXG5pbXBvcnQgeyBQaXBlbGluZUZlYXR1cmVGbGFncywgZmVhdHVyZUZsYWdzVG9TdHJpbmcgfSBmcm9tICcuLi9yZW5kZXJpbmcvZGVmYXVsdC1mb3J3YXJkLXBhc3MvcGlwZWxpbmUtZmVhdHVyZS1mbGFncyc7XG5pbXBvcnQgeyBwcmVwcm9jZXNzb3JzLCB3cmFwV2l0aEluY3JlbWVudCB9IGZyb20gJy4uL3V0aWxzL3NoYWRlcic7XG5pbXBvcnQgR2xvYmFsVW5pZm9ybXMgZnJvbSAnLi4vcmVuZGVyaW5nL2dsb2JhbC11bmlmb3Jtcyc7XG5pbXBvcnQgeyBHQnVmZmVyR3JvdXBJbmRpY2VzIH0gZnJvbSAnLi4vcmVuZGVyaW5nL2didWZmZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmluZGdyb3VwSW5mbyhmbGFnczogUGlwZWxpbmVGZWF0dXJlRmxhZ3MpOiBHUFVCaW5kR3JvdXBMYXlvdXREZXNjcmlwdG9yIHtcbiAgICBjb25zdCBlbnRyaWVzOiBHUFVCaW5kR3JvdXBMYXlvdXRFbnRyeVtdID0gW107XG5cbiAgICBmdW5jdGlvbiBwdXNoSXRlbShpdGVtOiBPbWl0PEdQVUJpbmRHcm91cExheW91dEVudHJ5LCAnYmluZGluZycgfCAndmlzaWJpbGl0eSc+KSB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7IC4uLml0ZW0sIGJpbmRpbmc6IGVudHJpZXMubGVuZ3RoLCB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCB8IEdQVVNoYWRlclN0YWdlLlZFUlRFWCB9KTtcbiAgICB9XG5cbiAgICBwdXNoSXRlbSh7IGJ1ZmZlcjogeyB0eXBlOiAndW5pZm9ybScgfSB9KTtcblxuICAgIHB1c2hJdGVtKHsgc2FtcGxlcjoge30gfSk7XG4gICAgcHVzaEl0ZW0oeyB0ZXh0dXJlOiB7IHZpZXdEaW1lbnNpb246ICcyZCcgfSB9KTtcblxuICAgIHB1c2hJdGVtKHsgc2FtcGxlcjoge30gfSk7XG4gICAgcHVzaEl0ZW0oeyB0ZXh0dXJlOiB7IHZpZXdEaW1lbnNpb246ICcyZCcgfSB9KTtcblxuICAgIHB1c2hJdGVtKHsgc2FtcGxlcjoge30gfSk7XG4gICAgcHVzaEl0ZW0oeyB0ZXh0dXJlOiB7IHZpZXdEaW1lbnNpb246ICcyZCcgfSB9KTtcblxuICAgIGlmIChmbGFncyAmIFBpcGVsaW5lRmVhdHVyZUZsYWdzLkVtaXNzaXZlKSB7XG4gICAgICAgIHB1c2hJdGVtKHsgc2FtcGxlcjoge30gfSk7XG4gICAgICAgIHB1c2hJdGVtKHsgdGV4dHVyZTogeyB2aWV3RGltZW5zaW9uOiAnMmQnIH0gfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbGFiZWw6IGZlYXR1cmVGbGFnc1RvU3RyaW5nKGZsYWdzKSwgZW50cmllcyB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSBmbGFncyBBIGZsYWcgZW51bSBjb250YWluaW5nIHRoZSBmZWF0dXJlcyB0aGlzIGNvZGUgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3JcbiAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgcHJlcHJvY2Vzc2VkIHdnc2wgc2hhZGVyIGNvZGUgZm9yIHRoZSBnaXZlbiBmZWF0dXJlc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmNsdWRlKGZsYWdzOiBQaXBlbGluZUZlYXR1cmVGbGFncykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICBjb25zdCB7IGlmZGVmIH0gPSBwcmVwcm9jZXNzb3JzKGZsYWdzIGFzIG51bWJlcik7XG4gICAgY29uc3QgdmVydGV4SW5Mb2NhdGlvbiA9IHdyYXBXaXRoSW5jcmVtZW50KChpZHgpID0+IC8qIHdnc2wgKi9gQGxvY2F0aW9uKCR7aWR4fSlgKTtcbiAgICBjb25zdCB2YXJ5aW5nc0xvY2F0aW9uID0gd3JhcFdpdGhJbmNyZW1lbnQoKGlkeCkgPT4gLyogd2dzbCAqL2BAbG9jYXRpb24oJHtpZHh9KWApO1xuXG4gICAgY29uc3QgbWF0ZXJpYWxCaW5kaW5nID0gd3JhcFdpdGhJbmNyZW1lbnQoKGlkeCkgPT4gLyogd2dzbCAqL2BcbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKCR7aWR4fSlcbiAgICBgKTtcblxuICAgIGNvbnN0IHZhcnlpbmdzID0gLyogd2dzbCAqL2BcbiAgICAgICAgJHt2YXJ5aW5nc0xvY2F0aW9uKCl9IHBvczogdmVjM2YsXG4gICAgICAgICR7dmFyeWluZ3NMb2NhdGlvbigpfSBjYW1Qb3M6IHZlYzNmLFxuICAgICAgICAke3ZhcnlpbmdzTG9jYXRpb24oKX0gdXY6IHZlYzJmLFxuXG4gICAgICAgICR7aWZkZWYoUGlwZWxpbmVGZWF0dXJlRmxhZ3MuVmVydGV4Tm9ybWFscywgKCkgPT4gLyogd2dzbCAqL2BcbiAgICAgICAgICAgICR7dmFyeWluZ3NMb2NhdGlvbigpfSB0YW5nZW50OiB2ZWM0ZixcbiAgICAgICAgICAgICR7dmFyeWluZ3NMb2NhdGlvbigpfSBub3JtYWw6IHZlYzNmLFxuICAgICAgICBgKX1cblxuICAgICAgICAke2lmZGVmKFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleENvbG9ycywgKCkgPT4gLyogd2dzbCAqL2BcbiAgICAgICAgICAgICR7dmFyeWluZ3NMb2NhdGlvbigpfSBjb2xvcjogdmVjNGYsXG4gICAgICAgIGApfVxuICAgIGA7XG5cbiAgICByZXR1cm4gLyogd2dzbCAqL2BcbiAgICAgICAgJHtHbG9iYWxVbmlmb3Jtcy5jb2RlKDApfVxuXG4gICAgICAgIHN0cnVjdCBGb3J3YXJkT3V0IHtcbiAgICAgICAgICAgIEBsb2NhdGlvbigke0dCdWZmZXJHcm91cEluZGljZXMuTm9ybWFsfSkgbm9ybWFsOiB2ZWM0ZixcbiAgICAgICAgICAgIEBsb2NhdGlvbigke0dCdWZmZXJHcm91cEluZGljZXMuQWxiZWRvfSkgYWxiZWRvOiB2ZWM0ZixcbiAgICAgICAgICAgIEBsb2NhdGlvbigke0dCdWZmZXJHcm91cEluZGljZXMuRW1pc3Npb259KSBlbWlzc2lvbjogdmVjNGYsXG4gICAgICAgICAgICBAbG9jYXRpb24oJHtHQnVmZmVyR3JvdXBJbmRpY2VzLk1ldGFsbGljUm91Z2huZXNzfSkgbWV0YWxsaWNSb3VnaG5lc3M6IHZlYzRmLFxuICAgICAgICB9XG5cbiAgICAgICAgc3RydWN0IE1hdGVyaWFsUHJvcGVydGllcyB7XG4gICAgICAgICAgICBiYXNlQ29sb3JGYWN0b3I6IHZlYzRmLFxuICAgICAgICAgICAgbWV0YWxsaWNGYWN0b3I6IGYzMixcbiAgICAgICAgICAgIHJvdWdobmVzc0ZhY3RvcjogZjMyLFxuXG4gICAgICAgICAgICAke2lmZGVmKFBpcGVsaW5lRmVhdHVyZUZsYWdzLkFscGhhQ3V0b2ZmLCAnYWxwaGFDdXRvZmY6IGYzMiwnKX1cbiAgICAgICAgICAgICR7aWZkZWYoUGlwZWxpbmVGZWF0dXJlRmxhZ3MuRW1pc3NpdmUsICdlbWlzc2l2ZUZhY3RvcjogdmVjM2YsJyl9XG4gICAgICAgIH1cblxuICAgICAgICAke21hdGVyaWFsQmluZGluZygpfSB2YXI8dW5pZm9ybT4gbWF0ZXJpYWw6IE1hdGVyaWFsUHJvcGVydGllcztcblxuICAgICAgICAke21hdGVyaWFsQmluZGluZygpfSB2YXIgYmFzZUNvbG9yU2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgJHttYXRlcmlhbEJpbmRpbmcoKX0gdmFyIGJhc2VDb2xvclRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICAgICAgICAke21hdGVyaWFsQmluZGluZygpfSB2YXIgbm9ybWFsU2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgJHttYXRlcmlhbEJpbmRpbmcoKX0gdmFyIG5vcm1hbFRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICAgICAgICAke21hdGVyaWFsQmluZGluZygpfSB2YXIgbWV0YWxsaWNSb3VnaG5lc3NTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgICAke21hdGVyaWFsQmluZGluZygpfSB2YXIgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgICAgICAgJHtpZmRlZihQaXBlbGluZUZlYXR1cmVGbGFncy5FbWlzc2l2ZSwgKCkgPT4gLyogd2dzbCAqL2BcbiAgICAgICAgICAgICR7bWF0ZXJpYWxCaW5kaW5nKCl9IHZhciBlbWlzc2lvblNhbXBsZXI6IHNhbXBsZXI7XG4gICAgICAgICAgICAke21hdGVyaWFsQmluZGluZygpfSB2YXIgZW1pc3Npb25UZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgICAgIGApfVxuXG4gICAgICAgIHN0cnVjdCBNb2RlbFByb3BlcnRpZXMge1xuICAgICAgICAgICAgbW9kZWxUb1dvcmxkTWF0cml4OiBtYXQ0eDRmLFxuXG4gICAgICAgICAgICAke2lmZGVmKFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleE5vcm1hbHMsICdub3JtYWxNYXRyaXg6IG1hdDN4M2YsJyl9XG4gICAgICAgIH1cblxuICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGluc3RhbmNlcyA6IGFycmF5PE1vZGVsUHJvcGVydGllcz47XG5cbiAgICAgICAgc3RydWN0IFZlcnRJbiB7XG4gICAgICAgICAgICBAYnVpbHRpbihpbnN0YW5jZV9pbmRleCkgaW5zdGFuY2U6IHUzMixcbiAgICAgICAgICAgICR7dmVydGV4SW5Mb2NhdGlvbigpfSBwb3M6IHZlYzNmLFxuICAgICAgICAgICAgJHt2ZXJ0ZXhJbkxvY2F0aW9uKCl9IHV2OiB2ZWMyZixcblxuICAgICAgICAgICAgJHtpZmRlZihQaXBlbGluZUZlYXR1cmVGbGFncy5WZXJ0ZXhOb3JtYWxzLCAoKSA9PiAvKiB3Z3NsICovYFxuICAgICAgICAgICAgICAgICR7dmVydGV4SW5Mb2NhdGlvbigpfSB0YW5nZW50OiB2ZWM0ZixcbiAgICAgICAgICAgICAgICAke3ZlcnRleEluTG9jYXRpb24oKX0gbm9ybWFsOiB2ZWMzZixcbiAgICAgICAgICAgIGApfVxuXG4gICAgICAgICAgICAke2lmZGVmKFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleENvbG9ycywgKCkgPT4gLyogd2dzbCAqL2BcbiAgICAgICAgICAgICAgICAke3ZlcnRleEluTG9jYXRpb24oKX0gY29sb3I6IHZlYzRmLFxuICAgICAgICAgICAgYCl9XG4gICAgICAgIH1cblxuICAgICAgICBzdHJ1Y3QgVmVydE91dCB7XG4gICAgICAgICAgICAke3ZhcnlpbmdzfVxuICAgICAgICAgICAgQGJ1aWx0aW4ocG9zaXRpb24pIFBvc2l0aW9uOiB2ZWM0ZixcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cnVjdCBGcmFnSW4ge1xuICAgICAgICAgICAgJHt2YXJ5aW5nc31cblxuICAgICAgICAgICAgJHtpZmRlZihQaXBlbGluZUZlYXR1cmVGbGFncy5WZXJ0ZXhOb3JtYWxzIHwgUGlwZWxpbmVGZWF0dXJlRmxhZ3MuRG91YmxlU2lkZWQsIC8qIHdnc2wgKi9gXG4gICAgICAgICAgICAgICAgQGJ1aWx0aW4oZnJvbnRfZmFjaW5nKSBmcm9udF9mYWNpbmc6IGJvb2wsXG4gICAgICAgICAgICBgKX1cbiAgICAgICAgfVxuXG4gICAgICAgIGZuIHNSR0JUb0xpbmVhcihjb2xvcjogdmVjM2YpIC0+IHZlYzNmIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3QoIFxuICAgICAgICAgICAgICAgIHBvdyhjb2xvciAqIDAuOTQ3ODY3Mjk4NiArIDAuMDUyMTMyNzAxNCwgdmVjMygyLjQpKSwgXG4gICAgICAgICAgICAgICAgY29sb3IgKiAwLjA3NzM5OTM4MDgsIFxuICAgICAgICAgICAgICAgIGNvbG9yIDw9IHZlYzMoMC4wNDA0NSksIFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSAgXG5cbiAgICAgICAgQHZlcnRleCBcbiAgICAgICAgZm4gdnMoaW5EYXRhOiBWZXJ0SW4pIC0+IFZlcnRPdXQge1xuICAgICAgICAgICAgdmFyIHZzT3V0OiBWZXJ0T3V0O1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luRGF0YS5pbnN0YW5jZV07XG4gICAgICAgICAgICBsZXQgd29ybGRQb3MgPSBpbnN0YW5jZS5tb2RlbFRvV29ybGRNYXRyaXggKiB2ZWM0ZihpbkRhdGEucG9zLCAxKTtcbiAgICAgICAgICAgIHZzT3V0LnBvcyA9IHdvcmxkUG9zLnh5ejtcbiAgICAgICAgICAgIHZzT3V0LlBvc2l0aW9uID0gZ2xvYmFscy53b3JsZFRvQ2xpcCAqIHdvcmxkUG9zO1xuICAgICAgICAgICAgdnNPdXQuY2FtUG9zID0gZ2xvYmFscy5pbnZlcnNlV29ybGRUb1ZpZXdbM10ueHl6O1xuICAgICAgICAgICAgdnNPdXQudXYgPSBpbkRhdGEudXY7XG5cbiAgICAgICAgICAgICR7aWZkZWYoUGlwZWxpbmVGZWF0dXJlRmxhZ3MuVmVydGV4Tm9ybWFscywgLyogd2dzbCAqL2BcbiAgICAgICAgICAgICAgICB2c091dC5ub3JtYWwgPSBub3JtYWxpemUoaW5zdGFuY2Uubm9ybWFsTWF0cml4ICogaW5EYXRhLm5vcm1hbCk7XG4gICAgICAgICAgICAgICAgbGV0IHdzVGFuZ2VudCA9IG5vcm1hbGl6ZSgoaW5zdGFuY2UubW9kZWxUb1dvcmxkTWF0cml4ICogdmVjNChpbkRhdGEudGFuZ2VudC54eXosIDAuMCkpLnh5eik7XG4gICAgICAgICAgICAgICAgdnNPdXQudGFuZ2VudCA9IHZlYzQod3NUYW5nZW50LCBpbkRhdGEudGFuZ2VudC53KTtcbiAgICAgICAgICAgIGApfVxuXG4gICAgICAgICAgICByZXR1cm4gdnNPdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtdWNoIG9mIHRoaXMgY29kZSBpcyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vUEJSXG4gICAgICAgIEBmcmFnbWVudFxuICAgICAgICBmbiBmcyhpbkRhdGE6IEZyYWdJbikgLT4gRm9yd2FyZE91dCB7XG4gICAgICAgICAgICB2YXIgb3V0OiBGb3J3YXJkT3V0O1xuICAgICAgICAgICAgbGV0IHJhd0NvbG9yOiB2ZWM0ZiA9IHRleHR1cmVTYW1wbGUoYmFzZUNvbG9yVGV4dHVyZSwgYmFzZUNvbG9yU2FtcGxlciwgaW5EYXRhLnV2KTtcblxuICAgICAgICAgICAgJHtpZmRlZihQaXBlbGluZUZlYXR1cmVGbGFncy5BbHBoYUN1dG9mZiwgLyogd2dzbCAqL2BcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSByYXdDb2xvci5hICogbWF0ZXJpYWwuYmFzZUNvbG9yRmFjdG9yLmE7XG5cbiAgICAgICAgICAgICAgICAke2lmZGVmKFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleENvbG9ycywgLyogd2dzbCAqL2BcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgKj0gaW5EYXRhLmNvbG9yLmE7XG4gICAgICAgICAgICAgICAgYCl9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPD0gbWF0ZXJpYWwuYWxwaGFDdXRvZmYpIHsgXG4gICAgICAgICAgICAgICAgICAgIGRpc2NhcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCl9XG5cbiAgICAgICAgICAgIG91dC5hbGJlZG8gPSB2ZWM0ZihyYXdDb2xvci5yZ2IgKiBtYXRlcmlhbC5iYXNlQ29sb3JGYWN0b3IucmdiLCAxKTtcblxuICAgICAgICAgICAgJHtpZmRlZihQaXBlbGluZUZlYXR1cmVGbGFncy5WZXJ0ZXhDb2xvcnMsIC8qIHdnc2wgKi9gXG4gICAgICAgICAgICAgICAgb3V0LmFsYmVkbyAqPSB2ZWM0ZihpbkRhdGEuY29sb3IucmdiLCAxKTtcbiAgICAgICAgICAgIGApfVxuXG4gICAgICAgICAgICBsZXQgbWV0YWxsaWNSb3VnaG5lc3MgPSB0ZXh0dXJlU2FtcGxlKG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSwgbWV0YWxsaWNSb3VnaG5lc3NTYW1wbGVyLCBpbkRhdGEudXYpO1xuICAgICAgICAgICAgb3V0Lm1ldGFsbGljUm91Z2huZXNzLnIgPSBzYXR1cmF0ZShtZXRhbGxpY1JvdWdobmVzcy5iICogbWF0ZXJpYWwubWV0YWxsaWNGYWN0b3IpO1xuICAgICAgICAgICAgb3V0Lm1ldGFsbGljUm91Z2huZXNzLmcgPSBzYXR1cmF0ZShtZXRhbGxpY1JvdWdobmVzcy5nICogbWF0ZXJpYWwucm91Z2huZXNzRmFjdG9yKTtcblxuICAgICAgICAgICAgJHtpZmRlZihQaXBlbGluZUZlYXR1cmVGbGFncy5WZXJ0ZXhOb3JtYWxzLCAvKiB3Z3NsICovYFxuICAgICAgICAgICAgICAgIGxldCBub3JtYWxTYW1wbGUgPSB0ZXh0dXJlU2FtcGxlKG5vcm1hbFRleHR1cmUsIG5vcm1hbFNhbXBsZXIsIGluRGF0YS51dikueHl6O1xuICAgICAgICAgICAgICAgIGxldCB0YW5nZW50Tm9ybWFsID0gbm9ybWFsaXplKG5vcm1hbFNhbXBsZSAqIDIuMCAtIDEuMCk7XG4gICAgICAgICAgICAgICAgbGV0IGJpdGFuZ2VudCA9aW5EYXRhLnRhbmdlbnQudyAqIGNyb3NzKGluRGF0YS5ub3JtYWwsIGluRGF0YS50YW5nZW50Lnh5eik7XG4gICAgICAgICAgICAgICAgbGV0IHRibiA9IG1hdDN4M2Yobm9ybWFsaXplKGluRGF0YS50YW5nZW50Lnh5eiksIGJpdGFuZ2VudCwgbm9ybWFsaXplKGluRGF0YS5ub3JtYWwpKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gbm9ybWFsaXplKHRibiAqIHRhbmdlbnROb3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgJHtpZmRlZihQaXBlbGluZUZlYXR1cmVGbGFncy5Eb3VibGVTaWRlZCwgLyogd2dzbCAqL2BcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbkRhdGEuZnJvbnRfZmFjaW5nKSB7IG5vcm1hbCAqPSAtMS4wOyB9XG4gICAgICAgICAgICAgICAgYCl9XG4gICAgICAgICAgICBgKS5lbHNlKC8qIHdnc2wgKi9gXG4gICAgICAgICAgICAgICAgbGV0IGZkeCA9IGRwZHgoaW5EYXRhLnBvcyk7XG4gICAgICAgICAgICAgICAgbGV0IGZkeSA9IGRwZHkoaW5EYXRhLnBvcyk7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1hbCA9IG5vcm1hbGl6ZShjcm9zcyhmZHgsIGZkeSkpO1xuICAgICAgICAgICAgYCl9XG5cbiAgICAgICAgICAgIG91dC5ub3JtYWwgPSB2ZWM0Zihub3JtYWwsIDEpO1xuXG4gICAgICAgICAgICAke2lmZGVmKFBpcGVsaW5lRmVhdHVyZUZsYWdzLkVtaXNzaXZlLCAvKiB3Z3NsICovYFxuICAgICAgICAgICAgICAgIGxldCBlbWlzc2lvbiA9IHRleHR1cmVTYW1wbGUoZW1pc3Npb25UZXh0dXJlLCBlbWlzc2lvblNhbXBsZXIsIGluRGF0YS51dikucmdiO1xuICAgICAgICAgICAgICAgIG91dC5lbWlzc2lvbiA9IHZlYzRmKGVtaXNzaW9uLCAxKTtcbiAgICAgICAgICAgIGApfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgYDtcbn1cbiIsImltcG9ydCB7IFBpcGVsaW5lRmVhdHVyZUZsYWdzIH0gZnJvbSAnLi9waXBlbGluZS1mZWF0dXJlLWZsYWdzJztcbmltcG9ydCAqIGFzIFBpcGVsaW5lRmVhdHVyZXMgZnJvbSAnLi9waXBlbGluZS1mZWF0dXJlLWZsYWdzJztcbmltcG9ydCBpbmNsdWRlLCB7IGdldEJpbmRncm91cEluZm8gYXMgZ2V0QmluZEdyb3VwSW5mbyB9IGZyb20gJy4uLy4uL3NoYWRlcnMvZm9yd2FyZC5zaGFkZXInO1xuXG5pbXBvcnQgR0J1ZmZlciBmcm9tICcuLi9nYnVmZmVyJztcbmltcG9ydCBHbG9iYWxVbmlmb3JtcyBmcm9tICcuLi9nbG9iYWwtdW5pZm9ybXMnO1xuXG50eXBlIFBpcGVsaW5lRmVhdHVyZU1hcDxUPiA9IFBhcnRpYWw8UmVjb3JkPG51bWJlciwgVD4+O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXNjcmlwdG9yTWFwIHtcbiAgICBzdGF0aWMgcmVhZG9ubHkgZmxhZ1RvVG9wb2xvZ3k6IFBhcnRpYWw8UmVjb3JkPFBpcGVsaW5lRmVhdHVyZUZsYWdzLCBHUFVQcmltaXRpdmVUb3BvbG9neT4+ID0ge1xuICAgICAgICBbUGlwZWxpbmVGZWF0dXJlRmxhZ3MuVHJpYW5nbGVMaXN0XTogJ3RyaWFuZ2xlLWxpc3QnLFxuICAgICAgICBbUGlwZWxpbmVGZWF0dXJlRmxhZ3MuVHJpYW5nbGVTdHJpcF06ICd0cmlhbmdsZS1zdHJpcCcsXG4gICAgICAgIFtQaXBlbGluZUZlYXR1cmVGbGFncy5Qb2ludExpc3RdOiAncG9pbnQtbGlzdCcsXG4gICAgICAgIFtQaXBlbGluZUZlYXR1cmVGbGFncy5MaW5lTGlzdF06ICdsaW5lLWxpc3QnLFxuICAgICAgICBbUGlwZWxpbmVGZWF0dXJlRmxhZ3MuTGluZVN0cmlwXTogJ2xpbmUtc3RyaXAnLFxuICAgIH07XG5cbiAgICByZWFkb25seSBwaXBlbGluZUxheW91dHM6IFBpcGVsaW5lRmVhdHVyZU1hcDxHUFVQaXBlbGluZUxheW91dD4gPSB7fTtcbiAgICByZWFkb25seSBwcmltaXRpdmVTdGF0ZXM6IFBpcGVsaW5lRmVhdHVyZU1hcDxHUFVQcmltaXRpdmVTdGF0ZT4gPSB7fTtcbiAgICByZWFkb25seSB2ZXJ0ZXhMYXlvdXRzOiBQaXBlbGluZUZlYXR1cmVNYXA8R1BVVmVydGV4QnVmZmVyTGF5b3V0PiA9IHt9O1xuICAgIHJlYWRvbmx5IHNoYWRlck1vZHVsZXM6IFBpcGVsaW5lRmVhdHVyZU1hcDxHUFVTaGFkZXJNb2R1bGU+ID0ge307XG4gICAgcmVhZG9ubHkgYmluZGdyb3VwTGF5b3V0czogUGlwZWxpbmVGZWF0dXJlTWFwPEdQVUJpbmRHcm91cExheW91dD4gPSB7fTtcblxuICAgIHJlYWRvbmx5IHNhbXBsZXJzOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIEdQVVNhbXBsZXI+PiA9IHt9O1xuXG4gICAgcmVhZG9ubHkgZm9yd2FyZEJpbmRncm91cExheW91dCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgIGxhYmVsOiBgZm9yd2FyZCBtYXRlcmlhbGAsXG4gICAgICAgIGVudHJpZXM6IFt7XG4gICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuVkVSVEVYIHwgR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICBidWZmZXI6IHsgdHlwZTogJ3JlYWQtb25seS1zdG9yYWdlJyB9LFxuICAgICAgICB9XSxcbiAgICB9KTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgZGV2aWNlOiBHUFVEZXZpY2UsXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBnYnVmZmVyOiBHQnVmZmVyLFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgZ2xvYmFsczogR2xvYmFsVW5pZm9ybXMsXG4gICAgKSB7IH1cblxuICAgIGdldFNhbXBsZXIoZGVzY3JpcHRvcjogR1BVU2FtcGxlckRlc2NyaXB0b3IpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRvcik7XG4gICAgICAgIHRoaXMuc2FtcGxlcnNba2V5XSA/Pz0gdGhpcy5kZXZpY2UuY3JlYXRlU2FtcGxlcihkZXNjcmlwdG9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlcnNba2V5XTtcbiAgICB9XG5cbiAgICBnZXRWZXJ0ZXhMYXlvdXQoZmxhZ3M6IFBpcGVsaW5lRmVhdHVyZUZsYWdzKSB7XG4gICAgICAgIGNvbnN0IG1hc2tlZDogUGlwZWxpbmVGZWF0dXJlRmxhZ3MgPSBmbGFncyAmIFBpcGVsaW5lRmVhdHVyZXMuVmVydGV4QnVmZmVyTGF5b3V0TWFzaztcblxuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhMYXlvdXRzW21hc2tlZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlczogR1BVVmVydGV4QXR0cmlidXRlW10gPSBbXG4gICAgICAgICAgICAgICAgeyBzaGFkZXJMb2NhdGlvbjogMCwgb2Zmc2V0OiAwLCBmb3JtYXQ6ICdmbG9hdDMyeDMnIH0sIC8vIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgeyBzaGFkZXJMb2NhdGlvbjogMSwgb2Zmc2V0OiAxMiwgZm9ybWF0OiAnZmxvYXQzMngyJyB9LCAvLyB1dlxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbGV0IGFycmF5U3RyaWRlID0gMjA7XG4gICAgICAgICAgICBsZXQgc2hhZGVyTG9jYXRpb24gPSAyO1xuXG4gICAgICAgICAgICBpZiAobWFza2VkICYgUGlwZWxpbmVGZWF0dXJlRmxhZ3MuVmVydGV4Tm9ybWFscykge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaCh7IHNoYWRlckxvY2F0aW9uLCBvZmZzZXQ6IGFycmF5U3RyaWRlLCBmb3JtYXQ6ICdmbG9hdDMyeDQnIH0pOyAvLyB0YW5nZW50XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKHsgc2hhZGVyTG9jYXRpb246IHNoYWRlckxvY2F0aW9uICsgMSwgb2Zmc2V0OiBhcnJheVN0cmlkZSArIDE2LCBmb3JtYXQ6ICdmbG9hdDMyeDMnIH0pOyAvLyBub3JtYWxcbiAgICAgICAgICAgICAgICBzaGFkZXJMb2NhdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIGFycmF5U3RyaWRlICs9IDI4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWFza2VkICYgUGlwZWxpbmVGZWF0dXJlRmxhZ3MuVmVydGV4Q29sb3JzKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKHsgc2hhZGVyTG9jYXRpb24sIG9mZnNldDogYXJyYXlTdHJpZGUsIGZvcm1hdDogJ2Zsb2F0MzJ4NCcgfSk7IC8vIGNvbG9yXG4gICAgICAgICAgICAgICAgYXJyYXlTdHJpZGUgKz0gMTY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudmVydGV4TGF5b3V0c1ttYXNrZWRdID0geyBhdHRyaWJ1dGVzLCBhcnJheVN0cmlkZSwgc3RlcE1vZGU6ICd2ZXJ0ZXgnIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52ZXJ0ZXhMYXlvdXRzW21hc2tlZF07XG4gICAgfVxuXG4gICAgZ2V0Rm9yd2FyZFBpcGVsaW5lTGF5b3V0KGZsYWdzOiBQaXBlbGluZUZlYXR1cmVGbGFncykge1xuICAgICAgICBjb25zdCBtYXNrZWQ6IFBpcGVsaW5lRmVhdHVyZUZsYWdzID0gZmxhZ3MgJiBQaXBlbGluZUZlYXR1cmVzLlBpcGVsaW5lTGF5b3V0TWFzaztcblxuICAgICAgICB0aGlzLnBpcGVsaW5lTGF5b3V0c1ttYXNrZWRdID8/PSB0aGlzLmRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCh7XG4gICAgICAgICAgICBsYWJlbDogUGlwZWxpbmVGZWF0dXJlcy5mZWF0dXJlRmxhZ3NUb1N0cmluZyhtYXNrZWQpLFxuICAgICAgICAgICAgYmluZEdyb3VwTGF5b3V0czogW1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFscy5iaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRNYXRlcmlhbEJpbmRHcm91cChmbGFncyksXG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkQmluZGdyb3VwTGF5b3V0LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGlwZWxpbmVMYXlvdXRzW21hc2tlZF07XG4gICAgfVxuXG4gICAgZ2V0U2hhZGVyTW9kdWxlKGZsYWdzOiBQaXBlbGluZUZlYXR1cmVGbGFncykge1xuICAgICAgICBjb25zdCBtYXNrZWQ6IFBpcGVsaW5lRmVhdHVyZUZsYWdzID0gZmxhZ3MgJiBQaXBlbGluZUZlYXR1cmVzLkNvZGVNYXNrO1xuICAgICAgICB0aGlzLnNoYWRlck1vZHVsZXNbbWFza2VkXSA/Pz0gdGhpcy5kZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtcbiAgICAgICAgICAgIGxhYmVsOiBQaXBlbGluZUZlYXR1cmVzLmZlYXR1cmVGbGFnc1RvU3RyaW5nKG1hc2tlZCksXG4gICAgICAgICAgICBjb2RlOiBpbmNsdWRlKG1hc2tlZCksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXJNb2R1bGVzW21hc2tlZF07XG4gICAgfVxuXG4gICAgZ2V0UHJpbWl0aXZlU3RhdGUoZmxhZ3M6IFBpcGVsaW5lRmVhdHVyZUZsYWdzKSB7XG4gICAgICAgIGNvbnN0IG1hc2tlZCA9IGZsYWdzICYgUGlwZWxpbmVGZWF0dXJlcy5QcmltaXRpdmVTdGF0ZU1hc2s7XG5cbiAgICAgICAgdGhpcy5wcmltaXRpdmVTdGF0ZXNbbWFza2VkXSA/Pz0ge1xuICAgICAgICAgICAgdG9wb2xvZ3k6IERlc2NyaXB0b3JNYXAuZmxhZ1RvVG9wb2xvZ3lbKGZsYWdzICYgUGlwZWxpbmVGZWF0dXJlcy5Ub3BvbG9neUZvcm1hdE1hc2spIGFzIFBpcGVsaW5lRmVhdHVyZUZsYWdzXSxcbiAgICAgICAgICAgIGN1bGxNb2RlOiBtYXNrZWQgJiBQaXBlbGluZUZlYXR1cmVGbGFncy5Eb3VibGVTaWRlZCA/ICdub25lJyA6ICdiYWNrJyxcbiAgICAgICAgICAgIGZyb250RmFjZTogbWFza2VkICYgUGlwZWxpbmVGZWF0dXJlRmxhZ3MuQ2xvY2t3aXNlV2luZGluZyA/ICdjdycgOiAnY2N3JyxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmltaXRpdmVTdGF0ZXNbbWFza2VkXTtcbiAgICB9XG5cbiAgICBnZXRNYXRlcmlhbEJpbmRHcm91cChmbGFnczogUGlwZWxpbmVGZWF0dXJlRmxhZ3MpIHtcbiAgICAgICAgY29uc3QgbWFza2VkID0gZmxhZ3MgJiBQaXBlbGluZUZlYXR1cmVzLk1hdGVyaWFsQmluZGdyb3VwTGF5b3V0TWFzaztcbiAgICAgICAgdGhpcy5iaW5kZ3JvdXBMYXlvdXRzW21hc2tlZF0gPz89IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dChnZXRCaW5kR3JvdXBJbmZvKG1hc2tlZCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kZ3JvdXBMYXlvdXRzW21hc2tlZF07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///360\n")},9274:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FO: () => (/* binding */ PipelineLayoutMask),\n/* harmony export */   Ot: () => (/* binding */ PipelineFeatureFlags),\n/* harmony export */   P7: () => (/* binding */ maskRedundantFeatures),\n/* harmony export */   Py: () => (/* binding */ TopologyFormatMask),\n/* harmony export */   Q7: () => (/* binding */ CodeMask),\n/* harmony export */   UZ: () => (/* binding */ featureFlagsToString),\n/* harmony export */   V3: () => (/* binding */ VertexBufferLayoutMask),\n/* harmony export */   Wq: () => (/* binding */ MaterialBindgroupLayoutMask),\n/* harmony export */   XY: () => (/* binding */ PrimitiveStateMask)\n/* harmony export */ });\n/* unused harmony exports InstanceBufferLayoutMask, MaterialBufferLayoutMask, MaterialMask, featureFlagsToNames */\nvar PipelineFeatureFlags;\n(function (PipelineFeatureFlags) {\n    PipelineFeatureFlags[PipelineFeatureFlags["Defaults"] = 0] = "Defaults";\n    /**\n     * If the meshes have vertex normals.\n     * If absent, meshes are shaded with flat normals.\n    */\n    PipelineFeatureFlags[PipelineFeatureFlags["VertexNormals"] = 1] = "VertexNormals";\n    /**\n     * If the meshes have vertex colors.\n     * If absent, mesh is shaded with a base color texture.\n    */\n    PipelineFeatureFlags[PipelineFeatureFlags["VertexColors"] = 2] = "VertexColors";\n    PipelineFeatureFlags[PipelineFeatureFlags["AlphaCutoff"] = 4] = "AlphaCutoff";\n    PipelineFeatureFlags[PipelineFeatureFlags["Emissive"] = 8] = "Emissive";\n    PipelineFeatureFlags[PipelineFeatureFlags["DoubleSided"] = 16] = "DoubleSided";\n    PipelineFeatureFlags[PipelineFeatureFlags["ClockwiseWinding"] = 32] = "ClockwiseWinding";\n    // Topology formats\n    PipelineFeatureFlags[PipelineFeatureFlags["TriangleList"] = 0] = "TriangleList";\n    PipelineFeatureFlags[PipelineFeatureFlags["TriangleStrip"] = 64] = "TriangleStrip";\n    PipelineFeatureFlags[PipelineFeatureFlags["PointList"] = 128] = "PointList";\n    PipelineFeatureFlags[PipelineFeatureFlags["LineList"] = 192] = "LineList";\n    PipelineFeatureFlags[PipelineFeatureFlags["LineStrip"] = 256] = "LineStrip";\n    PipelineFeatureFlags[PipelineFeatureFlags["Unindexed"] = 320] = "Unindexed";\n    // LINE_LOOP (currently unsupported by webgpu)\n    // TRIANGLE_FAN (currently unsupported by webgpu)\n})(PipelineFeatureFlags || (PipelineFeatureFlags = {}));\nconst TopologyFormatMask = 0x111 << 6;\nconst PrimitiveStateMask = (TopologyFormatMask\n    | PipelineFeatureFlags.DoubleSided\n    | PipelineFeatureFlags.ClockwiseWinding);\nconst CodeMask = ~(TopologyFormatMask\n    | PipelineFeatureFlags.ClockwiseWinding);\nconst InstanceBufferLayoutMask = (PipelineFeatureFlags.VertexNormals);\nconst VertexBufferLayoutMask = (PipelineFeatureFlags.VertexNormals\n    | PipelineFeatureFlags.VertexColors);\nconst MaterialBufferLayoutMask = (PipelineFeatureFlags.AlphaCutoff);\nconst MaterialBindgroupLayoutMask = (MaterialBufferLayoutMask\n    | PipelineFeatureFlags.Emissive);\nconst MaterialMask = (MaterialBindgroupLayoutMask\n    | PipelineFeatureFlags.DoubleSided);\nconst PipelineLayoutMask = (InstanceBufferLayoutMask\n    | MaterialMask);\nfunction featureFlagsToNames(val) {\n    return Object.entries(PipelineFeatureFlags)\n        .flatMap(([key, flag]) => typeof flag === \'number\' && (flag & val) ? key : []);\n}\nfunction featureFlagsToString(val) {\n    return featureFlagsToNames(val).toString();\n}\nfunction maskRedundantFeatures(flags) {\n    let masked = flags;\n    if (masked & PipelineFeatureFlags.DoubleSided)\n        masked &= ~PipelineFeatureFlags.ClockwiseWinding;\n    return masked;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI3NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxJQUFZLG9CQThCWDtBQTlCRCxXQUFZLG9CQUFvQjtJQUM1Qix1RUFBWTtJQUVaOzs7TUFHRTtJQUNGLGlGQUFzQjtJQUV0Qjs7O01BR0U7SUFDRiwrRUFBcUI7SUFFckIsNkVBQW9CO0lBQ3BCLHVFQUFpQjtJQUVqQiw4RUFBb0I7SUFDcEIsd0ZBQXlCO0lBRXpCLG1CQUFtQjtJQUNuQiwrRUFBcUI7SUFDckIsa0ZBQXNCO0lBQ3RCLDJFQUFrQjtJQUNsQix5RUFBaUI7SUFDakIsMkVBQWtCO0lBQ2xCLDJFQUFrQjtJQUNsQiw4Q0FBOEM7SUFDOUMsaURBQWlEO0FBQ3JELENBQUMsRUE5Qlcsb0JBQW9CLEtBQXBCLG9CQUFvQixRQThCL0I7QUFFTSxNQUFNLGtCQUFrQixHQUFHLEtBQUssSUFBSSxDQUFDLENBQUM7QUFFdEMsTUFBTSxrQkFBa0IsR0FBRyxDQUM5QixrQkFBa0I7TUFDaEIsb0JBQW9CLENBQUMsV0FBVztNQUNoQyxvQkFBb0IsQ0FBQyxnQkFBZ0IsQ0FDMUMsQ0FBQztBQUVLLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FDckIsa0JBQWtCO01BQ2hCLG9CQUFvQixDQUFDLGdCQUFnQixDQUMxQyxDQUFDO0FBRUssTUFBTSx3QkFBd0IsR0FBRyxDQUNwQyxvQkFBb0IsQ0FBQyxhQUFhLENBQ3JDLENBQUM7QUFFSyxNQUFNLHNCQUFzQixHQUFHLENBQ2xDLG9CQUFvQixDQUFDLGFBQWE7TUFDaEMsb0JBQW9CLENBQUMsWUFBWSxDQUN0QyxDQUFDO0FBRUssTUFBTSx3QkFBd0IsR0FBRyxDQUNwQyxvQkFBb0IsQ0FBQyxXQUFXLENBQ25DLENBQUM7QUFFSyxNQUFNLDJCQUEyQixHQUFHLENBQ3ZDLHdCQUF3QjtNQUN0QixvQkFBb0IsQ0FBQyxRQUFRLENBQ2xDLENBQUM7QUFFSyxNQUFNLFlBQVksR0FBRyxDQUN4QiwyQkFBMkI7TUFDekIsb0JBQW9CLENBQUMsV0FBVyxDQUNyQyxDQUFDO0FBRUssTUFBTSxrQkFBa0IsR0FBRyxDQUM5Qix3QkFBd0I7TUFDdEIsWUFBWSxDQUNqQixDQUFDO0FBRUssU0FBUyxtQkFBbUIsQ0FBQyxHQUFXO0lBQzNDLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztTQUN0QyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTyxJQUFJLEtBQUssUUFBUSxJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3ZGLENBQUM7QUFFTSxTQUFTLG9CQUFvQixDQUFDLEdBQVc7SUFDNUMsT0FBTyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUMvQyxDQUFDO0FBRU0sU0FBUyxxQkFBcUIsQ0FBQyxLQUEyQjtJQUM3RCxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDbkIsSUFBSSxNQUFNLEdBQUcsb0JBQW9CLENBQUMsV0FBVztRQUFFLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUFDLGdCQUFnQixDQUFDO0lBQ2hHLE9BQU8sTUFBTSxDQUFDO0FBQ2xCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL3BpcGVsaW5lLWZlYXR1cmUtZmxhZ3MudHM/NGI5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZW51bSBQaXBlbGluZUZlYXR1cmVGbGFncyB7XG4gICAgRGVmYXVsdHMgPSAwLFxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIG1lc2hlcyBoYXZlIHZlcnRleCBub3JtYWxzLlxuICAgICAqIElmIGFic2VudCwgbWVzaGVzIGFyZSBzaGFkZWQgd2l0aCBmbGF0IG5vcm1hbHMuXG4gICAgKi9cbiAgICBWZXJ0ZXhOb3JtYWxzID0gMSA8PCAwLFxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIG1lc2hlcyBoYXZlIHZlcnRleCBjb2xvcnMuXG4gICAgICogSWYgYWJzZW50LCBtZXNoIGlzIHNoYWRlZCB3aXRoIGEgYmFzZSBjb2xvciB0ZXh0dXJlLlxuICAgICovXG4gICAgVmVydGV4Q29sb3JzID0gMSA8PCAxLFxuXG4gICAgQWxwaGFDdXRvZmYgPSAxIDw8IDIsXG4gICAgRW1pc3NpdmUgPSAxIDw8IDMsXG5cbiAgICBEb3VibGVTaWRlZCA9IDEgPDwgNCxcbiAgICBDbG9ja3dpc2VXaW5kaW5nID0gMSA8PCA1LFxuXG4gICAgLy8gVG9wb2xvZ3kgZm9ybWF0c1xuICAgIFRyaWFuZ2xlTGlzdCA9IDAgPDwgNixcbiAgICBUcmlhbmdsZVN0cmlwID0gMSA8PCA2LFxuICAgIFBvaW50TGlzdCA9IDIgPDwgNixcbiAgICBMaW5lTGlzdCA9IDMgPDwgNixcbiAgICBMaW5lU3RyaXAgPSA0IDw8IDYsXG4gICAgVW5pbmRleGVkID0gNSA8PCA2LFxuICAgIC8vIExJTkVfTE9PUCAoY3VycmVudGx5IHVuc3VwcG9ydGVkIGJ5IHdlYmdwdSlcbiAgICAvLyBUUklBTkdMRV9GQU4gKGN1cnJlbnRseSB1bnN1cHBvcnRlZCBieSB3ZWJncHUpXG59XG5cbmV4cG9ydCBjb25zdCBUb3BvbG9neUZvcm1hdE1hc2sgPSAweDExMSA8PCA2O1xuXG5leHBvcnQgY29uc3QgUHJpbWl0aXZlU3RhdGVNYXNrID0gKFxuICAgIFRvcG9sb2d5Rm9ybWF0TWFza1xuICAgIHwgUGlwZWxpbmVGZWF0dXJlRmxhZ3MuRG91YmxlU2lkZWRcbiAgICB8IFBpcGVsaW5lRmVhdHVyZUZsYWdzLkNsb2Nrd2lzZVdpbmRpbmdcbik7XG5cbmV4cG9ydCBjb25zdCBDb2RlTWFzayA9IH4oXG4gICAgVG9wb2xvZ3lGb3JtYXRNYXNrXG4gICAgfCBQaXBlbGluZUZlYXR1cmVGbGFncy5DbG9ja3dpc2VXaW5kaW5nXG4pO1xuXG5leHBvcnQgY29uc3QgSW5zdGFuY2VCdWZmZXJMYXlvdXRNYXNrID0gKFxuICAgIFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleE5vcm1hbHNcbik7XG5cbmV4cG9ydCBjb25zdCBWZXJ0ZXhCdWZmZXJMYXlvdXRNYXNrID0gKFxuICAgIFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleE5vcm1hbHNcbiAgICB8IFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleENvbG9yc1xuKTtcblxuZXhwb3J0IGNvbnN0IE1hdGVyaWFsQnVmZmVyTGF5b3V0TWFzayA9IChcbiAgICBQaXBlbGluZUZlYXR1cmVGbGFncy5BbHBoYUN1dG9mZlxuKTtcblxuZXhwb3J0IGNvbnN0IE1hdGVyaWFsQmluZGdyb3VwTGF5b3V0TWFzayA9IChcbiAgICBNYXRlcmlhbEJ1ZmZlckxheW91dE1hc2tcbiAgICB8IFBpcGVsaW5lRmVhdHVyZUZsYWdzLkVtaXNzaXZlXG4pO1xuXG5leHBvcnQgY29uc3QgTWF0ZXJpYWxNYXNrID0gKFxuICAgIE1hdGVyaWFsQmluZGdyb3VwTGF5b3V0TWFza1xuICAgIHwgUGlwZWxpbmVGZWF0dXJlRmxhZ3MuRG91YmxlU2lkZWRcbik7XG5cbmV4cG9ydCBjb25zdCBQaXBlbGluZUxheW91dE1hc2sgPSAoXG4gICAgSW5zdGFuY2VCdWZmZXJMYXlvdXRNYXNrXG4gICAgfCBNYXRlcmlhbE1hc2tcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBmZWF0dXJlRmxhZ3NUb05hbWVzKHZhbDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKFBpcGVsaW5lRmVhdHVyZUZsYWdzKVxuICAgICAgICAuZmxhdE1hcCgoW2tleSwgZmxhZ10pID0+IHR5cGVvZiBmbGFnID09PSAnbnVtYmVyJyAmJiAoZmxhZyAmIHZhbCkgPyBrZXkgOiBbXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZWF0dXJlRmxhZ3NUb1N0cmluZyh2YWw6IG51bWJlcikge1xuICAgIHJldHVybiBmZWF0dXJlRmxhZ3NUb05hbWVzKHZhbCkudG9TdHJpbmcoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hc2tSZWR1bmRhbnRGZWF0dXJlcyhmbGFnczogUGlwZWxpbmVGZWF0dXJlRmxhZ3MpIHtcbiAgICBsZXQgbWFza2VkID0gZmxhZ3M7XG4gICAgaWYgKG1hc2tlZCAmIFBpcGVsaW5lRmVhdHVyZUZsYWdzLkRvdWJsZVNpZGVkKSBtYXNrZWQgJj0gflBpcGVsaW5lRmVhdHVyZUZsYWdzLkNsb2Nrd2lzZVdpbmRpbmc7XG4gICAgcmV0dXJuIG1hc2tlZDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9274\n')},992:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _camera_camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3048);\n\nconst label = 'global uniforms';\nclass GlobalUniforms {\n    constructor(device) {\n        this.deviceBuffer = device.createBuffer(GlobalUniforms.bufferDescriptor);\n        this.bindGroupLayout = device.createBindGroupLayout(GlobalUniforms.layoutDescriptor);\n        this.bindGroupDescriptor = {\n            label,\n            layout: this.bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.deviceBuffer,\n                        offset: 0,\n                        size: GlobalUniforms.bufferSize,\n                    },\n                },\n            ],\n        };\n        this.bindgroup = device.createBindGroup(this.bindGroupDescriptor);\n    }\n    updateDeviceBuffer(queue, camera) {\n        camera.cacheView();\n        queue.writeBuffer(this.deviceBuffer, 0, camera.buffer);\n    }\n}\nGlobalUniforms.code = (group) => /* wgsl */ `\r\n        struct GlobalUniforms {\r\n            worldToView: mat4x4f,\r\n            viewToClip: mat4x4f,\r\n            worldToClip: mat4x4f,\r\n            inverseWorldToView: mat4x4f,\r\n            inverseViewToClip: mat4x4f,\r\n            inverseWorldToClip: mat4x4f,\r\n        }\r\n\r\n        @group(${group}) @binding(0) var<uniform> globals: GlobalUniforms;\r\n    `;\nGlobalUniforms.bufferSize = _camera_camera__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A.bufferLength;\nGlobalUniforms.layoutDescriptor = {\n    label,\n    entries: [\n        {\n            binding: 0,\n            buffer: { minBindingSize: GlobalUniforms.bufferSize },\n            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n        },\n    ],\n};\nGlobalUniforms.bufferDescriptor = {\n    label,\n    size: GlobalUniforms.bufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GlobalUniforms);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBcUM7QUFFckMsTUFBTSxLQUFLLEdBQUcsaUJBQWlCLENBQUM7QUFFaEMsTUFBcUIsY0FBYztJQXNDL0IsWUFBWSxNQUFpQjtRQUN6QixJQUFJLENBQUMsWUFBWSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDekUsSUFBSSxDQUFDLGVBQWUsR0FBRyxNQUFNLENBQUMscUJBQXFCLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFckYsSUFBSSxDQUFDLG1CQUFtQixHQUFHO1lBQ3ZCLEtBQUs7WUFDTCxNQUFNLEVBQUUsSUFBSSxDQUFDLGVBQWU7WUFDNUIsT0FBTyxFQUFFO2dCQUNMO29CQUNJLE9BQU8sRUFBRSxDQUFDO29CQUNWLFFBQVEsRUFBRTt3QkFDTixNQUFNLEVBQUUsSUFBSSxDQUFDLFlBQVk7d0JBQ3pCLE1BQU0sRUFBRSxDQUFDO3dCQUNULElBQUksRUFBRSxjQUFjLENBQUMsVUFBVTtxQkFDbEM7aUJBQ0o7YUFDSjtTQUNKLENBQUM7UUFFRixJQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVELGtCQUFrQixDQUFDLEtBQWUsRUFBRSxNQUFjO1FBQzlDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNuQixLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzRCxDQUFDOztBQTlEZSxtQkFBSSxHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUUsQ0FBQyxVQUFVOzs7Ozs7Ozs7O2lCQVV2QyxLQUFLO0tBQ2pCLENBQUM7QUFFYyx5QkFBVSxHQUFHLCtEQUFNLENBQUMsWUFBWSxDQUFDO0FBRWpDLCtCQUFnQixHQUFpQztJQUM3RCxLQUFLO0lBQ0wsT0FBTyxFQUFFO1FBQ0w7WUFDSSxPQUFPLEVBQUUsQ0FBQztZQUNWLE1BQU0sRUFBRSxFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUMsVUFBVSxFQUFFO1lBQ3JELFVBQVUsRUFBRSxjQUFjLENBQUMsTUFBTSxHQUFHLGNBQWMsQ0FBQyxRQUFRO1NBQzlEO0tBQ0o7Q0FDSixDQUFDO0FBRWMsK0JBQWdCLEdBQXdCO0lBQ3BELEtBQUs7SUFDTCxJQUFJLEVBQUUsY0FBYyxDQUFDLFVBQVU7SUFDL0IsS0FBSyxFQUFFLGNBQWMsQ0FBQyxPQUFPLEdBQUcsY0FBYyxDQUFDLFFBQVE7Q0FDMUQsQ0FBQztpRUEvQmUsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy9yZW5kZXJpbmcvZ2xvYmFsLXVuaWZvcm1zLnRzPzZlNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhbWVyYSBmcm9tICcuL2NhbWVyYS9jYW1lcmEnO1xyXG5cclxuY29uc3QgbGFiZWwgPSAnZ2xvYmFsIHVuaWZvcm1zJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdsb2JhbFVuaWZvcm1zIHtcclxuICAgIHN0YXRpYyByZWFkb25seSBjb2RlID0gKGdyb3VwOiBudW1iZXIpID0+IC8qIHdnc2wgKi9gXHJcbiAgICAgICAgc3RydWN0IEdsb2JhbFVuaWZvcm1zIHtcclxuICAgICAgICAgICAgd29ybGRUb1ZpZXc6IG1hdDR4NGYsXHJcbiAgICAgICAgICAgIHZpZXdUb0NsaXA6IG1hdDR4NGYsXHJcbiAgICAgICAgICAgIHdvcmxkVG9DbGlwOiBtYXQ0eDRmLFxyXG4gICAgICAgICAgICBpbnZlcnNlV29ybGRUb1ZpZXc6IG1hdDR4NGYsXHJcbiAgICAgICAgICAgIGludmVyc2VWaWV3VG9DbGlwOiBtYXQ0eDRmLFxyXG4gICAgICAgICAgICBpbnZlcnNlV29ybGRUb0NsaXA6IG1hdDR4NGYsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBAZ3JvdXAoJHtncm91cH0pIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnbG9iYWxzOiBHbG9iYWxVbmlmb3JtcztcclxuICAgIGA7XHJcblxyXG4gICAgc3RhdGljIHJlYWRvbmx5IGJ1ZmZlclNpemUgPSBDYW1lcmEuYnVmZmVyTGVuZ3RoO1xyXG5cclxuICAgIHN0YXRpYyByZWFkb25seSBsYXlvdXREZXNjcmlwdG9yOiBHUFVCaW5kR3JvdXBMYXlvdXREZXNjcmlwdG9yID0ge1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGVudHJpZXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmluZGluZzogMCxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcjogeyBtaW5CaW5kaW5nU2l6ZTogR2xvYmFsVW5pZm9ybXMuYnVmZmVyU2l6ZSB9LFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuVkVSVEVYIHwgR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIHJlYWRvbmx5IGJ1ZmZlckRlc2NyaXB0b3I6IEdQVUJ1ZmZlckRlc2NyaXB0b3IgPSB7XHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgc2l6ZTogR2xvYmFsVW5pZm9ybXMuYnVmZmVyU2l6ZSxcclxuICAgICAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULFxyXG4gICAgfTtcclxuXHJcbiAgICBkZXZpY2VCdWZmZXI6IEdQVUJ1ZmZlcjtcclxuICAgIGJpbmRHcm91cExheW91dDogR1BVQmluZEdyb3VwTGF5b3V0O1xyXG4gICAgYmluZEdyb3VwRGVzY3JpcHRvciE6IEdQVUJpbmRHcm91cERlc2NyaXB0b3I7XHJcbiAgICBiaW5kZ3JvdXAhOiBHUFVCaW5kR3JvdXA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZGV2aWNlOiBHUFVEZXZpY2UpIHtcclxuICAgICAgICB0aGlzLmRldmljZUJ1ZmZlciA9IGRldmljZS5jcmVhdGVCdWZmZXIoR2xvYmFsVW5pZm9ybXMuYnVmZmVyRGVzY3JpcHRvcik7XHJcbiAgICAgICAgdGhpcy5iaW5kR3JvdXBMYXlvdXQgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KEdsb2JhbFVuaWZvcm1zLmxheW91dERlc2NyaXB0b3IpO1xyXG5cclxuICAgICAgICB0aGlzLmJpbmRHcm91cERlc2NyaXB0b3IgPSB7XHJcbiAgICAgICAgICAgIGxhYmVsLFxyXG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMuYmluZEdyb3VwTGF5b3V0LFxyXG4gICAgICAgICAgICBlbnRyaWVzOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMCxcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHRoaXMuZGV2aWNlQnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IEdsb2JhbFVuaWZvcm1zLmJ1ZmZlclNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kZ3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHRoaXMuYmluZEdyb3VwRGVzY3JpcHRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRGV2aWNlQnVmZmVyKHF1ZXVlOiBHUFVRdWV1ZSwgY2FtZXJhOiBDYW1lcmEpIHtcclxuICAgICAgICBjYW1lcmEuY2FjaGVWaWV3KCk7XHJcbiAgICAgICAgcXVldWUud3JpdGVCdWZmZXIodGhpcy5kZXZpY2VCdWZmZXIsIDAsIGNhbWVyYS5idWZmZXIpO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///992\n")},3156:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ cubemapGuassianPyramid)\n/* harmony export */ });\n/* harmony import */ var _shaders_cubemap_sampling_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6097);\n/* harmony import */ var _utils_data_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5752);\n/* harmony import */ var _utils_general__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4742);\n/* eslint @stylistic/max-len: \"error\" */\n\n\n\nconst createMipBlurCode = (groups, format) => /* wgsl */ `\r\n    ${_shaders_cubemap_sampling_shader__WEBPACK_IMPORTED_MODULE_1__/* .cubemapSampleConversions */ .X}\r\n    ${_shaders_cubemap_sampling_shader__WEBPACK_IMPORTED_MODULE_1__/* .toWorldDir */ .V}\r\n\r\n    override STEPS: i32 = 4;\r\n\r\n    struct Params {\r\n        offset: u32,\r\n        sigmas: array<f32>,\r\n    }\r\n\r\n    @group(0) @binding(0) var previousMip: texture_2d_array<f32>;\r\n\r\n    @group(0) @binding(1) \r\n    var outputTexture: texture_storage_2d_array<${format}, write>;\r\n\r\n    // sigma[0] reserved for work offset\r\n    @group(0) @binding(2) var<storage> params: Params;\r\n    \r\n    @compute @workgroup_size(${groups}, 1, 1)\r\n    fn main(@builtin(global_invocation_id) gid: vec3u) {\r\n        let mipSize = textureDimensions(outputTexture).x;\r\n\r\n        let idx = gid.x + params.offset;\r\n        let faceSize = mipSize * mipSize;\r\n        let faceIdx = idx % faceSize;\r\n        let coord = vec3u(\r\n            faceIdx % mipSize, \r\n            faceIdx / mipSize, \r\n            idx / faceSize,\r\n        ); \r\n\r\n        if (coord.x >= mipSize || coord.y >= mipSize || coord.z >= 6) { \r\n            return; \r\n        }\r\n\r\n        let previousSize = textureDimensions(previousMip).x;\r\n        let baseCoord = vec3i(vec3u(coord.x * 2, coord.y * 2, coord.z));\r\n        let pos = toWorldDir(vec3u(coord), mipSize);\r\n\r\n        let size = arrayLength(&params.sigmas);\r\n        let level = size - u32(ceil(log2(f32(previousSize))));\r\n        let sigma = params.sigmas[level];\r\n        let guassian_factor = -0.5 / (sigma * sigma);\r\n\r\n        var weight = 0.0;\r\n        var res = vec3(0.0);\r\n\r\n        for (var u = -STEPS; u <= STEPS + 1; u += 1) {\r\n            for (var v = -STEPS; v <= STEPS + 1; v += 1) {\r\n                let offsetCoord = baseCoord + vec3i(u, v, 0);\r\n                let sample = cubeSampleCoord(offsetCoord, previousSize);\r\n                if (sample.z == INVALID_FACE) { continue; }\r\n\r\n                let samplePos = toWorldDir(sample, previousSize);\r\n                let x = max(0.0, acos(dot(samplePos, pos)));\r\n                let w = exp(x * x * guassian_factor);\r\n                let color = textureLoad(previousMip, sample.xy, sample.z, 0);\r\n\r\n                res += color.rgb * w;\r\n                weight += w;\r\n            }\r\n        }\r\n\r\n        textureStore(outputTexture, coord.xy, coord.z, vec4(res / weight, 1));\r\n    }\r\n`;\n/**\n *  the minimum angular distance between any pixel on a cubemap\n *  of the given face width and any pixel lying on a perimeter\n *  the given number of steps away\n */\nfunction minStepDistance(steps, width) {\n    // the angular distance\n    // from the uvf: face = 0, u = 0, and v = width - Math.floor(steps / 2) - 1\n    // to the uvf: face = 3, u = 2 * width - baseV - steps - 2, and v = 0 or 1\n    // It's likely possible to programmatically determine whether the\n    // destination pixel should be v = 0 or v = 1, but checking both works fine\n    const nextMipWidth = width >> 1;\n    const baseV = nextMipWidth - Math.floor(steps / 4) - 1;\n    const baseVN = (2 / nextMipWidth) * (baseV + 0.5) - 1;\n    const baseUN = (1 / nextMipWidth) - 1;\n    const baseMag2 = 1 + baseVN * baseVN + baseUN * baseUN;\n    const sampU = 2 * width - (baseV * 2) - steps - 2;\n    const sampUN = (2 / width) * (sampU + 0.5) - 1;\n    const samp0VN = (1 / width) - 1;\n    const samp0Mag2 = 1 + sampUN * sampUN + samp0VN * samp0VN;\n    const samp1VN = (3 / width) - 1;\n    const samp1Mag2 = 1 + sampUN * sampUN + samp1VN * samp1VN;\n    const dot0 = (sampUN + baseVN + samp0VN * baseUN)\n        / Math.sqrt(samp0Mag2 * baseMag2);\n    const dot1 = (sampUN + baseVN + samp1VN * baseUN)\n        / Math.sqrt(samp1Mag2 * baseMag2);\n    return Math.min(1 - dot0, 1 - dot1);\n}\nasync function cubemapGuassianPyramid({ device, texture, outputTextureLabel, inPlace = false, minWidth = 8, steps = 4, maxOpsPerPass = 6 * ((17 * 256) ** 2), label = cubemapGuassianPyramid.name, delayWork, }) {\n    const { width, format } = texture;\n    const mipLevelCount = inPlace\n        ? texture.mipLevelCount\n        : (Math.log2(width) - Math.log2(minWidth) + 1);\n    if (mipLevelCount <= 1)\n        return texture;\n    const groups = Math.min(device.limits.maxComputeWorkgroupSizeX, device.limits.maxComputeInvocationsPerWorkgroup);\n    const shader = device.createShaderModule({\n        label,\n        code: createMipBlurCode(groups, format),\n    });\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d-array' },\n                visibility: GPUShaderStage.COMPUTE,\n            },\n            {\n                binding: 1,\n                storageTexture: {\n                    access: 'write-only',\n                    viewDimension: '2d-array',\n                    format,\n                },\n                visibility: GPUShaderStage.COMPUTE,\n            },\n            {\n                binding: 2,\n                buffer: { type: 'read-only-storage' },\n                visibility: GPUShaderStage.COMPUTE,\n            },\n        ],\n    });\n    const pipeline = device.createComputePipeline({\n        label,\n        layout: device.createPipelineLayout({\n            label,\n            bindGroupLayouts: [bindgroupLayout],\n        }),\n        compute: {\n            module: shader,\n            entryPoint: 'main',\n            constants: { STEPS: Math.ceil(steps) },\n        },\n    });\n    let gaussianPyramid = texture;\n    if (!inPlace) {\n        const size = { width, height: width, depthOrArrayLayers: 6 };\n        gaussianPyramid = device.createTexture({\n            label: outputTextureLabel,\n            usage: GPUTextureUsage.STORAGE_BINDING\n                | GPUTextureUsage.TEXTURE_BINDING\n                | GPUTextureUsage.COPY_SRC\n                | GPUTextureUsage.COPY_DST,\n            dimension: '2d',\n            format,\n            mipLevelCount,\n            size,\n        });\n        const copyEncoder = device.createCommandEncoder({\n            label: `${label} copy encoder`,\n        });\n        copyEncoder.copyTextureToTexture({ texture, mipLevel: 0 }, { texture: gaussianPyramid, mipLevel: 0 }, size);\n        device.queue.submit([copyEncoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n    const mipViews = (0,_utils_general__WEBPACK_IMPORTED_MODULE_2__/* .mapRange */ ._b)(mipLevelCount, (i) => gaussianPyramid.createView({\n        label: `${label} mip view ${i}`,\n        dimension: '2d-array',\n        baseMipLevel: i,\n        mipLevelCount: 1,\n    }));\n    const maxWorkgroups = device.limits.maxComputeWorkgroupsPerDimension;\n    const maxLayers = Math.ceil(Math.log2(width));\n    const maxDispatches = Math.max((maxOpsPerPass / (((1 + (steps * 2)) ** 2) * groups)) | 0, 1);\n    const propertyArray = new ArrayBuffer((maxLayers + 1) * 4);\n    const offset = new Uint32Array(propertyArray, 0, 1);\n    const simgas = new Float32Array(propertyArray, 4, maxLayers);\n    simgas.set((0,_utils_general__WEBPACK_IMPORTED_MODULE_2__/* .mapRange */ ._b)(maxLayers, (i) => {\n        const w = width >> i;\n        return Math.acos(1 - minStepDistance(Math.min(w, steps), w)) / 3;\n    }));\n    const propertyBuffer = (0,_utils_data_copy__WEBPACK_IMPORTED_MODULE_0__/* .createAndCopyBuffer */ .Lr)(propertyArray, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, device);\n    await new Promise((resolve) => {\n        let mipLevel = 0;\n        let mipPasses = 0;\n        let requiredMipDispatches = 0;\n        let currentMipDispatches = 0;\n        let batchDispatches = 0;\n        let bindgroup;\n        async function runPass() {\n            if (currentMipDispatches >= requiredMipDispatches) {\n                mipLevel += 1;\n                currentMipDispatches = 0;\n                mipPasses = 0;\n                if (mipLevel >= mipLevelCount) {\n                    resolve();\n                    return;\n                }\n                const mipPixels = 6 * ((width >> mipLevel) ** 2);\n                requiredMipDispatches = Math.ceil(mipPixels / groups);\n                bindgroup = device.createBindGroup({\n                    layout: bindgroupLayout,\n                    entries: [\n                        {\n                            binding: 0,\n                            resource: mipViews[mipLevel - 1],\n                        },\n                        {\n                            binding: 1,\n                            resource: mipViews[mipLevel],\n                        },\n                        {\n                            binding: 2,\n                            resource: { buffer: propertyBuffer },\n                        },\n                    ],\n                });\n            }\n            offset[0] = currentMipDispatches * groups;\n            device.queue.writeBuffer(propertyBuffer, 0, offset);\n            const passDispatches = Math.min(requiredMipDispatches - currentMipDispatches, maxDispatches - batchDispatches, maxWorkgroups);\n            const passLabel = `${label} mip ${mipLevel}, pass ${mipPasses}`;\n            const encoder = device.createCommandEncoder({ label: passLabel });\n            const pass = encoder.beginComputePass({ label: passLabel });\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindgroup);\n            pass.dispatchWorkgroups(passDispatches, 1, 1);\n            pass.end();\n            device.queue.submit([encoder.finish()]);\n            currentMipDispatches += passDispatches;\n            batchDispatches += passDispatches;\n            mipPasses += 1;\n            if (delayWork != null && batchDispatches >= maxDispatches) {\n                batchDispatches = 0;\n                await device.queue.onSubmittedWorkDone();\n                delayWork(runPass);\n            }\n            else {\n                void runPass();\n            }\n        }\n        void runPass();\n    });\n    return gaussianPyramid;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzlDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUVYLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUV4QyxvQkFBb0IsSUFBSSxjQUFjLENBQUM7WUFDdkMsZUFBZSxJQUFJLGNBQWMsQ0FBQztZQUNsQyxTQUFTLElBQUksQ0FBQyxDQUFDO1lBRWYsSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLGVBQWUsSUFBSSxhQUFhLEVBQUUsQ0FBQztnQkFDeEQsZUFBZSxHQUFHLENBQUMsQ0FBQztnQkFDcEIsTUFBTSxNQUFNLENBQUMsS0FBSyxDQUFDLG1CQUFtQixFQUFFLENBQUM7Z0JBQ3pDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN2QixDQUFDO2lCQUFNLENBQUM7Z0JBQ0osS0FBSyxPQUFPLEVBQUUsQ0FBQztZQUNuQixDQUFDO1FBQ0wsQ0FBQztRQUVELEtBQUssT0FBTyxFQUFFLENBQUM7SUFDbkIsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLGVBQWUsQ0FBQztBQUMzQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3NhbXBsZXMvY3ViZW1hcC1ibHVyL2N1YmVtYXAtZ3Vhc3NpYW4tcHlyYW1pZC50cz9kNzhlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBAc3R5bGlzdGljL21heC1sZW46IFwiZXJyb3JcIiAqL1xyXG5cclxuaW1wb3J0IHtcclxuICAgIHRvV29ybGREaXIsXHJcbiAgICBjdWJlbWFwU2FtcGxlQ29udmVyc2lvbnMsXHJcbn0gZnJvbSAnLi4vLi4vc2hhZGVycy9jdWJlbWFwLXNhbXBsaW5nLnNoYWRlcic7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVBbmRDb3B5QnVmZmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvZGF0YS1jb3B5JztcclxuaW1wb3J0IHsgbWFwUmFuZ2UgfSBmcm9tICcuLi8uLi91dGlscy9nZW5lcmFsJztcclxuXHJcbmNvbnN0IGNyZWF0ZU1pcEJsdXJDb2RlID0gKFxyXG4gICAgZ3JvdXBzOiBudW1iZXIsXHJcbiAgICBmb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXQsXHJcbikgPT4gLyogd2dzbCAqL2BcclxuICAgICR7Y3ViZW1hcFNhbXBsZUNvbnZlcnNpb25zfVxyXG4gICAgJHt0b1dvcmxkRGlyfVxyXG5cclxuICAgIG92ZXJyaWRlIFNURVBTOiBpMzIgPSA0O1xyXG5cclxuICAgIHN0cnVjdCBQYXJhbXMge1xyXG4gICAgICAgIG9mZnNldDogdTMyLFxyXG4gICAgICAgIHNpZ21hczogYXJyYXk8ZjMyPixcclxuICAgIH1cclxuXHJcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyIHByZXZpb3VzTWlwOiB0ZXh0dXJlXzJkX2FycmF5PGYzMj47XHJcblxyXG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIFxyXG4gICAgdmFyIG91dHB1dFRleHR1cmU6IHRleHR1cmVfc3RvcmFnZV8yZF9hcnJheTwke2Zvcm1hdH0sIHdyaXRlPjtcclxuXHJcbiAgICAvLyBzaWdtYVswXSByZXNlcnZlZCBmb3Igd29yayBvZmZzZXRcclxuICAgIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZT4gcGFyYW1zOiBQYXJhbXM7XHJcbiAgICBcclxuICAgIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke2dyb3Vwc30sIDEsIDEpXHJcbiAgICBmbiBtYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnaWQ6IHZlYzN1KSB7XHJcbiAgICAgICAgbGV0IG1pcFNpemUgPSB0ZXh0dXJlRGltZW5zaW9ucyhvdXRwdXRUZXh0dXJlKS54O1xyXG5cclxuICAgICAgICBsZXQgaWR4ID0gZ2lkLnggKyBwYXJhbXMub2Zmc2V0O1xyXG4gICAgICAgIGxldCBmYWNlU2l6ZSA9IG1pcFNpemUgKiBtaXBTaXplO1xyXG4gICAgICAgIGxldCBmYWNlSWR4ID0gaWR4ICUgZmFjZVNpemU7XHJcbiAgICAgICAgbGV0IGNvb3JkID0gdmVjM3UoXHJcbiAgICAgICAgICAgIGZhY2VJZHggJSBtaXBTaXplLCBcclxuICAgICAgICAgICAgZmFjZUlkeCAvIG1pcFNpemUsIFxyXG4gICAgICAgICAgICBpZHggLyBmYWNlU2l6ZSxcclxuICAgICAgICApOyBcclxuXHJcbiAgICAgICAgaWYgKGNvb3JkLnggPj0gbWlwU2l6ZSB8fCBjb29yZC55ID49IG1pcFNpemUgfHwgY29vcmQueiA+PSA2KSB7IFxyXG4gICAgICAgICAgICByZXR1cm47IFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHByZXZpb3VzU2l6ZSA9IHRleHR1cmVEaW1lbnNpb25zKHByZXZpb3VzTWlwKS54O1xyXG4gICAgICAgIGxldCBiYXNlQ29vcmQgPSB2ZWMzaSh2ZWMzdShjb29yZC54ICogMiwgY29vcmQueSAqIDIsIGNvb3JkLnopKTtcclxuICAgICAgICBsZXQgcG9zID0gdG9Xb3JsZERpcih2ZWMzdShjb29yZCksIG1pcFNpemUpO1xyXG5cclxuICAgICAgICBsZXQgc2l6ZSA9IGFycmF5TGVuZ3RoKCZwYXJhbXMuc2lnbWFzKTtcclxuICAgICAgICBsZXQgbGV2ZWwgPSBzaXplIC0gdTMyKGNlaWwobG9nMihmMzIocHJldmlvdXNTaXplKSkpKTtcclxuICAgICAgICBsZXQgc2lnbWEgPSBwYXJhbXMuc2lnbWFzW2xldmVsXTtcclxuICAgICAgICBsZXQgZ3Vhc3NpYW5fZmFjdG9yID0gLTAuNSAvIChzaWdtYSAqIHNpZ21hKTtcclxuXHJcbiAgICAgICAgdmFyIHdlaWdodCA9IDAuMDtcclxuICAgICAgICB2YXIgcmVzID0gdmVjMygwLjApO1xyXG5cclxuICAgICAgICBmb3IgKHZhciB1ID0gLVNURVBTOyB1IDw9IFNURVBTICsgMTsgdSArPSAxKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSAtU1RFUFM7IHYgPD0gU1RFUFMgKyAxOyB2ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXRDb29yZCA9IGJhc2VDb29yZCArIHZlYzNpKHUsIHYsIDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNhbXBsZSA9IGN1YmVTYW1wbGVDb29yZChvZmZzZXRDb29yZCwgcHJldmlvdXNTaXplKTtcclxuICAgICAgICAgICAgICAgIGlmIChzYW1wbGUueiA9PSBJTlZBTElEX0ZBQ0UpIHsgY29udGludWU7IH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgc2FtcGxlUG9zID0gdG9Xb3JsZERpcihzYW1wbGUsIHByZXZpb3VzU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IG1heCgwLjAsIGFjb3MoZG90KHNhbXBsZVBvcywgcG9zKSkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHcgPSBleHAoeCAqIHggKiBndWFzc2lhbl9mYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gdGV4dHVyZUxvYWQocHJldmlvdXNNaXAsIHNhbXBsZS54eSwgc2FtcGxlLnosIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlcyArPSBjb2xvci5yZ2IgKiB3O1xyXG4gICAgICAgICAgICAgICAgd2VpZ2h0ICs9IHc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRleHR1cmVTdG9yZShvdXRwdXRUZXh0dXJlLCBjb29yZC54eSwgY29vcmQueiwgdmVjNChyZXMgLyB3ZWlnaHQsIDEpKTtcclxuICAgIH1cclxuYDtcclxuXHJcbi8qKlxyXG4gKiAgdGhlIG1pbmltdW0gYW5ndWxhciBkaXN0YW5jZSBiZXR3ZWVuIGFueSBwaXhlbCBvbiBhIGN1YmVtYXBcclxuICogIG9mIHRoZSBnaXZlbiBmYWNlIHdpZHRoIGFuZCBhbnkgcGl4ZWwgbHlpbmcgb24gYSBwZXJpbWV0ZXJcclxuICogIHRoZSBnaXZlbiBudW1iZXIgb2Ygc3RlcHMgYXdheVxyXG4gKi9cclxuZnVuY3Rpb24gbWluU3RlcERpc3RhbmNlKHN0ZXBzOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcclxuICAgIC8vIHRoZSBhbmd1bGFyIGRpc3RhbmNlXHJcbiAgICAvLyBmcm9tIHRoZSB1dmY6IGZhY2UgPSAwLCB1ID0gMCwgYW5kIHYgPSB3aWR0aCAtIE1hdGguZmxvb3Ioc3RlcHMgLyAyKSAtIDFcclxuICAgIC8vIHRvIHRoZSB1dmY6IGZhY2UgPSAzLCB1ID0gMiAqIHdpZHRoIC0gYmFzZVYgLSBzdGVwcyAtIDIsIGFuZCB2ID0gMCBvciAxXHJcblxyXG4gICAgLy8gSXQncyBsaWtlbHkgcG9zc2libGUgdG8gcHJvZ3JhbW1hdGljYWxseSBkZXRlcm1pbmUgd2hldGhlciB0aGVcclxuICAgIC8vIGRlc3RpbmF0aW9uIHBpeGVsIHNob3VsZCBiZSB2ID0gMCBvciB2ID0gMSwgYnV0IGNoZWNraW5nIGJvdGggd29ya3MgZmluZVxyXG5cclxuICAgIGNvbnN0IG5leHRNaXBXaWR0aCA9IHdpZHRoID4+IDE7XHJcbiAgICBjb25zdCBiYXNlViA9IG5leHRNaXBXaWR0aCAtIE1hdGguZmxvb3Ioc3RlcHMgLyA0KSAtIDE7XHJcbiAgICBjb25zdCBiYXNlVk4gPSAoMiAvIG5leHRNaXBXaWR0aCkgKiAoYmFzZVYgKyAwLjUpIC0gMTtcclxuICAgIGNvbnN0IGJhc2VVTiA9ICgxIC8gbmV4dE1pcFdpZHRoKSAtIDE7XHJcbiAgICBjb25zdCBiYXNlTWFnMiA9IDEgKyBiYXNlVk4gKiBiYXNlVk4gKyBiYXNlVU4gKiBiYXNlVU47XHJcblxyXG4gICAgY29uc3Qgc2FtcFUgPSAyICogd2lkdGggLSAoYmFzZVYgKiAyKSAtIHN0ZXBzIC0gMjtcclxuICAgIGNvbnN0IHNhbXBVTiA9ICgyIC8gd2lkdGgpICogKHNhbXBVICsgMC41KSAtIDE7XHJcbiAgICBjb25zdCBzYW1wMFZOID0gKDEgLyB3aWR0aCkgLSAxO1xyXG4gICAgY29uc3Qgc2FtcDBNYWcyID0gMSArIHNhbXBVTiAqIHNhbXBVTiArIHNhbXAwVk4gKiBzYW1wMFZOO1xyXG4gICAgY29uc3Qgc2FtcDFWTiA9ICgzIC8gd2lkdGgpIC0gMTtcclxuICAgIGNvbnN0IHNhbXAxTWFnMiA9IDEgKyBzYW1wVU4gKiBzYW1wVU4gKyBzYW1wMVZOICogc2FtcDFWTjtcclxuXHJcbiAgICBjb25zdCBkb3QwID0gKHNhbXBVTiArIGJhc2VWTiArIHNhbXAwVk4gKiBiYXNlVU4pXHJcbiAgICAgICAgLyBNYXRoLnNxcnQoc2FtcDBNYWcyICogYmFzZU1hZzIpO1xyXG5cclxuICAgIGNvbnN0IGRvdDEgPSAoc2FtcFVOICsgYmFzZVZOICsgc2FtcDFWTiAqIGJhc2VVTilcclxuICAgICAgICAvIE1hdGguc3FydChzYW1wMU1hZzIgKiBiYXNlTWFnMik7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubWluKDEgLSBkb3QwLCAxIC0gZG90MSk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEdhdXNzaWFuUHlyYW1pZERlc2NyaXB0b3IgPSB7XHJcbiAgICBkZXZpY2U6IEdQVURldmljZSxcclxuICAgIHRleHR1cmU6IEdQVVRleHR1cmUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgSWYgdGhlIHB5cmFtaWQgc2hvdWxkIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgbWlwc1xyXG4gICAgICogIG9mIHRoZSBnaXZlbiB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxyXG4gICAgICovXHJcbiAgICBpblBsYWNlPzogYm9vbGVhbixcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWF4aW11bSB3aWR0aCBvZiB0aGUgc21hbGxlc3QgbWlwIGxldmVsLlxyXG4gICAgICpcclxuICAgICAqICBAZGVmYXVsdFZhbHVlIGA4YFxyXG4gICAgICovXHJcbiAgICBtaW5XaWR0aD86IG51bWJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUga2VybmVsIGV4dGVudCBkaXN0YW5jZSwgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqICBAZGVmYXVsdFZhbHVlIGA0YFxyXG4gICAgICovXHJcbiAgICBzdGVwcz86IG51bWJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqICBBIGZ1bmN0aW9uIHRvIGRlbGF5IHRoZSBwcm9jZXNzaW5nIG9mIGFkZGl0aW9uYWwgcGl4ZWxzLFxyXG4gICAgICogIGUuZy4gYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuIFNwYWNlcyB3b3JrIHRvIGFsbG93IGFkZGl0aW9uYWxcclxuICAgICAqICByZW5kZXJpbmcgYW5kIGludGVyYWN0aXZpdHkgZHVyaW5nIGhlYXZ5IGJsdXJyaW5nIHdvcmtsb2Fkcy5cclxuICAgICAqXHJcbiAgICAgKiAgSWYgdW5kZWZpbmVkLCBhbGwgcGl4ZWxzIGFyZSBwcm9jZXNzZWQgYXQgb25jZS5cclxuICAgICAqL1xyXG4gICAgZGVsYXlXb3JrPzogKGZuOiAoKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZCkgPT4gdm9pZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbWF4aW11bSBudW1iZXIgb2YgcGl4ZWxzIHRvIHByb2Nlc3Mgd2l0aGluIGEgYmF0Y2guXHJcbiAgICAgKiAgVW51c2VkIGlmIGBkZWxheVdvcmtgIGlzIHVuZGVmaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiAgQGRlZmF1bHRWYWx1ZSA2ICogKCgxNyAqIDI1NikgKiogMilcclxuICAgICAqXHJcbiAgICAgKiAgQWxsb3dpbmcgY3ViZW1hcCAyNTYgcGl4ZWxzIGluIHdpZHRoIHdpdGggYHN0ZXBzID0gOGAgdG8gcnVuXHJcbiAgICAgKiAgaW4gYSBzaW5nbGUgcGFzcy4gVGhpcyBpcyBhIGNvbnNlcnZhdGl2ZWx5IGxvdyBkZWZhdWx0IGZvclxyXG4gICAgICogIGNvbXBhdGliaWxpdHkgd2l0aCBsb3dlci1lbmQgaGFyZHdhcmUuXHJcbiAgICAgKi9cclxuICAgIG1heE9wc1BlclBhc3M/OiBudW1iZXIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgQSBwcmVmaXggc3RyaW5nIGZvciBlcnJvciBtZXNzYWdlIHRocm93biBmcm9tIHRoZSBmdW5jdGlvblxyXG4gICAgICpcclxuICAgICAqICBAZGVmYXVsdFZhbHVlIGBjdWJlbWFwR3Vhc3NpYW5QeXJhbWlkIC0tYFxyXG4gICAgICovXHJcbiAgICBsYWJlbD86IHN0cmluZyxcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgbGFiZWwgdG8gcGFzcyB0aGUgb3V0cHV0IEdQVVRleHR1cmUuXHJcbiAgICAgKlxyXG4gICAgICogIFVudXNlZCBpZiBgaW5QbGFjZSA9PSB0cnVlYFxyXG4gICAgICovXHJcbiAgICBvdXRwdXRUZXh0dXJlTGFiZWw/OiBzdHJpbmcsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBjdWJlbWFwR3Vhc3NpYW5QeXJhbWlkKHtcclxuICAgIGRldmljZSxcclxuICAgIHRleHR1cmUsXHJcbiAgICBvdXRwdXRUZXh0dXJlTGFiZWwsXHJcbiAgICBpblBsYWNlID0gZmFsc2UsXHJcbiAgICBtaW5XaWR0aCA9IDgsXHJcbiAgICBzdGVwcyA9IDQsXHJcbiAgICBtYXhPcHNQZXJQYXNzID0gNiAqICgoMTcgKiAyNTYpICoqIDIpLFxyXG4gICAgbGFiZWwgPSBjdWJlbWFwR3Vhc3NpYW5QeXJhbWlkLm5hbWUsXHJcbiAgICBkZWxheVdvcmssXHJcbn06IEdhdXNzaWFuUHlyYW1pZERlc2NyaXB0b3IpIHtcclxuICAgIGNvbnN0IHsgd2lkdGgsIGZvcm1hdCB9ID0gdGV4dHVyZTtcclxuICAgIGNvbnN0IG1pcExldmVsQ291bnQgPSBpblBsYWNlXHJcbiAgICAgICAgPyB0ZXh0dXJlLm1pcExldmVsQ291bnRcclxuICAgICAgICA6IChNYXRoLmxvZzIod2lkdGgpIC0gTWF0aC5sb2cyKG1pbldpZHRoKSArIDEpO1xyXG5cclxuICAgIGlmIChtaXBMZXZlbENvdW50IDw9IDEpIHJldHVybiB0ZXh0dXJlO1xyXG5cclxuICAgIGNvbnN0IGdyb3VwcyA9IE1hdGgubWluKFxyXG4gICAgICAgIGRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLFxyXG4gICAgICAgIGRldmljZS5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHNoYWRlciA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGNvZGU6IGNyZWF0ZU1pcEJsdXJDb2RlKGdyb3VwcywgZm9ybWF0KSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGJpbmRncm91cExheW91dCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoe1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGVudHJpZXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmluZGluZzogMCxcclxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHsgdmlld0RpbWVuc2lvbjogJzJkLWFycmF5JyB9LFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmluZGluZzogMSxcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2VUZXh0dXJlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzOiAnd3JpdGUtb25seScsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0RpbWVuc2lvbjogJzJkLWFycmF5JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmluZGluZzogMixcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcjogeyB0eXBlOiAncmVhZC1vbmx5LXN0b3JhZ2UnIH0sXHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBwaXBlbGluZSA9IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGxheW91dDogZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtcclxuICAgICAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgICAgIGJpbmRHcm91cExheW91dHM6IFtiaW5kZ3JvdXBMYXlvdXRdLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGNvbXB1dGU6IHtcclxuICAgICAgICAgICAgbW9kdWxlOiBzaGFkZXIsXHJcbiAgICAgICAgICAgIGVudHJ5UG9pbnQ6ICdtYWluJyxcclxuICAgICAgICAgICAgY29uc3RhbnRzOiB7IFNURVBTOiBNYXRoLmNlaWwoc3RlcHMpIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBnYXVzc2lhblB5cmFtaWQgPSB0ZXh0dXJlO1xyXG4gICAgaWYgKCFpblBsYWNlKSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHsgd2lkdGgsIGhlaWdodDogd2lkdGgsIGRlcHRoT3JBcnJheUxheWVyczogNiB9O1xyXG5cclxuICAgICAgICBnYXVzc2lhblB5cmFtaWQgPSBkZXZpY2UuY3JlYXRlVGV4dHVyZSh7XHJcbiAgICAgICAgICAgIGxhYmVsOiBvdXRwdXRUZXh0dXJlTGFiZWwsXHJcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HXHJcbiAgICAgICAgICAgIHwgR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElOR1xyXG4gICAgICAgICAgICB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQ1xyXG4gICAgICAgICAgICB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCxcclxuICAgICAgICAgICAgZGltZW5zaW9uOiAnMmQnLFxyXG4gICAgICAgICAgICBmb3JtYXQsXHJcbiAgICAgICAgICAgIG1pcExldmVsQ291bnQsXHJcbiAgICAgICAgICAgIHNpemUsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvcHlFbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKHtcclxuICAgICAgICAgICAgbGFiZWw6IGAke2xhYmVsfSBjb3B5IGVuY29kZXJgLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb3B5RW5jb2Rlci5jb3B5VGV4dHVyZVRvVGV4dHVyZShcclxuICAgICAgICAgICAgeyB0ZXh0dXJlLCBtaXBMZXZlbDogMCB9LFxyXG4gICAgICAgICAgICB7IHRleHR1cmU6IGdhdXNzaWFuUHlyYW1pZCwgbWlwTGV2ZWw6IDAgfSxcclxuICAgICAgICAgICAgc2l6ZSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBkZXZpY2UucXVldWUuc3VibWl0KFtjb3B5RW5jb2Rlci5maW5pc2goKV0pO1xyXG4gICAgICAgIGF3YWl0IGRldmljZS5xdWV1ZS5vblN1Ym1pdHRlZFdvcmtEb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWlwVmlld3MgPSBtYXBSYW5nZShtaXBMZXZlbENvdW50LCAoaSkgPT4gZ2F1c3NpYW5QeXJhbWlkLmNyZWF0ZVZpZXcoe1xyXG4gICAgICAgIGxhYmVsOiBgJHtsYWJlbH0gbWlwIHZpZXcgJHtpfWAsXHJcbiAgICAgICAgZGltZW5zaW9uOiAnMmQtYXJyYXknLFxyXG4gICAgICAgIGJhc2VNaXBMZXZlbDogaSxcclxuICAgICAgICBtaXBMZXZlbENvdW50OiAxLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIGNvbnN0IG1heFdvcmtncm91cHMgPSBkZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO1xyXG4gICAgY29uc3QgbWF4TGF5ZXJzID0gTWF0aC5jZWlsKE1hdGgubG9nMih3aWR0aCkpO1xyXG4gICAgY29uc3QgbWF4RGlzcGF0Y2hlcyA9IE1hdGgubWF4KFxyXG4gICAgICAgIChtYXhPcHNQZXJQYXNzIC8gKCgoMSArIChzdGVwcyAqIDIpKSAqKiAyKSAqIGdyb3VwcykpIHwgMCxcclxuICAgICAgICAxLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBwcm9wZXJ0eUFycmF5ID0gbmV3IEFycmF5QnVmZmVyKChtYXhMYXllcnMgKyAxKSAqIDQpO1xyXG4gICAgY29uc3Qgb2Zmc2V0ID0gbmV3IFVpbnQzMkFycmF5KHByb3BlcnR5QXJyYXksIDAsIDEpO1xyXG4gICAgY29uc3Qgc2ltZ2FzID0gbmV3IEZsb2F0MzJBcnJheShwcm9wZXJ0eUFycmF5LCA0LCBtYXhMYXllcnMpO1xyXG5cclxuICAgIHNpbWdhcy5zZXQobWFwUmFuZ2UobWF4TGF5ZXJzLCAoaSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHcgPSB3aWR0aCA+PiBpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoMSAtIG1pblN0ZXBEaXN0YW5jZShNYXRoLm1pbih3LCBzdGVwcyksIHcpKSAvIDM7XHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgcHJvcGVydHlCdWZmZXIgPSBjcmVhdGVBbmRDb3B5QnVmZmVyKFxyXG4gICAgICAgIHByb3BlcnR5QXJyYXksXHJcbiAgICAgICAgR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULFxyXG4gICAgICAgIGRldmljZSxcclxuICAgICk7XHJcblxyXG4gICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcclxuICAgICAgICBsZXQgbWlwTGV2ZWwgPSAwO1xyXG4gICAgICAgIGxldCBtaXBQYXNzZXMgPSAwO1xyXG4gICAgICAgIGxldCByZXF1aXJlZE1pcERpc3BhdGNoZXMgPSAwO1xyXG4gICAgICAgIGxldCBjdXJyZW50TWlwRGlzcGF0Y2hlcyA9IDA7XHJcbiAgICAgICAgbGV0IGJhdGNoRGlzcGF0Y2hlcyA9IDA7XHJcbiAgICAgICAgbGV0IGJpbmRncm91cDogR1BVQmluZEdyb3VwO1xyXG5cclxuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5QYXNzKCkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE1pcERpc3BhdGNoZXMgPj0gcmVxdWlyZWRNaXBEaXNwYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBtaXBMZXZlbCArPSAxO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE1pcERpc3BhdGNoZXMgPSAwO1xyXG4gICAgICAgICAgICAgICAgbWlwUGFzc2VzID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWlwTGV2ZWwgPj0gbWlwTGV2ZWxDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWlwUGl4ZWxzID0gNiAqICgod2lkdGggPj4gbWlwTGV2ZWwpICoqIDIpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWRNaXBEaXNwYXRjaGVzID0gTWF0aC5jZWlsKG1pcFBpeGVscyAvIGdyb3Vwcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgYmluZGdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiBiaW5kZ3JvdXBMYXlvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IG1pcFZpZXdzW21pcExldmVsIC0gMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogbWlwVmlld3NbbWlwTGV2ZWxdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHsgYnVmZmVyOiBwcm9wZXJ0eUJ1ZmZlciB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2Zmc2V0WzBdID0gY3VycmVudE1pcERpc3BhdGNoZXMgKiBncm91cHM7XHJcbiAgICAgICAgICAgIGRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihwcm9wZXJ0eUJ1ZmZlciwgMCwgb2Zmc2V0KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhc3NEaXNwYXRjaGVzID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICByZXF1aXJlZE1pcERpc3BhdGNoZXMgLSBjdXJyZW50TWlwRGlzcGF0Y2hlcyxcclxuICAgICAgICAgICAgICAgIG1heERpc3BhdGNoZXMgLSBiYXRjaERpc3BhdGNoZXMsXHJcbiAgICAgICAgICAgICAgICBtYXhXb3JrZ3JvdXBzLFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcGFzc0xhYmVsID0gYCR7bGFiZWx9IG1pcCAke21pcExldmVsfSwgcGFzcyAke21pcFBhc3Nlc31gO1xyXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKHsgbGFiZWw6IHBhc3NMYWJlbCB9KTtcclxuICAgICAgICAgICAgY29uc3QgcGFzcyA9IGVuY29kZXIuYmVnaW5Db21wdXRlUGFzcyh7IGxhYmVsOiBwYXNzTGFiZWwgfSk7XHJcblxyXG4gICAgICAgICAgICBwYXNzLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcclxuICAgICAgICAgICAgcGFzcy5zZXRCaW5kR3JvdXAoMCwgYmluZGdyb3VwKTtcclxuICAgICAgICAgICAgcGFzcy5kaXNwYXRjaFdvcmtncm91cHMocGFzc0Rpc3BhdGNoZXMsIDEsIDEpO1xyXG4gICAgICAgICAgICBwYXNzLmVuZCgpO1xyXG5cclxuICAgICAgICAgICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZW5jb2Rlci5maW5pc2goKV0pO1xyXG5cclxuICAgICAgICAgICAgY3VycmVudE1pcERpc3BhdGNoZXMgKz0gcGFzc0Rpc3BhdGNoZXM7XHJcbiAgICAgICAgICAgIGJhdGNoRGlzcGF0Y2hlcyArPSBwYXNzRGlzcGF0Y2hlcztcclxuICAgICAgICAgICAgbWlwUGFzc2VzICs9IDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVsYXlXb3JrICE9IG51bGwgJiYgYmF0Y2hEaXNwYXRjaGVzID49IG1heERpc3BhdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGJhdGNoRGlzcGF0Y2hlcyA9IDA7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkZXZpY2UucXVldWUub25TdWJtaXR0ZWRXb3JrRG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgZGVsYXlXb3JrKHJ1blBhc3MpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm9pZCBydW5QYXNzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgcnVuUGFzcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGdhdXNzaWFuUHlyYW1pZDtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3156\n")},2806:(module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _settings_property_listener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9528);\n/* harmony import */ var _settings_skybox_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5427);\n/* harmony import */ var _rendering_default_forward_pass_descriptor_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(360);\n/* harmony import */ var _rendering_default_forward_pass_pipeline_feature_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9274);\n/* harmony import */ var _cubemap_blur_cubemap_guassian_pyramid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3156);\n/* harmony import */ var _loader_gltf_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5308);\n/* harmony import */ var _utils_general__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4742);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_settings_skybox_options__WEBPACK_IMPORTED_MODULE_1__]);\n_settings_skybox_options__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _GltfModel_settings;\n\n\n\n\n\n\n\nconst gltfIndex = await getGltfIndex();\nasync function getGltfIndex() {\n    const indexUrl = \"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/\" + \"model-index.json\";\n    const indexRes = await fetch(indexUrl);\n    const indexStr = await indexRes.text();\n    const indexJson = JSON.parse(indexStr);\n    if (!Array.isArray(indexJson)) {\n        throw new Error('could not load gtlf model index');\n    }\n    const entries = indexJson.flatMap((gltf) => {\n        if (!(0,_utils_general__WEBPACK_IMPORTED_MODULE_6__/* .isObject */ .Gv)(gltf)\n            || !('label' in gltf)\n            || typeof gltf.label !== 'string'\n            || !('name' in gltf)\n            || typeof gltf.name !== 'string'\n            || !('variants' in gltf)\n            || !(0,_utils_general__WEBPACK_IMPORTED_MODULE_6__/* .isObject */ .Gv)(gltf.variants)\n            || typeof gltf.variants.glTF !== 'string')\n            return [];\n        const { variants: { glTF: file }, label, name } = gltf;\n        const path = `${\"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/\"}${name}/glTF/${file}`;\n        return [[label, path]];\n    });\n    return Object.fromEntries(entries);\n}\nclass GltfModel {\n    get depthTextureView() {\n        return this.descriptorMap.gbuffer.depth.view;\n    }\n    constructor(renderer) {\n        this.renderer = renderer;\n        this.geometryPipelines = {};\n        _GltfModel_settings.set(this, (0,_settings_property_listener__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)({\n            skybox: (0,_settings_skybox_options__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(this),\n            model: {\n                [_settings_property_listener__WEBPACK_IMPORTED_MODULE_0__/* .ListenerSyms */ .t.$type]: 'file',\n                [_settings_property_listener__WEBPACK_IMPORTED_MODULE_0__/* .ListenerSyms */ .t.$callback]: (val, key) => {\n                    if (key !== 'value' || val == null)\n                        return;\n                    if (typeof val === 'string' || val instanceof File) {\n                        void this.setModel(val);\n                    }\n                },\n                accept: '.hdr',\n                selection: {\n                    value: 'Environment Test',\n                    initialValues: gltfIndex,\n                },\n                process: (file) => file,\n            },\n        }));\n        this.settings = __classPrivateFieldGet(this, _GltfModel_settings, \"f\").publicSettings;\n        this.priority = 1000;\n        this.descriptorMap = new _rendering_default_forward_pass_descriptor_map__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A(renderer.device, renderer.gbuffer, renderer.globals);\n        this.device = renderer.device;\n        this.renderer.addForwardPass(this);\n    }\n    async setSkybox(skybox) {\n        await (0,_cubemap_blur_cubemap_guassian_pyramid__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A)({\n            texture: skybox,\n            device: this.renderer.device,\n            inPlace: true,\n            delayWork: requestAnimationFrame,\n        });\n        this.renderer.skybox = skybox;\n    }\n    async setModel(modelPath) {\n        const size = { width: 1, height: 1 };\n        const colorArray = new Float32Array([1, 1, 1, 1]);\n        const opaqueWhite = this.renderer.device.createTexture({\n            size,\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        this.renderer.device.queue.writeTexture({ texture: opaqueWhite }, colorArray, {}, size);\n        const normalMap = this.renderer.device.createTexture({\n            size,\n            format: 'rgba32float',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        colorArray.set([0.5, 0.5, 1, 1]);\n        this.renderer.device.queue.writeTexture({ texture: normalMap }, colorArray, {}, size);\n        const sampler = {\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'linear',\n            mipmapFilter: 'linear',\n        };\n        const matData = {\n            baseColorTexture: opaqueWhite,\n            baseColorFactor: [1, 1, 1, 1],\n            normalTexture: normalMap,\n            metallicRoughnessTexture: opaqueWhite,\n            metallicFactor: 1,\n            roughnessFactor: 1,\n            baseColorSampler: sampler,\n            normalSampler: sampler,\n            metallicRoughnessSampler: sampler,\n        };\n        this.geometryPipelines = await (0,_loader_gltf_loader__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A)(modelPath, this.renderer.device, this.descriptorMap, matData, GltfModel.goalLayout, {});\n    }\n    render({ encoder, gbuffer, globals }) {\n        const pass = encoder.beginRenderPass(gbuffer.passDescriptor);\n        pass.setBindGroup(0, globals.bindgroup);\n        for (const pipeline of Object.values(this.geometryPipelines)) {\n            pipeline?.draw(pass, this.renderer.device.queue);\n        }\n        pass.end();\n    }\n}\n_GltfModel_settings = new WeakMap();\nGltfModel.title = 'glTF Model Viewer';\nGltfModel.description = '';\nGltfModel.goalLayout = [\n    {\n        name: 'POSITION',\n        type: 'VEC3',\n        componentType: 5126 /* ComponentType.float32 */,\n    },\n    {\n        name: 'TEXCOORD_0',\n        type: 'VEC2',\n        componentType: 5126 /* ComponentType.float32 */,\n    },\n    {\n        name: 'TANGENT',\n        type: 'VEC4',\n        componentType: 5126 /* ComponentType.float32 */,\n        depends: ['NORMAL'],\n        fill: [1, 0, 0, 1],\n    },\n    {\n        name: 'NORMAL',\n        type: 'VEC3',\n        componentType: 5126 /* ComponentType.float32 */,\n        strip: true,\n        feature: _rendering_default_forward_pass_pipeline_feature_flags__WEBPACK_IMPORTED_MODULE_3__/* .PipelineFeatureFlags */ .Ot.VertexNormals,\n    },\n    {\n        name: 'COLOR_0',\n        type: 'VEC4',\n        componentType: 5126 /* ComponentType.float32 */,\n        strip: true,\n        feature: _rendering_default_forward_pass_pipeline_feature_flags__WEBPACK_IMPORTED_MODULE_3__/* .PipelineFeatureFlags */ .Ot.VertexColors,\n        fill: [1, 1, 1, 1],\n    },\n];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GltfModel);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDckI7SUFDRDtRQUNJLElBQUksRUFBRSxRQUFRO1FBQ2QsSUFBSSxFQUFFLE1BQU07UUFDWixhQUFhLGtDQUF1QjtRQUNwQyxLQUFLLEVBQUUsSUFBSTtRQUNYLE9BQU8sRUFBRSxrSEFBb0IsQ0FBQyxhQUFhO0tBQzlDO0lBQ0Q7UUFDSSxJQUFJLEVBQUUsU0FBUztRQUNmLElBQUksRUFBRSxNQUFNO1FBQ1osYUFBYSxrQ0FBdUI7UUFDcEMsS0FBSyxFQUFFLElBQUk7UUFDWCxPQUFPLEVBQUUsa0hBQW9CLENBQUMsWUFBWTtRQUMxQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDckI7Q0FDSixDQUFDO2lFQXJDZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3NhbXBsZXMvZ2x0Zi12aWV3ZXIvZ2x0Zi12aWV3ZXItc2FtcGxlLnRzP2MxOTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRnVsbFJlbmRlck1vZGVsIH0gZnJvbSAnLi4vc2V0dGluZ3Mvc2FtcGxlLXNwZWMnO1xuaW1wb3J0IHByb3BlcnR5TGlzdGVuZXIsIHsgTGlzdGVuZXJTeW1zIH0gZnJvbSAnLi4vc2V0dGluZ3MvcHJvcGVydHktbGlzdGVuZXInO1xuaW1wb3J0IGdldFNreWJveE9wdGlvbnMgZnJvbSAnLi4vc2V0dGluZ3Mvc2t5Ym94LW9wdGlvbnMnO1xuXG5pbXBvcnQgR2VvbWV0cnlQaXBlbGluZSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvZGVmYXVsdC1mb3J3YXJkLXBhc3MvZ2VvbWV0cnktcGlwZWxpbmUnO1xuaW1wb3J0IERlc2NyaXB0b3JNYXAgZnJvbSAnLi4vLi4vcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL2Rlc2NyaXB0b3ItbWFwJztcbmltcG9ydCBSZW5kZXJlciwgeyBGb3J3YXJkUGFzc1BhcmFtcyB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcic7XG5pbXBvcnQgeyBNYXRlcmlhbERlc2NyaXB0b3IgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvZGVmYXVsdC1mb3J3YXJkLXBhc3MvbWF0ZXJpYWwtZHJhdy1kYXRhJztcbmltcG9ydCB7IFBpcGVsaW5lRmVhdHVyZUZsYWdzIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL3BpcGVsaW5lLWZlYXR1cmUtZmxhZ3MnO1xuXG5pbXBvcnQgY3ViZW1hcEd1YXNzaWFuUHlyYW1pZCBmcm9tICcuLi9jdWJlbWFwLWJsdXIvY3ViZW1hcC1ndWFzc2lhbi1weXJhbWlkJztcblxuaW1wb3J0IHsgQXR0cmlidXRlRGV0YWlscywgQ29tcG9uZW50VHlwZSB9IGZyb20gJy4vbG9hZGVyL3R5cGUtY29udmVyc2lvbnMnO1xuaW1wb3J0IGltcG9ydEdsdGYgZnJvbSAnLi9sb2FkZXIvZ2x0Zi1sb2FkZXInO1xuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICdAbG9hZGVycy5nbC9jb3JlJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvZ2VuZXJhbCc7XG5cbmNvbnN0IGdsdGZJbmRleCA9IGF3YWl0IGdldEdsdGZJbmRleCgpO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRHbHRmSW5kZXgoKSB7XG4gICAgY29uc3QgaW5kZXhVcmwgPSBHTFRGX0JBU0VfVVJMX18gKyBHTFRGX0lOREVYX0ZJTEVfXztcbiAgICBjb25zdCBpbmRleFJlcyA9IGF3YWl0IGZldGNoKGluZGV4VXJsKTtcbiAgICBjb25zdCBpbmRleFN0ciA9IGF3YWl0IGluZGV4UmVzLnRleHQoKTtcbiAgICBjb25zdCBpbmRleEpzb24gPSBKU09OLnBhcnNlKGluZGV4U3RyKSBhcyB1bmtub3duO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGluZGV4SnNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgbG9hZCBndGxmIG1vZGVsIGluZGV4Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgZW50cmllczogW3N0cmluZywgc3RyaW5nXVtdID0gaW5kZXhKc29uLmZsYXRNYXAoKGdsdGY6IHVua25vd24pID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWlzT2JqZWN0KGdsdGYpXG4gICAgICAgICAgICB8fCAhKCdsYWJlbCcgaW4gZ2x0ZilcbiAgICAgICAgICAgIHx8IHR5cGVvZiBnbHRmLmxhYmVsICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgfHwgISgnbmFtZScgaW4gZ2x0ZilcbiAgICAgICAgICAgIHx8IHR5cGVvZiBnbHRmLm5hbWUgIT09ICdzdHJpbmcnXG4gICAgICAgICAgICB8fCAhKCd2YXJpYW50cycgaW4gZ2x0ZilcbiAgICAgICAgICAgIHx8ICFpc09iamVjdChnbHRmLnZhcmlhbnRzKVxuICAgICAgICAgICAgfHwgdHlwZW9mIGdsdGYudmFyaWFudHMuZ2xURiAhPT0gJ3N0cmluZydcbiAgICAgICAgKSByZXR1cm4gW107XG5cbiAgICAgICAgY29uc3QgeyB2YXJpYW50czogeyBnbFRGOiBmaWxlIH0sIGxhYmVsLCBuYW1lIH0gPSBnbHRmO1xuICAgICAgICBjb25zdCBwYXRoID0gYCR7R0xURl9CQVNFX1VSTF9ffSR7bmFtZX0vZ2xURi8ke2ZpbGV9YDtcbiAgICAgICAgcmV0dXJuIFtbbGFiZWwsIHBhdGhdXTtcbiAgICB9KTtcblxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdsdGZNb2RlbCBpbXBsZW1lbnRzIEZ1bGxSZW5kZXJNb2RlbCB7XG4gICAgc3RhdGljIHJlYWRvbmx5IHRpdGxlID0gJ2dsVEYgTW9kZWwgVmlld2VyJztcbiAgICBzdGF0aWMgcmVhZG9ubHkgZGVzY3JpcHRpb24gPSAnJztcblxuICAgIHN0YXRpYyByZWFkb25seSBnb2FsTGF5b3V0OiBBdHRyaWJ1dGVEZXRhaWxzW10gPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQT1NJVElPTicsXG4gICAgICAgICAgICB0eXBlOiAnVkVDMycsXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiBDb21wb25lbnRUeXBlLmZsb2F0MzIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdURVhDT09SRF8wJyxcbiAgICAgICAgICAgIHR5cGU6ICdWRUMyJyxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IENvbXBvbmVudFR5cGUuZmxvYXQzMixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1RBTkdFTlQnLFxuICAgICAgICAgICAgdHlwZTogJ1ZFQzQnLFxuICAgICAgICAgICAgY29tcG9uZW50VHlwZTogQ29tcG9uZW50VHlwZS5mbG9hdDMyLFxuICAgICAgICAgICAgZGVwZW5kczogWydOT1JNQUwnXSxcbiAgICAgICAgICAgIGZpbGw6IFsxLCAwLCAwLCAxXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ05PUk1BTCcsXG4gICAgICAgICAgICB0eXBlOiAnVkVDMycsXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiBDb21wb25lbnRUeXBlLmZsb2F0MzIsXG4gICAgICAgICAgICBzdHJpcDogdHJ1ZSxcbiAgICAgICAgICAgIGZlYXR1cmU6IFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleE5vcm1hbHMsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDT0xPUl8wJyxcbiAgICAgICAgICAgIHR5cGU6ICdWRUM0JyxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IENvbXBvbmVudFR5cGUuZmxvYXQzMixcbiAgICAgICAgICAgIHN0cmlwOiB0cnVlLFxuICAgICAgICAgICAgZmVhdHVyZTogUGlwZWxpbmVGZWF0dXJlRmxhZ3MuVmVydGV4Q29sb3JzLFxuICAgICAgICAgICAgZmlsbDogWzEsIDEsIDEsIDFdLFxuICAgICAgICB9LFxuICAgIF07XG5cbiAgICBnZW9tZXRyeVBpcGVsaW5lczogUGFydGlhbDxSZWNvcmQ8bnVtYmVyLCBHZW9tZXRyeVBpcGVsaW5lPj4gPSB7fTtcbiAgICBkZXNjcmlwdG9yTWFwOiBEZXNjcmlwdG9yTWFwO1xuICAgIGRldmljZTogR1BVRGV2aWNlO1xuXG4gICAgZ2V0IGRlcHRoVGV4dHVyZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0b3JNYXAuZ2J1ZmZlci5kZXB0aC52aWV3O1xuICAgIH1cblxuICAgIHJlYWRvbmx5ICNzZXR0aW5ncyA9IHByb3BlcnR5TGlzdGVuZXIoe1xuICAgICAgICBza3lib3g6IGdldFNreWJveE9wdGlvbnModGhpcyksXG4gICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICBbTGlzdGVuZXJTeW1zLiR0eXBlXTogJ2ZpbGUnIGFzIGNvbnN0LFxuICAgICAgICAgICAgW0xpc3RlbmVyU3ltcy4kY2FsbGJhY2tdOiAodmFsOiB1bmtub3duLCBrZXk6IFByb3BlcnR5S2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3ZhbHVlJyB8fCB2YWwgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5zZXRNb2RlbCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY2NlcHQ6ICcuaGRyJyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnRW52aXJvbm1lbnQgVGVzdCcsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlczogZ2x0ZkluZGV4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IChmaWxlOiBGaWxlKSA9PiBmaWxlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmVhZG9ubHkgc2V0dGluZ3MgPSB0aGlzLiNzZXR0aW5ncy5wdWJsaWNTZXR0aW5ncztcbiAgICByZWFkb25seSBwcmlvcml0eSA9IDEwMDA7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVuZGVyZXI6IFJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRvck1hcCA9IG5ldyBEZXNjcmlwdG9yTWFwKHJlbmRlcmVyLmRldmljZSwgcmVuZGVyZXIuZ2J1ZmZlciwgcmVuZGVyZXIuZ2xvYmFscyk7XG4gICAgICAgIHRoaXMuZGV2aWNlID0gcmVuZGVyZXIuZGV2aWNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZEZvcndhcmRQYXNzKHRoaXMpO1xuICAgIH1cblxuICAgIGFzeW5jIHNldFNreWJveChza3lib3g6IEdQVVRleHR1cmUpIHtcbiAgICAgICAgYXdhaXQgY3ViZW1hcEd1YXNzaWFuUHlyYW1pZCh7XG4gICAgICAgICAgICB0ZXh0dXJlOiBza3lib3gsXG4gICAgICAgICAgICBkZXZpY2U6IHRoaXMucmVuZGVyZXIuZGV2aWNlLFxuICAgICAgICAgICAgaW5QbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIGRlbGF5V29yazogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNreWJveCA9IHNreWJveDtcbiAgICB9XG5cbiAgICBhc3luYyBzZXRNb2RlbChtb2RlbFBhdGg6IHN0cmluZyB8IERhdGFUeXBlKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfTtcbiAgICAgICAgY29uc3QgY29sb3JBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKTtcblxuICAgICAgICBjb25zdCBvcGFxdWVXaGl0ZSA9IHRoaXMucmVuZGVyZXIuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGZvcm1hdDogJ3JnYmEzMmZsb2F0JyxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNULFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5kZXZpY2UucXVldWUud3JpdGVUZXh0dXJlKHsgdGV4dHVyZTogb3BhcXVlV2hpdGUgfSwgY29sb3JBcnJheSwge30sIHNpemUpO1xuXG4gICAgICAgIGNvbnN0IG5vcm1hbE1hcCA9IHRoaXMucmVuZGVyZXIuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGZvcm1hdDogJ3JnYmEzMmZsb2F0JyxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNULFxuICAgICAgICB9KTtcbiAgICAgICAgY29sb3JBcnJheS5zZXQoWzAuNSwgMC41LCAxLCAxXSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZSh7IHRleHR1cmU6IG5vcm1hbE1hcCB9LCBjb2xvckFycmF5LCB7fSwgc2l6ZSk7XG5cbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IHtcbiAgICAgICAgICAgIGFkZHJlc3NNb2RlVTogJ3JlcGVhdCcsXG4gICAgICAgICAgICBhZGRyZXNzTW9kZVY6ICdyZXBlYXQnLFxuICAgICAgICAgICAgbWFnRmlsdGVyOiAnbGluZWFyJyxcbiAgICAgICAgICAgIG1pbkZpbHRlcjogJ2xpbmVhcicsXG4gICAgICAgICAgICBtaXBtYXBGaWx0ZXI6ICdsaW5lYXInLFxuICAgICAgICB9IGFzIEdQVVNhbXBsZXJEZXNjcmlwdG9yO1xuXG4gICAgICAgIGNvbnN0IG1hdERhdGE6IE1hdGVyaWFsRGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIGJhc2VDb2xvclRleHR1cmU6IG9wYXF1ZVdoaXRlLFxuICAgICAgICAgICAgYmFzZUNvbG9yRmFjdG9yOiBbMSwgMSwgMSwgMV0sXG4gICAgICAgICAgICBub3JtYWxUZXh0dXJlOiBub3JtYWxNYXAsXG4gICAgICAgICAgICBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmU6IG9wYXF1ZVdoaXRlLFxuICAgICAgICAgICAgbWV0YWxsaWNGYWN0b3I6IDEsXG4gICAgICAgICAgICByb3VnaG5lc3NGYWN0b3I6IDEsXG4gICAgICAgICAgICBiYXNlQ29sb3JTYW1wbGVyOiBzYW1wbGVyLFxuICAgICAgICAgICAgbm9ybWFsU2FtcGxlcjogc2FtcGxlcixcbiAgICAgICAgICAgIG1ldGFsbGljUm91Z2huZXNzU2FtcGxlcjogc2FtcGxlcixcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdlb21ldHJ5UGlwZWxpbmVzID0gYXdhaXQgaW1wb3J0R2x0ZihcbiAgICAgICAgICAgIG1vZGVsUGF0aCxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZGV2aWNlLFxuICAgICAgICAgICAgdGhpcy5kZXNjcmlwdG9yTWFwLFxuICAgICAgICAgICAgbWF0RGF0YSxcbiAgICAgICAgICAgIEdsdGZNb2RlbC5nb2FsTGF5b3V0LFxuICAgICAgICAgICAge30sXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyKHsgZW5jb2RlciwgZ2J1ZmZlciwgZ2xvYmFscyB9OiBGb3J3YXJkUGFzc1BhcmFtcykge1xuICAgICAgICBjb25zdCBwYXNzID0gZW5jb2Rlci5iZWdpblJlbmRlclBhc3MoZ2J1ZmZlci5wYXNzRGVzY3JpcHRvcik7XG4gICAgICAgIHBhc3Muc2V0QmluZEdyb3VwKDAsIGdsb2JhbHMuYmluZGdyb3VwKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHBpcGVsaW5lIG9mIE9iamVjdC52YWx1ZXModGhpcy5nZW9tZXRyeVBpcGVsaW5lcykpIHtcbiAgICAgICAgICAgIHBpcGVsaW5lPy5kcmF3KHBhc3MsIHRoaXMucmVuZGVyZXIuZGV2aWNlLnF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXNzLmVuZCgpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2806\n")},5308:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ importGltf)\n});\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/wgpu-matrix@3.2.0/node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\nvar wgpu_matrix_module = __webpack_require__(7675);\n// EXTERNAL MODULE: ./node_modules/.pnpm/@loaders.gl+core@4.2.4/node_modules/@loaders.gl/core/dist/lib/api/load.js + 50 modules\nvar load = __webpack_require__(3361);\n// EXTERNAL MODULE: ./node_modules/.pnpm/@loaders.gl+gltf@4.2.4_@loaders.gl+core@4.2.4/node_modules/@loaders.gl/gltf/dist/gltf-loader.js + 71 modules\nvar gltf_loader = __webpack_require__(4248);\n// EXTERNAL MODULE: ./node_modules/.pnpm/@loaders.gl+gltf@4.2.4_@loaders.gl+core@4.2.4/node_modules/@loaders.gl/gltf/dist/lib/api/post-process-gltf.js\nvar post_process_gltf = __webpack_require__(3628);\n;// ./src/samples/gltf-viewer/loader/weld.ts\n/**\n * Adapted from gltf-transform's version:\n * github.com/donmccurdy/glTF-Transform/blob/main/packages/functions/src/weld.ts\n */\nclass HashTable {\n    constructor(prim) {\n        this.attributes = [];\n        let byteStride = 0;\n        for (const attribute of Object.values(prim)) {\n            byteStride += this.initAttribute(attribute);\n        }\n        const paddedByteStride = (byteStride + 3) & ~3;\n        this.u8 = new Uint8Array(paddedByteStride);\n        this.u32 = new Uint32Array(this.u8.buffer);\n    }\n    initAttribute(attribute) {\n        const u8 = attribute.data instanceof Uint8Array\n            ? attribute.data\n            : new Uint8Array(attribute.data.buffer);\n        const byteStride = attribute.bytesPerComponent * attribute.componentsPerElement;\n        this.attributes.push({ u8, byteStride });\n        return byteStride;\n    }\n    hash(index) {\n        let byteOffset = 0;\n        for (const { u8, byteStride } of this.attributes) {\n            for (let i = 0; i < byteStride; i += 1) {\n                this.u8[byteOffset + i] = u8[index * byteStride + i];\n            }\n            byteOffset += byteStride;\n        }\n        return this.murmurHash2();\n    }\n    equal(a, b) {\n        for (const { u8, byteStride } of this.attributes) {\n            for (let j = 0; j < byteStride; j += 1) {\n                if (u8[a * byteStride + j] !== u8[b * byteStride + j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    hashLookup(table, buckets, key, empty) {\n        const hashmod = buckets - 1;\n        const hashval = this.hash(key);\n        let bucket = hashval & hashmod;\n        for (let probe = 0; probe <= hashmod; probe += 1) {\n            const item = table[bucket];\n            if (item === empty || this.equal(item, key)) {\n                return bucket;\n            }\n            bucket = (bucket + probe + 1) & hashmod; // Hash collision.\n        }\n        throw new Error('Hash table full.');\n    }\n    /**\n     * References:\n     * - https://github.com/mikolalysenko/murmurhash-js/blob/f19136e9f9c17f8cddc216ca3d44ec7c5c502f60/murmurhash2_gc.js#L14\n     * - https://github.com/zeux/meshoptimizer/blob/e47e1be6d3d9513153188216455bdbed40a206ef/src/indexgenerator.cpp#L12\n     */\n    murmurHash2() {\n        const m = 0x5bd1e995;\n        const r = 24;\n        let h = 0;\n        for (let k of this.u32) {\n            k = Math.imul(k, m) >>> 0;\n            k = (k ^ (k >> r)) >>> 0;\n            k = Math.imul(k, m) >>> 0;\n            h = Math.imul(h, m) >>> 0;\n            h = (h ^ k) >>> 0;\n        }\n        return h;\n    }\n}\nfunction ceilPowerOfTwo(value) {\n    return 2 ** Math.ceil(Math.log(value) / Math.LN2);\n}\n/**\n * Weld and merge, combining vertices that are bitwise-equal.\n *\n * Adapted from gltf-transform's _weldPrimitiveStrict:\n * github.com/donmccurdy/glTF-Transform/blob/main/packages/functions/src/weld.ts#L193\n */\nfunction weld(prim) {\n    const srcVertexCount = prim.POSITION.count;\n    const hash = new HashTable(prim);\n    const tableSize = ceilPowerOfTwo(srcVertexCount + (srcVertexCount / 4));\n    const is16Bit = srcVertexCount < (2 ** 16 - 1);\n    const empty = 2 ** (is16Bit ? 16 : 32) - 1;\n    const indexFormat = is16Bit ? 'uint16' : 'uint32';\n    const writeMap = is16Bit ? new Uint16Array(srcVertexCount) : new Uint32Array(srcVertexCount);\n    const table = is16Bit ? new Uint16Array(tableSize) : new Uint32Array(tableSize);\n    table.fill(empty);\n    let dstVertexCount = 0;\n    for (let i = 0; i < srcVertexCount; i += 1) {\n        const hashIndex = hash.hashLookup(table, tableSize, i, empty);\n        const dstIndex = table[hashIndex];\n        if (dstIndex === empty) {\n            table[hashIndex] = i;\n            writeMap[i] = dstVertexCount;\n            dstVertexCount += 1;\n        }\n        else {\n            writeMap[i] = writeMap[dstIndex];\n        }\n    }\n    for (const attribute of Object.values(prim)) {\n        attribute.remap(writeMap, dstVertexCount);\n    }\n    // The gltf-transform version checks for degenerate triangles to remove.\n    // This is omitted here.\n    return { indexArray: writeMap, indexFormat, vertexCount: dstVertexCount };\n}\n\n// EXTERNAL MODULE: ./src/rendering/default-forward-pass/pipeline-feature-flags.ts\nvar pipeline_feature_flags = __webpack_require__(9274);\n// EXTERNAL MODULE: ./src/rendering/constants.ts\nvar constants = __webpack_require__(3970);\n// EXTERNAL MODULE: ./src/utils/data-copy.ts\nvar data_copy = __webpack_require__(5752);\n;// ./src/rendering/default-forward-pass/primitive-draw-data.ts\n\n\n\n\nclass PrimitiveDrawData {\n    constructor(primitive, device, max, descriptorMap, instances) {\n        this.instanceCount = 0;\n        this.dirty = false;\n        this.max = max;\n        this.features = primitive.features;\n        this.name = primitive.name ?? 'mesh';\n        this.vertexCount = primitive.vertexCount;\n        if (primitive.vertexArray instanceof GPUBuffer) {\n            this.vertexBuffer = primitive.vertexArray;\n        }\n        else {\n            this.vertexBuffer = (0,data_copy/* createAndCopyBuffer */.Lr)(primitive.vertexArray, GPUBufferUsage.VERTEX, device, `${this.name} vertex buffer`);\n        }\n        if (primitive.indexArray && primitive.indexFormat) {\n            const { indexArray, indexFormat } = primitive;\n            this.indexData = {\n                indexFormat,\n                indexCount: indexArray.byteLength / (indexFormat === 'uint16' ? 2 : 4),\n                indexBuffer: (0,data_copy/* createAndCopyBuffer */.Lr)(primitive.indexArray, GPUBufferUsage.INDEX, device, `${this.name} index buffer`),\n            };\n        }\n        this.instanceSize = constants/* TypeSizes */.vV.sizeofMat4x4f;\n        if (this.features & pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals) {\n            this.instanceSize += 12 * 4;\n        }\n        this.instances = new ArrayBuffer(max * this.instanceSize);\n        this.modelMatrices = new Array(max);\n        for (let i = 0; i < max; i += 1) {\n            const offset = i * this.instanceSize;\n            this.modelMatrices[i] = new Float32Array(this.instances, offset, 16);\n        }\n        if (this.features & pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals) {\n            this.normalMatrices = new Array(max);\n            for (let i = 0; i < max; i += 1) {\n                const offset = (i * this.instanceSize) + constants/* TypeSizes */.vV.sizeofMat4x4f;\n                this.normalMatrices[i] = new Float32Array(this.instances, offset, 12);\n            }\n        }\n        this.instanceBuffer = device.createBuffer({\n            label: `${this.name} instance buffer`,\n            size: this.instances.byteLength,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        });\n        this.instanceBindGroup = device.createBindGroup({\n            label: `PrimitiveDrawData instance bind group`,\n            layout: descriptorMap.forwardBindgroupLayout,\n            entries: [{\n                    binding: 0,\n                    resource: { buffer: this.instanceBuffer },\n                }],\n        });\n        if (instances) {\n            for (const instance of instances) {\n                this.addInstance(instance);\n            }\n        }\n    }\n    draw(passEncoder, queue) {\n        if (this.dirty) {\n            queue.writeBuffer(this.instanceBuffer, 0, this.instances);\n            this.dirty = false;\n        }\n        passEncoder.setVertexBuffer(0, this.vertexBuffer);\n        passEncoder.setBindGroup(2, this.instanceBindGroup);\n        if (this.indexData != null) {\n            const { indexBuffer, indexCount, indexFormat } = this.indexData;\n            passEncoder.setIndexBuffer(indexBuffer, indexFormat);\n            passEncoder.drawIndexed(indexCount, this.instanceCount);\n        }\n        else {\n            passEncoder.draw(this.vertexCount, this.instanceCount);\n        }\n    }\n    addInstance(transform) {\n        if (this.instanceCount === this.max)\n            return;\n        wgpu_matrix_module/* mat4 */.pB.copy(transform, this.modelMatrices[this.instanceCount]);\n        this.calculateNormalMatrix(this.instanceCount);\n        this.instanceCount += 1;\n        this.dirty = true;\n    }\n    calculateNormalMatrix(idx) {\n        if (!(this.features & pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals))\n            return;\n        const normalMatrix = this.normalMatrices[idx];\n        wgpu_matrix_module/* mat3 */.w0.fromMat4(this.modelMatrices[idx], normalMatrix);\n        wgpu_matrix_module/* mat3 */.w0.invert(normalMatrix, normalMatrix);\n        wgpu_matrix_module/* mat3 */.w0.transpose(normalMatrix, normalMatrix);\n    }\n}\n\n;// ./src/samples/gltf-viewer/loader/type-conversions.ts\n\nconst typeToElementCount = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 12,\n    MAT4: 16,\n};\nconst componentToSize = {\n    [5120 /* ComponentType.int8 */]: 1,\n    [5121 /* ComponentType.uint8 */]: 1,\n    [5122 /* ComponentType.int16 */]: 2,\n    [5123 /* ComponentType.uint16 */]: 2,\n    [5125 /* ComponentType.uint32 */]: 4,\n    [5126 /* ComponentType.float32 */]: 4,\n};\nconst modeToTopology = {\n    [0 /* TopologyMode.Points */]: pipeline_feature_flags/* PipelineFeatureFlags */.Ot.PointList, // POINTS\n    [1 /* TopologyMode.LineList */]: pipeline_feature_flags/* PipelineFeatureFlags */.Ot.LineList, // LINES\n    // 2: LINE_LOOP (unsupported by webgpu)\n    // 3: PipelineFeatureFlags.LineStrip, // LINE_STRIP\n    [4 /* TopologyMode.TriangleList */]: pipeline_feature_flags/* PipelineFeatureFlags */.Ot.TriangleList, // TRIANGLES\n    // 5: PipelineFeatureFlags.TriangleStrip, // TRIANGLE_STRIP\n    // 6: TRIANGLE_FAN (unsupported by webgpu)\n};\n\n;// ./src/samples/gltf-viewer/loader/attribute-wrapper.ts\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nclass AttributeWrapper {\n    constructor(accessor, componentCount) {\n        this.unwelded = false;\n        if (accessor instanceof Float32Array) {\n            this.data = accessor;\n            this.componentsPerElement = componentCount;\n            this.count = accessor.length / componentCount;\n            this.processed = true;\n            this.bytesPerComponent = 4;\n            this.copyFrom = this.copyProcessed.bind(this);\n        }\n        else {\n            this.data = accessor.value;\n            this.componentsPerElement = accessor.components;\n            this.count = accessor.count;\n            this.bytesPerComponent = accessor.bytesPerComponent;\n            this.processed = false;\n            this.view = new DataView(this.data.buffer);\n            this.copyFrom = this.copyUnprocessed.bind(this);\n            switch (accessor.componentType) {\n                case 5120 /* ComponentType.int8 */: {\n                    this.at = (i, j) => this.view.getInt8(i * this.componentsPerElement + j);\n                    break;\n                }\n                case 5121 /* ComponentType.uint8 */: {\n                    this.at = (i, j) => this.view.getUint8(i * this.componentsPerElement + j);\n                    break;\n                }\n                case 5122 /* ComponentType.int16 */: {\n                    this.at = (i, j) => {\n                        const offset = 2 * (i * this.componentsPerElement + j);\n                        return this.view.getInt16(offset, true);\n                    };\n                    break;\n                }\n                case 5123 /* ComponentType.uint16 */: {\n                    this.at = (i, j) => {\n                        const offset = 2 * (i * this.componentsPerElement + j);\n                        return this.view.getUint16(offset, true);\n                    };\n                    break;\n                }\n                case 5125 /* ComponentType.uint32 */: {\n                    this.at = (i, j) => {\n                        const offset = 4 * (i * this.componentsPerElement + j);\n                        return this.view.getUint32(offset, true);\n                    };\n                    break;\n                }\n                case 5126 /* ComponentType.float32 */: {\n                    this.at = (i, j) => {\n                        const offset = 4 * (i * this.componentsPerElement + j);\n                        return this.view.getFloat32(offset, true);\n                    };\n                    break;\n                }\n                default: throw new Error(`gltf importer -- invalid componentType ${accessor.componentType}`);\n            }\n            if (accessor.normalized) {\n                let val;\n                switch (accessor.componentType) {\n                    case 5121 /* ComponentType.uint8 */:\n                        val = 255;\n                        break;\n                    case 5120 /* ComponentType.int8 */:\n                        val = 127;\n                        break;\n                    case 5123 /* ComponentType.uint16 */:\n                        val = 65535;\n                        break;\n                    case 5122 /* ComponentType.int16 */:\n                        val = 32767;\n                        break;\n                    case 5125 /* ComponentType.uint32 */:\n                        val = 4294967295;\n                        break;\n                    default: throw new Error(`gltf importer -- invalid componentType ${accessor.componentType}`);\n                }\n                this.at = (i, j) => this.at(i, j) / val;\n            }\n        }\n    }\n    get array() {\n        if (!this.processed)\n            this.process();\n        return this.data;\n    }\n    copyProcessed(srcIdx, dstIdx, dst) {\n        for (let j = 0; j < this.componentsPerElement; j += 1) {\n            dst[dstIdx + j] = this.data[(srcIdx * this.componentsPerElement) + j];\n        }\n    }\n    copyUnprocessed(srcIdx, dstIdx, dst) {\n        for (let j = 0; j < this.componentsPerElement; j += 1) {\n            dst[dstIdx + j] = this.at(srcIdx, j);\n        }\n    }\n    markProcessed() {\n        this.processed = true;\n        this.copyFrom = this.copyProcessed.bind(this);\n        delete this.view;\n        delete this.at;\n    }\n    process() {\n        if (this.processed)\n            return;\n        const newView = new Float32Array(this.count * this.componentsPerElement);\n        for (let i = 0; i < this.count; i += 1) {\n            this.copyFrom(i, i * this.componentsPerElement, newView);\n        }\n        this.data = newView;\n        this.markProcessed();\n    }\n    unweld(indexArray) {\n        if (this.unwelded)\n            return;\n        this.unwelded = true;\n        const newView = new Float32Array(indexArray.length * this.componentsPerElement);\n        for (let i = 0; i < indexArray.length; i += 1) {\n            this.copyFrom(indexArray[i], i * this.componentsPerElement, newView);\n        }\n        this.count = indexArray.length;\n        this.data = newView;\n        this.markProcessed();\n    }\n    remap(remap, dstCount) {\n        const dstArray = new Float32Array(dstCount * this.componentsPerElement);\n        const done = new Uint8Array(dstCount);\n        for (let srcIndex = 0; srcIndex < this.count; srcIndex += 1) {\n            const dstIndex = remap[srcIndex];\n            if (done[dstIndex])\n                continue;\n            this.copyFrom(srcIndex, dstIndex * this.componentsPerElement, dstArray);\n            done[dstIndex] = 1;\n        }\n        this.data = dstArray;\n        this.markProcessed();\n    }\n}\n\n;// ./src/samples/gltf-viewer/loader/interleave-vertices.ts\n\n\n// const goalLayout: AttributeDetails[] = [\n//     {\n//         name: 'POSITION',\n//         type: 'VEC3',\n//         componentType: ComponentType.float32,\n//     },\n//     {\n//         name: 'TEXCOORD_0',\n//         type: 'VEC2',\n//         componentType: ComponentType.float32,\n//     },\n//     {\n//         name: 'TANGENT',\n//         type: 'VEC4',\n//         componentType: ComponentType.float32,\n//         depends: ['NORMAL'],\n//         fill: [1, 0, 0, 1],\n//     },\n//     {\n//         name: 'NORMAL',\n//         type: 'VEC3',\n//         componentType: ComponentType.float32,\n//         strip: true,\n//         feature: PipelineFeatureFlags.VertexNormals,\n//     },\n//     {\n//         name: 'COLOR_0',\n//         type: 'VEC4',\n//         componentType: ComponentType.float32,\n//         strip: true,\n//         feature: PipelineFeatureFlags.VertexColors,\n//         fill: [1, 1, 1, 1],\n//     },\n// ];\nfunction interleaveVertices(attributes, count) {\n    let vertexFeatures = pipeline_feature_flags/* PipelineFeatureFlags */.Ot.Defaults;\n    let stride = 5;\n    if (attributes.NORMAL != null)\n        stride += 7;\n    if (attributes.COLOR_0 != null)\n        stride += 4;\n    const vertexArray = new ArrayBuffer(stride * count * 4);\n    const vertexView = new Float32Array(vertexArray);\n    for (let i = 0; i < count; i += 1) {\n        attributes.POSITION?.copyFrom(i, stride * i, vertexView);\n    }\n    const uv = attributes.TEXCOORD_0 ?? new AttributeWrapper(new Float32Array(count * 2), 2);\n    for (let i = 0; i < count; i += 1) {\n        uv.copyFrom(i, i * stride + 3, vertexView);\n    }\n    if (attributes.NORMAL != null && attributes.TANGENT != null) {\n        vertexFeatures |= pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals;\n        for (let i = 0; i < count; i += 1) {\n            attributes.TANGENT.copyFrom(i, i * stride + 5, vertexView);\n        }\n        for (let i = 0; i < count; i += 1) {\n            attributes.NORMAL.copyFrom(i, i * stride + 9, vertexView);\n        }\n    }\n    if (attributes.COLOR_0 != null) {\n        vertexFeatures |= pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexColors;\n        const step = attributes.NORMAL != null ? 12 : 5;\n        for (let i = 0; i < count; i += 1) {\n            attributes.COLOR_0.copyFrom(i, i * stride + step, vertexView);\n            vertexView[i * stride + step + 3] = 1;\n        }\n    }\n    return { vertexArray, vertexFeatures };\n}\n\n// EXTERNAL MODULE: ./src/utils/general.ts\nvar general = __webpack_require__(4742);\n;// ./src/samples/gltf-viewer/loader/primitive-loader.ts\n\n\n\n\n\n\n\n\nconst generateTangentsAsync = __webpack_require__.e(/* import() */ 451).then(__webpack_require__.bind(__webpack_require__, 1451)).then((module) => module.generateTangents);\nfunction wrapIndices(indices) {\n    switch (indices.bytesPerComponent) {\n        case 2: return {\n            indexArray: new Uint16Array(indices.value.buffer),\n            indexFormat: 'uint16',\n        };\n        case 4: return {\n            indexArray: new Uint32Array(indices.value.buffer),\n            indexFormat: 'uint32',\n        };\n        case 1:\n        default: return {\n            indexArray: new Uint16Array(indices.value),\n            indexFormat: 'uint16',\n        };\n    }\n}\nfunction reindex(indices, originalMode) {\n    switch (originalMode) {\n        case 2 /* TopologyMode.LineLoop */:\n        case 3 /* TopologyMode.LineStrip */:\n        case 6 /* TopologyMode.TriangleFan */:\n        case 5 /* TopologyMode.TriangleStrip */: {\n            // TODO: convert non-list topologies into lists.\n            throw new Error('Topology currently unsupported');\n        }\n        default: return { ...wrapIndices(indices), mode: 4 /* TopologyMode.TriangleList */ };\n    }\n}\n/**\n * Checks the determinant of each given matrix and returns a culling mode such that\n * a primitive will render correctly for all nodes containing it, using 'none'\n * for primitive which are rendered both inverted and normally.\n *\n * @param instanceMatrices the instance matrices to render the primitive with\n * @returns The cull mode to use on the primitive.\n *\n * @remarks\n * The glFT spec determines the winding direction of a model by the\n * determinant of the transform of the node which uses it, allowing\n * inversion through negative scale. Changing cullMode instead\n * more easily integrates with instanced rendering, although comes\n * at a performance cost.\n */\nfunction getCullMode(instanceMatrices) {\n    let overallSign;\n    for (let i = 0; i < instanceMatrices.length; i += 1) {\n        const det = wgpu_matrix_module/* mat4 */.pB.determinant(instanceMatrices[i]);\n        const sign = Math.sign(det);\n        overallSign ??= sign;\n        if (sign !== overallSign)\n            return pipeline_feature_flags/* PipelineFeatureFlags */.Ot.DoubleSided;\n    }\n    return (overallSign == null || overallSign > 0)\n        ? pipeline_feature_flags/* PipelineFeatureFlags */.Ot.Defaults\n        : pipeline_feature_flags/* PipelineFeatureFlags */.Ot.ClockwiseWinding;\n}\nasync function loadPrimitive(layout, primitive, instances, descriptorMap, device) {\n    const attributes = primitive.attributes;\n    if (attributes.POSITION == null)\n        return {};\n    const { indices } = primitive;\n    const atrs = (0,general/* mapValues */.LG)(attributes, (atr) => new AttributeWrapper(atr));\n    let { mode } = primitive;\n    let vertexCount = attributes.POSITION.count;\n    let indexArray;\n    let indexFormat;\n    if (indices != null) {\n        ({ indexArray, indexFormat } = wrapIndices(indices));\n        if (mode !== 0 /* TopologyMode.Points */\n            && mode !== 1 /* TopologyMode.LineList */\n            && mode !== 4 /* TopologyMode.TriangleList */) {\n            ({ indexArray, indexFormat, mode } = reindex(indices, mode));\n        }\n    }\n    if (atrs.NORMAL != null && atrs.TANGENT == null) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (atrs.TEXCOORD_0 != null) {\n            if (indexArray != null) {\n                vertexCount = indexArray.length;\n                for (const atr of Object.values(atrs)) {\n                    atr.unweld(indexArray);\n                }\n            }\n            const start = Date.now();\n            const tangent = await generateTangentsAsync.then((func) => func(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            atrs.POSITION.array, \n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            atrs.NORMAL.array, atrs.TEXCOORD_0.array));\n            for (let i = 3; i < tangent.length; i += 4) {\n                tangent[i] *= -1;\n            }\n            console.log(`tangents generated in ${Date.now() - start}`);\n            atrs.TANGENT = new AttributeWrapper(tangent, 4);\n            ({ indexArray, indexFormat, vertexCount } = weld(atrs));\n            mode = 4 /* TopologyMode.TriangleList */;\n        }\n        else {\n            const tangent = new Float32Array(vertexCount * 4);\n            for (let i = 0; i < vertexCount; i += 1) {\n                tangent.set([1, 0, 0, 1], i * 4);\n            }\n            atrs.TANGENT = new AttributeWrapper(tangent, 4);\n        }\n    }\n    const { vertexArray, vertexFeatures } = interleaveVertices(atrs, vertexCount);\n    let features = getCullMode(instances) | vertexFeatures;\n    if (mode != null)\n        features |= modeToTopology[mode] || 0;\n    const drawData = new PrimitiveDrawData({\n        features,\n        indexArray,\n        indexFormat,\n        vertexCount,\n        vertexArray,\n    }, device, instances.length, descriptorMap, instances);\n    return { material: primitive.material, drawData };\n}\n\n// EXTERNAL MODULE: ./src/utils/texture-importing.ts + 1 modules\nvar texture_importing = __webpack_require__(8862);\n;// ./src/samples/gltf-viewer/loader/material-loader.ts\n\n\nconst DEFAULT_METALLIC = 0.0;\nconst DEFAULT_ROUGHNESS = 1.0;\nconst gltfToMagDescription = {\n    9728: 'nearest',\n    9729: 'linear',\n    9984: 'nearest', // NEAREST_MIPMAP_NEAREST\n    9985: 'linear', // LINEAR_MIPMAP_NEAREST\n    9986: 'nearest', // NEAREST_MIPMAP_LINEAR\n    9987: 'linear', // LINEAR_MIPMAP_LINEAR\n};\nconst gltfToMipDescription = {\n    9984: 'nearest', // NEAREST_MIPMAP_NEAREST\n    9985: 'nearest', // LINEAR_MIPMAP_NEAREST\n    9986: 'linear', // NEAREST_MIPMAP_LINEAR\n    9987: 'linear', // LINEAR_MIPMAP_LINEAR\n};\nconst gltfToAddressMode = {\n    33071: 'clamp-to-edge', // CLAMP_TO_EDGE\n    33648: 'mirror-repeat', // MIRRORED_REPEAT\n    10497: 'repeat', // REPEAT\n};\nfunction toSamplerDescription(sampler) {\n    const { magFilter, minFilter, wrapS, wrapT } = sampler;\n    return {\n        addressModeU: gltfToAddressMode[wrapS ?? 10497],\n        addressModeV: gltfToAddressMode[wrapT ?? 10497],\n        minFilter: gltfToMagDescription[minFilter ?? 9987],\n        magFilter: gltfToMagDescription[magFilter ?? 9729],\n        mipmapFilter: gltfToMipDescription[minFilter ?? 9987] ?? 'linear',\n    };\n}\nfunction getImageData(handle) {\n    const { source, sampler } = handle;\n    if (source == null)\n        return {};\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const data = source.image.data ?? source.bufferView?.data;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (data == null)\n        return {};\n    return { data, mimeType: source.mimeType, sampler };\n}\nasync function loadMaterial(material, defaultMaterial, device) {\n    const mat = {};\n    if (material.pbrMetallicRoughness != null) {\n        const { baseColorFactor, baseColorTexture, metallicFactor, metallicRoughnessTexture, roughnessFactor, } = material.pbrMetallicRoughness;\n        if (metallicRoughnessTexture?.texture.source == null) {\n            if (metallicFactor == null)\n                mat.metallicFactor = DEFAULT_METALLIC;\n            if (roughnessFactor == null)\n                mat.roughnessFactor = DEFAULT_ROUGHNESS;\n        }\n        else {\n            const { data, mimeType, sampler } = getImageData(metallicRoughnessTexture.texture);\n            if (data != null) {\n                mat.metallicRoughnessTexture = await (0,texture_importing/* imageToTexture */.u)({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                });\n                if (sampler)\n                    mat.metallicRoughnessSampler = toSamplerDescription(sampler);\n            }\n        }\n        if (baseColorTexture?.texture.source != null) {\n            const { data, mimeType, sampler } = getImageData(baseColorTexture.texture);\n            if (data != null) {\n                mat.baseColorTexture = await (0,texture_importing/* imageToTexture */.u)({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                    srgbToLinear: true,\n                });\n                if (sampler)\n                    mat.baseColorSampler = toSamplerDescription(sampler);\n            }\n        }\n        if (baseColorFactor != null)\n            mat.baseColorFactor = baseColorFactor;\n        if (metallicFactor != null)\n            mat.metallicFactor = metallicFactor;\n        if (roughnessFactor != null)\n            mat.metallicFactor = roughnessFactor;\n    }\n    else {\n        mat.metallicFactor = DEFAULT_METALLIC;\n        mat.roughnessFactor = DEFAULT_ROUGHNESS;\n    }\n    if (material.normalTexture?.texture.source != null) {\n        const { data, mimeType, sampler } = getImageData(material.normalTexture.texture);\n        if (data != null) {\n            mat.normalTexture = await (0,texture_importing/* imageToTexture */.u)({\n                label: `${material.id} mr texture`,\n                data,\n                mimeType,\n                usage: GPUTextureUsage.TEXTURE_BINDING,\n                device,\n            });\n            if (sampler)\n                mat.normalSampler = toSamplerDescription(sampler);\n        }\n    }\n    const { emissiveFactor, emissiveTexture } = material;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    const emissiveStrength = material.extensions?.KHR_materials_emissive_strength?.emissiveStrength;\n    if (emissiveTexture != null || emissiveFactor?.some((x) => x > 0)) {\n        mat.emissiveFactor = emissiveFactor ?? [1, 1, 1];\n        mat.emissiveSampler = { magFilter: 'linear', minFilter: 'linear' };\n        if (emissiveTexture?.texture.source != null) {\n            const { data, mimeType, sampler } = getImageData(emissiveTexture.texture);\n            if (data != null) {\n                mat.emissiveTexture = await (0,texture_importing/* imageToTexture */.u)({\n                    label: `${material.id} mr texture`,\n                    data,\n                    mimeType,\n                    usage: GPUTextureUsage.TEXTURE_BINDING,\n                    device,\n                    srgbToLinear: true,\n                });\n                if (sampler)\n                    mat.emissiveSampler = toSamplerDescription(sampler);\n            }\n        }\n        else {\n            mat.emissiveTexture = defaultMaterial.baseColorTexture;\n        }\n        if (emissiveStrength != null && typeof emissiveStrength === 'number') {\n            wgpu_matrix_module/* vec3 */.eR.scale(mat.emissiveFactor, emissiveStrength, mat.emissiveFactor);\n        }\n    }\n    if (material.doubleSided)\n        mat.doubleSided = true;\n    if (material.alphaMode === 'MASK')\n        mat.alphaCutoff = material.alphaCutoff ?? 0.5;\n    return { ...defaultMaterial, ...mat };\n}\n\n;// ./src/rendering/default-forward-pass/material-draw-data.ts\n\n\nclass MaterialDrawData {\n    constructor(data, device, descriptorMap, primitiveFeatures, primitives) {\n        this.primitives = [];\n        this.features = primitiveFeatures;\n        if (data.doubleSided)\n            this.features |= pipeline_feature_flags/* PipelineFeatureFlags */.Ot.DoubleSided;\n        // TODO : don't hardcode the properties features\n        const properties = new Float32Array(12);\n        properties.set(data.baseColorFactor);\n        properties[4] = data.metallicFactor;\n        properties[5] = data.roughnessFactor;\n        if (data.alphaCutoff != null) {\n            this.features |= pipeline_feature_flags/* PipelineFeatureFlags */.Ot.AlphaCutoff;\n            properties[6] = data.alphaCutoff;\n        }\n        if (data.emissiveFactor != null) {\n            properties.set(data.emissiveFactor, 8);\n        }\n        this.propertiesBuffer = (0,data_copy/* createAndCopyBuffer */.Lr)(properties, GPUBufferUsage.UNIFORM, device);\n        const entries = [\n            { binding: 0, resource: { buffer: this.propertiesBuffer } },\n            { binding: 1, resource: descriptorMap.getSampler(data.baseColorSampler) },\n            { binding: 2, resource: data.baseColorTexture.createView({ dimension: '2d' }) },\n            { binding: 3, resource: descriptorMap.getSampler(data.normalSampler) },\n            { binding: 4, resource: data.normalTexture.createView({ dimension: '2d' }) },\n            { binding: 5, resource: descriptorMap.getSampler(data.metallicRoughnessSampler) },\n            { binding: 6, resource: data.metallicRoughnessTexture.createView({ dimension: '2d' }) },\n        ];\n        if (data.emissiveTexture != null) {\n            this.features |= pipeline_feature_flags/* PipelineFeatureFlags */.Ot.Emissive;\n            entries.push({\n                binding: 7,\n                resource: descriptorMap.getSampler(data.emissiveSampler ?? {}),\n            });\n            entries.push({\n                binding: 8,\n                resource: data.emissiveTexture.createView({ dimension: '2d' }),\n            });\n        }\n        this.layout = descriptorMap.getMaterialBindGroup(this.features);\n        this.matData = data;\n        this.bindGroup = device.createBindGroup({\n            label: (0,pipeline_feature_flags/* featureFlagsToString */.UZ)(this.features),\n            layout: this.layout,\n            entries,\n        });\n        if (primitives != null) {\n            this.addPrimitives(...primitives);\n        }\n    }\n    draw(passEncoder, queue) {\n        if (this.primitives.length === 0)\n            return;\n        passEncoder.setBindGroup(1, this.bindGroup);\n        for (const primitive of this.primitives) {\n            primitive.draw(passEncoder, queue);\n        }\n    }\n    addPrimitives(...drawData) {\n        const filtered = drawData.filter((data) => {\n            if ((data.features & this.features) === data.features)\n                return true;\n            console.warn(`invalid primitive added to material: \nprimitive: ${data.name}\nprimitive features: ${(0,pipeline_feature_flags/* featureFlagsToString */.UZ)(data.features).toString()}\nmaterial: ${this.matData.name}\nmaterial features: ${(0,pipeline_feature_flags/* featureFlagsToString */.UZ)(this.features).toString()}`);\n            return false;\n        });\n        this.primitives.push(...filtered);\n    }\n}\n\n;// ./src/rendering/default-forward-pass/geometry-pipeline.ts\n\nclass GeometryPipeline {\n    constructor(features, maps) {\n        this.materials = [];\n        this.features = (0,pipeline_feature_flags/* maskRedundantFeatures */.P7)(features);\n        const module = maps.getShaderModule(features);\n        this.pipeline = maps.device.createRenderPipeline({\n            label: (0,pipeline_feature_flags/* featureFlagsToString */.UZ)(features),\n            layout: maps.getForwardPipelineLayout(features),\n            primitive: maps.getPrimitiveState(features),\n            vertex: {\n                entryPoint: 'vs',\n                buffers: [maps.getVertexLayout(features)],\n                module,\n            },\n            fragment: {\n                entryPoint: 'fs',\n                module,\n                targets: maps.gbuffer.targets,\n            },\n            depthStencil: {\n                depthWriteEnabled: true,\n                depthCompare: 'less-equal',\n                format: maps.gbuffer.depth.format,\n            },\n        });\n    }\n    addMaterials(...materials) {\n        if (materials.some((data) => data.features !== this.features)) {\n            throw new Error('invalid primitive added to material');\n        }\n        this.materials.push(...materials);\n    }\n    draw(passEncoder, queue) {\n        passEncoder.setPipeline(this.pipeline);\n        for (const mat of this.materials) {\n            mat.draw(passEncoder, queue);\n        }\n    }\n}\n\n;// ./src/samples/gltf-viewer/loader/gltf-loader.ts\n\n\n\n\n\n\n\n\nconst defaultLayout = [\n    {\n        name: 'POSITION',\n        type: 'VEC3',\n        componentType: 5126 /* ComponentType.float32 */,\n    },\n    {\n        name: 'TEXCOORD_0',\n        type: 'VEC2',\n        componentType: 5126 /* ComponentType.float32 */,\n    },\n    {\n        name: 'TANGENT',\n        type: 'VEC4',\n        componentType: 5126 /* ComponentType.float32 */,\n        depends: ['NORMAL'],\n        fill: [1, 0, 0, 1],\n    },\n    {\n        name: 'NORMAL',\n        type: 'VEC3',\n        componentType: 5126 /* ComponentType.float32 */,\n        strip: true,\n        feature: pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexNormals,\n    },\n    {\n        name: 'COLOR_0',\n        type: 'VEC4',\n        componentType: 5126 /* ComponentType.float32 */,\n        strip: true,\n        feature: pipeline_feature_flags/* PipelineFeatureFlags */.Ot.VertexColors,\n        fill: [1, 1, 1, 1],\n    },\n];\nconst recurseNode = (parentMatrix, meshes) => (node) => {\n    const matrix = node.matrix ?? wgpu_matrix_module/* mat4 */.pB.identity();\n    if (node.matrix == null) {\n        if (node.scale)\n            wgpu_matrix_module/* mat4 */.pB.scaling(node.scale, matrix);\n        if (node.rotation) {\n            const { axis, angle } = wgpu_matrix_module/* quat */.Yu.toAxisAngle(node.rotation);\n            wgpu_matrix_module/* mat4 */.pB.rotate(matrix, axis, angle, matrix);\n        }\n        if (node.translation != null) {\n            wgpu_matrix_module/* mat4 */.pB.setTranslation(matrix, node.translation, matrix);\n        }\n    }\n    wgpu_matrix_module/* mat4 */.pB.mul(parentMatrix, matrix, matrix);\n    if (node.mesh != null) {\n        if (!meshes.has(node.mesh))\n            meshes.set(node.mesh, []);\n        meshes.get(node.mesh).push(matrix); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    }\n    node.children?.forEach(recurseNode(matrix, meshes));\n};\nasync function importGltf(url, device, descriptorMap, defaultMaterial, layout = defaultLayout, pipelines = {}, \n// eslint-disable-next-line no-console\nlog = console.log) {\n    log('starting import');\n    const start = Date.now();\n    const gltfWithBuffers = await (0,load/* load */.H)(url, gltf_loader/* GLTFLoader */.B);\n    log(`finished loading: ${Date.now() - start}`);\n    const { scene } = (0,post_process_gltf/* postProcessGLTF */.R)(gltfWithBuffers);\n    if (scene?.nodes == null)\n        return pipelines;\n    log(`finished processing: ${Date.now() - start}`);\n    const meshes = new Map();\n    scene.nodes.forEach(recurseNode(wgpu_matrix_module/* mat4 */.pB.identity(), meshes));\n    log(`finished creating instances: ${Date.now() - start}`);\n    const meshEntries = Array.from(meshes.entries());\n    const primitivePromises = meshEntries.flatMap(([{ primitives }, instances]) => primitives.map((prim) => loadPrimitive(layout, prim, instances, descriptorMap, device)));\n    const primitiveDescriptors = await Promise.all(primitivePromises);\n    log(`finished creating primitives: ${Date.now() - start}`);\n    const materialMap = new Map();\n    const materialPromises = {};\n    for (const { material, drawData } of primitiveDescriptors) {\n        if (drawData == null)\n            continue;\n        const key = { materialId: material?.id, features: drawData.features };\n        if (!materialMap.has(key))\n            materialMap.set(key, []);\n        materialMap.get(key).push(drawData); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        if (material != null) {\n            materialPromises[material.id] = loadMaterial(material, defaultMaterial, device);\n        }\n    }\n    const materialEntries = Object.entries(materialPromises)\n        .map(async ([id, mat]) => [id, await mat]);\n    const materialDescriptors = Object.fromEntries(await Promise.all(materialEntries));\n    log(`finished creating material descriptors: ${Date.now() - start}`);\n    const fullDefaultMat = { ...defaultMaterial, metallicFactor: 0 };\n    for (const [{ features, materialId }, drawDatas] of materialMap.entries()) {\n        const descriptor = materialId != null ? materialDescriptors[materialId] : fullDefaultMat;\n        const mat = new MaterialDrawData(descriptor, device, descriptorMap, features, drawDatas);\n        const { features: f } = mat;\n        pipelines[f] ??= new GeometryPipeline(f, descriptorMap);\n        pipelines[f].addMaterials(mat);\n    }\n    log(`finished: ${Date.now() - start}`);\n    return pipelines;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SyxFQUFFLENBQUMsQ0FBQztJQUN2QyxPQUFPLFNBQVMsQ0FBQztBQUNyQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3NhbXBsZXMvZ2x0Zi12aWV3ZXIvbG9hZGVyL3dlbGQudHM/ZGMyNCIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL3ByaW1pdGl2ZS1kcmF3LWRhdGEudHM/OGEwZSIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvc2FtcGxlcy9nbHRmLXZpZXdlci9sb2FkZXIvdHlwZS1jb252ZXJzaW9ucy50cz8yYWFmIiwid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy9zYW1wbGVzL2dsdGYtdmlld2VyL2xvYWRlci9hdHRyaWJ1dGUtd3JhcHBlci50cz81OTU0Iiwid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy9zYW1wbGVzL2dsdGYtdmlld2VyL2xvYWRlci9pbnRlcmxlYXZlLXZlcnRpY2VzLnRzP2IzYzUiLCJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3NhbXBsZXMvZ2x0Zi12aWV3ZXIvbG9hZGVyL3ByaW1pdGl2ZS1sb2FkZXIudHM/MGY1NyIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvc2FtcGxlcy9nbHRmLXZpZXdlci9sb2FkZXIvbWF0ZXJpYWwtbG9hZGVyLnRzP2FkYTAiLCJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3JlbmRlcmluZy9kZWZhdWx0LWZvcndhcmQtcGFzcy9tYXRlcmlhbC1kcmF3LWRhdGEudHM/Mzg5YSIsIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL2dlb21ldHJ5LXBpcGVsaW5lLnRzP2IzZWIiLCJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3NhbXBsZXMvZ2x0Zi12aWV3ZXIvbG9hZGVyL2dsdGYtbG9hZGVyLnRzPzcwN2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEF0dHJpYnV0ZVdyYXBwZXIgZnJvbSAnLi9hdHRyaWJ1dGUtd3JhcHBlcic7XG5cbi8qKlxuICogQWRhcHRlZCBmcm9tIGdsdGYtdHJhbnNmb3JtJ3MgdmVyc2lvbjpcbiAqIGdpdGh1Yi5jb20vZG9ubWNjdXJkeS9nbFRGLVRyYW5zZm9ybS9ibG9iL21haW4vcGFja2FnZXMvZnVuY3Rpb25zL3NyYy93ZWxkLnRzXG4gKi9cbmNsYXNzIEhhc2hUYWJsZSB7XG4gICAgcHJpdmF0ZSBhdHRyaWJ1dGVzOiB7IHU4OiBVaW50OEFycmF5LCBieXRlU3RyaWRlOiBudW1iZXIgfVtdID0gW107XG4gICAgcHJpdmF0ZSB1ODogVWludDhBcnJheTtcbiAgICBwcml2YXRlIHUzMjogVWludDMyQXJyYXk7XG5cbiAgICBjb25zdHJ1Y3RvcihwcmltOiBSZWNvcmQ8c3RyaW5nLCBBdHRyaWJ1dGVXcmFwcGVyPikge1xuICAgICAgICBsZXQgYnl0ZVN0cmlkZSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIE9iamVjdC52YWx1ZXMocHJpbSkpIHtcbiAgICAgICAgICAgIGJ5dGVTdHJpZGUgKz0gdGhpcy5pbml0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFkZGVkQnl0ZVN0cmlkZSA9IChieXRlU3RyaWRlICsgMykgJiB+MztcbiAgICAgICAgdGhpcy51OCA9IG5ldyBVaW50OEFycmF5KHBhZGRlZEJ5dGVTdHJpZGUpO1xuICAgICAgICB0aGlzLnUzMiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnU4LmJ1ZmZlcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0QXR0cmlidXRlKGF0dHJpYnV0ZTogQXR0cmlidXRlV3JhcHBlcik6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHU4ID0gYXR0cmlidXRlLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgICAgICA/IGF0dHJpYnV0ZS5kYXRhXG4gICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KGF0dHJpYnV0ZS5kYXRhLmJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGJ5dGVTdHJpZGUgPSBhdHRyaWJ1dGUuYnl0ZXNQZXJDb21wb25lbnQgKiBhdHRyaWJ1dGUuY29tcG9uZW50c1BlckVsZW1lbnQ7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHsgdTgsIGJ5dGVTdHJpZGUgfSk7XG4gICAgICAgIHJldHVybiBieXRlU3RyaWRlO1xuICAgIH1cblxuICAgIGhhc2goaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGxldCBieXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB7IHU4LCBieXRlU3RyaWRlIH0gb2YgdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVTdHJpZGU7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMudThbYnl0ZU9mZnNldCArIGldID0gdThbaW5kZXggKiBieXRlU3RyaWRlICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieXRlT2Zmc2V0ICs9IGJ5dGVTdHJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubXVybXVySGFzaDIoKTtcbiAgICB9XG5cbiAgICBlcXVhbChhOiBudW1iZXIsIGI6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBmb3IgKGNvbnN0IHsgdTgsIGJ5dGVTdHJpZGUgfSBvZiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYnl0ZVN0cmlkZTsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHU4W2EgKiBieXRlU3RyaWRlICsgal0gIT09IHU4W2IgKiBieXRlU3RyaWRlICsgal0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBoYXNoTG9va3VwKHRhYmxlOiBUeXBlZEFycmF5LCBidWNrZXRzOiBudW1iZXIsIGtleTogbnVtYmVyLCBlbXB0eTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgaGFzaG1vZCA9IGJ1Y2tldHMgLSAxO1xuICAgICAgICBjb25zdCBoYXNodmFsID0gdGhpcy5oYXNoKGtleSk7XG4gICAgICAgIGxldCBidWNrZXQgPSBoYXNodmFsICYgaGFzaG1vZDtcblxuICAgICAgICBmb3IgKGxldCBwcm9iZSA9IDA7IHByb2JlIDw9IGhhc2htb2Q7IHByb2JlICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YWJsZVtidWNrZXRdO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gZW1wdHkgfHwgdGhpcy5lcXVhbChpdGVtLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1Y2tldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVja2V0ID0gKGJ1Y2tldCArIHByb2JlICsgMSkgJiBoYXNobW9kOyAvLyBIYXNoIGNvbGxpc2lvbi5cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCB0YWJsZSBmdWxsLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZXM6XG4gICAgICogLSBodHRwczovL2dpdGh1Yi5jb20vbWlrb2xhbHlzZW5rby9tdXJtdXJoYXNoLWpzL2Jsb2IvZjE5MTM2ZTlmOWMxN2Y4Y2RkYzIxNmNhM2Q0NGVjN2M1YzUwMmY2MC9tdXJtdXJoYXNoMl9nYy5qcyNMMTRcbiAgICAgKiAtIGh0dHBzOi8vZ2l0aHViLmNvbS96ZXV4L21lc2hvcHRpbWl6ZXIvYmxvYi9lNDdlMWJlNmQzZDk1MTMxNTMxODgyMTY0NTViZGJlZDQwYTIwNmVmL3NyYy9pbmRleGdlbmVyYXRvci5jcHAjTDEyXG4gICAgICovXG4gICAgbXVybXVySGFzaDIoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgbSA9IDB4NWJkMWU5OTU7XG4gICAgICAgIGNvbnN0IHIgPSAyNDtcbiAgICAgICAgbGV0IGggPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGsgb2YgdGhpcy51MzIpIHtcbiAgICAgICAgICAgIGsgPSBNYXRoLmltdWwoaywgbSkgPj4+IDA7XG4gICAgICAgICAgICBrID0gKGsgXiAoayA+PiByKSkgPj4+IDA7XG4gICAgICAgICAgICBrID0gTWF0aC5pbXVsKGssIG0pID4+PiAwO1xuXG4gICAgICAgICAgICBoID0gTWF0aC5pbXVsKGgsIG0pID4+PiAwO1xuICAgICAgICAgICAgaCA9IChoIF4gaykgPj4+IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNlaWxQb3dlck9mVHdvKHZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiAyICoqIE1hdGguY2VpbChNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG59XG5cbi8qKlxuICogV2VsZCBhbmQgbWVyZ2UsIGNvbWJpbmluZyB2ZXJ0aWNlcyB0aGF0IGFyZSBiaXR3aXNlLWVxdWFsLlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBnbHRmLXRyYW5zZm9ybSdzIF93ZWxkUHJpbWl0aXZlU3RyaWN0OlxuICogZ2l0aHViLmNvbS9kb25tY2N1cmR5L2dsVEYtVHJhbnNmb3JtL2Jsb2IvbWFpbi9wYWNrYWdlcy9mdW5jdGlvbnMvc3JjL3dlbGQudHMjTDE5M1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3ZWxkKHByaW06IFJlY29yZDxzdHJpbmcsIEF0dHJpYnV0ZVdyYXBwZXI+KSB7XG4gICAgY29uc3Qgc3JjVmVydGV4Q291bnQgPSBwcmltLlBPU0lUSU9OLmNvdW50O1xuICAgIGNvbnN0IGhhc2ggPSBuZXcgSGFzaFRhYmxlKHByaW0pO1xuICAgIGNvbnN0IHRhYmxlU2l6ZSA9IGNlaWxQb3dlck9mVHdvKHNyY1ZlcnRleENvdW50ICsgKHNyY1ZlcnRleENvdW50IC8gNCkpO1xuICAgIGNvbnN0IGlzMTZCaXQgPSBzcmNWZXJ0ZXhDb3VudCA8ICgyICoqIDE2IC0gMSk7XG4gICAgY29uc3QgZW1wdHkgPSAyICoqIChpczE2Qml0ID8gMTYgOiAzMikgLSAxO1xuICAgIGNvbnN0IGluZGV4Rm9ybWF0OiBHUFVJbmRleEZvcm1hdCA9IGlzMTZCaXQgPyAndWludDE2JyA6ICd1aW50MzInO1xuICAgIGNvbnN0IHdyaXRlTWFwID0gaXMxNkJpdCA/IG5ldyBVaW50MTZBcnJheShzcmNWZXJ0ZXhDb3VudCkgOiBuZXcgVWludDMyQXJyYXkoc3JjVmVydGV4Q291bnQpO1xuICAgIGNvbnN0IHRhYmxlID0gaXMxNkJpdCA/IG5ldyBVaW50MTZBcnJheSh0YWJsZVNpemUpIDogbmV3IFVpbnQzMkFycmF5KHRhYmxlU2l6ZSk7XG4gICAgdGFibGUuZmlsbChlbXB0eSk7XG5cbiAgICBsZXQgZHN0VmVydGV4Q291bnQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmNWZXJ0ZXhDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGhhc2hJbmRleCA9IGhhc2guaGFzaExvb2t1cCh0YWJsZSwgdGFibGVTaXplLCBpLCBlbXB0eSk7XG4gICAgICAgIGNvbnN0IGRzdEluZGV4ID0gdGFibGVbaGFzaEluZGV4XTtcblxuICAgICAgICBpZiAoZHN0SW5kZXggPT09IGVtcHR5KSB7XG4gICAgICAgICAgICB0YWJsZVtoYXNoSW5kZXhdID0gaTtcbiAgICAgICAgICAgIHdyaXRlTWFwW2ldID0gZHN0VmVydGV4Q291bnQ7XG4gICAgICAgICAgICBkc3RWZXJ0ZXhDb3VudCArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JpdGVNYXBbaV0gPSB3cml0ZU1hcFtkc3RJbmRleF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBPYmplY3QudmFsdWVzKHByaW0pKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5yZW1hcCh3cml0ZU1hcCwgZHN0VmVydGV4Q291bnQpO1xuICAgIH1cblxuICAgIC8vIFRoZSBnbHRmLXRyYW5zZm9ybSB2ZXJzaW9uIGNoZWNrcyBmb3IgZGVnZW5lcmF0ZSB0cmlhbmdsZXMgdG8gcmVtb3ZlLlxuICAgIC8vIFRoaXMgaXMgb21pdHRlZCBoZXJlLlxuICAgIHJldHVybiB7IGluZGV4QXJyYXk6IHdyaXRlTWFwLCBpbmRleEZvcm1hdCwgdmVydGV4Q291bnQ6IGRzdFZlcnRleENvdW50IH07XG59XG4iLCJpbXBvcnQgeyBtYXQzLCBtYXQ0LCBNYXQzLCBNYXQ0IH0gZnJvbSAnd2dwdS1tYXRyaXgnO1xuXG5pbXBvcnQgeyBUeXBlU2l6ZXMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY3JlYXRlQW5kQ29weUJ1ZmZlciB9IGZyb20gJy4uLy4uL3V0aWxzL2RhdGEtY29weSc7XG5pbXBvcnQgeyBQaXBlbGluZUZlYXR1cmVGbGFncyB9IGZyb20gJy4vcGlwZWxpbmUtZmVhdHVyZS1mbGFncyc7XG5pbXBvcnQgRGVzY3JpcHRvck1hcCBmcm9tICcuL2Rlc2NyaXB0b3ItbWFwJztcblxuZXhwb3J0IHR5cGUgUHJpbWl0aXZlRGVzY3JpcHRvciA9IHtcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIC8vIHZlcnRleEJ1ZmZlckxheW91dHM6IEdQVVZlcnRleEJ1ZmZlckxheW91dDtcbiAgICBmZWF0dXJlczogUGlwZWxpbmVGZWF0dXJlRmxhZ3MsXG4gICAgdmVydGV4Q291bnQ6IG51bWJlcixcbiAgICB2ZXJ0ZXhBcnJheTogQXJyYXlCdWZmZXIgfCBUeXBlZEFycmF5IHwgR1BVQnVmZmVyLFxuICAgIGluZGV4QXJyYXk/OiBBcnJheUJ1ZmZlciB8IFR5cGVkQXJyYXksXG4gICAgaW5kZXhGb3JtYXQ/OiBHUFVJbmRleEZvcm1hdCxcbn07XG5cbmV4cG9ydCB0eXBlIEluZGV4RGF0YSA9IHtcbiAgICBpbmRleEJ1ZmZlcjogR1BVQnVmZmVyLFxuICAgIGluZGV4Q291bnQ6IG51bWJlcixcbiAgICBpbmRleEZvcm1hdDogR1BVSW5kZXhGb3JtYXQsXG59O1xuXG5leHBvcnQgY2xhc3MgUHJpbWl0aXZlRHJhd0RhdGEge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB2ZXJ0ZXhCdWZmZXI6IEdQVUJ1ZmZlcjtcbiAgICBpbmRleERhdGE/OiBJbmRleERhdGE7XG4gICAgaW5zdGFuY2VCdWZmZXI6IEdQVUJ1ZmZlcjtcbiAgICBpbnN0YW5jZUJpbmRHcm91cDogR1BVQmluZEdyb3VwO1xuICAgIHZlcnRleENvdW50OiBudW1iZXI7XG4gICAgZmVhdHVyZXM6IG51bWJlcjtcblxuICAgIGluc3RhbmNlU2l6ZTogbnVtYmVyO1xuXG4gICAgaW5zdGFuY2VzOiBBcnJheUJ1ZmZlcjtcbiAgICBtb2RlbE1hdHJpY2VzOiBNYXQ0W107XG4gICAgbm9ybWFsTWF0cmljZXMhOiBNYXQzW107XG4gICAgbWF4OiBudW1iZXI7XG5cbiAgICBpbnN0YW5jZUNvdW50OiBudW1iZXIgPSAwO1xuICAgIGRpcnR5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpbWl0aXZlOiBQcmltaXRpdmVEZXNjcmlwdG9yLFxuICAgICAgICBkZXZpY2U6IEdQVURldmljZSxcbiAgICAgICAgbWF4OiBudW1iZXIsXG4gICAgICAgIGRlc2NyaXB0b3JNYXA6IERlc2NyaXB0b3JNYXAsXG4gICAgICAgIGluc3RhbmNlcz86IE1hdDRbXSxcbiAgICApIHtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBwcmltaXRpdmUuZmVhdHVyZXM7XG4gICAgICAgIHRoaXMubmFtZSA9IHByaW1pdGl2ZS5uYW1lID8/ICdtZXNoJztcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IHByaW1pdGl2ZS52ZXJ0ZXhDb3VudDtcblxuICAgICAgICBpZiAocHJpbWl0aXZlLnZlcnRleEFycmF5IGluc3RhbmNlb2YgR1BVQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IHByaW1pdGl2ZS52ZXJ0ZXhBcnJheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gY3JlYXRlQW5kQ29weUJ1ZmZlcihcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUudmVydGV4QXJyYXksXG4gICAgICAgICAgICAgICAgR1BVQnVmZmVyVXNhZ2UuVkVSVEVYLFxuICAgICAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgICAgICBgJHt0aGlzLm5hbWV9IHZlcnRleCBidWZmZXJgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmltaXRpdmUuaW5kZXhBcnJheSAmJiBwcmltaXRpdmUuaW5kZXhGb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXhBcnJheSwgaW5kZXhGb3JtYXQgfSA9IHByaW1pdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhEYXRhID0ge1xuICAgICAgICAgICAgICAgIGluZGV4Rm9ybWF0LFxuICAgICAgICAgICAgICAgIGluZGV4Q291bnQ6IGluZGV4QXJyYXkuYnl0ZUxlbmd0aCAvIChpbmRleEZvcm1hdCA9PT0gJ3VpbnQxNicgPyAyIDogNCksXG4gICAgICAgICAgICAgICAgaW5kZXhCdWZmZXI6IGNyZWF0ZUFuZENvcHlCdWZmZXIoXG4gICAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5pbmRleEFycmF5LFxuICAgICAgICAgICAgICAgICAgICBHUFVCdWZmZXJVc2FnZS5JTkRFWCxcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLm5hbWV9IGluZGV4IGJ1ZmZlcmAsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluc3RhbmNlU2l6ZSA9IFR5cGVTaXplcy5zaXplb2ZNYXQ0eDRmO1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlcyAmIFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleE5vcm1hbHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VTaXplICs9IDEyICogNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IEFycmF5QnVmZmVyKG1heCAqIHRoaXMuaW5zdGFuY2VTaXplKTtcbiAgICAgICAgdGhpcy5tb2RlbE1hdHJpY2VzID0gbmV3IEFycmF5KG1heCkgYXMgRmxvYXQzMkFycmF5W107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIHRoaXMuaW5zdGFuY2VTaXplO1xuICAgICAgICAgICAgdGhpcy5tb2RlbE1hdHJpY2VzW2ldID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmluc3RhbmNlcywgb2Zmc2V0LCAxNik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mZWF0dXJlcyAmIFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleE5vcm1hbHMpIHtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsTWF0cmljZXMgPSBuZXcgQXJyYXkobWF4KSBhcyBGbG9hdDMyQXJyYXlbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IChpICogdGhpcy5pbnN0YW5jZVNpemUpICsgVHlwZVNpemVzLnNpemVvZk1hdDR4NGY7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxNYXRyaWNlc1tpXSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5pbnN0YW5jZXMsIG9mZnNldCwgMTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnN0YW5jZUJ1ZmZlciA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICAgICAgbGFiZWw6IGAke3RoaXMubmFtZX0gaW5zdGFuY2UgYnVmZmVyYCxcbiAgICAgICAgICAgIHNpemU6IHRoaXMuaW5zdGFuY2VzLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pbnN0YW5jZUJpbmRHcm91cCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICAgICAgbGFiZWw6IGBQcmltaXRpdmVEcmF3RGF0YSBpbnN0YW5jZSBiaW5kIGdyb3VwYCxcbiAgICAgICAgICAgIGxheW91dDogZGVzY3JpcHRvck1hcC5mb3J3YXJkQmluZGdyb3VwTGF5b3V0LFxuICAgICAgICAgICAgZW50cmllczogW3tcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgIHJlc291cmNlOiB7IGJ1ZmZlcjogdGhpcy5pbnN0YW5jZUJ1ZmZlciB9LFxuICAgICAgICAgICAgfV0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmF3KHBhc3NFbmNvZGVyOiBHUFVSZW5kZXJQYXNzRW5jb2RlciwgcXVldWU6IEdQVVF1ZXVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICBxdWV1ZS53cml0ZUJ1ZmZlcih0aGlzLmluc3RhbmNlQnVmZmVyLCAwLCB0aGlzLmluc3RhbmNlcyk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBwYXNzRW5jb2Rlci5zZXRWZXJ0ZXhCdWZmZXIoMCwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgICAgICBwYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMiwgdGhpcy5pbnN0YW5jZUJpbmRHcm91cCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5kZXhEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXhCdWZmZXIsIGluZGV4Q291bnQsIGluZGV4Rm9ybWF0IH0gPSB0aGlzLmluZGV4RGF0YTtcbiAgICAgICAgICAgIHBhc3NFbmNvZGVyLnNldEluZGV4QnVmZmVyKGluZGV4QnVmZmVyLCBpbmRleEZvcm1hdCk7XG4gICAgICAgICAgICBwYXNzRW5jb2Rlci5kcmF3SW5kZXhlZChpbmRleENvdW50LCB0aGlzLmluc3RhbmNlQ291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFzc0VuY29kZXIuZHJhdyh0aGlzLnZlcnRleENvdW50LCB0aGlzLmluc3RhbmNlQ291bnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkSW5zdGFuY2UodHJhbnNmb3JtOiBNYXQ0KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlQ291bnQgPT09IHRoaXMubWF4KSByZXR1cm47XG4gICAgICAgIG1hdDQuY29weSh0cmFuc2Zvcm0sIHRoaXMubW9kZWxNYXRyaWNlc1t0aGlzLmluc3RhbmNlQ291bnRdKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVOb3JtYWxNYXRyaXgodGhpcy5pbnN0YW5jZUNvdW50KTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZUNvdW50ICs9IDE7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZU5vcm1hbE1hdHJpeChpZHg6IG51bWJlcikge1xuICAgICAgICBpZiAoISh0aGlzLmZlYXR1cmVzICYgUGlwZWxpbmVGZWF0dXJlRmxhZ3MuVmVydGV4Tm9ybWFscykpIHJldHVybjtcbiAgICAgICAgY29uc3Qgbm9ybWFsTWF0cml4ID0gdGhpcy5ub3JtYWxNYXRyaWNlc1tpZHhdO1xuICAgICAgICBtYXQzLmZyb21NYXQ0KHRoaXMubW9kZWxNYXRyaWNlc1tpZHhdLCBub3JtYWxNYXRyaXgpO1xuICAgICAgICBtYXQzLmludmVydChub3JtYWxNYXRyaXgsIG5vcm1hbE1hdHJpeCk7XG4gICAgICAgIG1hdDMudHJhbnNwb3NlKG5vcm1hbE1hdHJpeCwgbm9ybWFsTWF0cml4KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IEdMVEYgfSBmcm9tICcuLi8uLi8uLi9pbmNsdWRlL2dsdGYnO1xuaW1wb3J0IHsgUGlwZWxpbmVGZWF0dXJlRmxhZ3MgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvZGVmYXVsdC1mb3J3YXJkLXBhc3MvcGlwZWxpbmUtZmVhdHVyZS1mbGFncyc7XG5cbmV4cG9ydCB0eXBlIEF0dHJpYnV0ZURldGFpbHMgPSB7XG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHR5cGU6IEdMVEYuQWNjZXNzb3JUeXBlLFxuICAgIGNvbXBvbmVudFR5cGU6IEdMVEYuQWNjZXNzb3JDb21wb25lbnRUeXBlLFxuICAgIHN0cmlwPzogYm9vbGVhbixcbiAgICBkZXBlbmRzPzogc3RyaW5nW10sXG4gICAgZmVhdHVyZT86IFBpcGVsaW5lRmVhdHVyZUZsYWdzLFxuICAgIGZpbGw/OiBudW1iZXJbXSxcbn07XG5cbmV4cG9ydCBjb25zdCBlbnVtIENvbXBvbmVudFR5cGUge1xuICAgIGludDggPSA1MTIwLFxuICAgIHVpbnQ4ID0gNTEyMSxcbiAgICBpbnQxNiA9IDUxMjIsXG4gICAgdWludDE2ID0gNTEyMyxcbiAgICB1aW50MzIgPSA1MTI1LFxuICAgIGZsb2F0MzIgPSA1MTI2LFxufVxuXG5leHBvcnQgY29uc3QgdHlwZVRvRWxlbWVudENvdW50OiBSZWNvcmQ8R0xURi5BY2Nlc3NvclR5cGUsIG51bWJlcj4gPSB7XG4gICAgU0NBTEFSOiAxLFxuICAgIFZFQzI6IDIsXG4gICAgVkVDMzogMyxcbiAgICBWRUM0OiA0LFxuICAgIE1BVDI6IDQsXG4gICAgTUFUMzogMTIsXG4gICAgTUFUNDogMTYsXG59O1xuXG5leHBvcnQgY29uc3QgY29tcG9uZW50VG9TaXplOiBSZWNvcmQ8Q29tcG9uZW50VHlwZSwgbnVtYmVyPiA9IHtcbiAgICBbQ29tcG9uZW50VHlwZS5pbnQ4XTogMSxcbiAgICBbQ29tcG9uZW50VHlwZS51aW50OF06IDEsXG4gICAgW0NvbXBvbmVudFR5cGUuaW50MTZdOiAyLFxuICAgIFtDb21wb25lbnRUeXBlLnVpbnQxNl06IDIsXG4gICAgW0NvbXBvbmVudFR5cGUudWludDMyXTogNCxcbiAgICBbQ29tcG9uZW50VHlwZS5mbG9hdDMyXTogNCxcbn07XG5cbmV4cG9ydCBjb25zdCBlbnVtIFRvcG9sb2d5TW9kZSB7XG4gICAgUG9pbnRzID0gMCxcbiAgICBMaW5lTGlzdCA9IDEsXG4gICAgTGluZUxvb3AgPSAyLFxuICAgIExpbmVTdHJpcCA9IDMsXG4gICAgVHJpYW5nbGVMaXN0ID0gNCxcbiAgICBUcmlhbmdsZVN0cmlwID0gNSxcbiAgICBUcmlhbmdsZUZhbiA9IDYsXG59XG5cbmV4cG9ydCBjb25zdCBtb2RlVG9Ub3BvbG9neTogUGFydGlhbDxSZWNvcmQ8VG9wb2xvZ3lNb2RlLCBQaXBlbGluZUZlYXR1cmVGbGFncz4+ID0ge1xuICAgIFtUb3BvbG9neU1vZGUuUG9pbnRzXTogUGlwZWxpbmVGZWF0dXJlRmxhZ3MuUG9pbnRMaXN0LCAvLyBQT0lOVFNcbiAgICBbVG9wb2xvZ3lNb2RlLkxpbmVMaXN0XTogUGlwZWxpbmVGZWF0dXJlRmxhZ3MuTGluZUxpc3QsIC8vIExJTkVTXG4gICAgLy8gMjogTElORV9MT09QICh1bnN1cHBvcnRlZCBieSB3ZWJncHUpXG4gICAgLy8gMzogUGlwZWxpbmVGZWF0dXJlRmxhZ3MuTGluZVN0cmlwLCAvLyBMSU5FX1NUUklQXG4gICAgW1RvcG9sb2d5TW9kZS5UcmlhbmdsZUxpc3RdOiBQaXBlbGluZUZlYXR1cmVGbGFncy5UcmlhbmdsZUxpc3QsIC8vIFRSSUFOR0xFU1xuICAgIC8vIDU6IFBpcGVsaW5lRmVhdHVyZUZsYWdzLlRyaWFuZ2xlU3RyaXAsIC8vIFRSSUFOR0xFX1NUUklQXG4gICAgLy8gNjogVFJJQU5HTEVfRkFOICh1bnN1cHBvcnRlZCBieSB3ZWJncHUpXG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAqL1xuXG5pbXBvcnQgeyBHTFRGQWNjZXNzb3JQb3N0cHJvY2Vzc2VkIH0gZnJvbSAnQGxvYWRlcnMuZ2wvZ2x0Zic7XG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAnLi90eXBlLWNvbnZlcnNpb25zJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlV3JhcHBlciB7XG4gICAgZGF0YTogVHlwZWRBcnJheTtcbiAgICBwcm9jZXNzZWQ6IGJvb2xlYW47XG4gICAgY29tcG9uZW50c1BlckVsZW1lbnQ6IG51bWJlcjtcbiAgICBieXRlc1BlckNvbXBvbmVudDogbnVtYmVyO1xuICAgIGNvdW50OiBudW1iZXI7XG5cbiAgICBjb3B5RnJvbTogKHNyY0lkeDogbnVtYmVyLCBkc3RJZHg6IG51bWJlciwgZHN0OiBGbG9hdDMyQXJyYXkpID0+IHZvaWQ7XG5cbiAgICBhdD86IChpOiBudW1iZXIsIGo6IG51bWJlcikgPT4gbnVtYmVyO1xuICAgIHZpZXc/OiBEYXRhVmlldztcblxuICAgIHVud2VsZGVkID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihhY2Nlc3NvcjogR0xURkFjY2Vzc29yUG9zdHByb2Nlc3NlZCk7XG4gICAgY29uc3RydWN0b3IoYXJyYXk6IEZsb2F0MzJBcnJheSwgY29tcG9uZW50Q291bnQ6IG51bWJlcik7XG5cbiAgICBjb25zdHJ1Y3RvcihhY2Nlc3NvcjogR0xURkFjY2Vzc29yUG9zdHByb2Nlc3NlZCB8IEZsb2F0MzJBcnJheSwgY29tcG9uZW50Q291bnQ/OiBudW1iZXIpIHtcbiAgICAgICAgaWYgKGFjY2Vzc29yIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBhY2Nlc3NvcjtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1BlckVsZW1lbnQgPSBjb21wb25lbnRDb3VudCE7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gYWNjZXNzb3IubGVuZ3RoIC8gY29tcG9uZW50Q291bnQhO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ieXRlc1BlckNvbXBvbmVudCA9IDQ7XG4gICAgICAgICAgICB0aGlzLmNvcHlGcm9tID0gdGhpcy5jb3B5UHJvY2Vzc2VkLmJpbmQodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBhY2Nlc3Nvci52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1BlckVsZW1lbnQgPSBhY2Nlc3Nvci5jb21wb25lbnRzO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IGFjY2Vzc29yLmNvdW50O1xuICAgICAgICAgICAgdGhpcy5ieXRlc1BlckNvbXBvbmVudCA9IGFjY2Vzc29yLmJ5dGVzUGVyQ29tcG9uZW50O1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuY29weUZyb20gPSB0aGlzLmNvcHlVbnByb2Nlc3NlZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGFjY2Vzc29yLmNvbXBvbmVudFR5cGUgYXMgQ29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ29tcG9uZW50VHlwZS5pbnQ4OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXQgPSAoaSwgaikgPT4gdGhpcy52aWV3IS5nZXRJbnQ4KGkgKiB0aGlzLmNvbXBvbmVudHNQZXJFbGVtZW50ICsgaik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIENvbXBvbmVudFR5cGUudWludDg6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdCA9IChpLCBqKSA9PiB0aGlzLnZpZXchLmdldFVpbnQ4KGkgKiB0aGlzLmNvbXBvbmVudHNQZXJFbGVtZW50ICsgaik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIENvbXBvbmVudFR5cGUuaW50MTY6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdCA9IChpLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAyICogKGkgKiB0aGlzLmNvbXBvbmVudHNQZXJFbGVtZW50ICsgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3IS5nZXRJbnQxNihvZmZzZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBDb21wb25lbnRUeXBlLnVpbnQxNjoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0ID0gKGksIGopID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IDIgKiAoaSAqIHRoaXMuY29tcG9uZW50c1BlckVsZW1lbnQgKyBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXchLmdldFVpbnQxNihvZmZzZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBDb21wb25lbnRUeXBlLnVpbnQzMjoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0ID0gKGksIGopID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IDQgKiAoaSAqIHRoaXMuY29tcG9uZW50c1BlckVsZW1lbnQgKyBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXchLmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBDb21wb25lbnRUeXBlLmZsb2F0MzI6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdCA9IChpLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSA0ICogKGkgKiB0aGlzLmNvbXBvbmVudHNQZXJFbGVtZW50ICsgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3IS5nZXRGbG9hdDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYGdsdGYgaW1wb3J0ZXIgLS0gaW52YWxpZCBjb21wb25lbnRUeXBlICR7YWNjZXNzb3IuY29tcG9uZW50VHlwZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsOiBudW1iZXI7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhY2Nlc3Nvci5jb21wb25lbnRUeXBlIGFzIENvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb21wb25lbnRUeXBlLnVpbnQ4OiB2YWwgPSAyNTU7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENvbXBvbmVudFR5cGUuaW50ODogdmFsID0gMTI3OyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb21wb25lbnRUeXBlLnVpbnQxNjogdmFsID0gNjU1MzU7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENvbXBvbmVudFR5cGUuaW50MTY6IHZhbCA9IDMyNzY3OyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb21wb25lbnRUeXBlLnVpbnQzMjogdmFsID0gNDI5NDk2NzI5NTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgZ2x0ZiBpbXBvcnRlciAtLSBpbnZhbGlkIGNvbXBvbmVudFR5cGUgJHthY2Nlc3Nvci5jb21wb25lbnRUeXBlfWApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYXQgPSAoaSwgaikgPT4gdGhpcy5hdCEoaSwgaikgLyB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgYXJyYXkoKTogRmxvYXQzMkFycmF5IHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NlZCkgdGhpcy5wcm9jZXNzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgYXMgRmxvYXQzMkFycmF5O1xuICAgIH1cblxuICAgIGNvcHlQcm9jZXNzZWQoc3JjSWR4OiBudW1iZXIsIGRzdElkeDogbnVtYmVyLCBkc3Q6IEZsb2F0MzJBcnJheSkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29tcG9uZW50c1BlckVsZW1lbnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgZHN0W2RzdElkeCArIGpdID0gdGhpcy5kYXRhWyhzcmNJZHggKiB0aGlzLmNvbXBvbmVudHNQZXJFbGVtZW50KSArIGpdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29weVVucHJvY2Vzc2VkKHNyY0lkeDogbnVtYmVyLCBkc3RJZHg6IG51bWJlciwgZHN0OiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbXBvbmVudHNQZXJFbGVtZW50OyBqICs9IDEpIHtcbiAgICAgICAgICAgIGRzdFtkc3RJZHggKyBqXSA9IHRoaXMuYXQhKHNyY0lkeCwgaik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYXJrUHJvY2Vzc2VkKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29weUZyb20gPSB0aGlzLmNvcHlQcm9jZXNzZWQuYmluZCh0aGlzKTtcbiAgICAgICAgZGVsZXRlIHRoaXMudmlldztcbiAgICAgICAgZGVsZXRlIHRoaXMuYXQ7XG4gICAgfVxuXG4gICAgcHJvY2VzcygpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IG5ld1ZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY291bnQgKiB0aGlzLmNvbXBvbmVudHNQZXJFbGVtZW50KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5jb3B5RnJvbShpLCBpICogdGhpcy5jb21wb25lbnRzUGVyRWxlbWVudCwgbmV3Vmlldyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGEgPSBuZXdWaWV3O1xuICAgICAgICB0aGlzLm1hcmtQcm9jZXNzZWQoKTtcbiAgICB9XG5cbiAgICB1bndlbGQoaW5kZXhBcnJheTogVHlwZWRBcnJheSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy51bndlbGRlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnVud2VsZGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbmV3VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoaW5kZXhBcnJheS5sZW5ndGggKiB0aGlzLmNvbXBvbmVudHNQZXJFbGVtZW50KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4QXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY29weUZyb20oaW5kZXhBcnJheVtpXSwgaSAqIHRoaXMuY29tcG9uZW50c1BlckVsZW1lbnQsIG5ld1ZpZXcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb3VudCA9IGluZGV4QXJyYXkubGVuZ3RoO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXdWaWV3O1xuICAgICAgICB0aGlzLm1hcmtQcm9jZXNzZWQoKTtcbiAgICB9XG5cbiAgICByZW1hcChyZW1hcDogVHlwZWRBcnJheSwgZHN0Q291bnQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBkc3RBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoZHN0Q291bnQgKiB0aGlzLmNvbXBvbmVudHNQZXJFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZG9uZSA9IG5ldyBVaW50OEFycmF5KGRzdENvdW50KTtcblxuICAgICAgICBmb3IgKGxldCBzcmNJbmRleCA9IDA7IHNyY0luZGV4IDwgdGhpcy5jb3VudDsgc3JjSW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgZHN0SW5kZXggPSByZW1hcFtzcmNJbmRleF07XG4gICAgICAgICAgICBpZiAoZG9uZVtkc3RJbmRleF0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5jb3B5RnJvbShzcmNJbmRleCwgZHN0SW5kZXggKiB0aGlzLmNvbXBvbmVudHNQZXJFbGVtZW50LCBkc3RBcnJheSk7XG4gICAgICAgICAgICBkb25lW2RzdEluZGV4XSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGEgPSBkc3RBcnJheTtcbiAgICAgICAgdGhpcy5tYXJrUHJvY2Vzc2VkKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEF0dHJpYnV0ZVdyYXBwZXIgZnJvbSAnLi9hdHRyaWJ1dGUtd3JhcHBlcic7XG5pbXBvcnQgeyBQaXBlbGluZUZlYXR1cmVGbGFncyB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9kZWZhdWx0LWZvcndhcmQtcGFzcy9waXBlbGluZS1mZWF0dXJlLWZsYWdzJztcblxuLy8gY29uc3QgZ29hbExheW91dDogQXR0cmlidXRlRGV0YWlsc1tdID0gW1xuLy8gICAgIHtcbi8vICAgICAgICAgbmFtZTogJ1BPU0lUSU9OJyxcbi8vICAgICAgICAgdHlwZTogJ1ZFQzMnLFxuLy8gICAgICAgICBjb21wb25lbnRUeXBlOiBDb21wb25lbnRUeXBlLmZsb2F0MzIsXG4vLyAgICAgfSxcbi8vICAgICB7XG4vLyAgICAgICAgIG5hbWU6ICdURVhDT09SRF8wJyxcbi8vICAgICAgICAgdHlwZTogJ1ZFQzInLFxuLy8gICAgICAgICBjb21wb25lbnRUeXBlOiBDb21wb25lbnRUeXBlLmZsb2F0MzIsXG4vLyAgICAgfSxcbi8vICAgICB7XG4vLyAgICAgICAgIG5hbWU6ICdUQU5HRU5UJyxcbi8vICAgICAgICAgdHlwZTogJ1ZFQzQnLFxuLy8gICAgICAgICBjb21wb25lbnRUeXBlOiBDb21wb25lbnRUeXBlLmZsb2F0MzIsXG4vLyAgICAgICAgIGRlcGVuZHM6IFsnTk9STUFMJ10sXG4vLyAgICAgICAgIGZpbGw6IFsxLCAwLCAwLCAxXSxcbi8vICAgICB9LFxuLy8gICAgIHtcbi8vICAgICAgICAgbmFtZTogJ05PUk1BTCcsXG4vLyAgICAgICAgIHR5cGU6ICdWRUMzJyxcbi8vICAgICAgICAgY29tcG9uZW50VHlwZTogQ29tcG9uZW50VHlwZS5mbG9hdDMyLFxuLy8gICAgICAgICBzdHJpcDogdHJ1ZSxcbi8vICAgICAgICAgZmVhdHVyZTogUGlwZWxpbmVGZWF0dXJlRmxhZ3MuVmVydGV4Tm9ybWFscyxcbi8vICAgICB9LFxuLy8gICAgIHtcbi8vICAgICAgICAgbmFtZTogJ0NPTE9SXzAnLFxuLy8gICAgICAgICB0eXBlOiAnVkVDNCcsXG4vLyAgICAgICAgIGNvbXBvbmVudFR5cGU6IENvbXBvbmVudFR5cGUuZmxvYXQzMixcbi8vICAgICAgICAgc3RyaXA6IHRydWUsXG4vLyAgICAgICAgIGZlYXR1cmU6IFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleENvbG9ycyxcbi8vICAgICAgICAgZmlsbDogWzEsIDEsIDEsIDFdLFxuLy8gICAgIH0sXG4vLyBdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnRlcmxlYXZlVmVydGljZXMoXG4gICAgYXR0cmlidXRlczogUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCBBdHRyaWJ1dGVXcmFwcGVyPj4sXG4gICAgY291bnQ6IG51bWJlcixcbikge1xuICAgIGxldCB2ZXJ0ZXhGZWF0dXJlczogUGlwZWxpbmVGZWF0dXJlRmxhZ3MgPSBQaXBlbGluZUZlYXR1cmVGbGFncy5EZWZhdWx0cztcbiAgICBsZXQgc3RyaWRlID0gNTtcbiAgICBpZiAoYXR0cmlidXRlcy5OT1JNQUwgIT0gbnVsbCkgc3RyaWRlICs9IDc7XG4gICAgaWYgKGF0dHJpYnV0ZXMuQ09MT1JfMCAhPSBudWxsKSBzdHJpZGUgKz0gNDtcblxuICAgIGNvbnN0IHZlcnRleEFycmF5ID0gbmV3IEFycmF5QnVmZmVyKHN0cmlkZSAqIGNvdW50ICogNCk7XG4gICAgY29uc3QgdmVydGV4VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4QXJyYXkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMuUE9TSVRJT04/LmNvcHlGcm9tKGksIHN0cmlkZSAqIGksIHZlcnRleFZpZXcpO1xuICAgIH1cblxuICAgIGNvbnN0IHV2ID0gYXR0cmlidXRlcy5URVhDT09SRF8wID8/IG5ldyBBdHRyaWJ1dGVXcmFwcGVyKG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiAyKSwgMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHV2LmNvcHlGcm9tKGksIGkgKiBzdHJpZGUgKyAzLCB2ZXJ0ZXhWaWV3KTtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlcy5OT1JNQUwgIT0gbnVsbCAmJiBhdHRyaWJ1dGVzLlRBTkdFTlQgIT0gbnVsbCkge1xuICAgICAgICB2ZXJ0ZXhGZWF0dXJlcyB8PSBQaXBlbGluZUZlYXR1cmVGbGFncy5WZXJ0ZXhOb3JtYWxzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5UQU5HRU5ULmNvcHlGcm9tKGksIGkgKiBzdHJpZGUgKyA1LCB2ZXJ0ZXhWaWV3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5OT1JNQUwuY29weUZyb20oaSwgaSAqIHN0cmlkZSArIDksIHZlcnRleFZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZXMuQ09MT1JfMCAhPSBudWxsKSB7XG4gICAgICAgIHZlcnRleEZlYXR1cmVzIHw9IFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleENvbG9ycztcbiAgICAgICAgY29uc3Qgc3RlcCA9IGF0dHJpYnV0ZXMuTk9STUFMICE9IG51bGwgPyAxMiA6IDU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5DT0xPUl8wLmNvcHlGcm9tKGksIGkgKiBzdHJpZGUgKyBzdGVwLCB2ZXJ0ZXhWaWV3KTtcbiAgICAgICAgICAgIHZlcnRleFZpZXdbaSAqIHN0cmlkZSArIHN0ZXAgKyAzXSA9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB2ZXJ0ZXhBcnJheSwgdmVydGV4RmVhdHVyZXMgfTtcbn1cbiIsImltcG9ydCB7IE1hdDQsIG1hdDQgfSBmcm9tICd3Z3B1LW1hdHJpeCc7XG5pbXBvcnQgeyBHTFRGQWNjZXNzb3JQb3N0cHJvY2Vzc2VkLCBHTFRGTWF0ZXJpYWxQb3N0cHJvY2Vzc2VkLCBHTFRGTWVzaFByaW1pdGl2ZVBvc3Rwcm9jZXNzZWQgfSBmcm9tICdAbG9hZGVycy5nbC9nbHRmJztcblxuaW1wb3J0IHdlbGQgZnJvbSAnLi93ZWxkJztcbmltcG9ydCB7IFBpcGVsaW5lRmVhdHVyZUZsYWdzIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL3BpcGVsaW5lLWZlYXR1cmUtZmxhZ3MnO1xuaW1wb3J0IHsgUHJpbWl0aXZlRHJhd0RhdGEgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvZGVmYXVsdC1mb3J3YXJkLXBhc3MvcHJpbWl0aXZlLWRyYXctZGF0YSc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVEZXRhaWxzLCBUb3BvbG9neU1vZGUsIG1vZGVUb1RvcG9sb2d5IH0gZnJvbSAnLi90eXBlLWNvbnZlcnNpb25zJztcbmltcG9ydCBEZXNjcmlwdG9yTWFwIGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9kZWZhdWx0LWZvcndhcmQtcGFzcy9kZXNjcmlwdG9yLW1hcCc7XG5pbXBvcnQgQXR0cmlidXRlV3JhcHBlciBmcm9tICcuL2F0dHJpYnV0ZS13cmFwcGVyJztcbmltcG9ydCBpbnRlcmxlYXZlVmVydGljZXMgZnJvbSAnLi9pbnRlcmxlYXZlLXZlcnRpY2VzJztcbmltcG9ydCB7IG1hcFZhbHVlcyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2dlbmVyYWwnO1xuXG5leHBvcnQgdHlwZSBOYW1lZEF0dHJpYnV0ZSA9ICdQT1NJVElPTicgfCAnTk9STUFMJyB8ICdUQU5HRU5UJztcbmV4cG9ydCB0eXBlIE51bWJlcmVkQXR0cmlidXRlID0gJ1RFWENPT1JEJyB8ICdDT0xPUicgfCAnSk9JTlRTJyB8ICdXRUlHSFRTJztcbmV4cG9ydCB0eXBlIFByaW1pdGl2ZUF0dHJpYnV0ZUtleSA9IE5hbWVkQXR0cmlidXRlIHwgYCR7TnVtYmVyZWRBdHRyaWJ1dGV9XyR7bnVtYmVyfWAgfCBgXyR7c3RyaW5nfWA7XG5cbmNvbnN0IGdlbmVyYXRlVGFuZ2VudHNBc3luYyA9IGltcG9ydCgnbWlra3RzcGFjZScpLnRoZW4oKG1vZHVsZSkgPT4gbW9kdWxlLmdlbmVyYXRlVGFuZ2VudHMpO1xuXG5mdW5jdGlvbiB3cmFwSW5kaWNlcyhpbmRpY2VzOiBHTFRGQWNjZXNzb3JQb3N0cHJvY2Vzc2VkKSB7XG4gICAgc3dpdGNoIChpbmRpY2VzLmJ5dGVzUGVyQ29tcG9uZW50KSB7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4QXJyYXk6IG5ldyBVaW50MTZBcnJheShpbmRpY2VzLnZhbHVlLmJ1ZmZlciksXG4gICAgICAgICAgICBpbmRleEZvcm1hdDogJ3VpbnQxNicgYXMgR1BVSW5kZXhGb3JtYXQsXG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4QXJyYXk6IG5ldyBVaW50MzJBcnJheShpbmRpY2VzLnZhbHVlLmJ1ZmZlciksXG4gICAgICAgICAgICBpbmRleEZvcm1hdDogJ3VpbnQzMicgYXMgR1BVSW5kZXhGb3JtYXQsXG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4QXJyYXk6IG5ldyBVaW50MTZBcnJheShpbmRpY2VzLnZhbHVlKSxcbiAgICAgICAgICAgIGluZGV4Rm9ybWF0OiAndWludDE2JyBhcyBHUFVJbmRleEZvcm1hdCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlaW5kZXgoaW5kaWNlczogR0xURkFjY2Vzc29yUG9zdHByb2Nlc3NlZCwgb3JpZ2luYWxNb2RlPzogbnVtYmVyKSB7XG4gICAgc3dpdGNoIChvcmlnaW5hbE1vZGUpIHtcbiAgICAgICAgY2FzZSBUb3BvbG9neU1vZGUuTGluZUxvb3A6XG4gICAgICAgIGNhc2UgVG9wb2xvZ3lNb2RlLkxpbmVTdHJpcDpcbiAgICAgICAgY2FzZSBUb3BvbG9neU1vZGUuVHJpYW5nbGVGYW46XG4gICAgICAgIGNhc2UgVG9wb2xvZ3lNb2RlLlRyaWFuZ2xlU3RyaXA6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IGNvbnZlcnQgbm9uLWxpc3QgdG9wb2xvZ2llcyBpbnRvIGxpc3RzLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb3BvbG9neSBjdXJyZW50bHkgdW5zdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4geyAuLi53cmFwSW5kaWNlcyhpbmRpY2VzKSwgbW9kZTogVG9wb2xvZ3lNb2RlLlRyaWFuZ2xlTGlzdCB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgdGhlIGRldGVybWluYW50IG9mIGVhY2ggZ2l2ZW4gbWF0cml4IGFuZCByZXR1cm5zIGEgY3VsbGluZyBtb2RlIHN1Y2ggdGhhdFxuICogYSBwcmltaXRpdmUgd2lsbCByZW5kZXIgY29ycmVjdGx5IGZvciBhbGwgbm9kZXMgY29udGFpbmluZyBpdCwgdXNpbmcgJ25vbmUnXG4gKiBmb3IgcHJpbWl0aXZlIHdoaWNoIGFyZSByZW5kZXJlZCBib3RoIGludmVydGVkIGFuZCBub3JtYWxseS5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2VNYXRyaWNlcyB0aGUgaW5zdGFuY2UgbWF0cmljZXMgdG8gcmVuZGVyIHRoZSBwcmltaXRpdmUgd2l0aFxuICogQHJldHVybnMgVGhlIGN1bGwgbW9kZSB0byB1c2Ugb24gdGhlIHByaW1pdGl2ZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIGdsRlQgc3BlYyBkZXRlcm1pbmVzIHRoZSB3aW5kaW5nIGRpcmVjdGlvbiBvZiBhIG1vZGVsIGJ5IHRoZVxuICogZGV0ZXJtaW5hbnQgb2YgdGhlIHRyYW5zZm9ybSBvZiB0aGUgbm9kZSB3aGljaCB1c2VzIGl0LCBhbGxvd2luZ1xuICogaW52ZXJzaW9uIHRocm91Z2ggbmVnYXRpdmUgc2NhbGUuIENoYW5naW5nIGN1bGxNb2RlIGluc3RlYWRcbiAqIG1vcmUgZWFzaWx5IGludGVncmF0ZXMgd2l0aCBpbnN0YW5jZWQgcmVuZGVyaW5nLCBhbHRob3VnaCBjb21lc1xuICogYXQgYSBwZXJmb3JtYW5jZSBjb3N0LlxuICovXG5mdW5jdGlvbiBnZXRDdWxsTW9kZShpbnN0YW5jZU1hdHJpY2VzOiBNYXQ0W10pIHtcbiAgICBsZXQgb3ZlcmFsbFNpZ246IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VNYXRyaWNlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBkZXQgPSBtYXQ0LmRldGVybWluYW50KGluc3RhbmNlTWF0cmljZXNbaV0pO1xuICAgICAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKGRldCk7XG4gICAgICAgIG92ZXJhbGxTaWduID8/PSBzaWduO1xuXG4gICAgICAgIGlmIChzaWduICE9PSBvdmVyYWxsU2lnbikgcmV0dXJuIFBpcGVsaW5lRmVhdHVyZUZsYWdzLkRvdWJsZVNpZGVkO1xuICAgIH1cblxuICAgIHJldHVybiAob3ZlcmFsbFNpZ24gPT0gbnVsbCB8fCBvdmVyYWxsU2lnbiA+IDApXG4gICAgICAgID8gUGlwZWxpbmVGZWF0dXJlRmxhZ3MuRGVmYXVsdHNcbiAgICAgICAgOiBQaXBlbGluZUZlYXR1cmVGbGFncy5DbG9ja3dpc2VXaW5kaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBsb2FkUHJpbWl0aXZlKFxuICAgIGxheW91dDogQXR0cmlidXRlRGV0YWlsc1tdLFxuICAgIHByaW1pdGl2ZTogR0xURk1lc2hQcmltaXRpdmVQb3N0cHJvY2Vzc2VkLFxuICAgIGluc3RhbmNlczogTWF0NFtdLFxuICAgIGRlc2NyaXB0b3JNYXA6IERlc2NyaXB0b3JNYXAsXG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXG4pOiBQcm9taXNlPHsgZHJhd0RhdGE/OiBQcmltaXRpdmVEcmF3RGF0YSwgbWF0ZXJpYWw/OiBHTFRGTWF0ZXJpYWxQb3N0cHJvY2Vzc2VkIH0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlLmF0dHJpYnV0ZXMgYXMgUGFydGlhbDxSZWNvcmQ8UHJpbWl0aXZlQXR0cmlidXRlS2V5LCBHTFRGQWNjZXNzb3JQb3N0cHJvY2Vzc2VkPj47XG4gICAgaWYgKGF0dHJpYnV0ZXMuUE9TSVRJT04gPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgY29uc3QgeyBpbmRpY2VzIH0gPSBwcmltaXRpdmU7XG4gICAgY29uc3QgYXRycyA9IG1hcFZhbHVlcyhhdHRyaWJ1dGVzLCAoYXRyKSA9PiBuZXcgQXR0cmlidXRlV3JhcHBlcihhdHIgYXMgR0xURkFjY2Vzc29yUG9zdHByb2Nlc3NlZCkpO1xuICAgIGxldCB7IG1vZGUgfSA9IHByaW1pdGl2ZTtcbiAgICBsZXQgdmVydGV4Q291bnQgPSBhdHRyaWJ1dGVzLlBPU0lUSU9OLmNvdW50O1xuICAgIGxldCBpbmRleEFycmF5OiBUeXBlZEFycmF5IHwgdW5kZWZpbmVkO1xuICAgIGxldCBpbmRleEZvcm1hdDogR1BVSW5kZXhGb3JtYXQgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaW5kaWNlcyAhPSBudWxsKSB7XG4gICAgICAgICh7IGluZGV4QXJyYXksIGluZGV4Rm9ybWF0IH0gPSB3cmFwSW5kaWNlcyhpbmRpY2VzKSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbW9kZSAhPT0gVG9wb2xvZ3lNb2RlLlBvaW50c1xuICAgICAgICAgICAgJiYgbW9kZSAhPT0gVG9wb2xvZ3lNb2RlLkxpbmVMaXN0XG4gICAgICAgICAgICAmJiBtb2RlICE9PSBUb3BvbG9neU1vZGUuVHJpYW5nbGVMaXN0XG4gICAgICAgICkge1xuICAgICAgICAgICAgKHsgaW5kZXhBcnJheSwgaW5kZXhGb3JtYXQsIG1vZGUgfSA9IHJlaW5kZXgoaW5kaWNlcywgbW9kZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF0cnMuTk9STUFMICE9IG51bGwgJiYgYXRycy5UQU5HRU5UID09IG51bGwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgaWYgKGF0cnMuVEVYQ09PUkRfMCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhBcnJheSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4Q291bnQgPSBpbmRleEFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGF0ciBvZiBPYmplY3QudmFsdWVzKGF0cnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0ci51bndlbGQoaW5kZXhBcnJheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhbmdlbnQgPSBhd2FpdCBnZW5lcmF0ZVRhbmdlbnRzQXN5bmMudGhlbigoZnVuYykgPT4gZnVuYyhcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIGF0cnMuUE9TSVRJT04hLmFycmF5LFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgYXRycy5OT1JNQUwhLmFycmF5LFxuICAgICAgICAgICAgICAgIGF0cnMuVEVYQ09PUkRfMC5hcnJheSxcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMzsgaSA8IHRhbmdlbnQubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICB0YW5nZW50W2ldICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coYHRhbmdlbnRzIGdlbmVyYXRlZCBpbiAke0RhdGUubm93KCkgLSBzdGFydH1gKTtcblxuICAgICAgICAgICAgYXRycy5UQU5HRU5UID0gbmV3IEF0dHJpYnV0ZVdyYXBwZXIodGFuZ2VudCwgNCk7XG5cbiAgICAgICAgICAgICh7IGluZGV4QXJyYXksIGluZGV4Rm9ybWF0LCB2ZXJ0ZXhDb3VudCB9ID0gd2VsZChhdHJzKSk7XG4gICAgICAgICAgICBtb2RlID0gVG9wb2xvZ3lNb2RlLlRyaWFuZ2xlTGlzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRhbmdlbnQgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRleENvdW50ICogNCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0YW5nZW50LnNldChbMSwgMCwgMCwgMV0sIGkgKiA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0cnMuVEFOR0VOVCA9IG5ldyBBdHRyaWJ1dGVXcmFwcGVyKHRhbmdlbnQsIDQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyB2ZXJ0ZXhBcnJheSwgdmVydGV4RmVhdHVyZXMgfSA9IGludGVybGVhdmVWZXJ0aWNlcyhhdHJzLCB2ZXJ0ZXhDb3VudCk7XG4gICAgbGV0IGZlYXR1cmVzID0gZ2V0Q3VsbE1vZGUoaW5zdGFuY2VzKSB8IHZlcnRleEZlYXR1cmVzO1xuICAgIGlmIChtb2RlICE9IG51bGwpIGZlYXR1cmVzIHw9IG1vZGVUb1RvcG9sb2d5W21vZGUgYXMgVG9wb2xvZ3lNb2RlXSB8fCAwO1xuXG4gICAgY29uc3QgZHJhd0RhdGEgPSBuZXcgUHJpbWl0aXZlRHJhd0RhdGEoe1xuICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgaW5kZXhBcnJheSxcbiAgICAgICAgaW5kZXhGb3JtYXQsXG4gICAgICAgIHZlcnRleENvdW50LFxuICAgICAgICB2ZXJ0ZXhBcnJheSxcbiAgICB9LCBkZXZpY2UsIGluc3RhbmNlcy5sZW5ndGgsIGRlc2NyaXB0b3JNYXAsIGluc3RhbmNlcyk7XG5cbiAgICByZXR1cm4geyBtYXRlcmlhbDogcHJpbWl0aXZlLm1hdGVyaWFsLCBkcmF3RGF0YSB9O1xufVxuIiwiaW1wb3J0IHsgR0xURk1hdGVyaWFsUG9zdHByb2Nlc3NlZCwgR0xURlNhbXBsZXIsIEdMVEZUZXh0dXJlUG9zdHByb2Nlc3NlZCB9IGZyb20gJ0Bsb2FkZXJzLmdsL2dsdGYnO1xuXG5pbXBvcnQgeyB2ZWMzIH0gZnJvbSAnd2dwdS1tYXRyaXgnO1xuaW1wb3J0IHsgTWF0ZXJpYWxEZXNjcmlwdG9yIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL21hdGVyaWFsLWRyYXctZGF0YSc7XG5pbXBvcnQgeyBpbWFnZVRvVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3RleHR1cmUtaW1wb3J0aW5nJztcblxuY29uc3QgREVGQVVMVF9NRVRBTExJQyA9IDAuMDtcbmNvbnN0IERFRkFVTFRfUk9VR0hORVNTID0gMS4wO1xuXG5jb25zdCBnbHRmVG9NYWdEZXNjcmlwdGlvbjogUmVjb3JkPG51bWJlciwgR1BVRmlsdGVyTW9kZT4gPSB7XG4gICAgOTcyODogJ25lYXJlc3QnLFxuICAgIDk3Mjk6ICdsaW5lYXInLFxuICAgIDk5ODQ6ICduZWFyZXN0JywgLy8gTkVBUkVTVF9NSVBNQVBfTkVBUkVTVFxuICAgIDk5ODU6ICdsaW5lYXInLCAvLyBMSU5FQVJfTUlQTUFQX05FQVJFU1RcbiAgICA5OTg2OiAnbmVhcmVzdCcsIC8vIE5FQVJFU1RfTUlQTUFQX0xJTkVBUlxuICAgIDk5ODc6ICdsaW5lYXInLCAvLyBMSU5FQVJfTUlQTUFQX0xJTkVBUlxufTtcblxuY29uc3QgZ2x0ZlRvTWlwRGVzY3JpcHRpb246IFBhcnRpYWw8UmVjb3JkPG51bWJlciwgR1BVRmlsdGVyTW9kZT4+ID0ge1xuICAgIDk5ODQ6ICduZWFyZXN0JywgLy8gTkVBUkVTVF9NSVBNQVBfTkVBUkVTVFxuICAgIDk5ODU6ICduZWFyZXN0JywgLy8gTElORUFSX01JUE1BUF9ORUFSRVNUXG4gICAgOTk4NjogJ2xpbmVhcicsIC8vIE5FQVJFU1RfTUlQTUFQX0xJTkVBUlxuICAgIDk5ODc6ICdsaW5lYXInLCAvLyBMSU5FQVJfTUlQTUFQX0xJTkVBUlxufTtcblxuY29uc3QgZ2x0ZlRvQWRkcmVzc01vZGU6IFJlY29yZDxudW1iZXIsIEdQVUFkZHJlc3NNb2RlPiA9IHtcbiAgICAzMzA3MTogJ2NsYW1wLXRvLWVkZ2UnLCAvLyBDTEFNUF9UT19FREdFXG4gICAgMzM2NDg6ICdtaXJyb3ItcmVwZWF0JywgLy8gTUlSUk9SRURfUkVQRUFUXG4gICAgMTA0OTc6ICdyZXBlYXQnLCAvLyBSRVBFQVRcbn07XG5cbmZ1bmN0aW9uIHRvU2FtcGxlckRlc2NyaXB0aW9uKHNhbXBsZXI6IEdMVEZTYW1wbGVyKTogR1BVU2FtcGxlckRlc2NyaXB0b3Ige1xuICAgIGNvbnN0IHsgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIHdyYXBTLCB3cmFwVCB9ID0gc2FtcGxlcjtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3NNb2RlVTogZ2x0ZlRvQWRkcmVzc01vZGVbd3JhcFMgPz8gMTA0OTddLFxuICAgICAgICBhZGRyZXNzTW9kZVY6IGdsdGZUb0FkZHJlc3NNb2RlW3dyYXBUID8/IDEwNDk3XSxcbiAgICAgICAgbWluRmlsdGVyOiBnbHRmVG9NYWdEZXNjcmlwdGlvblttaW5GaWx0ZXIgPz8gOTk4N10sXG4gICAgICAgIG1hZ0ZpbHRlcjogZ2x0ZlRvTWFnRGVzY3JpcHRpb25bbWFnRmlsdGVyID8/IDk3MjldLFxuICAgICAgICBtaXBtYXBGaWx0ZXI6IGdsdGZUb01pcERlc2NyaXB0aW9uW21pbkZpbHRlciA/PyA5OTg3XSA/PyAnbGluZWFyJyxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRJbWFnZURhdGEoaGFuZGxlOiBHTFRGVGV4dHVyZVBvc3Rwcm9jZXNzZWQpIHtcbiAgICBjb25zdCB7IHNvdXJjZSwgc2FtcGxlciB9ID0gaGFuZGxlO1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBjb25zdCBkYXRhID0gc291cmNlLmltYWdlLmRhdGEgPz8gc291cmNlLmJ1ZmZlclZpZXc/LmRhdGE7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4geyBkYXRhLCBtaW1lVHlwZTogc291cmNlLm1pbWVUeXBlLCBzYW1wbGVyIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGxvYWRNYXRlcmlhbChcbiAgICBtYXRlcmlhbDogR0xURk1hdGVyaWFsUG9zdHByb2Nlc3NlZCxcbiAgICBkZWZhdWx0TWF0ZXJpYWw6IE1hdGVyaWFsRGVzY3JpcHRvcixcbiAgICBkZXZpY2U6IEdQVURldmljZSxcbik6IFByb21pc2U8TWF0ZXJpYWxEZXNjcmlwdG9yPiB7XG4gICAgY29uc3QgbWF0OiBQYXJ0aWFsPE1hdGVyaWFsRGVzY3JpcHRvcj4gPSB7fTtcbiAgICBpZiAobWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBiYXNlQ29sb3JGYWN0b3IsXG4gICAgICAgICAgICBiYXNlQ29sb3JUZXh0dXJlLFxuICAgICAgICAgICAgbWV0YWxsaWNGYWN0b3IsXG4gICAgICAgICAgICBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmUsXG4gICAgICAgICAgICByb3VnaG5lc3NGYWN0b3IsXG4gICAgICAgIH0gPSBtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcztcblxuICAgICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlPy50ZXh0dXJlLnNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWV0YWxsaWNGYWN0b3IgPT0gbnVsbCkgbWF0Lm1ldGFsbGljRmFjdG9yID0gREVGQVVMVF9NRVRBTExJQztcbiAgICAgICAgICAgIGlmIChyb3VnaG5lc3NGYWN0b3IgPT0gbnVsbCkgbWF0LnJvdWdobmVzc0ZhY3RvciA9IERFRkFVTFRfUk9VR0hORVNTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBtaW1lVHlwZSwgc2FtcGxlciB9ID0gZ2V0SW1hZ2VEYXRhKG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtYXQubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlID0gYXdhaXQgaW1hZ2VUb1RleHR1cmUoe1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogYCR7bWF0ZXJpYWwuaWR9IG1yIHRleHR1cmVgLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcsXG4gICAgICAgICAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlcikgbWF0Lm1ldGFsbGljUm91Z2huZXNzU2FtcGxlciA9IHRvU2FtcGxlckRlc2NyaXB0aW9uKHNhbXBsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhc2VDb2xvclRleHR1cmU/LnRleHR1cmUuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgbWltZVR5cGUsIHNhbXBsZXIgfSA9IGdldEltYWdlRGF0YShiYXNlQ29sb3JUZXh0dXJlLnRleHR1cmUpO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1hdC5iYXNlQ29sb3JUZXh0dXJlID0gYXdhaXQgaW1hZ2VUb1RleHR1cmUoe1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogYCR7bWF0ZXJpYWwuaWR9IG1yIHRleHR1cmVgLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcsXG4gICAgICAgICAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgICAgICAgICAgc3JnYlRvTGluZWFyOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVyKSBtYXQuYmFzZUNvbG9yU2FtcGxlciA9IHRvU2FtcGxlckRlc2NyaXB0aW9uKHNhbXBsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhc2VDb2xvckZhY3RvciAhPSBudWxsKSBtYXQuYmFzZUNvbG9yRmFjdG9yID0gYmFzZUNvbG9yRmFjdG9yO1xuICAgICAgICBpZiAobWV0YWxsaWNGYWN0b3IgIT0gbnVsbCkgbWF0Lm1ldGFsbGljRmFjdG9yID0gbWV0YWxsaWNGYWN0b3I7XG4gICAgICAgIGlmIChyb3VnaG5lc3NGYWN0b3IgIT0gbnVsbCkgbWF0Lm1ldGFsbGljRmFjdG9yID0gcm91Z2huZXNzRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdC5tZXRhbGxpY0ZhY3RvciA9IERFRkFVTFRfTUVUQUxMSUM7XG4gICAgICAgIG1hdC5yb3VnaG5lc3NGYWN0b3IgPSBERUZBVUxUX1JPVUdITkVTUztcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWwubm9ybWFsVGV4dHVyZT8udGV4dHVyZS5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIG1pbWVUeXBlLCBzYW1wbGVyIH0gPSBnZXRJbWFnZURhdGEobWF0ZXJpYWwubm9ybWFsVGV4dHVyZS50ZXh0dXJlKTtcblxuICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXQubm9ybWFsVGV4dHVyZSA9IGF3YWl0IGltYWdlVG9UZXh0dXJlKHtcbiAgICAgICAgICAgICAgICBsYWJlbDogYCR7bWF0ZXJpYWwuaWR9IG1yIHRleHR1cmVgLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgbWltZVR5cGUsXG4gICAgICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcsXG4gICAgICAgICAgICAgICAgZGV2aWNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2FtcGxlcikgbWF0Lm5vcm1hbFNhbXBsZXIgPSB0b1NhbXBsZXJEZXNjcmlwdGlvbihzYW1wbGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgZW1pc3NpdmVGYWN0b3IsIGVtaXNzaXZlVGV4dHVyZSB9ID0gbWF0ZXJpYWw7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICBjb25zdCBlbWlzc2l2ZVN0cmVuZ3RoID0gbWF0ZXJpYWwuZXh0ZW5zaW9ucz8uS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aD8uZW1pc3NpdmVTdHJlbmd0aDtcblxuICAgIGlmIChlbWlzc2l2ZVRleHR1cmUgIT0gbnVsbCB8fCBlbWlzc2l2ZUZhY3Rvcj8uc29tZSgoeCkgPT4geCA+IDApKSB7XG4gICAgICAgIG1hdC5lbWlzc2l2ZUZhY3RvciA9IGVtaXNzaXZlRmFjdG9yID8/IFsxLCAxLCAxXTtcbiAgICAgICAgbWF0LmVtaXNzaXZlU2FtcGxlciA9IHsgbWFnRmlsdGVyOiAnbGluZWFyJywgbWluRmlsdGVyOiAnbGluZWFyJyB9O1xuXG4gICAgICAgIGlmIChlbWlzc2l2ZVRleHR1cmU/LnRleHR1cmUuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgbWltZVR5cGUsIHNhbXBsZXIgfSA9IGdldEltYWdlRGF0YShlbWlzc2l2ZVRleHR1cmUudGV4dHVyZSk7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWF0LmVtaXNzaXZlVGV4dHVyZSA9IGF3YWl0IGltYWdlVG9UZXh0dXJlKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGAke21hdGVyaWFsLmlkfSBtciB0ZXh0dXJlYCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HLFxuICAgICAgICAgICAgICAgICAgICBkZXZpY2UsXG4gICAgICAgICAgICAgICAgICAgIHNyZ2JUb0xpbmVhcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlcikgbWF0LmVtaXNzaXZlU2FtcGxlciA9IHRvU2FtcGxlckRlc2NyaXB0aW9uKHNhbXBsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0LmVtaXNzaXZlVGV4dHVyZSA9IGRlZmF1bHRNYXRlcmlhbC5iYXNlQ29sb3JUZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVtaXNzaXZlU3RyZW5ndGggIT0gbnVsbCAmJiB0eXBlb2YgZW1pc3NpdmVTdHJlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZlYzMuc2NhbGUobWF0LmVtaXNzaXZlRmFjdG9yLCBlbWlzc2l2ZVN0cmVuZ3RoLCBtYXQuZW1pc3NpdmVGYWN0b3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGVyaWFsLmRvdWJsZVNpZGVkKSBtYXQuZG91YmxlU2lkZWQgPSB0cnVlO1xuICAgIGlmIChtYXRlcmlhbC5hbHBoYU1vZGUgPT09ICdNQVNLJykgbWF0LmFscGhhQ3V0b2ZmID0gbWF0ZXJpYWwuYWxwaGFDdXRvZmYgPz8gMC41O1xuXG4gICAgcmV0dXJuIHsgLi4uZGVmYXVsdE1hdGVyaWFsLCAuLi5tYXQgfTtcbn1cbiIsImltcG9ydCB7IFZlYzNuLCBWZWM0biB9IGZyb20gJ3dncHUtbWF0cml4JztcbmltcG9ydCBEZXNjcmlwdG9yTWFwIGZyb20gJy4vZGVzY3JpcHRvci1tYXAnO1xuaW1wb3J0IHsgZmVhdHVyZUZsYWdzVG9TdHJpbmcsIFBpcGVsaW5lRmVhdHVyZUZsYWdzIH0gZnJvbSAnLi9waXBlbGluZS1mZWF0dXJlLWZsYWdzJztcbmltcG9ydCB7IFByaW1pdGl2ZURyYXdEYXRhIH0gZnJvbSAnLi9wcmltaXRpdmUtZHJhdy1kYXRhJztcbmltcG9ydCB7IGNyZWF0ZUFuZENvcHlCdWZmZXIgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhLWNvcHknO1xuXG5leHBvcnQgdHlwZSBNYXRlcmlhbERlc2NyaXB0b3IgPSB7XG4gICAgbmFtZT86IHN0cmluZyxcblxuICAgIGJhc2VDb2xvckZhY3RvcjogVmVjNG4sXG4gICAgYmFzZUNvbG9yVGV4dHVyZTogR1BVVGV4dHVyZSxcbiAgICBiYXNlQ29sb3JTYW1wbGVyOiBHUFVTYW1wbGVyRGVzY3JpcHRvcixcblxuICAgIHJvdWdobmVzc0ZhY3RvcjogbnVtYmVyLFxuICAgIG1ldGFsbGljRmFjdG9yOiBudW1iZXIsXG4gICAgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlOiBHUFVUZXh0dXJlLFxuICAgIG1ldGFsbGljUm91Z2huZXNzU2FtcGxlcjogR1BVU2FtcGxlckRlc2NyaXB0b3IsXG5cbiAgICBub3JtYWxUZXh0dXJlOiBHUFVUZXh0dXJlLFxuICAgIG5vcm1hbFNhbXBsZXI6IEdQVVNhbXBsZXJEZXNjcmlwdG9yLFxuXG4gICAgYWxwaGFDdXRvZmY/OiBudW1iZXIsXG5cbiAgICBlbWlzc2l2ZUZhY3Rvcj86IFZlYzNuLFxuICAgIGVtaXNzaXZlVGV4dHVyZT86IEdQVVRleHR1cmUsXG4gICAgZW1pc3NpdmVTYW1wbGVyPzogR1BVU2FtcGxlckRlc2NyaXB0b3IsXG5cbiAgICBkb3VibGVTaWRlZD86IGJvb2xlYW4sXG59O1xuXG5leHBvcnQgY2xhc3MgTWF0ZXJpYWxEcmF3RGF0YSB7XG4gICAgbGF5b3V0OiBHUFVCaW5kR3JvdXBMYXlvdXQ7XG4gICAgcHJpbWl0aXZlczogUHJpbWl0aXZlRHJhd0RhdGFbXSA9IFtdO1xuICAgIG1hdERhdGE6IE1hdGVyaWFsRGVzY3JpcHRvcjtcbiAgICBiaW5kR3JvdXA6IEdQVUJpbmRHcm91cDtcbiAgICBwcm9wZXJ0aWVzQnVmZmVyOiBHUFVCdWZmZXI7XG4gICAgZmVhdHVyZXM6IFBpcGVsaW5lRmVhdHVyZUZsYWdzO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGRhdGE6IE1hdGVyaWFsRGVzY3JpcHRvcixcbiAgICAgICAgZGV2aWNlOiBHUFVEZXZpY2UsXG4gICAgICAgIGRlc2NyaXB0b3JNYXA6IERlc2NyaXB0b3JNYXAsXG4gICAgICAgIHByaW1pdGl2ZUZlYXR1cmVzOiBQaXBlbGluZUZlYXR1cmVGbGFncyxcbiAgICAgICAgcHJpbWl0aXZlcz86IFByaW1pdGl2ZURyYXdEYXRhW10sXG4gICAgKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBwcmltaXRpdmVGZWF0dXJlcztcbiAgICAgICAgaWYgKGRhdGEuZG91YmxlU2lkZWQpIHRoaXMuZmVhdHVyZXMgfD0gUGlwZWxpbmVGZWF0dXJlRmxhZ3MuRG91YmxlU2lkZWQ7XG5cbiAgICAgICAgLy8gVE9ETyA6IGRvbid0IGhhcmRjb2RlIHRoZSBwcm9wZXJ0aWVzIGZlYXR1cmVzXG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBuZXcgRmxvYXQzMkFycmF5KDEyKTtcbiAgICAgICAgcHJvcGVydGllcy5zZXQoZGF0YS5iYXNlQ29sb3JGYWN0b3IpO1xuICAgICAgICBwcm9wZXJ0aWVzWzRdID0gZGF0YS5tZXRhbGxpY0ZhY3RvcjtcbiAgICAgICAgcHJvcGVydGllc1s1XSA9IGRhdGEucm91Z2huZXNzRmFjdG9yO1xuXG4gICAgICAgIGlmIChkYXRhLmFscGhhQ3V0b2ZmICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMgfD0gUGlwZWxpbmVGZWF0dXJlRmxhZ3MuQWxwaGFDdXRvZmY7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzWzZdID0gZGF0YS5hbHBoYUN1dG9mZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmVtaXNzaXZlRmFjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuc2V0KGRhdGEuZW1pc3NpdmVGYWN0b3IsIDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzQnVmZmVyID0gY3JlYXRlQW5kQ29weUJ1ZmZlcihcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBHUFVCdWZmZXJVc2FnZS5VTklGT1JNLFxuICAgICAgICAgICAgZGV2aWNlLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgICAgICB7IGJpbmRpbmc6IDAsIHJlc291cmNlOiB7IGJ1ZmZlcjogdGhpcy5wcm9wZXJ0aWVzQnVmZmVyIH0gfSxcbiAgICAgICAgICAgIHsgYmluZGluZzogMSwgcmVzb3VyY2U6IGRlc2NyaXB0b3JNYXAuZ2V0U2FtcGxlcihkYXRhLmJhc2VDb2xvclNhbXBsZXIpIH0sXG4gICAgICAgICAgICB7IGJpbmRpbmc6IDIsIHJlc291cmNlOiBkYXRhLmJhc2VDb2xvclRleHR1cmUuY3JlYXRlVmlldyh7IGRpbWVuc2lvbjogJzJkJyB9KSB9LFxuICAgICAgICAgICAgeyBiaW5kaW5nOiAzLCByZXNvdXJjZTogZGVzY3JpcHRvck1hcC5nZXRTYW1wbGVyKGRhdGEubm9ybWFsU2FtcGxlcikgfSxcbiAgICAgICAgICAgIHsgYmluZGluZzogNCwgcmVzb3VyY2U6IGRhdGEubm9ybWFsVGV4dHVyZS5jcmVhdGVWaWV3KHsgZGltZW5zaW9uOiAnMmQnIH0pIH0sXG4gICAgICAgICAgICB7IGJpbmRpbmc6IDUsIHJlc291cmNlOiBkZXNjcmlwdG9yTWFwLmdldFNhbXBsZXIoZGF0YS5tZXRhbGxpY1JvdWdobmVzc1NhbXBsZXIpIH0sXG4gICAgICAgICAgICB7IGJpbmRpbmc6IDYsIHJlc291cmNlOiBkYXRhLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZS5jcmVhdGVWaWV3KHsgZGltZW5zaW9uOiAnMmQnIH0pIH0sXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKGRhdGEuZW1pc3NpdmVUZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMgfD0gUGlwZWxpbmVGZWF0dXJlRmxhZ3MuRW1pc3NpdmU7XG5cbiAgICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgYmluZGluZzogNyxcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogZGVzY3JpcHRvck1hcC5nZXRTYW1wbGVyKGRhdGEuZW1pc3NpdmVTYW1wbGVyID8/IHt9KSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDgsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IGRhdGEuZW1pc3NpdmVUZXh0dXJlLmNyZWF0ZVZpZXcoeyBkaW1lbnNpb246ICcyZCcgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGF5b3V0ID0gZGVzY3JpcHRvck1hcC5nZXRNYXRlcmlhbEJpbmRHcm91cCh0aGlzLmZlYXR1cmVzKTtcbiAgICAgICAgdGhpcy5tYXREYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5iaW5kR3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcbiAgICAgICAgICAgIGxhYmVsOiBmZWF0dXJlRmxhZ3NUb1N0cmluZyh0aGlzLmZlYXR1cmVzKSxcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5sYXlvdXQsXG4gICAgICAgICAgICBlbnRyaWVzLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocHJpbWl0aXZlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFByaW1pdGl2ZXMoLi4ucHJpbWl0aXZlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmF3KHBhc3NFbmNvZGVyOiBHUFVSZW5kZXJQYXNzRW5jb2RlciwgcXVldWU6IEdQVVF1ZXVlKSB7XG4gICAgICAgIGlmICh0aGlzLnByaW1pdGl2ZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgcGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDEsIHRoaXMuYmluZEdyb3VwKTtcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgdGhpcy5wcmltaXRpdmVzKSB7XG4gICAgICAgICAgICBwcmltaXRpdmUuZHJhdyhwYXNzRW5jb2RlciwgcXVldWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkUHJpbWl0aXZlcyguLi5kcmF3RGF0YTogUHJpbWl0aXZlRHJhd0RhdGFbXSkge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IGRyYXdEYXRhLmZpbHRlcigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKChkYXRhLmZlYXR1cmVzICYgdGhpcy5mZWF0dXJlcykgPT09IGRhdGEuZmVhdHVyZXMpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBpbnZhbGlkIHByaW1pdGl2ZSBhZGRlZCB0byBtYXRlcmlhbDogXG5wcmltaXRpdmU6ICR7ZGF0YS5uYW1lfVxucHJpbWl0aXZlIGZlYXR1cmVzOiAke2ZlYXR1cmVGbGFnc1RvU3RyaW5nKGRhdGEuZmVhdHVyZXMpLnRvU3RyaW5nKCl9XG5tYXRlcmlhbDogJHt0aGlzLm1hdERhdGEubmFtZX1cbm1hdGVyaWFsIGZlYXR1cmVzOiAke2ZlYXR1cmVGbGFnc1RvU3RyaW5nKHRoaXMuZmVhdHVyZXMpLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByaW1pdGl2ZXMucHVzaCguLi5maWx0ZXJlZCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IERlc2NyaXB0b3JNYXAgZnJvbSAnLi9kZXNjcmlwdG9yLW1hcCc7XG5pbXBvcnQgeyBNYXRlcmlhbERyYXdEYXRhIH0gZnJvbSAnLi9tYXRlcmlhbC1kcmF3LWRhdGEnO1xuaW1wb3J0IHsgUGlwZWxpbmVGZWF0dXJlRmxhZ3MsIGZlYXR1cmVGbGFnc1RvU3RyaW5nLCBtYXNrUmVkdW5kYW50RmVhdHVyZXMgfSBmcm9tICcuL3BpcGVsaW5lLWZlYXR1cmUtZmxhZ3MnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHZW9tZXRyeVBpcGVsaW5lIHtcbiAgICBmZWF0dXJlczogUGlwZWxpbmVGZWF0dXJlRmxhZ3M7XG4gICAgcGlwZWxpbmU6IEdQVVJlbmRlclBpcGVsaW5lO1xuXG4gICAgbWF0ZXJpYWxzOiBNYXRlcmlhbERyYXdEYXRhW10gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKGZlYXR1cmVzOiBQaXBlbGluZUZlYXR1cmVGbGFncywgbWFwczogRGVzY3JpcHRvck1hcCkge1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0gbWFza1JlZHVuZGFudEZlYXR1cmVzKGZlYXR1cmVzKTtcblxuICAgICAgICBjb25zdCBtb2R1bGUgPSBtYXBzLmdldFNoYWRlck1vZHVsZShmZWF0dXJlcyk7XG5cbiAgICAgICAgdGhpcy5waXBlbGluZSA9IG1hcHMuZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcbiAgICAgICAgICAgIGxhYmVsOiBmZWF0dXJlRmxhZ3NUb1N0cmluZyhmZWF0dXJlcyksXG4gICAgICAgICAgICBsYXlvdXQ6IG1hcHMuZ2V0Rm9yd2FyZFBpcGVsaW5lTGF5b3V0KGZlYXR1cmVzKSxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogbWFwcy5nZXRQcmltaXRpdmVTdGF0ZShmZWF0dXJlcyksXG4gICAgICAgICAgICB2ZXJ0ZXg6IHtcbiAgICAgICAgICAgICAgICBlbnRyeVBvaW50OiAndnMnLFxuICAgICAgICAgICAgICAgIGJ1ZmZlcnM6IFttYXBzLmdldFZlcnRleExheW91dChmZWF0dXJlcyldLFxuICAgICAgICAgICAgICAgIG1vZHVsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmFnbWVudDoge1xuICAgICAgICAgICAgICAgIGVudHJ5UG9pbnQ6ICdmcycsXG4gICAgICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgICAgIHRhcmdldHM6IG1hcHMuZ2J1ZmZlci50YXJnZXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbDoge1xuICAgICAgICAgICAgICAgIGRlcHRoV3JpdGVFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlcHRoQ29tcGFyZTogJ2xlc3MtZXF1YWwnLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogbWFwcy5nYnVmZmVyLmRlcHRoLmZvcm1hdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZE1hdGVyaWFscyguLi5tYXRlcmlhbHM6IE1hdGVyaWFsRHJhd0RhdGFbXSkge1xuICAgICAgICBpZiAobWF0ZXJpYWxzLnNvbWUoKGRhdGEpID0+IGRhdGEuZmVhdHVyZXMgIT09IHRoaXMuZmVhdHVyZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpbWl0aXZlIGFkZGVkIHRvIG1hdGVyaWFsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRlcmlhbHMucHVzaCguLi5tYXRlcmlhbHMpO1xuICAgIH1cblxuICAgIGRyYXcocGFzc0VuY29kZXI6IEdQVVJlbmRlclBhc3NFbmNvZGVyLCBxdWV1ZTogR1BVUXVldWUpIHtcbiAgICAgICAgcGFzc0VuY29kZXIuc2V0UGlwZWxpbmUodGhpcy5waXBlbGluZSk7XG4gICAgICAgIGZvciAoY29uc3QgbWF0IG9mIHRoaXMubWF0ZXJpYWxzKSB7XG4gICAgICAgICAgICBtYXQuZHJhdyhwYXNzRW5jb2RlciwgcXVldWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTWF0NCwgbWF0NCwgTWF0NEFyZywgTWF0NFR5cGUsIHF1YXQgfSBmcm9tICd3Z3B1LW1hdHJpeCc7XG5pbXBvcnQgeyBEYXRhVHlwZSwgbG9hZCB9IGZyb20gJ0Bsb2FkZXJzLmdsL2NvcmUnO1xuaW1wb3J0IHsgR0xURkxvYWRlciwgR0xURk1lc2hQb3N0cHJvY2Vzc2VkLCBHTFRGTm9kZVBvc3Rwcm9jZXNzZWQsIHBvc3RQcm9jZXNzR0xURiB9IGZyb20gJ0Bsb2FkZXJzLmdsL2dsdGYnO1xuXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlLCBBdHRyaWJ1dGVEZXRhaWxzIH0gZnJvbSAnLi90eXBlLWNvbnZlcnNpb25zJztcbmltcG9ydCBsb2FkUHJpbWl0aXZlIGZyb20gJy4vcHJpbWl0aXZlLWxvYWRlcic7XG5pbXBvcnQgbG9hZE1hdGVyaWFsIGZyb20gJy4vbWF0ZXJpYWwtbG9hZGVyJztcblxuaW1wb3J0IHsgTWF0ZXJpYWxEZXNjcmlwdG9yLCBNYXRlcmlhbERyYXdEYXRhIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL21hdGVyaWFsLWRyYXctZGF0YSc7XG5pbXBvcnQgeyBQaXBlbGluZUZlYXR1cmVGbGFncyB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9kZWZhdWx0LWZvcndhcmQtcGFzcy9waXBlbGluZS1mZWF0dXJlLWZsYWdzJztcbmltcG9ydCB7IFByaW1pdGl2ZURyYXdEYXRhIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL3ByaW1pdGl2ZS1kcmF3LWRhdGEnO1xuaW1wb3J0IERlc2NyaXB0b3JNYXAgZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2RlZmF1bHQtZm9yd2FyZC1wYXNzL2Rlc2NyaXB0b3ItbWFwJztcbmltcG9ydCBHZW9tZXRyeVBpcGVsaW5lIGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9kZWZhdWx0LWZvcndhcmQtcGFzcy9nZW9tZXRyeS1waXBlbGluZSc7XG5cbmNvbnN0IGRlZmF1bHRMYXlvdXQ6IEF0dHJpYnV0ZURldGFpbHNbXSA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICdQT1NJVElPTicsXG4gICAgICAgIHR5cGU6ICdWRUMzJyxcbiAgICAgICAgY29tcG9uZW50VHlwZTogQ29tcG9uZW50VHlwZS5mbG9hdDMyLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnVEVYQ09PUkRfMCcsXG4gICAgICAgIHR5cGU6ICdWRUMyJyxcbiAgICAgICAgY29tcG9uZW50VHlwZTogQ29tcG9uZW50VHlwZS5mbG9hdDMyLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnVEFOR0VOVCcsXG4gICAgICAgIHR5cGU6ICdWRUM0JyxcbiAgICAgICAgY29tcG9uZW50VHlwZTogQ29tcG9uZW50VHlwZS5mbG9hdDMyLFxuICAgICAgICBkZXBlbmRzOiBbJ05PUk1BTCddLFxuICAgICAgICBmaWxsOiBbMSwgMCwgMCwgMV0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOT1JNQUwnLFxuICAgICAgICB0eXBlOiAnVkVDMycsXG4gICAgICAgIGNvbXBvbmVudFR5cGU6IENvbXBvbmVudFR5cGUuZmxvYXQzMixcbiAgICAgICAgc3RyaXA6IHRydWUsXG4gICAgICAgIGZlYXR1cmU6IFBpcGVsaW5lRmVhdHVyZUZsYWdzLlZlcnRleE5vcm1hbHMsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdDT0xPUl8wJyxcbiAgICAgICAgdHlwZTogJ1ZFQzQnLFxuICAgICAgICBjb21wb25lbnRUeXBlOiBDb21wb25lbnRUeXBlLmZsb2F0MzIsXG4gICAgICAgIHN0cmlwOiB0cnVlLFxuICAgICAgICBmZWF0dXJlOiBQaXBlbGluZUZlYXR1cmVGbGFncy5WZXJ0ZXhDb2xvcnMsXG4gICAgICAgIGZpbGw6IFsxLCAxLCAxLCAxXSxcbiAgICB9LFxuXTtcblxuY29uc3QgcmVjdXJzZU5vZGUgPSAoXG4gICAgcGFyZW50TWF0cml4OiBNYXQ0VHlwZTxNYXQ0QXJnPixcbiAgICBtZXNoZXM6IE1hcDxHTFRGTWVzaFBvc3Rwcm9jZXNzZWQsIE1hdDRUeXBlPE1hdDRBcmc+W10+LFxuKSA9PiAobm9kZTogR0xURk5vZGVQb3N0cHJvY2Vzc2VkKSA9PiB7XG4gICAgY29uc3QgbWF0cml4ID0gbm9kZS5tYXRyaXggPz8gbWF0NC5pZGVudGl0eSgpO1xuXG4gICAgaWYgKG5vZGUubWF0cml4ID09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuc2NhbGUpIG1hdDQuc2NhbGluZyhub2RlLnNjYWxlLCBtYXRyaXgpO1xuXG4gICAgICAgIGlmIChub2RlLnJvdGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB7IGF4aXMsIGFuZ2xlIH0gPSBxdWF0LnRvQXhpc0FuZ2xlKG5vZGUucm90YXRpb24pO1xuICAgICAgICAgICAgbWF0NC5yb3RhdGUobWF0cml4LCBheGlzLCBhbmdsZSwgbWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnRyYW5zbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hdDQuc2V0VHJhbnNsYXRpb24obWF0cml4LCBub2RlLnRyYW5zbGF0aW9uLCBtYXRyaXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWF0NC5tdWwocGFyZW50TWF0cml4LCBtYXRyaXgsIG1hdHJpeCk7XG5cbiAgICBpZiAobm9kZS5tZXNoICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCFtZXNoZXMuaGFzKG5vZGUubWVzaCkpIG1lc2hlcy5zZXQobm9kZS5tZXNoLCBbXSk7XG4gICAgICAgIG1lc2hlcy5nZXQobm9kZS5tZXNoKSEucHVzaChtYXRyaXgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICB9XG5cbiAgICBub2RlLmNoaWxkcmVuPy5mb3JFYWNoKHJlY3Vyc2VOb2RlKG1hdHJpeCwgbWVzaGVzKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBpbXBvcnRHbHRmKFxuICAgIHVybDogc3RyaW5nIHwgRGF0YVR5cGUsXG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXG4gICAgZGVzY3JpcHRvck1hcDogRGVzY3JpcHRvck1hcCxcbiAgICBkZWZhdWx0TWF0ZXJpYWw6IE1hdGVyaWFsRGVzY3JpcHRvcixcbiAgICBsYXlvdXQ6IEF0dHJpYnV0ZURldGFpbHNbXSA9IGRlZmF1bHRMYXlvdXQsXG4gICAgcGlwZWxpbmVzOiBQYXJ0aWFsPFJlY29yZDxudW1iZXIsIEdlb21ldHJ5UGlwZWxpbmU+PiA9IHt9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgbG9nOiAoKG1zZzogdW5rbm93bikgPT4gdm9pZCkgPSBjb25zb2xlLmxvZyxcbikge1xuICAgIGxvZygnc3RhcnRpbmcgaW1wb3J0Jyk7XG5cbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZ2x0ZldpdGhCdWZmZXJzID0gYXdhaXQgbG9hZCh1cmwsIEdMVEZMb2FkZXIpO1xuICAgIGxvZyhgZmluaXNoZWQgbG9hZGluZzogJHtEYXRlLm5vdygpIC0gc3RhcnR9YCk7XG5cbiAgICBjb25zdCB7IHNjZW5lIH0gPSBwb3N0UHJvY2Vzc0dMVEYoZ2x0ZldpdGhCdWZmZXJzKTtcbiAgICBpZiAoc2NlbmU/Lm5vZGVzID09IG51bGwpIHJldHVybiBwaXBlbGluZXM7XG4gICAgbG9nKGBmaW5pc2hlZCBwcm9jZXNzaW5nOiAke0RhdGUubm93KCkgLSBzdGFydH1gKTtcblxuICAgIGNvbnN0IG1lc2hlcyA9IG5ldyBNYXA8R0xURk1lc2hQb3N0cHJvY2Vzc2VkLCBNYXQ0W10+KCk7XG4gICAgc2NlbmUubm9kZXMuZm9yRWFjaChyZWN1cnNlTm9kZShtYXQ0LmlkZW50aXR5KCksIG1lc2hlcykpO1xuICAgIGxvZyhgZmluaXNoZWQgY3JlYXRpbmcgaW5zdGFuY2VzOiAke0RhdGUubm93KCkgLSBzdGFydH1gKTtcblxuICAgIGNvbnN0IG1lc2hFbnRyaWVzID0gQXJyYXkuZnJvbShtZXNoZXMuZW50cmllcygpKTtcbiAgICBjb25zdCBwcmltaXRpdmVQcm9taXNlcyA9IG1lc2hFbnRyaWVzLmZsYXRNYXAoKFt7IHByaW1pdGl2ZXMgfSwgaW5zdGFuY2VzXSkgPT5cbiAgICAgICAgcHJpbWl0aXZlcy5tYXAoKHByaW0pID0+IGxvYWRQcmltaXRpdmUoXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICBwcmltLFxuICAgICAgICAgICAgaW5zdGFuY2VzLFxuICAgICAgICAgICAgZGVzY3JpcHRvck1hcCxcbiAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgKSksXG4gICAgKTtcblxuICAgIGNvbnN0IHByaW1pdGl2ZURlc2NyaXB0b3JzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJpbWl0aXZlUHJvbWlzZXMpO1xuICAgIGxvZyhgZmluaXNoZWQgY3JlYXRpbmcgcHJpbWl0aXZlczogJHtEYXRlLm5vdygpIC0gc3RhcnR9YCk7XG5cbiAgICB0eXBlIE1hdGVyaWFsS2V5ID0geyBtYXRlcmlhbElkPzogc3RyaW5nLCBmZWF0dXJlczogbnVtYmVyIH07XG4gICAgY29uc3QgbWF0ZXJpYWxNYXAgPSBuZXcgTWFwPE1hdGVyaWFsS2V5LCBQcmltaXRpdmVEcmF3RGF0YVtdPigpO1xuICAgIGNvbnN0IG1hdGVyaWFsUHJvbWlzZXM6IFJlY29yZDxzdHJpbmcsIFByb21pc2U8TWF0ZXJpYWxEZXNjcmlwdG9yPj4gPSB7fTtcblxuICAgIGZvciAoY29uc3QgeyBtYXRlcmlhbCwgZHJhd0RhdGEgfSBvZiBwcmltaXRpdmVEZXNjcmlwdG9ycykge1xuICAgICAgICBpZiAoZHJhd0RhdGEgPT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgICAgY29uc3Qga2V5ID0geyBtYXRlcmlhbElkOiBtYXRlcmlhbD8uaWQsIGZlYXR1cmVzOiBkcmF3RGF0YS5mZWF0dXJlcyB9O1xuICAgICAgICBpZiAoIW1hdGVyaWFsTWFwLmhhcyhrZXkpKSBtYXRlcmlhbE1hcC5zZXQoa2V5LCBbXSk7XG4gICAgICAgIG1hdGVyaWFsTWFwLmdldChrZXkpIS5wdXNoKGRyYXdEYXRhKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG5cbiAgICAgICAgaWYgKG1hdGVyaWFsICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsUHJvbWlzZXNbbWF0ZXJpYWwuaWRdID0gbG9hZE1hdGVyaWFsKG1hdGVyaWFsLCBkZWZhdWx0TWF0ZXJpYWwsIGRldmljZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtYXRlcmlhbEVudHJpZXMgPSBPYmplY3QuZW50cmllcyhtYXRlcmlhbFByb21pc2VzKVxuICAgICAgICAubWFwKGFzeW5jIChbaWQsIG1hdF0pID0+IFtpZCwgYXdhaXQgbWF0XSk7XG5cbiAgICBjb25zdCBtYXRlcmlhbERlc2NyaXB0b3JzID0gT2JqZWN0LmZyb21FbnRyaWVzKGF3YWl0IFByb21pc2UuYWxsKG1hdGVyaWFsRW50cmllcykpIGFzIFJlY29yZDxzdHJpbmcsIE1hdGVyaWFsRGVzY3JpcHRvcj47XG4gICAgbG9nKGBmaW5pc2hlZCBjcmVhdGluZyBtYXRlcmlhbCBkZXNjcmlwdG9yczogJHtEYXRlLm5vdygpIC0gc3RhcnR9YCk7XG5cbiAgICBjb25zdCBmdWxsRGVmYXVsdE1hdDogTWF0ZXJpYWxEZXNjcmlwdG9yID0geyAuLi5kZWZhdWx0TWF0ZXJpYWwsIG1ldGFsbGljRmFjdG9yOiAwIH07XG5cbiAgICBmb3IgKGNvbnN0IFt7IGZlYXR1cmVzLCBtYXRlcmlhbElkIH0sIGRyYXdEYXRhc10gb2YgbWF0ZXJpYWxNYXAuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBtYXRlcmlhbElkICE9IG51bGwgPyBtYXRlcmlhbERlc2NyaXB0b3JzW21hdGVyaWFsSWRdIDogZnVsbERlZmF1bHRNYXQ7XG4gICAgICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRlcmlhbERyYXdEYXRhKGRlc2NyaXB0b3IsIGRldmljZSwgZGVzY3JpcHRvck1hcCwgZmVhdHVyZXMsIGRyYXdEYXRhcyk7XG4gICAgICAgIGNvbnN0IHsgZmVhdHVyZXM6IGYgfSA9IG1hdDtcblxuICAgICAgICBwaXBlbGluZXNbZl0gPz89IG5ldyBHZW9tZXRyeVBpcGVsaW5lKGYsIGRlc2NyaXB0b3JNYXApO1xuICAgICAgICBwaXBlbGluZXNbZl0uYWRkTWF0ZXJpYWxzKG1hdCk7XG4gICAgfVxuXG4gICAgbG9nKGBmaW5pc2hlZDogJHtEYXRlLm5vdygpIC0gc3RhcnR9YCk7XG4gICAgcmV0dXJuIHBpcGVsaW5lcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5308\n")},5427:(module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ getSkyboxOptions)\n/* harmony export */ });\n/* unused harmony export hdrs */\n/* harmony import */ var _utils_texture_importing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8862);\n/* harmony import */ var _utils_texture_processing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9629);\n/* harmony import */ var _property_listener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9528);\n\n\n\nconst hdrPromises = await fetch(\"https://api.github.com/repos/KhronosGroup/glTF-Sample-Environments/contents?ref=low_resolution_hdrs\", { headers: { 'Content-Type': 'application/vnd.github.object+json' } })\n    .then((res) => res.json());\nconst hdrs = Object.fromEntries(hdrPromises.flatMap(({ name, download_url }) => typeof name === 'string' && typeof download_url === 'string' && download_url.endsWith('.hdr') ? [[name, download_url]] : []));\nasync function processSkybox(device, file) {\n    let buffer;\n    if (file instanceof ArrayBuffer) {\n        buffer = file;\n    }\n    else if (file instanceof File) {\n        buffer = await file.arrayBuffer();\n    }\n    else {\n        const res = await fetch(file);\n        buffer = await res.arrayBuffer();\n    }\n    const hdr = (0,_utils_texture_importing__WEBPACK_IMPORTED_MODULE_0__/* .parseHDR */ .y)(buffer);\n    return (0,_utils_texture_processing__WEBPACK_IMPORTED_MODULE_1__/* .equirectangularToCubemap */ .l3)(device, hdr, {\n        format: 'rgba16float',\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC,\n    });\n}\nfunction getSkyboxOptions(target) {\n    return {\n        [_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$type]: 'file',\n        [_property_listener__WEBPACK_IMPORTED_MODULE_2__/* .ListenerSyms */ .t.$callback]: async (val, key) => {\n            if (key !== 'value' || val == null)\n                return;\n            if (typeof val === 'string' || val instanceof File) {\n                const texture = await processSkybox(target.device, val);\n                const res = target.setSkybox(texture);\n                if (res instanceof Promise)\n                    await res;\n            }\n        },\n        accept: '.hdr',\n        selection: {\n            value: Object.keys(hdrs)[0],\n            initialValues: hdrs,\n        },\n        process: (file) => file,\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQyNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5RDtBQUNpQjtBQUN2QjtBQUVuRCxNQUFNLFdBQVcsR0FBRyxNQUFNLEtBQUssQ0FBQyxxR0FBYyxFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsY0FBYyxFQUFFLG9DQUFvQyxFQUFFLEVBQUUsQ0FBQztLQUNqSCxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBOEIsQ0FBQztBQUVyRCxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsRUFBRSxFQUFFLENBQUMsT0FBTyxJQUFJLEtBQUssUUFBUSxJQUFJLE9BQU8sWUFBWSxLQUFLLFFBQVEsSUFBSSxZQUFZLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFFck4sS0FBSyxVQUFVLGFBQWEsQ0FBQyxNQUFpQixFQUFFLElBQXVDO0lBQ25GLElBQUksTUFBbUIsQ0FBQztJQUN4QixJQUFJLElBQUksWUFBWSxXQUFXLEVBQUUsQ0FBQztRQUM5QixNQUFNLEdBQUcsSUFBSSxDQUFDO0lBQ2xCLENBQUM7U0FBTSxJQUFJLElBQUksWUFBWSxJQUFJLEVBQUUsQ0FBQztRQUM5QixNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdEMsQ0FBQztTQUFNLENBQUM7UUFDSixNQUFNLEdBQUcsR0FBRyxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM5QixNQUFNLEdBQUcsTUFBTSxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDckMsQ0FBQztJQUVELE1BQU0sR0FBRyxHQUFHLDJFQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFN0IsT0FBTyw2RkFBd0IsQ0FDM0IsTUFBTSxFQUNOLEdBQUcsRUFDSDtRQUNJLE1BQU0sRUFBRSxhQUFhO1FBQ3JCLEtBQUssRUFBRSxlQUFlLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDLFFBQVE7S0FDdEcsQ0FDSixDQUFDO0FBQ04sQ0FBQztBQUljLFNBQVMsZ0JBQWdCLENBQUMsTUFBb0I7SUFDekQsT0FBTztRQUNILENBQUMscUVBQVksQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFlO1FBQ3JDLENBQUMscUVBQVksQ0FBQyxTQUFTLENBQUMsRUFBRSxLQUFLLEVBQUUsR0FBWSxFQUFFLEdBQWdCLEVBQUUsRUFBRTtZQUMvRCxJQUFJLEdBQUcsS0FBSyxPQUFPLElBQUksR0FBRyxJQUFJLElBQUk7Z0JBQUUsT0FBTztZQUMzQyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsSUFBSSxHQUFHLFlBQVksSUFBSSxFQUFFLENBQUM7Z0JBQ2pELE1BQU0sT0FBTyxHQUFHLE1BQU0sYUFBYSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ3hELE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3RDLElBQUksR0FBRyxZQUFZLE9BQU87b0JBQUUsTUFBTSxHQUFHLENBQUM7WUFDMUMsQ0FBQztRQUNMLENBQUM7UUFDRCxNQUFNLEVBQUUsTUFBTTtRQUNkLFNBQVMsRUFBRTtZQUNQLEtBQUssRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzQixhQUFhLEVBQUUsSUFBSTtTQUN0QjtRQUNELE9BQU8sRUFBRSxDQUFDLElBQVUsRUFBRSxFQUFFLENBQUMsSUFBSTtLQUNoQyxDQUFDO0FBQ04sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy9zYW1wbGVzL3NldHRpbmdzL3NreWJveC1vcHRpb25zLnRzP2UxMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VIRFIgfSBmcm9tICcuLi8uLi91dGlscy90ZXh0dXJlLWltcG9ydGluZyc7XG5pbXBvcnQgeyBlcXVpcmVjdGFuZ3VsYXJUb0N1YmVtYXAgfSBmcm9tICcuLi8uLi91dGlscy90ZXh0dXJlLXByb2Nlc3NpbmcnO1xuaW1wb3J0IHsgTGlzdGVuZXJTeW1zIH0gZnJvbSAnLi9wcm9wZXJ0eS1saXN0ZW5lcic7XG5cbmNvbnN0IGhkclByb21pc2VzID0gYXdhaXQgZmV0Y2goSERSX0JBU0VfVVJMX18sIHsgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3ZuZC5naXRodWIub2JqZWN0K2pzb24nIH0gfSlcbiAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdO1xuXG5leHBvcnQgY29uc3QgaGRycyA9IE9iamVjdC5mcm9tRW50cmllcyhoZHJQcm9taXNlcy5mbGF0TWFwKCh7IG5hbWUsIGRvd25sb2FkX3VybCB9KSA9PiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGRvd25sb2FkX3VybCA9PT0gJ3N0cmluZycgJiYgZG93bmxvYWRfdXJsLmVuZHNXaXRoKCcuaGRyJykgPyBbW25hbWUsIGRvd25sb2FkX3VybF1dIDogW10pKTtcblxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NreWJveChkZXZpY2U6IEdQVURldmljZSwgZmlsZTogc3RyaW5nIHwgVVJMIHwgRmlsZSB8IEFycmF5QnVmZmVyKSB7XG4gICAgbGV0IGJ1ZmZlcjogQXJyYXlCdWZmZXI7XG4gICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBidWZmZXIgPSBmaWxlO1xuICAgIH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgYnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGZpbGUpO1xuICAgICAgICBidWZmZXIgPSBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZHIgPSBwYXJzZUhEUihidWZmZXIpO1xuXG4gICAgcmV0dXJuIGVxdWlyZWN0YW5ndWxhclRvQ3ViZW1hcChcbiAgICAgICAgZGV2aWNlLFxuICAgICAgICBoZHIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ3JnYmExNmZsb2F0JyxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQyxcbiAgICAgICAgfSxcbiAgICApO1xufVxuXG5leHBvcnQgdHlwZSBTa3lib3hUYXJnZXQgPSB7IGRldmljZTogR1BVRGV2aWNlLCBzZXRTa3lib3g6IChyZXNvdXJjZTogR1BVVGV4dHVyZSkgPT4gdW5rbm93biB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTa3lib3hPcHRpb25zKHRhcmdldDogU2t5Ym94VGFyZ2V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW0xpc3RlbmVyU3ltcy4kdHlwZV06ICdmaWxlJyBhcyBjb25zdCxcbiAgICAgICAgW0xpc3RlbmVyU3ltcy4kY2FsbGJhY2tdOiBhc3luYyAodmFsOiB1bmtub3duLCBrZXk6IFByb3BlcnR5S2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAndmFsdWUnIHx8IHZhbCA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBhd2FpdCBwcm9jZXNzU2t5Ym94KHRhcmdldC5kZXZpY2UsIHZhbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gdGFyZ2V0LnNldFNreWJveCh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUHJvbWlzZSkgYXdhaXQgcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhY2NlcHQ6ICcuaGRyJyxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgICB2YWx1ZTogT2JqZWN0LmtleXMoaGRycylbMF0sXG4gICAgICAgICAgICBpbml0aWFsVmFsdWVzOiBoZHJzLFxuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzOiAoZmlsZTogRmlsZSkgPT4gZmlsZSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5427\n")},157:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/* wgsl */`\r\n    struct VertOut {\r\n        @builtin(position) pos: vec4f,\r\n        @location(0) uv: vec2f,\r\n    }\r\n\r\n    @vertex\r\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\r\n        const pos = array(\r\n            vec2f(-1,  3),\r\n            vec2f(3, -1),\r\n            vec2f(-1, -1),\r\n        );\r\n        var res: VertOut;\r\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\r\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\r\n        return res;\r\n    }\r\n`);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBLDJFQUF5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0J4QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3NoYWRlcnMvYmxpdC12ZXJ0LnNoYWRlci50cz9hNTE4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC8qIHdnc2wgKi9gXHJcbiAgICBzdHJ1Y3QgVmVydE91dCB7XHJcbiAgICAgICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvczogdmVjNGYsXHJcbiAgICAgICAgQGxvY2F0aW9uKDApIHV2OiB2ZWMyZixcclxuICAgIH1cclxuXHJcbiAgICBAdmVydGV4XHJcbiAgICBmbiB2cyhAYnVpbHRpbih2ZXJ0ZXhfaW5kZXgpIGlkeDogdTMyKSAtPiBWZXJ0T3V0IHtcclxuICAgICAgICBjb25zdCBwb3MgPSBhcnJheShcclxuICAgICAgICAgICAgdmVjMmYoLTEsICAzKSxcclxuICAgICAgICAgICAgdmVjMmYoMywgLTEpLFxyXG4gICAgICAgICAgICB2ZWMyZigtMSwgLTEpLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyIHJlczogVmVydE91dDtcclxuICAgICAgICByZXMucG9zID0gdmVjNGYocG9zW2lkeF0sIDAuMCwgMS4wKTtcclxuICAgICAgICByZXMudXYgPSBwb3NbaWR4XSAqIHZlYzJmKDAuNSwgLTAuNSkgKyAwLjU7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuYDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///157\n")},6097:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* binding */ toWorldDir),\n/* harmony export */   X: () => (/* binding */ cubemapSampleConversions)\n/* harmony export */ });\nconst toWorldDir = /* wgsl */ `\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n`;\n/**\n *  WGSL functions for sampling across adjacent faces of a cubemap\n */\nconst cubemapSampleConversions = /* wgsl */ `\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA5Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTSxVQUFVLEdBQVcsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQzNDLENBQUM7QUFFRjs7R0FFRztBQUNJLE1BQU0sd0JBQXdCLEdBQVcsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThJekQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy9zaGFkZXJzL2N1YmVtYXAtc2FtcGxpbmcuc2hhZGVyLnRzPzZjOTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHRvV29ybGREaXI6IHN0cmluZyA9IC8qIHdnc2wgKi9gXG4gICAgZm4gdG9Xb3JsZERpcihjb29yZDogdmVjM3UsIHNpemU6IHUzMikgLT4gdmVjM2Yge1xuICAgICAgICBsZXQgdXYgPSAoMi4wIC8gZjMyKHNpemUpKSAqICh2ZWMyZihjb29yZC54eSkgKyAwLjUpIC0gMS4wO1xuXG4gICAgICAgIHZhciBwb3M6IHZlYzNmO1xuICAgICAgICBzd2l0Y2ggKGNvb3JkLnopIHtcbiAgICAgICAgICAgIGNhc2UgMCAgeyBwb3MgPSB2ZWMzKCAgMS4wLCAtdXYueSwgLXV2LngpOyB9XG4gICAgICAgICAgICBjYXNlIDEgIHsgcG9zID0gdmVjMyggLTEuMCwgLXV2LnksICB1di54KTsgfVxuICAgICAgICAgICAgY2FzZSAyICB7IHBvcyA9IHZlYzMoIHV2LngsICAgMS4wLCAgdXYueSk7IH1cbiAgICAgICAgICAgIGNhc2UgMyAgeyBwb3MgPSB2ZWMzKCB1di54LCAgLTEuMCwgLXV2LnkpOyB9XG4gICAgICAgICAgICBjYXNlIDQgIHsgcG9zID0gdmVjMyggdXYueCwgLXV2LnksICAgMS4wKTsgfVxuICAgICAgICAgICAgZGVmYXVsdCB7IHBvcyA9IHZlYzMoLXV2LngsIC11di55LCAgLTEuMCk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemUocG9zKTtcbiAgICB9XG5cbiAgICBmbiB0b1dvcmxkRGlyRjMyKGNvb3JkOiB2ZWMyZiwgZmFjZTogdTMyKSAtPiB2ZWMzZiB7XG4gICAgICAgIGxldCB1diA9IDIuMCAqIGNvb3JkIC0gMS4wO1xuXG4gICAgICAgIHZhciBwb3M6IHZlYzNmO1xuICAgICAgICBzd2l0Y2ggKGZhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgMCAgeyBwb3MgPSB2ZWMzKCAgMS4wLCAtdXYueSwgLXV2LngpOyB9XG4gICAgICAgICAgICBjYXNlIDEgIHsgcG9zID0gdmVjMyggLTEuMCwgLXV2LnksICB1di54KTsgfVxuICAgICAgICAgICAgY2FzZSAyICB7IHBvcyA9IHZlYzMoIHV2LngsICAgMS4wLCAgdXYueSk7IH1cbiAgICAgICAgICAgIGNhc2UgMyAgeyBwb3MgPSB2ZWMzKCB1di54LCAgLTEuMCwgLXV2LnkpOyB9XG4gICAgICAgICAgICBjYXNlIDQgIHsgcG9zID0gdmVjMyggdXYueCwgLXV2LnksICAgMS4wKTsgfVxuICAgICAgICAgICAgZGVmYXVsdCB7IHBvcyA9IHZlYzMoLXV2LngsIC11di55LCAgLTEuMCk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemUocG9zKTtcbiAgICB9XG5gO1xuXG4vKipcbiAqICBXR1NMIGZ1bmN0aW9ucyBmb3Igc2FtcGxpbmcgYWNyb3NzIGFkamFjZW50IGZhY2VzIG9mIGEgY3ViZW1hcFxuICovXG5leHBvcnQgY29uc3QgY3ViZW1hcFNhbXBsZUNvbnZlcnNpb25zOiBzdHJpbmcgPSAvKiB3Z3NsICovYFxuICAgIGNvbnN0IElOVkFMSURfRkFDRSA9IDY7XG4gICAgY29uc3QgSU5WQUxJRF9JRFggPSA0Mjk0OTY3Mjk1dTsgLy8gbWF4IHUzMlxuXG4gICAgZm4gY3ViZVNhbXBsZUNvb3JkKGNvb3JkOiB2ZWMzaSwgdzogdTMyKSAtPiB2ZWMzdSB7XG4gICAgICAgIC8vIGEgZmxhdHRlbmVkIG1hdHJpeCBvZiBkZXN0aW5hdGlvbiBmYWNlcyBiYXNlZCBvblxuICAgICAgICAvLyBzdGFydGluZyBmYWNlIGFuZCBkaXJlY3Rpb25cbiAgICAgICAgY29uc3QgZGZhY2VzID0gYXJyYXkoXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJICBVcCBEb3duIExlZnQgUmlnaHQgSW52YWxpZFxuICAgICAgICAgICAgMCwgMiwgMywgNCwgNSwgSU5WQUxJRF9GQUNFLCAvLyArWCAgK1kgICAtWSAgICtaICAgLVogICBcbiAgICAgICAgICAgIDEsIDIsIDMsIDUsIDQsIElOVkFMSURfRkFDRSwgLy8gLVggICtZICAgLVkgICAtWiAgICtaIFxuICAgICAgICAgICAgMiwgNSwgNCwgMSwgMCwgSU5WQUxJRF9GQUNFLCAvLyArWSAgLVogICArWiAgIC1YICAgK1ggXG4gICAgICAgICAgICAzLCA0LCA1LCAxLCAwLCBJTlZBTElEX0ZBQ0UsIC8vIC1ZICArWiAgIC1aICAgLVggICArWCBcbiAgICAgICAgICAgIDQsIDIsIDMsIDEsIDAsIElOVkFMSURfRkFDRSwgLy8gK1ogICtZICAgLVkgICAtWCAgICtYIFxuICAgICAgICAgICAgNSwgMiwgMywgMCwgMSwgSU5WQUxJRF9GQUNFLCAvLyAtWiAgK1kgICAtWSAgICtYICAgLVggXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYSBmbGF0dGVuZWQgbWF0cml4IGluIHRoZSBzYW1lIGZvcm0gYXMgZGZhY2VzXG4gICAgICAgIC8vIGdpdmluZyB0aGUgaW5kZXggb2YgdGhlIGRtYXQgYXJyYXkgY29udGFpbmluZyBcbiAgICAgICAgLy8gdGhlIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIHN0YXJ0aW5nIGZhY2UgdG8gXG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBmYWNlXG4gICAgICAgIGNvbnN0IGRpbmRpY2VzID0gYXJyYXkoXG4gICAgICAgICAgICAwLCAxLCAgMiwgIDMsICA0LCAgMCxcbiAgICAgICAgICAgIDAsIDUsICA2LCAgMywgIDQsICAwLFxuICAgICAgICAgICAgMCwgNywgIDgsICA5LCAgMTAsIDAsXG4gICAgICAgICAgICAwLCAxMSwgMTIsIDEzLCAxNCwgMCxcbiAgICAgICAgICAgIDAsIDExLCA4LCAgMywgIDQsICAwLFxuICAgICAgICAgICAgMCwgNywgIDEyLCAzLCAgNCwgIDAsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gMng0IG1hdHJpY2VzIHRyYW5zZm9ybWluZyBhIGNvb3JkaW5hdGUgdmVjdG9yIDx1LCB2LCB3LCAxPlxuICAgICAgICAvLyBmcm9tIG9uZSBmYWNlIHRvIGFub3RoZXJcbiAgICAgICAgY29uc3QgZG1hdHMgPSBhcnJheShcbiAgICAgICAgICAgIGFycmF5KC8vIDBcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDAsIDApLCAgIC8vIHUgPSB1XG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAwLCAwKSwgICAvLyB2ID0gdlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDEsIDApLCAgIC8vIHUgPSB2ICsgd1xuICAgICAgICAgICAgICAgIHZlYzQoLTEsIDAsIDEsIC0xKSwgLy8gdiA9IHcgLSB1IC0gMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDJcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAyLCAtMSksIC8vIHUgPSAydyAtIHYgLSAxXG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAwLCAwKSwgICAvLyB2ID0gdVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDNcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDEsIDApLCAgIC8vIHUgPSB1ICsgd1xuICAgICAgICAgICAgICAgIHZlYzQoMCwgMSwgMCwgMCksICAgLy8gdiA9IHZcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhcnJheSgvLyA0XG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAtMSwgMCksICAvLyB1ID0gdSAtIHdcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDAsIDApLCAgIC8vIHYgPSB2XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gNVxuICAgICAgICAgICAgICAgIHZlYzQoMCwgLTEsIDAsIC0xKSwgLy8gdSA9IC12IC0gMVxuICAgICAgICAgICAgICAgIHZlYzQoMSwgMCwgMCwgMCksICAgLy8gdiA9IHVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhcnJheSgvLyA2XG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAtMSwgMCksICAvLyB1ID0gdiAtIHdcbiAgICAgICAgICAgICAgICB2ZWM0KC0xLCAwLCAxLCAtMSksIC8vIHYgPSB3IC0gdSAtIDFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhcnJheSgvLyA3XG4gICAgICAgICAgICAgICAgdmVjNCgtMSwgMCwgMSwgLTEpLCAvLyB1ID0gdyAtIHUgLSAxXG4gICAgICAgICAgICAgICAgdmVjNCgwLCAtMSwgMCwgLTEpLCAvLyB2ID0gLXYgLSAxXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gOFxuICAgICAgICAgICAgICAgIHZlYzQoMSwgMCwgMCwgMCksICAgLy8gdSA9IHVcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIC0xLCAwKSwgIC8vIHYgPSB2IC0gd1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDlcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIDEsIDAsIDApLCAgIC8vIHUgPSB2XG4gICAgICAgICAgICAgICAgdmVjNCgtMSwgMCwgMCwgLTEpLCAvLyB2ID0gLXUgLSAxXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gMTBcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAxLCAtMSksIC8vIHUgPSB3IC0gdiAtIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIC0xLCAwKSwgIC8vIHYgPSB1IC0gd1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDExXG4gICAgICAgICAgICAgICAgdmVjNCgxLCAwLCAwLCAwKSwgICAvLyB1ID0gdVxuICAgICAgICAgICAgICAgIHZlYzQoMCwgMSwgMSwgMCksICAgLy8gdiA9IHYgKyB3XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gMTJcbiAgICAgICAgICAgICAgICB2ZWM0KC0xLCAwLCAxLCAtMSksIC8vIHUgPSB3IC0gdSAtIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAyLCAtMSksIC8vIHYgPSAydyAtIHYgLSAxXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXJyYXkoLy8gMTNcbiAgICAgICAgICAgICAgICB2ZWM0KDAsIC0xLCAxLCAtMSksIC8vIHUgPSB3IC0gdiAtIDFcbiAgICAgICAgICAgICAgICB2ZWM0KDEsIDAsIDEsIDApLCAgIC8vIHYgPSB1ICsgd1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFycmF5KC8vIDE0XG4gICAgICAgICAgICAgICAgdmVjNCgwLCAxLCAwLCAwKSwgICAvLyB1ID0gdlxuICAgICAgICAgICAgICAgIHZlYzQoLTEsIDAsIDIsIC0xKSwgLy8gdiA9IDJ3IC0gdSAtIDFcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGl3ID0gaTMyKHcpO1xuXG4gICAgICAgIHZhciBkaXIgPSAwO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb29yZC55ID49IGl3ICogMiAtIDEgXG4gICAgICAgICAgICB8fCBjb29yZC55IDw9IC1pdyBcbiAgICAgICAgICAgIHx8IGNvb3JkLnggPj0gaXcgKiAyIC0gMSBcbiAgICAgICAgICAgIHx8IGNvb3JkLnggPD0gLWl3XG4gICAgICAgICkge1xuICAgICAgICAgICAgZGlyID0gNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb29yZC55IDwgMCkge1xuICAgICAgICAgICAgICAgIGRpciA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvb3JkLnkgPj0gaXcpIHtcbiAgICAgICAgICAgICAgICBkaXIgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvb3JkLnggPCAwKSB7XG4gICAgICAgICAgICAgICAgZGlyID0gc2VsZWN0KDUsIDMsIGRpciA9PSAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29vcmQueCA+PSBpdykge1xuICAgICAgICAgICAgICAgIGRpciA9IHNlbGVjdCg1LCA0LCBkaXIgPT0gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaWR4ID0gY29vcmQueiAqIDYgKyBkaXI7XG4gICAgICAgIGxldCBzYW1wID0gdmVjNChjb29yZC54eSwgaXcsIDEpO1xuICAgICAgICBsZXQgZG1hdCA9IGRtYXRzW2RpbmRpY2VzW2lkeF1dO1xuICAgICAgICByZXR1cm4gdmVjM3UodmVjMyhkb3QoZG1hdFswXSwgc2FtcCksIGRvdChkbWF0WzFdLCBzYW1wKSwgZGZhY2VzW2lkeF0pKTtcbiAgICB9XG5cbiAgICBmbiBjdWJlQ29vcmRUb0lkeChjb29yZDogdmVjM3UsIHc6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkLnggKyBjb29yZC55ICogdyArIGNvb3JkLnogKiB3ICogdztcbiAgICB9XG5cbiAgICBmbiBjdWJlSWR4VG9Db29yZChpZHg6IHUzMiwgdzogdTMyKSAtPiB2ZWMzdSB7XG4gICAgICAgIGxldCB3MiA9IHcgKiB3O1xuICAgICAgICBsZXQgZmlkeCA9IGlkeCAlIHcyO1xuICAgICAgICByZXR1cm4gdmVjM3UoZmlkeCAlIHcsIGZpZHggLyB3LCBpZHggLyB3Mik7XG4gICAgfVxuXG4gICAgZm4gY3ViZVNhbXBsZUlkeCh1dmY6IHZlYzNpLCB3OiB1MzIpIC0+IHUzMiB7XG4gICAgICAgIGxldCBjb29yZCA9IGN1YmVTYW1wbGVDb29yZCh1dmYsIHcpO1xuICAgICAgICByZXR1cm4gc2VsZWN0KFxuICAgICAgICAgICAgY3ViZUNvb3JkVG9JZHgoY29vcmQsIHcpLCBcbiAgICAgICAgICAgIElOVkFMSURfSURYLCBcbiAgICAgICAgICAgIGNvb3JkLnogPT0gSU5WQUxJRF9GQUNFLFxuICAgICAgICApO1xuICAgIH1cbmA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6097\n")},5752:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lr: () => (/* binding */ createAndCopyBuffer)\n/* harmony export */ });\n/* unused harmony exports createAndCopyCubemap, ktx2ToTexture, textureToArrayBuffer, textureToKTX */\n/* harmony import */ var _rendering_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3970);\n\n\n\nfunction createAndCopyBuffer(arr, usage, device, label, alignment = 4) {\n    const pad = alignment - 1;\n    const buffer = device.createBuffer({\n        label,\n        usage,\n        size: (arr.byteLength + pad) & ~pad,\n        mappedAtCreation: true,\n    });\n    const writeArray = new Uint8Array(buffer.getMappedRange());\n    const readArray = arr instanceof ArrayBuffer\n        ? new Uint8Array(arr)\n        : new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n    writeArray.set(readArray);\n    buffer.unmap();\n    return buffer;\n}\nfunction createAndCopyCubemap(device, data, format, usage, label) {\n    const pixelSize = TextureFormatToSize[format];\n    if (pixelSize == null) {\n        throw new Error(`copy cubemap -- unsupported format: ${format}`);\n    }\n    const width = Math.sqrt(data.byteLength / (6 * pixelSize));\n    const size = { width, height: width, depthOrArrayLayers: 6 };\n    const texture = device.createTexture({\n        usage: usage | GPUTextureUsage.COPY_DST,\n        label,\n        format,\n        size,\n    });\n    device.queue.writeTexture({ texture }, data, { bytesPerRow: width * pixelSize, rowsPerImage: width }, size);\n    return texture;\n}\nfunction ktx2ToTexture(buffer, device, options) {\n    const arr = new Uint8Array(buffer);\n    const ktx = ktxparse.read(arr);\n    const format = VkFormatToWebGPU[ktx.vkFormat];\n    if (format == null) {\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not covert to webgpu`);\n    }\n    const pixelSize = TextureFormatToSize[format];\n    if (pixelSize == null) {\n        throw new Error(`ktx texture import -- unsupported format: ${ktx.vkFormat}\\n\\tCould not get pixel byte size`);\n    }\n    const size = {\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        depthOrArrayLayers: ktx.faceCount,\n    };\n    const maxMipCount = Math.ceil(Math.log2(Math.max(size.width, size.height))) + 1;\n    let mipLevelCount = ktx.levels.length;\n    if (options?.mipLevelCount === 'max') {\n        mipLevelCount = maxMipCount;\n    }\n    else if (typeof options?.mipLevelCount === 'number') {\n        mipLevelCount = Math.min(maxMipCount, options.mipLevelCount);\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (options?.textureUsage)\n        usage |= options.textureUsage;\n    const texture = device.createTexture({\n        label: options?.label,\n        size,\n        mipLevelCount,\n        format,\n        usage,\n    });\n    const mipCopies = Math.min(ktx.levels.length, mipLevelCount) - 1;\n    for (let mipLevel = mipCopies; mipLevel >= 0; mipLevel -= 1) {\n        const width = size.width >> mipLevel;\n        const height = size.height >> mipLevel;\n        const { levelData } = ktx.levels[mipLevel];\n        const rawBytesPerRow = width * pixelSize;\n        const bytesPerRow = Math.max(rawBytesPerRow, 256);\n        const rowsPerImage = height;\n        const bytesPerImage = rowsPerImage * bytesPerRow;\n        let imageData = levelData;\n        if (bytesPerRow > rawBytesPerRow) {\n            imageData = new Uint8Array(bytesPerImage * texture.depthOrArrayLayers);\n            for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\n                for (let w = 0; w < rawBytesPerRow; w += 1) {\n                    imageData[w + h * bytesPerRow] = levelData[w + h * rawBytesPerRow];\n                }\n            }\n        }\n        const layerBatch = Math.min(Math.floor(device.limits.maxBufferSize / bytesPerImage), ktx.faceCount);\n        const layerCount = Math.ceil(ktx.faceCount / layerBatch);\n        for (let l = 0; l < layerCount; l += 1) {\n            const offset = l * layerBatch;\n            const count = Math.min(layerBatch, ktx.faceCount - offset);\n            const data = layerCount > 1\n                ? imageData.subarray(offset * bytesPerImage, (offset + count) * bytesPerImage)\n                : imageData;\n            device.queue.writeTexture({ mipLevel, texture, origin: [0, 0, offset] }, data, { bytesPerRow, rowsPerImage }, [width, height, count]);\n        }\n    }\n    return texture;\n}\nasync function textureToArrayBuffer({ device, texture, mipLevel = 0, returnBuffer, storageBuffer, resultBuffer, description, }) {\n    const pixelSize = TextureFormatToSize[texture.format];\n    const fullDescription = padTemplate `[textureToKTX${description ?? ''}${texture.label}] --`;\n    if (pixelSize == null) {\n        throw new Error(`${fullDescription} format ${texture.format} unsupported`);\n    }\n    const width = texture.width >> mipLevel;\n    const height = texture.height >> mipLevel;\n    const rawBytesPerRow = width * pixelSize;\n    const bytesPerRow = Math.max(rawBytesPerRow, 256);\n    const rowsPerImage = height;\n    const byteSize = rowsPerImage * bytesPerRow * texture.depthOrArrayLayers;\n    const resultSize = rawBytesPerRow * height * texture.depthOrArrayLayers;\n    if (resultBuffer != null && resultBuffer.byteLength < byteSize) {\n        throw new Error(`${fullDescription} given result array not large enough.\r\n${resultBuffer.byteLength} < ${byteSize}`);\n    }\n    if (storageBuffer != null && storageBuffer.size < byteSize) {\n        throw new Error(`${fullDescription} given storage buffer not large enough.\r\n${storageBuffer.size} < ${byteSize}`);\n    }\n    const requiredUsage = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n    if (storageBuffer != null && (storageBuffer.usage & requiredUsage) !== requiredUsage) {\n        throw new Error(`${fullDescription} given storage does not have correct usage flags.\r\nGiven: ${storageBuffer.usage}\r\nRequired: ${requiredUsage}`);\n    }\n    let imageData = resultBuffer ?? new Uint8Array(byteSize);\n    const storage = storageBuffer ?? device.createBuffer({\n        label: `${fullDescription} storage buffer`,\n        size: byteSize,\n        usage: requiredUsage,\n    });\n    const encoder = device.createCommandEncoder({ label: `${fullDescription} encoder` });\n    encoder.copyTextureToBuffer({ texture, mipLevel }, { buffer: storage, rowsPerImage, bytesPerRow }, { width, height, depthOrArrayLayers: texture.depthOrArrayLayers });\n    device.queue.submit([encoder.finish()]);\n    await Promise.all([\n        storage.mapAsync(GPUMapMode.READ, 0, byteSize),\n        device.queue.onSubmittedWorkDone(),\n    ]);\n    const mapped = storage.getMappedRange(0, byteSize);\n    imageData.set(new Uint8Array(mapped));\n    storage.unmap();\n    if (bytesPerRow > rawBytesPerRow) {\n        for (let h = 0; h < height * texture.depthOrArrayLayers; h += 1) {\n            for (let w = 0; w < rawBytesPerRow; w += 1) {\n                imageData[w + h * rawBytesPerRow] = imageData[w + h * bytesPerRow];\n            }\n        }\n        imageData = imageData.slice(0, resultSize);\n    }\n    return {\n        imageData,\n        storageBuffer: returnBuffer ? storage : undefined,\n    };\n}\nasync function textureToKTX(device, texture, cube = false) {\n    const pixelSize = TextureFormatToSize[texture.format];\n    const typeSize = TextureFormatToChannelSize[texture.format];\n    if (pixelSize == null || typeSize == null) {\n        throw new Error(`textureToKTX -- format ${texture.format} of ${texture.label} unsupported`);\n    }\n    const container = new ktxparse.KTX2Container();\n    container.pixelWidth = texture.width;\n    container.pixelHeight = texture.height;\n    container.vkFormat = WebGPUToVkFormat[texture.format];\n    container.typeSize = typeSize;\n    delete container.keyValue.KTXswizzle;\n    const dataFormat = container.dataFormatDescriptor[0];\n    dataFormat.colorModel = ktxparse.KHR_DF_MODEL_RGBSDA;\n    dataFormat.transferFunction = ktxparse.KHR_DF_TRANSFER_LINEAR;\n    dataFormat.bytesPlane[0] = pixelSize;\n    dataFormat.samples = [0, 1, 2, 3].map((i) => ({\n        channelType: [192, 193, 194, 207][i],\n        samplePosition: [0, 0, 0, 0],\n        bitLength: container.typeSize * 8 - 1,\n        bitOffset: container.typeSize * 8 * i,\n        sampleLower: -1082130432,\n        sampleUpper: 1065353216,\n    }));\n    if (texture.dimension === '3d') {\n        container.faceCount = 1;\n        container.pixelDepth = texture.depthOrArrayLayers;\n    }\n    else if (cube) {\n        const cubeLayers = texture.depthOrArrayLayers / 6;\n        container.layerCount = cubeLayers === 1 ? 0 : cubeLayers;\n        container.faceCount = 6;\n    }\n    else {\n        container.layerCount = texture.depthOrArrayLayers;\n        container.faceCount = 1;\n    }\n    let storageBuffer;\n    let imageData;\n    for (let i = 0; i < texture.mipLevelCount; i += 1) {\n        // eslint-disable-next-line no-await-in-loop\n        ({ imageData, storageBuffer } = await textureToArrayBuffer({\n            mipLevel: i,\n            returnBuffer: true,\n            device,\n            texture,\n            storageBuffer,\n        }));\n        container.levels.push({\n            levelData: imageData,\n            uncompressedByteLength: imageData.byteLength,\n        });\n    }\n    return ktxparse.write(container);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUcsTUFBTSxvQkFBb0IsQ0FBQztZQUN2RCxRQUFRLEVBQUUsQ0FBQztZQUNYLFlBQVksRUFBRSxJQUFJO1lBQ2xCLE1BQU07WUFDTixPQUFPO1lBQ1AsYUFBYTtTQUNoQixDQUFDLENBQUMsQ0FBQztRQUVKLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2xCLFNBQVMsRUFBRSxTQUFTO1lBQ3BCLHNCQUFzQixFQUFFLFNBQVMsQ0FBQyxVQUFVO1NBQy9DLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRCxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDckMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NidW50LXBvcnRmb2xpby8uL3NyYy91dGlscy9kYXRhLWNvcHkudHM/YmE1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBrdHhwYXJzZSBmcm9tICdrdHgtcGFyc2UnO1xyXG5cclxuaW1wb3J0IHsgVmtGb3JtYXRUb1dlYkdQVSwgVGV4dHVyZUZvcm1hdFRvU2l6ZSwgVGV4dHVyZUZvcm1hdFRvQ2hhbm5lbFNpemUsIFdlYkdQVVRvVmtGb3JtYXQgfSBmcm9tICcuLi9yZW5kZXJpbmcvY29uc3RhbnRzJztcclxuaW1wb3J0IHsgcGFkVGVtcGxhdGUgfSBmcm9tICcuL2dlbmVyYWwnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFuZENvcHlCdWZmZXIoXHJcbiAgICBhcnI6IEFycmF5QnVmZmVyIHwgVHlwZWRBcnJheUxpa2UsXHJcbiAgICB1c2FnZTogR1BVRmxhZ3NDb25zdGFudCxcclxuICAgIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgbGFiZWw/OiBzdHJpbmcsXHJcbiAgICBhbGlnbm1lbnQgPSA0LFxyXG4pOiBHUFVCdWZmZXIge1xyXG4gICAgY29uc3QgcGFkID0gYWxpZ25tZW50IC0gMTtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIHVzYWdlLFxyXG4gICAgICAgIHNpemU6IChhcnIuYnl0ZUxlbmd0aCArIHBhZCkgJiB+cGFkLFxyXG4gICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXHJcbiAgICB9IGFzIEdQVUJ1ZmZlckRlc2NyaXB0b3IpO1xyXG5cclxuICAgIGNvbnN0IHdyaXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSk7XHJcbiAgICBjb25zdCByZWFkQXJyYXkgPSBhcnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxyXG4gICAgICAgID8gbmV3IFVpbnQ4QXJyYXkoYXJyKVxyXG4gICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcclxuXHJcbiAgICB3cml0ZUFycmF5LnNldChyZWFkQXJyYXkpO1xyXG4gICAgYnVmZmVyLnVubWFwKCk7XHJcblxyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFuZENvcHlDdWJlbWFwKFxyXG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXHJcbiAgICBkYXRhOiBBcnJheUJ1ZmZlcixcclxuICAgIGZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCxcclxuICAgIHVzYWdlOiBudW1iZXIsXHJcbiAgICBsYWJlbD86IHN0cmluZyxcclxuKSB7XHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW2Zvcm1hdF07XHJcbiAgICBpZiAocGl4ZWxTaXplID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvcHkgY3ViZW1hcCAtLSB1bnN1cHBvcnRlZCBmb3JtYXQ6ICR7Zm9ybWF0fWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5zcXJ0KGRhdGEuYnl0ZUxlbmd0aCAvICg2ICogcGl4ZWxTaXplKSk7XHJcbiAgICBjb25zdCBzaXplID0geyB3aWR0aCwgaGVpZ2h0OiB3aWR0aCwgZGVwdGhPckFycmF5TGF5ZXJzOiA2IH07XHJcblxyXG4gICAgY29uc3QgdGV4dHVyZSA9IGRldmljZS5jcmVhdGVUZXh0dXJlKHtcclxuICAgICAgICB1c2FnZTogdXNhZ2UgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1QsXHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgZm9ybWF0LFxyXG4gICAgICAgIHNpemUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXZpY2UucXVldWUud3JpdGVUZXh0dXJlKFxyXG4gICAgICAgIHsgdGV4dHVyZSB9LFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgeyBieXRlc1BlclJvdzogd2lkdGggKiBwaXhlbFNpemUsIHJvd3NQZXJJbWFnZTogd2lkdGggfSxcclxuICAgICAgICBzaXplLFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgS1RYSW1wb3J0T3B0aW9ucyA9IHtcclxuICAgIGxhYmVsPzogc3RyaW5nLFxyXG4gICAgbWlwTGV2ZWxDb3VudD86IG51bWJlciB8ICdtYXgnIHwgJ2RlZmF1bHQnLFxyXG4gICAgdGV4dHVyZVVzYWdlPzogbnVtYmVyLFxyXG4gICAgdmFsaWRhdGU/OiBib29sZWFuLFxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGt0eDJUb1RleHR1cmUoXHJcbiAgICBidWZmZXI6IEFycmF5QnVmZmVyLFxyXG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXHJcbiAgICBvcHRpb25zPzogS1RYSW1wb3J0T3B0aW9ucyxcclxuKSB7XHJcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgY29uc3Qga3R4ID0ga3R4cGFyc2UucmVhZChhcnIpO1xyXG4gICAgY29uc3QgZm9ybWF0ID0gVmtGb3JtYXRUb1dlYkdQVVtrdHgudmtGb3JtYXRdO1xyXG5cclxuICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihga3R4IHRleHR1cmUgaW1wb3J0IC0tIHVuc3VwcG9ydGVkIGZvcm1hdDogJHtrdHgudmtGb3JtYXR9XFxuXFx0Q291bGQgbm90IGNvdmVydCB0byB3ZWJncHVgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW2Zvcm1hdF07XHJcbiAgICBpZiAocGl4ZWxTaXplID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGt0eCB0ZXh0dXJlIGltcG9ydCAtLSB1bnN1cHBvcnRlZCBmb3JtYXQ6ICR7a3R4LnZrRm9ybWF0fVxcblxcdENvdWxkIG5vdCBnZXQgcGl4ZWwgYnl0ZSBzaXplYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2l6ZSA9IHtcclxuICAgICAgICB3aWR0aDoga3R4LnBpeGVsV2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBrdHgucGl4ZWxIZWlnaHQsXHJcbiAgICAgICAgZGVwdGhPckFycmF5TGF5ZXJzOiBrdHguZmFjZUNvdW50LFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBtYXhNaXBDb3VudCA9IE1hdGguY2VpbChNYXRoLmxvZzIoTWF0aC5tYXgoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpKSkgKyAxO1xyXG4gICAgbGV0IG1pcExldmVsQ291bnQgPSBrdHgubGV2ZWxzLmxlbmd0aDtcclxuICAgIGlmIChvcHRpb25zPy5taXBMZXZlbENvdW50ID09PSAnbWF4Jykge1xyXG4gICAgICAgIG1pcExldmVsQ291bnQgPSBtYXhNaXBDb3VudDtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnM/Lm1pcExldmVsQ291bnQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgbWlwTGV2ZWxDb3VudCA9IE1hdGgubWluKG1heE1pcENvdW50LCBvcHRpb25zLm1pcExldmVsQ291bnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB1c2FnZSA9IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1Q7XHJcbiAgICBpZiAob3B0aW9ucz8udGV4dHVyZVVzYWdlKSB1c2FnZSB8PSBvcHRpb25zLnRleHR1cmVVc2FnZTtcclxuXHJcbiAgICBjb25zdCB0ZXh0dXJlID0gZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xyXG4gICAgICAgIGxhYmVsOiBvcHRpb25zPy5sYWJlbCxcclxuICAgICAgICBzaXplLFxyXG4gICAgICAgIG1pcExldmVsQ291bnQsXHJcbiAgICAgICAgZm9ybWF0LFxyXG4gICAgICAgIHVzYWdlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbWlwQ29waWVzID0gTWF0aC5taW4oa3R4LmxldmVscy5sZW5ndGgsIG1pcExldmVsQ291bnQpIC0gMTtcclxuXHJcbiAgICBmb3IgKGxldCBtaXBMZXZlbCA9IG1pcENvcGllczsgbWlwTGV2ZWwgPj0gMDsgbWlwTGV2ZWwgLT0gMSkge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gc2l6ZS53aWR0aCA+PiBtaXBMZXZlbDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBzaXplLmhlaWdodCA+PiBtaXBMZXZlbDtcclxuICAgICAgICBjb25zdCB7IGxldmVsRGF0YSB9ID0ga3R4LmxldmVsc1ttaXBMZXZlbF07XHJcblxyXG4gICAgICAgIGNvbnN0IHJhd0J5dGVzUGVyUm93ID0gd2lkdGggKiBwaXhlbFNpemU7XHJcbiAgICAgICAgY29uc3QgYnl0ZXNQZXJSb3cgPSBNYXRoLm1heChyYXdCeXRlc1BlclJvdywgMjU2KTtcclxuICAgICAgICBjb25zdCByb3dzUGVySW1hZ2UgPSBoZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgYnl0ZXNQZXJJbWFnZSA9IHJvd3NQZXJJbWFnZSAqIGJ5dGVzUGVyUm93O1xyXG5cclxuICAgICAgICBsZXQgaW1hZ2VEYXRhID0gbGV2ZWxEYXRhO1xyXG4gICAgICAgIGlmIChieXRlc1BlclJvdyA+IHJhd0J5dGVzUGVyUm93KSB7XHJcbiAgICAgICAgICAgIGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzUGVySW1hZ2UgKiB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBoID0gMDsgaCA8IGhlaWdodCAqIHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzOyBoICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgcmF3Qnl0ZXNQZXJSb3c7IHcgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YVt3ICsgaCAqIGJ5dGVzUGVyUm93XSA9IGxldmVsRGF0YVt3ICsgaCAqIHJhd0J5dGVzUGVyUm93XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbGF5ZXJCYXRjaCA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICBNYXRoLmZsb29yKGRldmljZS5saW1pdHMubWF4QnVmZmVyU2l6ZSAvIGJ5dGVzUGVySW1hZ2UpLFxyXG4gICAgICAgICAgICBrdHguZmFjZUNvdW50LFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgbGF5ZXJDb3VudCA9IE1hdGguY2VpbChrdHguZmFjZUNvdW50IC8gbGF5ZXJCYXRjaCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgbGF5ZXJDb3VudDsgbCArPSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGwgKiBsYXllckJhdGNoO1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKGxheWVyQmF0Y2gsIGt0eC5mYWNlQ291bnQgLSBvZmZzZXQpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGxheWVyQ291bnQgPiAxXHJcbiAgICAgICAgICAgICAgICA/IGltYWdlRGF0YS5zdWJhcnJheShvZmZzZXQgKiBieXRlc1BlckltYWdlLCAob2Zmc2V0ICsgY291bnQpICogYnl0ZXNQZXJJbWFnZSlcclxuICAgICAgICAgICAgICAgIDogaW1hZ2VEYXRhO1xyXG5cclxuICAgICAgICAgICAgZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZShcclxuICAgICAgICAgICAgICAgIHsgbWlwTGV2ZWwsIHRleHR1cmUsIG9yaWdpbjogWzAsIDAsIG9mZnNldF0gfSxcclxuICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICB7IGJ5dGVzUGVyUm93LCByb3dzUGVySW1hZ2UgfSxcclxuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0LCBjb3VudF0sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBUZXh0dXJlVG9BcnJheUJ1ZmZlck9wdGlvbnMgPSB7XHJcbiAgICBkZXZpY2U6IEdQVURldmljZSxcclxuICAgIHRleHR1cmU6IEdQVVRleHR1cmUsXHJcbiAgICBtaXBMZXZlbD86IG51bWJlcixcclxuICAgIHJlc3VsdEJ1ZmZlcj86IFVpbnQ4QXJyYXksXHJcbiAgICBzdG9yYWdlQnVmZmVyPzogR1BVQnVmZmVyLFxyXG4gICAgcmV0dXJuQnVmZmVyPzogYm9vbGVhbixcclxuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxyXG59O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRleHR1cmVUb0FycmF5QnVmZmVyKFxyXG4gICAgb3B0aW9uczogT21pdDxUZXh0dXJlVG9BcnJheUJ1ZmZlck9wdGlvbnMsICdyZXR1cm5CdWZmZXInPiAmIHsgcmV0dXJuQnVmZmVyPzogZmFsc2UgfSxcclxuKTogUHJvbWlzZTx7IGltYWdlRGF0YTogVWludDhBcnJheSB9PjtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0ZXh0dXJlVG9BcnJheUJ1ZmZlcihcclxuICAgIG9wdGlvbnM6IE9taXQ8VGV4dHVyZVRvQXJyYXlCdWZmZXJPcHRpb25zLCAncmV0dXJuQnVmZmVyJz4gJiB7IHJldHVybkJ1ZmZlcjogdHJ1ZSB9LFxyXG4pOiBQcm9taXNlPHsgaW1hZ2VEYXRhOiBVaW50OEFycmF5LCBzdG9yYWdlQnVmZmVyOiBHUFVCdWZmZXIgfT47XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGV4dHVyZVRvQXJyYXlCdWZmZXIoe1xyXG4gICAgZGV2aWNlLFxyXG4gICAgdGV4dHVyZSxcclxuICAgIG1pcExldmVsID0gMCxcclxuICAgIHJldHVybkJ1ZmZlcixcclxuICAgIHN0b3JhZ2VCdWZmZXIsXHJcbiAgICByZXN1bHRCdWZmZXIsXHJcbiAgICBkZXNjcmlwdGlvbixcclxufTogVGV4dHVyZVRvQXJyYXlCdWZmZXJPcHRpb25zKSB7XHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW3RleHR1cmUuZm9ybWF0XTtcclxuICAgIGNvbnN0IGZ1bGxEZXNjcmlwdGlvbiA9IHBhZFRlbXBsYXRlYFt0ZXh0dXJlVG9LVFgke2Rlc2NyaXB0aW9uID8/ICcnfSR7dGV4dHVyZS5sYWJlbH1dIC0tYDtcclxuXHJcbiAgICBpZiAocGl4ZWxTaXplID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVsbERlc2NyaXB0aW9ufSBmb3JtYXQgJHt0ZXh0dXJlLmZvcm1hdH0gdW5zdXBwb3J0ZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB3aWR0aCA9IHRleHR1cmUud2lkdGggPj4gbWlwTGV2ZWw7XHJcbiAgICBjb25zdCBoZWlnaHQgPSB0ZXh0dXJlLmhlaWdodCA+PiBtaXBMZXZlbDtcclxuICAgIGNvbnN0IHJhd0J5dGVzUGVyUm93ID0gd2lkdGggKiBwaXhlbFNpemU7XHJcbiAgICBjb25zdCBieXRlc1BlclJvdyA9IE1hdGgubWF4KHJhd0J5dGVzUGVyUm93LCAyNTYpO1xyXG4gICAgY29uc3Qgcm93c1BlckltYWdlID0gaGVpZ2h0O1xyXG4gICAgY29uc3QgYnl0ZVNpemUgPSByb3dzUGVySW1hZ2UgKiBieXRlc1BlclJvdyAqIHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzO1xyXG4gICAgY29uc3QgcmVzdWx0U2l6ZSA9IHJhd0J5dGVzUGVyUm93ICogaGVpZ2h0ICogdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnM7XHJcblxyXG4gICAgaWYgKHJlc3VsdEJ1ZmZlciAhPSBudWxsICYmIHJlc3VsdEJ1ZmZlci5ieXRlTGVuZ3RoIDwgYnl0ZVNpemUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVsbERlc2NyaXB0aW9ufSBnaXZlbiByZXN1bHQgYXJyYXkgbm90IGxhcmdlIGVub3VnaC5cclxuJHtyZXN1bHRCdWZmZXIuYnl0ZUxlbmd0aH0gPCAke2J5dGVTaXplfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdG9yYWdlQnVmZmVyICE9IG51bGwgJiYgc3RvcmFnZUJ1ZmZlci5zaXplIDwgYnl0ZVNpemUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVsbERlc2NyaXB0aW9ufSBnaXZlbiBzdG9yYWdlIGJ1ZmZlciBub3QgbGFyZ2UgZW5vdWdoLlxyXG4ke3N0b3JhZ2VCdWZmZXIuc2l6ZX0gPCAke2J5dGVTaXplfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlcXVpcmVkVXNhZ2UgPSBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEO1xyXG5cclxuICAgIGlmIChzdG9yYWdlQnVmZmVyICE9IG51bGwgJiYgKHN0b3JhZ2VCdWZmZXIudXNhZ2UgJiByZXF1aXJlZFVzYWdlKSAhPT0gcmVxdWlyZWRVc2FnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdWxsRGVzY3JpcHRpb259IGdpdmVuIHN0b3JhZ2UgZG9lcyBub3QgaGF2ZSBjb3JyZWN0IHVzYWdlIGZsYWdzLlxyXG5HaXZlbjogJHtzdG9yYWdlQnVmZmVyLnVzYWdlfVxyXG5SZXF1aXJlZDogJHtyZXF1aXJlZFVzYWdlfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpbWFnZURhdGEgPSByZXN1bHRCdWZmZXIgPz8gbmV3IFVpbnQ4QXJyYXkoYnl0ZVNpemUpO1xyXG4gICAgY29uc3Qgc3RvcmFnZSA9IHN0b3JhZ2VCdWZmZXIgPz8gZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XHJcbiAgICAgICAgbGFiZWw6IGAke2Z1bGxEZXNjcmlwdGlvbn0gc3RvcmFnZSBidWZmZXJgLFxyXG4gICAgICAgIHNpemU6IGJ5dGVTaXplLFxyXG4gICAgICAgIHVzYWdlOiByZXF1aXJlZFVzYWdlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgZW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2Rlcih7IGxhYmVsOiBgJHtmdWxsRGVzY3JpcHRpb259IGVuY29kZXJgIH0pO1xyXG4gICAgZW5jb2Rlci5jb3B5VGV4dHVyZVRvQnVmZmVyKFxyXG4gICAgICAgIHsgdGV4dHVyZSwgbWlwTGV2ZWwgfSxcclxuICAgICAgICB7IGJ1ZmZlcjogc3RvcmFnZSwgcm93c1BlckltYWdlLCBieXRlc1BlclJvdyB9LFxyXG4gICAgICAgIHsgd2lkdGgsIGhlaWdodCwgZGVwdGhPckFycmF5TGF5ZXJzOiB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycyB9LFxyXG4gICAgKTtcclxuICAgIGRldmljZS5xdWV1ZS5zdWJtaXQoW2VuY29kZXIuZmluaXNoKCldKTtcclxuXHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgc3RvcmFnZS5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQsIDAsIGJ5dGVTaXplKSxcclxuICAgICAgICBkZXZpY2UucXVldWUub25TdWJtaXR0ZWRXb3JrRG9uZSgpLFxyXG4gICAgXSk7XHJcblxyXG4gICAgY29uc3QgbWFwcGVkID0gc3RvcmFnZS5nZXRNYXBwZWRSYW5nZSgwLCBieXRlU2l6ZSk7XHJcbiAgICBpbWFnZURhdGEuc2V0KG5ldyBVaW50OEFycmF5KG1hcHBlZCkpO1xyXG4gICAgc3RvcmFnZS51bm1hcCgpO1xyXG5cclxuICAgIGlmIChieXRlc1BlclJvdyA+IHJhd0J5dGVzUGVyUm93KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCBoZWlnaHQgKiB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVyczsgaCArPSAxKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgcmF3Qnl0ZXNQZXJSb3c7IHcgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhW3cgKyBoICogcmF3Qnl0ZXNQZXJSb3ddID0gaW1hZ2VEYXRhW3cgKyBoICogYnl0ZXNQZXJSb3ddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGltYWdlRGF0YSA9IGltYWdlRGF0YS5zbGljZSgwLCByZXN1bHRTaXplKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGltYWdlRGF0YSxcclxuICAgICAgICBzdG9yYWdlQnVmZmVyOiByZXR1cm5CdWZmZXIgPyBzdG9yYWdlIDogdW5kZWZpbmVkLFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRleHR1cmVUb0tUWChkZXZpY2U6IEdQVURldmljZSwgdGV4dHVyZTogR1BVVGV4dHVyZSwgY3ViZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBwaXhlbFNpemUgPSBUZXh0dXJlRm9ybWF0VG9TaXplW3RleHR1cmUuZm9ybWF0XTtcclxuICAgIGNvbnN0IHR5cGVTaXplID0gVGV4dHVyZUZvcm1hdFRvQ2hhbm5lbFNpemVbdGV4dHVyZS5mb3JtYXRdO1xyXG5cclxuICAgIGlmIChwaXhlbFNpemUgPT0gbnVsbCB8fCB0eXBlU2l6ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZXh0dXJlVG9LVFggLS0gZm9ybWF0ICR7dGV4dHVyZS5mb3JtYXR9IG9mICR7dGV4dHVyZS5sYWJlbH0gdW5zdXBwb3J0ZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcga3R4cGFyc2UuS1RYMkNvbnRhaW5lcigpO1xyXG4gICAgY29udGFpbmVyLnBpeGVsV2lkdGggPSB0ZXh0dXJlLndpZHRoO1xyXG4gICAgY29udGFpbmVyLnBpeGVsSGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQ7XHJcbiAgICBjb250YWluZXIudmtGb3JtYXQgPSBXZWJHUFVUb1ZrRm9ybWF0W3RleHR1cmUuZm9ybWF0XTtcclxuICAgIGNvbnRhaW5lci50eXBlU2l6ZSA9IHR5cGVTaXplO1xyXG4gICAgZGVsZXRlIGNvbnRhaW5lci5rZXlWYWx1ZS5LVFhzd2l6emxlO1xyXG5cclxuICAgIGNvbnN0IGRhdGFGb3JtYXQgPSBjb250YWluZXIuZGF0YUZvcm1hdERlc2NyaXB0b3JbMF07XHJcbiAgICBkYXRhRm9ybWF0LmNvbG9yTW9kZWwgPSBrdHhwYXJzZS5LSFJfREZfTU9ERUxfUkdCU0RBO1xyXG4gICAgZGF0YUZvcm1hdC50cmFuc2ZlckZ1bmN0aW9uID0ga3R4cGFyc2UuS0hSX0RGX1RSQU5TRkVSX0xJTkVBUjtcclxuICAgIGRhdGFGb3JtYXQuYnl0ZXNQbGFuZVswXSA9IHBpeGVsU2l6ZTtcclxuXHJcbiAgICBkYXRhRm9ybWF0LnNhbXBsZXMgPSBbMCwgMSwgMiwgM10ubWFwKChpKSA9PiAoe1xyXG4gICAgICAgIGNoYW5uZWxUeXBlOiBbMTkyLCAxOTMsIDE5NCwgMjA3XVtpXSxcclxuICAgICAgICBzYW1wbGVQb3NpdGlvbjogWzAsIDAsIDAsIDBdLFxyXG4gICAgICAgIGJpdExlbmd0aDogY29udGFpbmVyLnR5cGVTaXplICogOCAtIDEsXHJcbiAgICAgICAgYml0T2Zmc2V0OiBjb250YWluZXIudHlwZVNpemUgKiA4ICogaSxcclxuICAgICAgICBzYW1wbGVMb3dlcjogLTEwODIxMzA0MzIsXHJcbiAgICAgICAgc2FtcGxlVXBwZXI6IDEwNjUzNTMyMTYsXHJcbiAgICB9KSk7XHJcblxyXG4gICAgaWYgKHRleHR1cmUuZGltZW5zaW9uID09PSAnM2QnKSB7XHJcbiAgICAgICAgY29udGFpbmVyLmZhY2VDb3VudCA9IDE7XHJcbiAgICAgICAgY29udGFpbmVyLnBpeGVsRGVwdGggPSB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycztcclxuICAgIH0gZWxzZSBpZiAoY3ViZSkge1xyXG4gICAgICAgIGNvbnN0IGN1YmVMYXllcnMgPSB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycyAvIDY7XHJcbiAgICAgICAgY29udGFpbmVyLmxheWVyQ291bnQgPSBjdWJlTGF5ZXJzID09PSAxID8gMCA6IGN1YmVMYXllcnM7XHJcbiAgICAgICAgY29udGFpbmVyLmZhY2VDb3VudCA9IDY7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnRhaW5lci5sYXllckNvdW50ID0gdGV4dHVyZS5kZXB0aE9yQXJyYXlMYXllcnM7XHJcbiAgICAgICAgY29udGFpbmVyLmZhY2VDb3VudCA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0b3JhZ2VCdWZmZXI6IEdQVUJ1ZmZlciB8IHVuZGVmaW5lZDtcclxuICAgIGxldCBpbWFnZURhdGE6IFVpbnQ4QXJyYXk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlLm1pcExldmVsQ291bnQ7IGkgKz0gMSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXHJcbiAgICAgICAgKHsgaW1hZ2VEYXRhLCBzdG9yYWdlQnVmZmVyIH0gPSBhd2FpdCB0ZXh0dXJlVG9BcnJheUJ1ZmZlcih7XHJcbiAgICAgICAgICAgIG1pcExldmVsOiBpLFxyXG4gICAgICAgICAgICByZXR1cm5CdWZmZXI6IHRydWUsXHJcbiAgICAgICAgICAgIGRldmljZSxcclxuICAgICAgICAgICAgdGV4dHVyZSxcclxuICAgICAgICAgICAgc3RvcmFnZUJ1ZmZlcixcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lci5sZXZlbHMucHVzaCh7XHJcbiAgICAgICAgICAgIGxldmVsRGF0YTogaW1hZ2VEYXRhLFxyXG4gICAgICAgICAgICB1bmNvbXByZXNzZWRCeXRlTGVuZ3RoOiBpbWFnZURhdGEuYnl0ZUxlbmd0aCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ga3R4cGFyc2Uud3JpdGUoY29udGFpbmVyKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5752\n")},8862:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  u: () => (/* binding */ imageToTexture),\n  y: () => (/* binding */ parseHDR)\n});\n\n;// ./src/utils/data-conversion.ts\nconst { baseTable, shiftTable } = (() => {\n    const baseTable = new Uint32Array(256);\n    const shiftTable = new Uint32Array(256);\n    for (let i = 0; i < 255; ++i) {\n        const e = i - 127;\n        if (e < -27) { // very small number (0, -0)\n            baseTable[i] = 0x0000;\n            shiftTable[i] = 24;\n        }\n        else if (e < -14) { // small number (denorm)\n            baseTable[i] = 0x0400 >> (-e - 14);\n            shiftTable[i] = -e - 1;\n        }\n        else if (e <= 15) { // normal number\n            baseTable[i] = (e + 15) << 10;\n            shiftTable[i] = 13;\n        }\n        else { // e < 128, large number (Infinity, -Infinity)\n            baseTable[i] = 0x7c00;\n            shiftTable[i] = 24;\n        }\n    }\n    // e == 128, stay (NaN, Infinity, -Infinity)\n    baseTable[255] = 0x7c00;\n    shiftTable[255] = 13;\n    return { baseTable, shiftTable };\n})();\nconst conversionBuffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(conversionBuffer);\nconst uintView = new Uint32Array(conversionBuffer);\nfunction toFloat16Bytes(val) {\n    floatView[0] = val;\n    const f = uintView[0];\n    const e = (f >> 23) & 0x1ff;\n    const idx = e & 0xff;\n    return baseTable[idx] + ((f & 0x007fffff) >> shiftTable[idx]) + ((e & 0x100) << 7);\n}\n\n// EXTERNAL MODULE: ./src/utils/texture-processing.ts\nvar texture_processing = __webpack_require__(9629);\n;// ./src/utils/texture-importing.ts\n\n\nasync function imageToTexture({ device, data, mimeType, usage = GPUTextureUsage.TEXTURE_BINDING, mips = true, format = 'rgba8unorm', colorSpace = 'srgb', label = '', srgbToLinear, }) {\n    const blob = new Blob([data], { type: mimeType });\n    const bitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });\n    const size = { width: bitmap.width, height: bitmap.height };\n    const texture = device.createTexture({\n        label,\n        format,\n        size: size,\n        usage: usage | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: mips ? 1 + (Math.log2(Math.max(bitmap.width, bitmap.height)) | 0) : 1,\n    });\n    device.queue.copyExternalImageToTexture({ source: bitmap }, { texture, colorSpace }, size);\n    if (srgbToLinear)\n        (0,texture_processing/* srgbTextureToLinear */.sP)(device, texture);\n    if (mips)\n        void (0,texture_processing/* generateMips */.fF)(device, texture);\n    return texture;\n}\nfunction parseHDR(inData) {\n    const decoder = new TextDecoder();\n    const buffer = inData instanceof Uint8Array ? inData : new Uint8Array(inData);\n    let pos = 0;\n    const getLine = (lineLimit = 1024) => {\n        const limit = Math.min(buffer.length, lineLimit + pos);\n        const sub = buffer.subarray(pos, limit);\n        const end = sub.indexOf(0x0A) + 1;\n        pos += end;\n        return end === 0 ? undefined : decoder.decode(sub.subarray(0, end));\n    };\n    const importError = (msg) => new Error('HDR Import Error: ' + msg);\n    // #region Read Header\n    const magicTokenRegex = /^#\\?(\\S+)/;\n    const magicTokenLine = getLine();\n    if (magicTokenLine == null)\n        throw importError('no header found');\n    if (!magicTokenRegex.test(magicTokenLine))\n        throw importError('bad initial token');\n    const headerRegs = [\n        /FORMAT=(?<format>\\S+)/, // format\n        /-Y\\s+(?<Y>\\d+)\\s+\\+X\\s+(?<X>\\d+)/, // size\n        /EXPOSURE\\s*=\\s*(?<exposure>\\d+(\\.\\d+)?)/, // exposure\n        /GAMMA\\s*=\\s*(?<gamma>\\d+(\\.\\d+)?)/, // gamma\n    ];\n    const headerReg = new RegExp(`^\\\\s*(${headerRegs.map(({ source }) => `(${source})`).join('|')})\\\\s*$`);\n    let noFormat = true;\n    let gamma = 1; /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n    let exposure = 1; /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n    let width = undefined;\n    let height = undefined;\n    for (let line = getLine(); line != null; line = width == null ? getLine() : undefined) {\n        const groups = line.match(headerReg)?.groups;\n        if (groups == null)\n            continue;\n        if (groups.format != null) {\n            noFormat = false;\n        }\n        else if (groups.X != null && groups.Y != null) {\n            width = parseInt(groups.X);\n            height = parseInt(groups.Y);\n        }\n        else if (groups.gamma != null) {\n            gamma = parseFloat(groups.gamma);\n        }\n        else if (groups.exposure != null) {\n            exposure = parseFloat(groups.exposure);\n        }\n    }\n    if (noFormat)\n        throw importError('missing format specifier');\n    if (width == null || height == null)\n        throw importError('missing image size specifier');\n    // #endregion\n    // #region Read Scanline Data\n    let rawData;\n    const unencodable = width < 8 || width > 0x7fff;\n    const flatData = buffer[pos] !== 2 || buffer[pos + 1] !== 2 || (buffer[pos + 2] & 0x80) !== 0;\n    if (unencodable || flatData) {\n        rawData = buffer.subarray(pos);\n    }\n    else {\n        rawData = new Uint8Array(width * height * 4);\n        const end = 4 * width;\n        const scanline_buffer = new Uint8Array(end);\n        const len = buffer.byteLength;\n        for (let k = 0, offset = 0; k < height && pos < len; k++) {\n            if (pos + 4 > len)\n                throw importError('file ended durning scanline');\n            if ((2 != buffer[pos++]) || (2 != buffer[pos++]) || (((buffer[pos++] << 8) | buffer[pos++]) != width))\n                throw importError('bad rgbe scanline format');\n            let count;\n            for (let ptr = 0; ptr < end && pos < len; ptr += count) {\n                count = buffer[pos++];\n                const isEncodedRun = count > 128;\n                if (isEncodedRun)\n                    count -= 128;\n                if (count == 0 || ptr + count > end)\n                    throw importError('bad scanline data');\n                if (isEncodedRun) {\n                    scanline_buffer.fill(buffer[pos], ptr, ptr + count);\n                    pos += 1;\n                }\n                else {\n                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                    pos += count;\n                }\n            }\n            for (let i = 0; i < width; i++)\n                for (let j = 0; j < end; j += width)\n                    rawData[offset++] = scanline_buffer[i + j];\n        }\n    }\n    // #endregion\n    // #region Convert to Float16\n    const data = new Uint16Array(rawData.length);\n    const float16One = toFloat16Bytes(1);\n    for (let i = 0; i < width * height * 4; i += 4) {\n        const raw_e = rawData[i + 3];\n        const scale = Math.pow(2.0, raw_e - 128.0) / 255.0;\n        for (let j = 0; j < 3; j += 1) {\n            data[i + j] = toFloat16Bytes(Math.min(rawData[i + j] * scale, 65504));\n        }\n        data[i + 3] = float16One;\n    }\n    // #endregion\n    return { data, width, height, gamma, exposure };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM3QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDO1FBRW5ELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQzVCLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUMxRSxDQUFDO1FBQ0QsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUM7SUFDN0IsQ0FBQztJQUNELGFBQWE7SUFFYixPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxDQUFDO0FBQ3BELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvdXRpbHMvZGF0YS1jb252ZXJzaW9uLnRzPzYwYzEiLCJ3ZWJwYWNrOi8vY2J1bnQtcG9ydGZvbGlvLy4vc3JjL3V0aWxzL3RleHR1cmUtaW1wb3J0aW5nLnRzPzQyNTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBiYXNlVGFibGUsIHNoaWZ0VGFibGUgfSA9ICgoKSA9PiB7XG4gICAgY29uc3QgYmFzZVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgY29uc3Qgc2hpZnRUYWJsZSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTU7ICsraSkge1xuICAgICAgICBjb25zdCBlID0gaSAtIDEyNztcbiAgICAgICAgaWYgKGUgPCAtMjcpIHsgLy8gdmVyeSBzbWFsbCBudW1iZXIgKDAsIC0wKVxuICAgICAgICAgICAgYmFzZVRhYmxlW2ldID0gMHgwMDAwO1xuICAgICAgICAgICAgc2hpZnRUYWJsZVtpXSA9IDI0O1xuICAgICAgICB9IGVsc2UgaWYgKGUgPCAtMTQpIHsgLy8gc21hbGwgbnVtYmVyIChkZW5vcm0pXG4gICAgICAgICAgICBiYXNlVGFibGVbaV0gPSAweDA0MDAgPj4gKC1lIC0gMTQpO1xuICAgICAgICAgICAgc2hpZnRUYWJsZVtpXSA9IC1lIC0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChlIDw9IDE1KSB7IC8vIG5vcm1hbCBudW1iZXJcbiAgICAgICAgICAgIGJhc2VUYWJsZVtpXSA9IChlICsgMTUpIDw8IDEwO1xuICAgICAgICAgICAgc2hpZnRUYWJsZVtpXSA9IDEzO1xuICAgICAgICB9IGVsc2UgeyAvLyBlIDwgMTI4LCBsYXJnZSBudW1iZXIgKEluZmluaXR5LCAtSW5maW5pdHkpXG4gICAgICAgICAgICBiYXNlVGFibGVbaV0gPSAweDdjMDA7XG4gICAgICAgICAgICBzaGlmdFRhYmxlW2ldID0gMjQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlID09IDEyOCwgc3RheSAoTmFOLCBJbmZpbml0eSwgLUluZmluaXR5KVxuICAgIGJhc2VUYWJsZVsyNTVdID0gMHg3YzAwO1xuICAgIHNoaWZ0VGFibGVbMjU1XSA9IDEzO1xuXG4gICAgcmV0dXJuIHsgYmFzZVRhYmxlLCBzaGlmdFRhYmxlIH07XG59KSgpO1xuXG5jb25zdCBjb252ZXJzaW9uQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuY29uc3QgZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheShjb252ZXJzaW9uQnVmZmVyKTtcbmNvbnN0IHVpbnRWaWV3ID0gbmV3IFVpbnQzMkFycmF5KGNvbnZlcnNpb25CdWZmZXIpO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9GbG9hdDE2Qnl0ZXModmFsOiBudW1iZXIpIHtcbiAgICBmbG9hdFZpZXdbMF0gPSB2YWw7XG4gICAgY29uc3QgZiA9IHVpbnRWaWV3WzBdO1xuICAgIGNvbnN0IGUgPSAoZiA+PiAyMykgJiAweDFmZjtcbiAgICBjb25zdCBpZHggPSBlICYgMHhmZjtcbiAgICByZXR1cm4gYmFzZVRhYmxlW2lkeF0gKyAoKGYgJiAweDAwN2ZmZmZmKSA+PiBzaGlmdFRhYmxlW2lkeF0pICsgKChlICYgMHgxMDApIDw8IDcpO1xufVxuIiwiaW1wb3J0IHsgdG9GbG9hdDE2Qnl0ZXMgfSBmcm9tICcuL2RhdGEtY29udmVyc2lvbic7XG5pbXBvcnQgeyBzcmdiVGV4dHVyZVRvTGluZWFyLCBnZW5lcmF0ZU1pcHMgfSBmcm9tICcuL3RleHR1cmUtcHJvY2Vzc2luZyc7XG5cbmV4cG9ydCB0eXBlIGltYWdlVG9UZXh0dXJlRGVzY3JpcHRvciA9IHtcbiAgICBkZXZpY2U6IEdQVURldmljZSxcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIG1pbWVUeXBlPzogc3RyaW5nLFxuICAgIGxhYmVsPzogc3RyaW5nLFxuICAgIHVzYWdlPzogbnVtYmVyLFxuICAgIGZvcm1hdD86IEdQVVRleHR1cmVGb3JtYXQsXG4gICAgbWlwcz86IGJvb2xlYW4sXG4gICAgc3JnYlRvTGluZWFyPzogYm9vbGVhbixcbiAgICBjb2xvclNwYWNlPzogUHJlZGVmaW5lZENvbG9yU3BhY2UsXG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1hZ2VUb1RleHR1cmUoe1xuICAgIGRldmljZSxcbiAgICBkYXRhLFxuICAgIG1pbWVUeXBlLFxuICAgIHVzYWdlID0gR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyxcbiAgICBtaXBzID0gdHJ1ZSxcbiAgICBmb3JtYXQgPSAncmdiYTh1bm9ybScsXG4gICAgY29sb3JTcGFjZSA9ICdzcmdiJyxcbiAgICBsYWJlbCA9ICcnLFxuICAgIHNyZ2JUb0xpbmVhcixcbn06IGltYWdlVG9UZXh0dXJlRGVzY3JpcHRvcikge1xuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogbWltZVR5cGUgfSk7XG4gICAgY29uc3QgYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYiwgeyBjb2xvclNwYWNlQ29udmVyc2lvbjogJ25vbmUnIH0pO1xuICAgIGNvbnN0IHNpemUgPSB7IHdpZHRoOiBiaXRtYXAud2lkdGgsIGhlaWdodDogYml0bWFwLmhlaWdodCB9O1xuXG4gICAgY29uc3QgdGV4dHVyZSA9IGRldmljZS5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgdXNhZ2U6IHVzYWdlIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDIHwgR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5ULFxuICAgICAgICBtaXBMZXZlbENvdW50OiBtaXBzID8gMSArIChNYXRoLmxvZzIoTWF0aC5tYXgoYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0KSkgfCAwKSA6IDEsXG4gICAgfSk7XG5cbiAgICBkZXZpY2UucXVldWUuY29weUV4dGVybmFsSW1hZ2VUb1RleHR1cmUoXG4gICAgICAgIHsgc291cmNlOiBiaXRtYXAgfSxcbiAgICAgICAgeyB0ZXh0dXJlLCBjb2xvclNwYWNlIH0sXG4gICAgICAgIHNpemUsXG4gICAgKTtcblxuICAgIGlmIChzcmdiVG9MaW5lYXIpIHNyZ2JUZXh0dXJlVG9MaW5lYXIoZGV2aWNlLCB0ZXh0dXJlKTtcbiAgICBpZiAobWlwcykgdm9pZCBnZW5lcmF0ZU1pcHMoZGV2aWNlLCB0ZXh0dXJlKTtcblxuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIRFIoaW5EYXRhOiBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgY29uc3QgYnVmZmVyID0gaW5EYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGluRGF0YSA6IG5ldyBVaW50OEFycmF5KGluRGF0YSk7XG4gICAgbGV0IHBvcyA9IDA7XG5cbiAgICBjb25zdCBnZXRMaW5lID0gKGxpbmVMaW1pdCA9IDEwMjQpID0+IHtcbiAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLm1pbihidWZmZXIubGVuZ3RoLCBsaW5lTGltaXQgKyBwb3MpO1xuICAgICAgICBjb25zdCBzdWIgPSBidWZmZXIuc3ViYXJyYXkocG9zLCBsaW1pdCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN1Yi5pbmRleE9mKDB4MEEpICsgMTtcbiAgICAgICAgcG9zICs9IGVuZDtcbiAgICAgICAgcmV0dXJuIGVuZCA9PT0gMCA/IHVuZGVmaW5lZCA6IGRlY29kZXIuZGVjb2RlKHN1Yi5zdWJhcnJheSgwLCBlbmQpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaW1wb3J0RXJyb3IgPSAobXNnOiBzdHJpbmcpID0+IG5ldyBFcnJvcignSERSIEltcG9ydCBFcnJvcjogJyArIG1zZyk7XG5cbiAgICAvLyAjcmVnaW9uIFJlYWQgSGVhZGVyXG4gICAgY29uc3QgbWFnaWNUb2tlblJlZ2V4ID0gL14jXFw/KFxcUyspLztcbiAgICBjb25zdCBtYWdpY1Rva2VuTGluZSA9IGdldExpbmUoKTtcblxuICAgIGlmIChtYWdpY1Rva2VuTGluZSA9PSBudWxsKSB0aHJvdyBpbXBvcnRFcnJvcignbm8gaGVhZGVyIGZvdW5kJyk7XG4gICAgaWYgKCFtYWdpY1Rva2VuUmVnZXgudGVzdChtYWdpY1Rva2VuTGluZSkpIHRocm93IGltcG9ydEVycm9yKCdiYWQgaW5pdGlhbCB0b2tlbicpO1xuXG4gICAgY29uc3QgaGVhZGVyUmVncyA9IFtcbiAgICAgICAgL0ZPUk1BVD0oPzxmb3JtYXQ+XFxTKykvLCAvLyBmb3JtYXRcbiAgICAgICAgLy1ZXFxzKyg/PFk+XFxkKylcXHMrXFwrWFxccysoPzxYPlxcZCspLywgLy8gc2l6ZVxuICAgICAgICAvRVhQT1NVUkVcXHMqPVxccyooPzxleHBvc3VyZT5cXGQrKFxcLlxcZCspPykvLCAvLyBleHBvc3VyZVxuICAgICAgICAvR0FNTUFcXHMqPVxccyooPzxnYW1tYT5cXGQrKFxcLlxcZCspPykvLCAvLyBnYW1tYVxuICAgIF07XG5cbiAgICBjb25zdCBoZWFkZXJSZWcgPSBuZXcgUmVnRXhwKGBeXFxcXHMqKCR7XG4gICAgICAgIGhlYWRlclJlZ3MubWFwKCh7IHNvdXJjZSB9KSA9PiBgKCR7c291cmNlfSlgKS5qb2luKCd8JylcbiAgICB9KVxcXFxzKiRgKTtcblxuICAgIGxldCBub0Zvcm1hdCA9IHRydWU7XG4gICAgbGV0IGdhbW1hID0gMTsgLyogYSB2YWx1ZSBvZiAxLjAgaW4gYW4gaW1hZ2UgY29ycmVzcG9uZHMgdG8gPGV4cG9zdXJlPiB3YXR0cy9zdGVyYWRpYW4vbV4yLiBkZWZhdWx0cyB0byAxLjAgKi9cbiAgICBsZXQgZXhwb3N1cmUgPSAxOyAvKiBpbWFnZSBoYXMgYWxyZWFkeSBiZWVuIGdhbW1hIGNvcnJlY3RlZCB3aXRoIGdpdmVuIGdhbW1hLiBkZWZhdWx0cyB0byAxLjAgKG5vIGNvcnJlY3Rpb24pICovXG4gICAgbGV0IHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gICAgZm9yIChsZXQgbGluZSA9IGdldExpbmUoKTsgbGluZSAhPSBudWxsOyBsaW5lID0gd2lkdGggPT0gbnVsbCA/IGdldExpbmUoKSA6IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBncm91cHMgPSBsaW5lLm1hdGNoKGhlYWRlclJlZyk/Lmdyb3VwcyBhcyBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+IHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZ3JvdXBzID09IG51bGwpIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChncm91cHMuZm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5vRm9ybWF0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBzLlggIT0gbnVsbCAmJiBncm91cHMuWSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KGdyb3Vwcy5YKTtcbiAgICAgICAgICAgIGhlaWdodCA9IHBhcnNlSW50KGdyb3Vwcy5ZKTtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cHMuZ2FtbWEgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FtbWEgPSBwYXJzZUZsb2F0KGdyb3Vwcy5nYW1tYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBzLmV4cG9zdXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4cG9zdXJlID0gcGFyc2VGbG9hdChncm91cHMuZXhwb3N1cmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vRm9ybWF0KSB0aHJvdyBpbXBvcnRFcnJvcignbWlzc2luZyBmb3JtYXQgc3BlY2lmaWVyJyk7XG4gICAgaWYgKHdpZHRoID09IG51bGwgfHwgaGVpZ2h0ID09IG51bGwpIHRocm93IGltcG9ydEVycm9yKCdtaXNzaW5nIGltYWdlIHNpemUgc3BlY2lmaWVyJyk7XG4gICAgLy8gI2VuZHJlZ2lvblxuXG4gICAgLy8gI3JlZ2lvbiBSZWFkIFNjYW5saW5lIERhdGFcbiAgICBsZXQgcmF3RGF0YTogVWludDhBcnJheTtcbiAgICBjb25zdCB1bmVuY29kYWJsZSA9IHdpZHRoIDwgOCB8fCB3aWR0aCA+IDB4N2ZmZjtcbiAgICBjb25zdCBmbGF0RGF0YSA9IGJ1ZmZlcltwb3NdICE9PSAyIHx8IGJ1ZmZlcltwb3MgKyAxXSAhPT0gMiB8fCAoYnVmZmVyW3BvcyArIDJdICYgMHg4MCkgIT09IDA7XG5cbiAgICBpZiAodW5lbmNvZGFibGUgfHwgZmxhdERhdGEpIHtcbiAgICAgICAgcmF3RGF0YSA9IGJ1ZmZlci5zdWJhcnJheShwb3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJhd0RhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICBjb25zdCBlbmQgPSA0ICogd2lkdGg7XG4gICAgICAgIGNvbnN0IHNjYW5saW5lX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGVuZCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IGsgPSAwLCBvZmZzZXQgPSAwOyBrIDwgaGVpZ2h0ICYmIHBvcyA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICBpZiAocG9zICsgNCA+IGxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbXBvcnRFcnJvcignZmlsZSBlbmRlZCBkdXJuaW5nIHNjYW5saW5lJyk7XG5cbiAgICAgICAgICAgIGlmICgoMiAhPSBidWZmZXJbcG9zKytdKSB8fCAoMiAhPSBidWZmZXJbcG9zKytdKSB8fCAoKChidWZmZXJbcG9zKytdIDw8IDgpIHwgYnVmZmVyW3BvcysrXSkgIT0gd2lkdGgpKVxuICAgICAgICAgICAgICAgIHRocm93IGltcG9ydEVycm9yKCdiYWQgcmdiZSBzY2FubGluZSBmb3JtYXQnKTtcblxuICAgICAgICAgICAgbGV0IGNvdW50O1xuICAgICAgICAgICAgZm9yIChsZXQgcHRyID0gMDsgcHRyIDwgZW5kICYmIHBvcyA8IGxlbjsgcHRyICs9IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBidWZmZXJbcG9zKytdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRW5jb2RlZFJ1biA9IGNvdW50ID4gMTI4O1xuICAgICAgICAgICAgICAgIGlmIChpc0VuY29kZWRSdW4pIGNvdW50IC09IDEyODtcblxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PSAwIHx8IHB0ciArIGNvdW50ID4gZW5kKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbXBvcnRFcnJvcignYmFkIHNjYW5saW5lIGRhdGEnKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0VuY29kZWRSdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbmxpbmVfYnVmZmVyLmZpbGwoYnVmZmVyW3Bvc10sIHB0ciwgcHRyICsgY291bnQpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY2FubGluZV9idWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheShwb3MsIHBvcyArIGNvdW50KSwgcHRyKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IGNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZW5kOyBqICs9IHdpZHRoKVxuICAgICAgICAgICAgICAgICAgICByYXdEYXRhW29mZnNldCsrXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuXG4gICAgLy8gI3JlZ2lvbiBDb252ZXJ0IHRvIEZsb2F0MTZcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KHJhd0RhdGEubGVuZ3RoKTtcbiAgICBjb25zdCBmbG9hdDE2T25lID0gdG9GbG9hdDE2Qnl0ZXMoMSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoICogaGVpZ2h0ICogNDsgaSArPSA0KSB7XG4gICAgICAgIGNvbnN0IHJhd19lID0gcmF3RGF0YVtpICsgM107XG4gICAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMi4wLCByYXdfZSAtIDEyOC4wKSAvIDI1NS4wO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaiArPSAxKSB7XG4gICAgICAgICAgICBkYXRhW2kgKyBqXSA9IHRvRmxvYXQxNkJ5dGVzKE1hdGgubWluKHJhd0RhdGFbaSArIGpdICogc2NhbGUsIDY1NTA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtpICsgM10gPSBmbG9hdDE2T25lO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG5cbiAgICByZXR1cm4geyBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBnYW1tYSwgZXhwb3N1cmUgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8862\n")},9629:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fF: () => (/* binding */ generateMips),\n/* harmony export */   l3: () => (/* binding */ equirectangularToCubemap),\n/* harmony export */   sP: () => (/* binding */ srgbTextureToLinear)\n/* harmony export */ });\n/* harmony import */ var _shaders_blit_vert_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(157);\n/* harmony import */ var _shaders_cubemap_sampling_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6097);\n/* harmony import */ var _data_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5752);\n/* harmony import */ var _general__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4742);\n\n\n\n\nasync function equirectangularToCubemap(device, { data, width, height, gamma = 1, exposure = 1 }, outputDescriptor) {\n    const code = /* wgsl */ `\n        override EXPOSURE: f32 = 1.0;\n        override GAMMA: f32 = 1.0;\n        override FLIP_Y: bool = false;\n\n        @group(0) @binding(0) var equirectangularMap: texture_2d<f32>;\n        @group(0) @binding(1) var mapSampler: sampler;\n        @group(0) @binding(2) var<uniform> face: u32;\n\n        fn sampleSphericalMap(v: vec3f) -> vec2f {\n            const invAtan = vec2(0.1591, 0.3183);\n\n            var uv = vec2(atan2(v.z, v.x), asin(v.y));\n            uv *= invAtan;\n            uv += 0.5;\n            return uv;\n        }\n \n        ${_shaders_blit_vert_shader__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A}\n        ${_shaders_cubemap_sampling_shader__WEBPACK_IMPORTED_MODULE_2__/* .toWorldDir */ .V}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            var dir = toWorldDirF32(uv, face);\n            dir = vec3(dir.z, dir.y, -dir.x);\n            var coord = sampleSphericalMap(dir);\n            if (FLIP_Y) { coord.y = 1 - coord.y; }\n\n            var color = textureSample(equirectangularMap, mapSampler, coord).rgb;\n            if (GAMMA != 1.0) { color = pow(color, vec3(1.0 / GAMMA)); }\n            if (EXPOSURE != 1.0) { color /= EXPOSURE; }\n            return vec4(color, 1.0);\n        }\n    `;\n    let FLIP_Y = 0;\n    let equirectangular;\n    if (data instanceof GPUTexture) {\n        equirectangular = data;\n    }\n    else {\n        FLIP_Y = 1;\n        equirectangular = device.createTexture({\n            label: `${outputDescriptor.label} equirectangular`,\n            dimension: '2d',\n            format: 'rgba16float',\n            size: { width, height },\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        });\n        device.queue.writeTexture({ texture: equirectangular, mipLevel: 0 }, data, { bytesPerRow: width * 2 * 4 }, { width, height, depthOrArrayLayers: 1 });\n        await device.queue.onSubmittedWorkDone();\n    }\n    const faceSize = equirectangular.height >> 1;\n    const cubemapDescriptor = outputDescriptor;\n    cubemapDescriptor.mipLevelCount ??= Math.log2(faceSize) | 0;\n    cubemapDescriptor.size = { width: faceSize, height: faceSize, depthOrArrayLayers: 6 };\n    cubemapDescriptor.dimension = '2d';\n    cubemapDescriptor.usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    const cubemap = device.createTexture(cubemapDescriptor);\n    const label = (0,_general__WEBPACK_IMPORTED_MODULE_3__/* .padTemplate */ .OY) `hdr copy${outputDescriptor.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 2,\n                buffer: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n    const module = device.createShaderModule({ label, code });\n    const sampler = device.createSampler({ label, minFilter: 'linear', magFilter: 'linear' });\n    const params = new Uint32Array(1);\n    const paramBuffer = (0,_data_copy__WEBPACK_IMPORTED_MODULE_0__/* .createAndCopyBuffer */ .Lr)(params, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, device, label);\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            { binding: 0, resource: equirectangular.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: paramBuffer } },\n        ],\n    });\n    const pipelineLayout = device.createPipelineLayout({\n        label,\n        bindGroupLayouts: [bindgroupLayout],\n    });\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: { module },\n        fragment: {\n            module,\n            targets: [{ format: cubemap.format }],\n            constants: {\n                GAMMA: gamma,\n                EXPOSURE: exposure,\n                FLIP_Y,\n            },\n        },\n    });\n    for (let i = 0; i < 6; i += 1) {\n        params[0] = i;\n        device.queue.writeBuffer(paramBuffer, 0, params, 0, 1);\n        const view = cubemap.createView({\n            dimension: '2d',\n            arrayLayerCount: 1,\n            baseArrayLayer: i,\n            mipLevelCount: 1,\n        });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [{\n                    view,\n                    loadOp: 'clear',\n                    storeOp: 'store',\n                }],\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n    }\n    return cubemap;\n}\nasync function generateMips(device, texture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var mipSampler: sampler;\n\n        ${_shaders_blit_vert_shader__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A}\n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n            return textureSample(image, mipSampler, uv);\n        }\n    `;\n    const label = (0,_general__WEBPACK_IMPORTED_MODULE_3__/* .padTemplate */ .OY) `mip generation${texture.label}`;\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: { viewDimension: '2d', sampleType: 'float' },\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n    const colorAttachment = {\n        view: undefined,\n        loadOp: 'clear',\n        storeOp: 'store',\n    };\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n    colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: 0 });\n    await device.queue.onSubmittedWorkDone();\n    for (let i = 1; i < texture.mipLevelCount; i += 1) {\n        const bindgroup = device.createBindGroup({\n            label,\n            layout: bindgroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: colorAttachment.view,\n                },\n                {\n                    binding: 1,\n                    resource: sampler,\n                },\n            ],\n        });\n        colorAttachment.view = texture.createView({ mipLevelCount: 1, baseMipLevel: i });\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n            label,\n            colorAttachments: [colorAttachment],\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindgroup);\n        pass.draw(3);\n        pass.end();\n        device.queue.submit([encoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n}\nfunction srgbTextureToLinear(device, texture) {\n    const code = /* wgsl */ `\n        @group(0) @binding(0) var image: texture_2d<f32>;\n        @group(0) @binding(1) var imageSampler: sampler;\n\n        ${_shaders_blit_vert_shader__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A}\n\n        fn sRGBToLinear(color: vec3f) -> vec3f {\n            return select( \n                pow(color * 0.9478672986 + 0.0521327014, vec3(2.4)), \n                color * 0.0773993808, \n                color <= vec3(0.04045), \n            );\n        }  \n\n        @fragment\n        fn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n            let sample = textureSample(image, imageSampler, uv);\n            let color = sRGBToLinear(sample.rgb);\n            return vec4(color, sample.a);\n        }\n    `;\n    const label = (0,_general__WEBPACK_IMPORTED_MODULE_3__/* .padTemplate */ .OY) `srgb to linear${texture.label}`;\n    const size = { width: texture.width, height: texture.height };\n    const tempTexture = device.createTexture({\n        format: texture.format,\n        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n        size,\n    });\n    const bindgroupLayout = device.createBindGroupLayout({\n        label,\n        entries: [\n            {\n                binding: 0,\n                texture: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n            {\n                binding: 1,\n                sampler: {},\n                visibility: GPUShaderStage.FRAGMENT,\n            },\n        ],\n    });\n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n    });\n    const module = device.createShaderModule({ label, code: code });\n    const pipelineLayout = device.createPipelineLayout({ label, bindGroupLayouts: [bindgroupLayout] });\n    const pipeline = device.createRenderPipeline({\n        label,\n        layout: pipelineLayout,\n        vertex: {\n            entryPoint: 'vs',\n            module,\n        },\n        fragment: {\n            entryPoint: 'fs',\n            targets: [{ format: texture.format }],\n            module,\n        },\n    });\n    const bindgroup = device.createBindGroup({\n        label,\n        layout: bindgroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: tempTexture.createView(),\n            },\n            {\n                binding: 1,\n                resource: sampler,\n            },\n        ],\n    });\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToTexture({ texture }, { texture: tempTexture }, size);\n    const pass = encoder.beginRenderPass({\n        label,\n        colorAttachments: [{\n                view: texture.createView({ mipLevelCount: 1, baseMipLevel: 0 }),\n                loadOp: 'clear',\n                storeOp: 'store',\n            }],\n    });\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindgroup);\n    pass.draw(3);\n    pass.end();\n    device.queue.submit([encoder.finish()]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUMsb0JBQW9CLENBQ3hCLEVBQUUsT0FBTyxFQUFFLEVBQ1gsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLEVBQ3hCLElBQUksQ0FDUCxDQUFDO0lBRUYsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQztRQUNqQyxLQUFLO1FBQ0wsZ0JBQWdCLEVBQUUsQ0FBQztnQkFDZixJQUFJLEVBQUUsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxDQUFDLEVBQUUsWUFBWSxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUMvRCxNQUFNLEVBQUUsT0FBTztnQkFDZixPQUFPLEVBQUUsT0FBTzthQUNuQixDQUFDO0tBQ0wsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMzQixJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2IsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBRVgsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzVDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYnVudC1wb3J0Zm9saW8vLi9zcmMvdXRpbHMvdGV4dHVyZS1wcm9jZXNzaW5nLnRzPzc2NDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJsaXQgZnJvbSAnLi4vc2hhZGVycy9ibGl0LXZlcnQuc2hhZGVyJztcbmltcG9ydCB7IHRvV29ybGREaXIgfSBmcm9tICcuLi9zaGFkZXJzL2N1YmVtYXAtc2FtcGxpbmcuc2hhZGVyJztcbmltcG9ydCB7IGNyZWF0ZUFuZENvcHlCdWZmZXIgfSBmcm9tICcuL2RhdGEtY29weSc7XG5pbXBvcnQgeyBwYWRUZW1wbGF0ZSB9IGZyb20gJy4vZ2VuZXJhbCc7XG5cbnR5cGUgRXF1aXJlY3Rhbmd1bGFyRGVzY3JpcHRvciA9IHtcbiAgICBkYXRhOiBTaGFyZWRBcnJheUJ1ZmZlciB8IEJ1ZmZlclNvdXJjZSB8IEdQVVRleHR1cmUsXG4gICAgd2lkdGg6IG51bWJlcixcbiAgICBoZWlnaHQ6IG51bWJlcixcbiAgICBnYW1tYT86IG51bWJlcixcbiAgICBleHBvc3VyZT86IG51bWJlcixcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlcXVpcmVjdGFuZ3VsYXJUb0N1YmVtYXAoXG4gICAgZGV2aWNlOiBHUFVEZXZpY2UsXG4gICAgeyBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBnYW1tYSA9IDEsIGV4cG9zdXJlID0gMSB9OiBFcXVpcmVjdGFuZ3VsYXJEZXNjcmlwdG9yLFxuICAgIG91dHB1dERlc2NyaXB0b3I6IE9taXQ8R1BVVGV4dHVyZURlc2NyaXB0b3IsICdkaW1lbnNpb24nIHwgJ3NpemUnPixcbikge1xuICAgIGNvbnN0IGNvZGUgPSAvKiB3Z3NsICovIGBcbiAgICAgICAgb3ZlcnJpZGUgRVhQT1NVUkU6IGYzMiA9IDEuMDtcbiAgICAgICAgb3ZlcnJpZGUgR0FNTUE6IGYzMiA9IDEuMDtcbiAgICAgICAgb3ZlcnJpZGUgRkxJUF9ZOiBib29sID0gZmFsc2U7XG5cbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhciBlcXVpcmVjdGFuZ3VsYXJNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciBtYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHVuaWZvcm0+IGZhY2U6IHUzMjtcblxuICAgICAgICBmbiBzYW1wbGVTcGhlcmljYWxNYXAodjogdmVjM2YpIC0+IHZlYzJmIHtcbiAgICAgICAgICAgIGNvbnN0IGludkF0YW4gPSB2ZWMyKDAuMTU5MSwgMC4zMTgzKTtcblxuICAgICAgICAgICAgdmFyIHV2ID0gdmVjMihhdGFuMih2LnosIHYueCksIGFzaW4odi55KSk7XG4gICAgICAgICAgICB1diAqPSBpbnZBdGFuO1xuICAgICAgICAgICAgdXYgKz0gMC41O1xuICAgICAgICAgICAgcmV0dXJuIHV2O1xuICAgICAgICB9XG4gXG4gICAgICAgICR7YmxpdH1cbiAgICAgICAgJHt0b1dvcmxkRGlyfVxuXG4gICAgICAgIEBmcmFnbWVudFxuICAgICAgICBmbiBmcyhAbG9jYXRpb24oMCkgdXY6IHZlYzJmKSAtPiBAbG9jYXRpb24oMCkgdmVjNGYge1xuICAgICAgICAgICAgdmFyIGRpciA9IHRvV29ybGREaXJGMzIodXYsIGZhY2UpO1xuICAgICAgICAgICAgZGlyID0gdmVjMyhkaXIueiwgZGlyLnksIC1kaXIueCk7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSBzYW1wbGVTcGhlcmljYWxNYXAoZGlyKTtcbiAgICAgICAgICAgIGlmIChGTElQX1kpIHsgY29vcmQueSA9IDEgLSBjb29yZC55OyB9XG5cbiAgICAgICAgICAgIHZhciBjb2xvciA9IHRleHR1cmVTYW1wbGUoZXF1aXJlY3Rhbmd1bGFyTWFwLCBtYXBTYW1wbGVyLCBjb29yZCkucmdiO1xuICAgICAgICAgICAgaWYgKEdBTU1BICE9IDEuMCkgeyBjb2xvciA9IHBvdyhjb2xvciwgdmVjMygxLjAgLyBHQU1NQSkpOyB9XG4gICAgICAgICAgICBpZiAoRVhQT1NVUkUgIT0gMS4wKSB7IGNvbG9yIC89IEVYUE9TVVJFOyB9XG4gICAgICAgICAgICByZXR1cm4gdmVjNChjb2xvciwgMS4wKTtcbiAgICAgICAgfVxuICAgIGA7XG5cbiAgICBsZXQgRkxJUF9ZID0gMDtcbiAgICBsZXQgZXF1aXJlY3Rhbmd1bGFyOiBHUFVUZXh0dXJlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgR1BVVGV4dHVyZSkge1xuICAgICAgICBlcXVpcmVjdGFuZ3VsYXIgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEZMSVBfWSA9IDE7XG4gICAgICAgIGVxdWlyZWN0YW5ndWxhciA9IGRldmljZS5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgICAgIGxhYmVsOiBgJHtvdXRwdXREZXNjcmlwdG9yLmxhYmVsfSBlcXVpcmVjdGFuZ3VsYXJgLFxuICAgICAgICAgICAgZGltZW5zaW9uOiAnMmQnLFxuICAgICAgICAgICAgZm9ybWF0OiAncmdiYTE2ZmxvYXQnLFxuICAgICAgICAgICAgc2l6ZTogeyB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUIHwgR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZShcbiAgICAgICAgICAgIHsgdGV4dHVyZTogZXF1aXJlY3Rhbmd1bGFyLCBtaXBMZXZlbDogMCB9LFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHsgYnl0ZXNQZXJSb3c6IHdpZHRoICogMiAqIDQgfSxcbiAgICAgICAgICAgIHsgd2lkdGgsIGhlaWdodCwgZGVwdGhPckFycmF5TGF5ZXJzOiAxIH0sXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IGRldmljZS5xdWV1ZS5vblN1Ym1pdHRlZFdvcmtEb25lKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZmFjZVNpemUgPSBlcXVpcmVjdGFuZ3VsYXIuaGVpZ2h0ID4+IDE7XG4gICAgY29uc3QgY3ViZW1hcERlc2NyaXB0b3IgPSBvdXRwdXREZXNjcmlwdG9yIGFzIEdQVVRleHR1cmVEZXNjcmlwdG9yO1xuICAgIGN1YmVtYXBEZXNjcmlwdG9yLm1pcExldmVsQ291bnQgPz89IE1hdGgubG9nMihmYWNlU2l6ZSkgfCAwO1xuICAgIGN1YmVtYXBEZXNjcmlwdG9yLnNpemUgPSB7IHdpZHRoOiBmYWNlU2l6ZSwgaGVpZ2h0OiBmYWNlU2l6ZSwgZGVwdGhPckFycmF5TGF5ZXJzOiA2IH07XG4gICAgY3ViZW1hcERlc2NyaXB0b3IuZGltZW5zaW9uID0gJzJkJztcbiAgICBjdWJlbWFwRGVzY3JpcHRvci51c2FnZSB8PSBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQ7XG4gICAgY29uc3QgY3ViZW1hcCA9IGRldmljZS5jcmVhdGVUZXh0dXJlKGN1YmVtYXBEZXNjcmlwdG9yKTtcblxuICAgIGNvbnN0IGxhYmVsID0gcGFkVGVtcGxhdGVgaGRyIGNvcHkke291dHB1dERlc2NyaXB0b3IubGFiZWx9YDtcbiAgICBjb25zdCBiaW5kZ3JvdXBMYXlvdXQgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHt9LFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgIHNhbXBsZXI6IHt9LFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAyLFxuICAgICAgICAgICAgICAgIGJ1ZmZlcjoge30sXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0pO1xuXG4gICAgY29uc3QgbW9kdWxlID0gZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7IGxhYmVsLCBjb2RlIH0pO1xuICAgIGNvbnN0IHNhbXBsZXIgPSBkZXZpY2UuY3JlYXRlU2FtcGxlcih7IGxhYmVsLCBtaW5GaWx0ZXI6ICdsaW5lYXInLCBtYWdGaWx0ZXI6ICdsaW5lYXInIH0pO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVaW50MzJBcnJheSgxKTtcbiAgICBjb25zdCBwYXJhbUJ1ZmZlciA9IGNyZWF0ZUFuZENvcHlCdWZmZXIocGFyYW1zLCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0sIGRldmljZSwgbGFiZWwpO1xuXG4gICAgY29uc3QgYmluZGdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBsYXlvdXQ6IGJpbmRncm91cExheW91dCxcbiAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgeyBiaW5kaW5nOiAwLCByZXNvdXJjZTogZXF1aXJlY3Rhbmd1bGFyLmNyZWF0ZVZpZXcoKSB9LFxuICAgICAgICAgICAgeyBiaW5kaW5nOiAxLCByZXNvdXJjZTogc2FtcGxlciB9LFxuICAgICAgICAgICAgeyBiaW5kaW5nOiAyLCByZXNvdXJjZTogeyBidWZmZXI6IHBhcmFtQnVmZmVyIH0gfSxcbiAgICAgICAgXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHBpcGVsaW5lTGF5b3V0ID0gZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGJpbmRHcm91cExheW91dHM6IFtiaW5kZ3JvdXBMYXlvdXRdLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcGlwZWxpbmUgPSBkZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgbGF5b3V0OiBwaXBlbGluZUxheW91dCxcbiAgICAgICAgdmVydGV4OiB7IG1vZHVsZSB9LFxuICAgICAgICBmcmFnbWVudDoge1xuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgdGFyZ2V0czogW3sgZm9ybWF0OiBjdWJlbWFwLmZvcm1hdCB9XSxcbiAgICAgICAgICAgIGNvbnN0YW50czoge1xuICAgICAgICAgICAgICAgIEdBTU1BOiBnYW1tYSxcbiAgICAgICAgICAgICAgICBFWFBPU1VSRTogZXhwb3N1cmUsXG4gICAgICAgICAgICAgICAgRkxJUF9ZLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSArPSAxKSB7XG4gICAgICAgIHBhcmFtc1swXSA9IGk7XG4gICAgICAgIGRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihwYXJhbUJ1ZmZlciwgMCwgcGFyYW1zLCAwLCAxKTtcblxuICAgICAgICBjb25zdCB2aWV3ID0gY3ViZW1hcC5jcmVhdGVWaWV3KHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogJzJkJyxcbiAgICAgICAgICAgIGFycmF5TGF5ZXJDb3VudDogMSxcbiAgICAgICAgICAgIGJhc2VBcnJheUxheWVyOiBpLFxuICAgICAgICAgICAgbWlwTGV2ZWxDb3VudDogMSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgICAgICBjb25zdCBwYXNzID0gZW5jb2Rlci5iZWdpblJlbmRlclBhc3Moe1xuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBjb2xvckF0dGFjaG1lbnRzOiBbe1xuICAgICAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICAgICAgbG9hZE9wOiAnY2xlYXInLFxuICAgICAgICAgICAgICAgIHN0b3JlT3A6ICdzdG9yZScsXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGFzcy5zZXRQaXBlbGluZShwaXBlbGluZSk7XG4gICAgICAgIHBhc3Muc2V0QmluZEdyb3VwKDAsIGJpbmRncm91cCk7XG4gICAgICAgIHBhc3MuZHJhdygzKTtcbiAgICAgICAgcGFzcy5lbmQoKTtcbiAgICAgICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZW5jb2Rlci5maW5pc2goKV0pO1xuICAgIH1cblxuICAgIHJldHVybiBjdWJlbWFwO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlTWlwcyhkZXZpY2U6IEdQVURldmljZSwgdGV4dHVyZTogR1BVVGV4dHVyZSkge1xuICAgIGNvbnN0IGNvZGUgPSAvKiB3Z3NsICovIGBcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhciBpbWFnZTogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIG1pcFNhbXBsZXI6IHNhbXBsZXI7XG5cbiAgICAgICAgJHtibGl0fVxuXG4gICAgICAgIEBmcmFnbWVudFxuICAgICAgICBmbiBmcyhAbG9jYXRpb24oMCkgdXY6IHZlYzJmKSAtPiBAbG9jYXRpb24oMCkgdmVjNGYge1xuICAgICAgICAgICAgcmV0dXJuIHRleHR1cmVTYW1wbGUoaW1hZ2UsIG1pcFNhbXBsZXIsIHV2KTtcbiAgICAgICAgfVxuICAgIGA7XG5cbiAgICBjb25zdCBsYWJlbCA9IHBhZFRlbXBsYXRlYG1pcCBnZW5lcmF0aW9uJHt0ZXh0dXJlLmxhYmVsfWA7XG5cbiAgICBjb25zdCBiaW5kZ3JvdXBMYXlvdXQgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHsgdmlld0RpbWVuc2lvbjogJzJkJywgc2FtcGxlVHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgIHNhbXBsZXI6IHt9LFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbG9yQXR0YWNobWVudCA9IHtcbiAgICAgICAgdmlldzogdW5kZWZpbmVkIGFzIEdQVVRleHR1cmVWaWV3IHwgdW5kZWZpbmVkLFxuICAgICAgICBsb2FkT3A6ICdjbGVhcicsXG4gICAgICAgIHN0b3JlT3A6ICdzdG9yZScsXG4gICAgfTtcblxuICAgIGNvbnN0IHNhbXBsZXIgPSBkZXZpY2UuY3JlYXRlU2FtcGxlcih7XG4gICAgICAgIG1pbkZpbHRlcjogJ2xpbmVhcicsXG4gICAgICAgIG1hZ0ZpbHRlcjogJ2xpbmVhcicsXG4gICAgfSk7XG4gICAgY29uc3QgbW9kdWxlID0gZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7IGxhYmVsLCBjb2RlIH0pO1xuICAgIGNvbnN0IHBpcGVsaW5lTGF5b3V0ID0gZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHsgbGFiZWwsIGJpbmRHcm91cExheW91dHM6IFtiaW5kZ3JvdXBMYXlvdXRdIH0pO1xuXG4gICAgY29uc3QgcGlwZWxpbmUgPSBkZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgbGF5b3V0OiBwaXBlbGluZUxheW91dCxcbiAgICAgICAgdmVydGV4OiB7XG4gICAgICAgICAgICBlbnRyeVBvaW50OiAndnMnLFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICB9LFxuICAgICAgICBmcmFnbWVudDoge1xuICAgICAgICAgICAgZW50cnlQb2ludDogJ2ZzJyxcbiAgICAgICAgICAgIHRhcmdldHM6IFt7IGZvcm1hdDogdGV4dHVyZS5mb3JtYXQgfV0sXG4gICAgICAgICAgICBtb2R1bGUsXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb2xvckF0dGFjaG1lbnQudmlldyA9IHRleHR1cmUuY3JlYXRlVmlldyh7IG1pcExldmVsQ291bnQ6IDEsIGJhc2VNaXBMZXZlbDogMCB9KTtcbiAgICBhd2FpdCBkZXZpY2UucXVldWUub25TdWJtaXR0ZWRXb3JrRG9uZSgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0ZXh0dXJlLm1pcExldmVsQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBiaW5kZ3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgbGF5b3V0OiBiaW5kZ3JvdXBMYXlvdXQsXG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogY29sb3JBdHRhY2htZW50LnZpZXcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiBzYW1wbGVyLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb2xvckF0dGFjaG1lbnQudmlldyA9IHRleHR1cmUuY3JlYXRlVmlldyh7IG1pcExldmVsQ291bnQ6IDEsIGJhc2VNaXBMZXZlbDogaSB9KTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgICAgICBjb25zdCBwYXNzID0gZW5jb2Rlci5iZWdpblJlbmRlclBhc3Moe1xuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBjb2xvckF0dGFjaG1lbnRzOiBbY29sb3JBdHRhY2htZW50IGFzIEdQVVJlbmRlclBhc3NDb2xvckF0dGFjaG1lbnRdLFxuICAgICAgICB9KTtcblxuICAgICAgICBwYXNzLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcbiAgICAgICAgcGFzcy5zZXRCaW5kR3JvdXAoMCwgYmluZGdyb3VwKTtcbiAgICAgICAgcGFzcy5kcmF3KDMpO1xuICAgICAgICBwYXNzLmVuZCgpO1xuXG4gICAgICAgIGRldmljZS5xdWV1ZS5zdWJtaXQoW2VuY29kZXIuZmluaXNoKCldKTtcbiAgICAgICAgYXdhaXQgZGV2aWNlLnF1ZXVlLm9uU3VibWl0dGVkV29ya0RvbmUoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcmdiVGV4dHVyZVRvTGluZWFyKGRldmljZTogR1BVRGV2aWNlLCB0ZXh0dXJlOiBHUFVUZXh0dXJlKSB7XG4gICAgY29uc3QgY29kZSA9IC8qIHdnc2wgKi8gYFxuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyIGltYWdlOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXIgaW1hZ2VTYW1wbGVyOiBzYW1wbGVyO1xuXG4gICAgICAgICR7YmxpdH1cblxuICAgICAgICBmbiBzUkdCVG9MaW5lYXIoY29sb3I6IHZlYzNmKSAtPiB2ZWMzZiB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0KCBcbiAgICAgICAgICAgICAgICBwb3coY29sb3IgKiAwLjk0Nzg2NzI5ODYgKyAwLjA1MjEzMjcwMTQsIHZlYzMoMi40KSksIFxuICAgICAgICAgICAgICAgIGNvbG9yICogMC4wNzczOTkzODA4LCBcbiAgICAgICAgICAgICAgICBjb2xvciA8PSB2ZWMzKDAuMDQwNDUpLCBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gIFxuXG4gICAgICAgIEBmcmFnbWVudFxuICAgICAgICBmbiBmcyhAbG9jYXRpb24oMCkgdXY6IHZlYzJmKSAtPiBAbG9jYXRpb24oMCkgdmVjNGYgIHtcbiAgICAgICAgICAgIGxldCBzYW1wbGUgPSB0ZXh0dXJlU2FtcGxlKGltYWdlLCBpbWFnZVNhbXBsZXIsIHV2KTtcbiAgICAgICAgICAgIGxldCBjb2xvciA9IHNSR0JUb0xpbmVhcihzYW1wbGUucmdiKTtcbiAgICAgICAgICAgIHJldHVybiB2ZWM0KGNvbG9yLCBzYW1wbGUuYSk7XG4gICAgICAgIH1cbiAgICBgO1xuXG4gICAgY29uc3QgbGFiZWwgPSBwYWRUZW1wbGF0ZWBzcmdiIHRvIGxpbmVhciR7dGV4dHVyZS5sYWJlbH1gO1xuXG4gICAgY29uc3Qgc2l6ZSA9IHsgd2lkdGg6IHRleHR1cmUud2lkdGgsIGhlaWdodDogdGV4dHVyZS5oZWlnaHQgfTtcblxuICAgIGNvbnN0IHRlbXBUZXh0dXJlID0gZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgICBmb3JtYXQ6IHRleHR1cmUuZm9ybWF0LFxuICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUIHwgR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyxcbiAgICAgICAgc2l6ZSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGJpbmRncm91cExheW91dCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDAsXG4gICAgICAgICAgICAgICAgdGV4dHVyZToge30sXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXG4gICAgICAgICAgICAgICAgc2FtcGxlcjoge30sXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2FtcGxlciA9IGRldmljZS5jcmVhdGVTYW1wbGVyKHtcbiAgICAgICAgbWluRmlsdGVyOiAnbGluZWFyJyxcbiAgICAgICAgbWFnRmlsdGVyOiAnbGluZWFyJyxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoeyBsYWJlbCwgY29kZTogY29kZSB9KTtcbiAgICBjb25zdCBwaXBlbGluZUxheW91dCA9IGRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCh7IGxhYmVsLCBiaW5kR3JvdXBMYXlvdXRzOiBbYmluZGdyb3VwTGF5b3V0XSB9KTtcblxuICAgIGNvbnN0IHBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGxheW91dDogcGlwZWxpbmVMYXlvdXQsXG4gICAgICAgIHZlcnRleDoge1xuICAgICAgICAgICAgZW50cnlQb2ludDogJ3ZzJyxcbiAgICAgICAgICAgIG1vZHVsZSxcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgICAgIGVudHJ5UG9pbnQ6ICdmcycsXG4gICAgICAgICAgICB0YXJnZXRzOiBbeyBmb3JtYXQ6IHRleHR1cmUuZm9ybWF0IH1dLFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgYmluZGdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBsYXlvdXQ6IGJpbmRncm91cExheW91dCxcbiAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDAsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRlbXBUZXh0dXJlLmNyZWF0ZVZpZXcoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMSxcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogc2FtcGxlcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBlbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgZW5jb2Rlci5jb3B5VGV4dHVyZVRvVGV4dHVyZShcbiAgICAgICAgeyB0ZXh0dXJlIH0sXG4gICAgICAgIHsgdGV4dHVyZTogdGVtcFRleHR1cmUgfSxcbiAgICAgICAgc2l6ZSxcbiAgICApO1xuXG4gICAgY29uc3QgcGFzcyA9IGVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGNvbG9yQXR0YWNobWVudHM6IFt7XG4gICAgICAgICAgICB2aWV3OiB0ZXh0dXJlLmNyZWF0ZVZpZXcoeyBtaXBMZXZlbENvdW50OiAxLCBiYXNlTWlwTGV2ZWw6IDAgfSksXG4gICAgICAgICAgICBsb2FkT3A6ICdjbGVhcicsXG4gICAgICAgICAgICBzdG9yZU9wOiAnc3RvcmUnLFxuICAgICAgICB9XSxcbiAgICB9KTtcblxuICAgIHBhc3Muc2V0UGlwZWxpbmUocGlwZWxpbmUpO1xuICAgIHBhc3Muc2V0QmluZEdyb3VwKDAsIGJpbmRncm91cCk7XG4gICAgcGFzcy5kcmF3KDMpO1xuICAgIHBhc3MuZW5kKCk7XG5cbiAgICBkZXZpY2UucXVldWUuc3VibWl0KFtlbmNvZGVyLmZpbmlzaCgpXSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9629\n")}}]);