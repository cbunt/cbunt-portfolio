/*! For license information see: https://cbunt.ing/oss-licenses.json */
"use strict";(self.webpackChunkcbunt_portfolio=self.webpackChunkcbunt_portfolio||[]).push([[438],{9451:(e,t,r)=>{r.d(t,{A:()=>o});var n=r(9887);const i="global uniforms";class a{constructor(e){this.deviceBuffer=e.createBuffer(a.bufferDescriptor),this.bindGroupLayout=e.createBindGroupLayout(a.layoutDescriptor),this.bindGroupDescriptor={label:i,layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:this.deviceBuffer,offset:0,size:a.bufferSize}}]},this.bindgroup=e.createBindGroup(this.bindGroupDescriptor)}updateDeviceBuffer(e,t){t.cacheView(),e.writeBuffer(this.deviceBuffer,0,t.buffer)}}a.code=e=>`\n        struct GlobalUniforms {\n            worldToView: mat4x4f,\n            viewToClip: mat4x4f,\n            worldToClip: mat4x4f,\n            inverseWorldToView: mat4x4f,\n            inverseViewToClip: mat4x4f,\n            inverseWorldToClip: mat4x4f,\n        }\n\n        @group(${e}) @binding(0) var<uniform> globals: GlobalUniforms;\n    `,a.bufferSize=n.A.bufferLength,a.layoutDescriptor={label:i,entries:[{binding:0,buffer:{minBindingSize:a.bufferSize},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}]},a.bufferDescriptor={label:i,size:a.bufferSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};const o=a},1438:(e,t,r)=>{r.r(t),r.d(t,{default:()=>V});var n=r(9887),i=r(9451),a=r(5360);const o="tonemap pass";class s{constructor(e,t){this.device=e,this.colorAttachment={loadOp:"load",storeOp:"store",view:void 0},this.passDescriptor={label:o,colorAttachments:[this.colorAttachment]},this.renderTarget={format:t},this.bindgroupLayout=e.createBindGroupLayout(s.bindGroupLayoutDescriptor);const r=e.createShaderModule({label:o,code:s.code});this.pipelineDescriptor={label:o,layout:e.createPipelineLayout({label:o,bindGroupLayouts:[this.bindgroupLayout]}),vertex:{module:r,entryPoint:"vs"},fragment:{module:r,entryPoint:"fs",targets:[this.renderTarget]}},this.pipeline=e.createRenderPipeline(this.pipelineDescriptor)}updateInput(e){this.bindgroup=this.device.createBindGroup({label:o,layout:this.bindgroupLayout,entries:[{binding:0,resource:e}]})}render(e,t){if(null==this.bindgroup)return;this.renderTarget.format!==t.format&&(this.renderTarget.format=t.format,this.pipeline=this.device.createRenderPipeline(this.pipelineDescriptor)),this.colorAttachment.view=t.createView({dimension:"2d"});const r=e.beginRenderPass(this.passDescriptor);r.setPipeline(this.pipeline),r.setBindGroup(0,this.bindgroup),r.draw(3),r.end()}}s.code=`\n        @group(0) @binding(0) var colorTexture: texture_2d<f32>;\n\n        ${a.A}\n\n        fn fitRRTAndODT(color: vec3f) -> vec3f {\n            let a = color * (color + 0.0245786) - 0.000090537;\n            let b = color * (0.983729 * color + 0.4329510) + 0.238081;\n            return a / b;\n        }\n\n        fn aces_tone_map(hdr: vec3f) -> vec3f {\n            const inputMat = mat3x3(\n                0.59719, 0.07600, 0.02840,\n                0.35458, 0.90834, 0.13383,\n                0.04823, 0.01566, 0.83777,\n            );\n            const outputMat = mat3x3(\n                1.60475, -0.10208, -0.00327,\n                -0.53108, 1.10813, -0.07276,\n                -0.07367, -0.00605, 1.07602,\n            );\n            const boost = 1.0 / 0.6;\n\n            var color = hdr * boost;\n            color = inputMat * color;\n            color = fitRRTAndODT(color);\n            color = outputMat * color;\n            return saturate(color);\n        }\n\n        fn linear_to_srgb(color: vec3f) -> vec3f {\n            return pow(color, vec3(1.0/2.2));\n        }\n\n        @fragment\n        fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {\n            let uv = vec2<i32>(floor(pos.xy));\n\n            var color = textureLoad(colorTexture, uv, 0).rgb;\n            color = aces_tone_map(color);\n            color = linear_to_srgb(color);\n            return vec4f(color, 1.0);\n        }\n    `,s.bindGroupLayoutDescriptor={label:o,entries:[{binding:0,texture:{sampleType:"float",viewDimension:"2d"},visibility:GPUShaderStage.FRAGMENT}]};const u=s;var l,c,d,p,f,h,v=function(e,t,r,n){if("a"===r&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?n:"a"===r?n.call(e):n?n.value:t.get(e)},m=function(e,t,r,n,i){if("m"===n)throw new TypeError("Private method is not writable");if("a"===n&&!i)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===n?i.call(e,r):i?i.value=r:t.set(e,r),r};const g="skybox pass";class b{get mipLevel(){return this.uniformArray[0]}set mipLevel(e){e!==this.uniformArray[0]&&(this.uniformArray[0]=e,this.device.queue.writeBuffer(this.uniformBuffer,0,this.uniformArray,0,1))}get useNearestSample(){return v(this,f,"f")}set useNearestSample(e){e!==v(this,f,"f")&&(m(this,f,e,"f"),v(this,l,"m",h).call(this))}get targetFormat(){return v(this,p,"f")}set targetFormat(e){e!==v(this,p,"f")&&(m(this,p,e,"f"),this.pipeline=this.device.createRenderPipeline({label:g,layout:this.pipelineLayout,vertex:{entryPoint:"vs",module:this.shader},fragment:{entryPoint:"fs",targets:[{format:e}],module:this.shader}}))}set skyTexture(e){e!==v(this,c,"f")&&(m(this,c,e,"f"),v(this,l,"m",h).call(this))}set depthTexture(e){e!==v(this,d,"f")&&(m(this,d,e,"f"),v(this,l,"m",h).call(this))}constructor(e,t,r,n){l.add(this),this.device=e,this.globals=t,this.uniformArray=new Float32Array(8),c.set(this,void 0),d.set(this,void 0),p.set(this,void 0),f.set(this,!1),this.target={clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store",view:void 0},this.passDescriptor={colorAttachments:[this.target]},this.bindgroupLayout=e.createBindGroupLayout({label:g,entries:[{binding:0,texture:{viewDimension:"cube"},visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.VERTEX},{binding:1,texture:{viewDimension:"2d",sampleType:"depth"},visibility:GPUShaderStage.FRAGMENT},{binding:2,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:3,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.linearSampler=e.createSampler({minFilter:"linear",magFilter:"linear",mipmapFilter:"linear"}),this.nearestSampler=e.createSampler({minFilter:"nearest",magFilter:"nearest",mipmapFilter:"nearest"}),this.shader=e.createShaderModule({code:b.code,label:g}),this.pipelineLayout=e.createPipelineLayout({label:g,bindGroupLayouts:[t.bindGroupLayout,this.bindgroupLayout]}),this.uniformBuffer=e.createBuffer({label:g,size:32,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.targetFormat=r,null!=n&&(this.skyTexture=n)}render(e){return null!=this.textureBindgroup&&null!=this.pipeline&&(e.setPipeline(this.pipeline),e.setBindGroup(0,this.globals.bindgroup),e.setBindGroup(1,this.textureBindgroup),e.draw(3),!0)}}c=new WeakMap,d=new WeakMap,p=new WeakMap,f=new WeakMap,l=new WeakSet,h=function(){null!=v(this,c,"f")&&null!=v(this,d,"f")&&(this.textureBindgroup=this.device.createBindGroup({label:g,layout:this.bindgroupLayout,entries:[{binding:0,resource:v(this,c,"f")},{binding:1,resource:v(this,d,"f")},{binding:2,resource:this.useNearestSample?this.nearestSampler:this.linearSampler},{binding:3,resource:{buffer:this.uniformBuffer}}]}))},b.code=`\n        ${i.A.code(0)}\n\n        struct SkyboxUniforms {\n            mipBias: f32,\n        };\n\n        @group(1) @binding(0) var environmentTexture: texture_cube<f32>;\n        @group(1) @binding(1) var depthTexture: texture_depth_2d;\n        @group(1) @binding(2) var environmentSampler: sampler;\n        @group(1) @binding(3) var<uniform> skyboxUniforms: SkyboxUniforms;\n\n        struct Varyings {\n            @builtin(position) position: vec4f,\n            @location(0) pos: vec4f,\n            @location(1) mipBias: f32,\n        };\n    \n        @vertex \n        fn vs(@builtin(vertex_index) vNdx: u32) -> Varyings {\n            const pos = array(\n                vec2(-1.0,  3.0),\n                vec2(-1.0, -1.0),\n                vec2( 3.0, -1.0),\n            );\n    \n            var vsOut: Varyings;\n            vsOut.position = vec4(pos[vNdx], 0.0, 1.0);\n    \n            // Ignores the camera's translation without needing a separate rotation matrix.\n            vsOut.pos = globals.inverseViewToClip * vsOut.position;\n            let w = vsOut.pos.w;\n            vsOut.pos.w = 0.0;\n            vsOut.pos = globals.inverseWorldToView * vsOut.pos;\n            vsOut.pos.w = w;\n\n            vsOut.mipBias = clamp(skyboxUniforms.mipBias, 0, f32(textureNumLevels(environmentTexture)));\n            return vsOut;\n        }\n\n        @fragment\n        fn fs(in: Varyings) -> @location(0) vec4f {\n            let dimensions = textureDimensions(depthTexture);\n            let uv = min(vec2<u32>(floor(in.position.xy)), dimensions - 1);\n            let depth = textureLoad(depthTexture, uv, 0);\n            if (depth < 1.0) { discard; }\n\n            let t = normalize(in.pos.xyz / in.pos.w);\n            let color = textureSampleLevel(environmentTexture, environmentSampler, t, in.mipBias).rgb;\n            return vec4(color, 1.0);\n        }\n    `;const y=b;class x{get size(){return this._size}set size(e){this._size=e,this.textures.forEach((e=>{this.createTexture(e)})),this.bindgroup=this.updateBindgroup(),this.passDescriptor=this.updatePassDescriptor()}constructor(e,t){this.device=e,this._size=t,this.normal=this.createTexture({format:"rgba16float",name:"normal",clearValue:{r:0,g:0,b:1,a:1}}),this.albedo=this.createTexture({format:"rgba8unorm",name:"albedo",clearValue:{r:0,g:0,b:0,a:1}}),this.emission=this.createTexture({format:"rgba16float",name:"emission",clearValue:{r:0,g:0,b:0,a:1}}),this.metallicRoughness=this.createTexture({format:"rg8unorm",name:"metallic roughness",clearValue:{r:0,g:0,b:0,a:0}}),this.depth=this.createTexture({format:"depth32float",name:"depth"}),this.textures=[this.normal,this.albedo,this.emission,this.metallicRoughness,this.depth],this.targets=this.textures.slice(0,-1).map((({format:e})=>({format:e}))),this.bindGroupLayout=this.device.createBindGroupLayout(x.layoutDescription),this.bindgroup=this.updateBindgroup(),this.passDescriptor=this.updatePassDescriptor()}updateBindgroup(){const e=this.textures.map((({view:e},t)=>({binding:t,resource:e})));return this.device.createBindGroup({label:"gbuffer bind group",layout:this.bindGroupLayout,entries:e})}updatePassDescriptor(){return{label:"forward pass encoder",colorAttachments:this.textures.slice(0,-1).map((({view:e,clearValue:t})=>({view:e,clearValue:t,loadOp:"clear",storeOp:"store"}))),depthStencilAttachment:{view:this.depth.view,depthLoadOp:"clear",depthStoreOp:"store",depthClearValue:1}}}createTexture(e){const t=`gbuffer ${e.name}`;return e.texture=this.device.createTexture({label:t,size:this._size,format:e.format,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),e.view=e.texture.createView({label:t}),e}}x.code=e=>`\n        @group(${e}) @binding(0) \n        var gBufferNormal: texture_2d<f32>;\n        \n        @group(${e}) @binding(1) \n        var gBufferAlbedo: texture_2d<f32>;\n        \n        @group(${e}) @binding(2) \n        var gBufferEmission: texture_2d<f32>;\n\n        @group(${e}) @binding(3) \n        var gBufferMetallicRoughness: texture_2d<f32>;\n        \n        @group(${e}) @binding(4)  \n        var gBufferDepth: texture_depth_2d;\n    `,x.layoutDescription={label:"gbuffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float"}},{binding:4,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"depth"}}]};const w=x,T="\n    fn hammersley(i: u32, N: u32) -> vec2f {\n        var bits = (i << 16u) | (i >> 16u);\n        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n        let rdi = f32(bits) * 2.3283064365386963e-10; // / 0x100000000\n        return vec2(f32(i) / f32(N), rdi);\n    }\n\n    fn tangentSampleGGX(N: vec3f, Xi: vec2f, a2: f32) -> vec3f {\n        const PI = 3.14159265359;\n\n        let phi = 2.0 * PI * Xi.x;\n        let cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));\n        let sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n        \n        var H: vec3f;\n        H.x = cos(phi) * sinTheta;\n        H.y = sin(phi) * sinTheta;\n        H.z = cosTheta;\n\n        let up = select(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), abs(N.z) >= 0.999);\n        let T = normalize(cross(up, N));\n        let B = cross(N, T);\n\n        let S = T * H.x + B * H.y + N * H.z;\n        return normalize(S);\n    }\n\n    fn vPartLambda(NoV: f32, a2: f32) -> f32 {\n        return sqrt(NoV * NoV * (1.0 - a2) + a2);\n    }\n\n    fn vCorrelatedGGX(NoV: f32, NoL: f32, a2: f32) -> f32 {\n        let GGXV = NoL * vPartLambda(NoV, a2);\n        let GGXL = NoV * vPartLambda(NoL, a2);\n        return 0.5 / (GGXV + GGXL);\n    }\n\n    fn dS2GGX(NoH: f32, a2: f32) -> f32 {\n        let s = (a2 - 1.0) * NoH * NoH + 1.0;\n        return s * s;\n    }\n\n    fn dGGX(NoH: f32, a2: f32) -> f32 {\n        const invPI = 1.0 / 3.14159265359;\n\n        let s2 = dS2GGX(NoH, a2);\n        return invPI * select(1, a2 / s2, a2 != s2);\n    }\n",P=`\noverride SAMPLE_COUNT: u32 = 1024u;\n\n${a.A}\n${T}\n\n@fragment\nfn fs(@location(0) uv: vec2f) -> @location(0) vec4f  {\n    let NoV = uv.x;\n    let roughness = uv.y;\n    let alpha = roughness * roughness;\n    let a2 = alpha * alpha;\n    let V = vec3(sqrt(1.0 - NoV * NoV), NoV, 0.0);\n    let N = vec3(0.0, 1.0, 0.0);\n\n    var brdf = vec2(0.0);\n\n    for (var i = 0u; i < SAMPLE_COUNT; i++) {\n        let Xi = hammersley(i, SAMPLE_COUNT);\n        let H = tangentSampleGGX(N, Xi, a2);\n        let L = normalize(2.0 * dot(V, H) * H - V);\n\n        let NoL = saturate(L.y);\n        let NoH = saturate(H.y);\n        let VoH = saturate(dot(V, H));\n\n        if (NoL > 0.0) {\n            let pdf = vCorrelatedGGX(NoV, NoL, a2) * VoH * NoL / NoH;\n            let Fc = pow(1.0 - VoH, 5.0);\n            brdf += vec2(1.0 - Fc, Fc) * pdf;\n        }\n    }\n\n    return vec4f(brdf * 4.0 / f32(SAMPLE_COUNT), 0.0, 1.0);\n}\n`;var S=r(3654),L=r(1575);const A=`\n    const PI = 3.14159265359;\n\n    override SAMPLES: u32 = 2048u;\n\n    struct Params {\n        face: u32,\n        size: u32,\n    }\n\n    @group(0) @binding(0) var environment: texture_cube<f32>;\n    @group(0) @binding(1) var environmentSampler: sampler;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    ${S.V}\n    ${T}\n    ${a.A}\n\n    @fragment\n    fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {\n        let coord = vec3u(vec2u(floor(pos.xy)), params.face);\n        let size = f32(textureDimensions(environment).x);\n        let lodFactor = 6.0 * size * size / f32(SAMPLES);\n\n        let N = toWorldDir(coord, params.size);\n        let right = normalize(cross(vec3(0.0, 1.0, 0.0), N));\n        let up = normalize(cross(N, right));\n        let TBN = mat3x3(right, up, N);\n        \n        var irradiance = vec3(0.0);\n        var samples = 0.0;\n\n        for (var i = 0u; i < SAMPLES; i += 1) {\n            let xi = hammersley(i, SAMPLES);\n            let cosTheta = sqrt(1.0 - xi.y);\n            let sinTheta = sqrt(xi.y);\n            let phi = 2.0 * PI * xi.x;\n            let invPdf = PI / cosTheta;\n            let localDir = normalize(vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta));\n            let worldDir = TBN * localDir;\n            let lod = 0.5 * log2(lodFactor * invPdf);\n            irradiance += textureSampleLevel(environment, environmentSampler, worldDir, lod).rgb;\n        }\n\n        return vec4(irradiance / f32(SAMPLES), 1.0);\n    }\n`;const G=`\n    override SAMPLES: u32 = 1024u;\n\n    const PI = 3.14159265359;\n    const invPI = 1.0 / PI;\n\n    struct Params {\n        face: u32,\n        mipSize: u32,\n        invOmegaP: f32,\n        a2: f32,\n    }\n\n    @group(0) @binding(0) var environment: texture_cube<f32>;\n    @group(0) @binding(1) var environmentSampler: sampler;\n    @group(0) @binding(2) var<uniform> params: Params;\n\n    ${S.V}\n    ${T}\n    ${a.A}\n\n    @fragment\n    fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {\n        let N = toWorldDirF32(uv, params.face);\n\n        var radiance = vec3(0.0);\n        var totalWeight = 0.0;\n        \n        for (var i = 0u; i < SAMPLES; i += 1) {\n            let Xi = hammersley(i, SAMPLES);\n            let H = tangentSampleGGX(N, Xi, params.a2);\n            let HoV = saturate(dot(H, N));\n            let L = normalize(2.0 * HoV * H - N);\n            let NoL = saturate(dot(N, L));\n\n            if (NoL <= 0.0) { continue; }\n\n            let pdf = dGGX(HoV, params.a2) / 4.0 + 0.001;\n            let omegaS = 1.0 / (f32(SAMPLES) * pdf);\n            let mipLevel = 0.5 * log2(omegaS * params.invOmegaP) + params.a2;\n\n            radiance += textureSampleLevel(environment, environmentSampler, L, mipLevel).rgb * NoL;\n            totalWeight += NoL;\n        }\n    \n        return vec4(radiance / totalWeight, 1.0);\n    }\n`;class N{set skybox(e){this.irradianceTexture=function({device:e,texture:t,label:r="irradiance",usage:n=0,samples:i=2048,outputWidth:a,outputFormat:o,outputTexture:s}){const u=s?.format??o??t.format,l=s?.width??a??64,c=e.createBindGroupLayout({label:r,entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),d=e.createSampler({minFilter:"linear",magFilter:"linear",mipmapFilter:"linear"}),p=6===s?.depthOrArrayLayers?s:e.createTexture({label:r,format:u,dimension:"2d",usage:GPUTextureUsage.RENDER_ATTACHMENT|n,size:{width:l,height:l,depthOrArrayLayers:6}}),f=new Uint32Array([0,p.width]),h=(0,L.Lr)(f,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,e),v=e.createBindGroup({label:r,layout:c,entries:[{binding:0,resource:t.createView({dimension:"cube"})},{binding:1,resource:d},{binding:2,resource:{buffer:h}}]}),m=e.createPipelineLayout({label:r,bindGroupLayouts:[c]}),g=e.createShaderModule({label:r,code:A}),b=e.createRenderPipeline({label:r,layout:m,vertex:{module:g,entryPoint:"vs"},fragment:{entryPoint:"fs",constants:{SAMPLES:i},module:g,targets:[{format:u}]}});for(let t=0;t<6;t+=1){f[0]=t,e.queue.writeBuffer(h,0,f,0,1);const r=p.createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:t}),n=e.createCommandEncoder(),i=n.beginRenderPass({colorAttachments:[{view:r,loadOp:"clear",storeOp:"store"}]});i.setPipeline(b),i.setBindGroup(0,v),i.draw(3),i.end(),e.queue.submit([n.finish()])}return p}({texture:e,device:this.device,usage:GPUTextureUsage.TEXTURE_BINDING}),this.radianceTexture=function({device:e,texture:t,targetFormat:r,usage:n=0,label:i="radiance",samples:a=1024,outputWidth:o,outputTexture:s}){const u=s?.format??r??t.format,l=s?.width??o??t.width,c=e.createBindGroupLayout({label:i,entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),d=e.createSampler({minFilter:"linear",magFilter:"linear",mipmapFilter:"linear"}),p=new ArrayBuffer(16),f=new Uint32Array(p,0,2),h=new Float32Array(p,8,2),v=(0,L.Lr)(p,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,e),m=6===s?.depthOrArrayLayers?s:e.createTexture({label:i,format:u,dimension:"2d",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST|n,size:{width:l,height:l,depthOrArrayLayers:6},mipLevelCount:Math.max((0|Math.log2(l))-2,1)}),g=e.createCommandEncoder({label:`${i} copy encoder`});g.copyTextureToTexture({texture:t,mipLevel:0},{texture:m,mipLevel:0},{width:l,height:l,depthOrArrayLayers:6}),e.queue.submit([g.finish()]);const b=e.createPipelineLayout({label:i,bindGroupLayouts:[c]}),y=e.createShaderModule({label:i,code:G}),x=e.createRenderPipeline({label:i,layout:b,vertex:{module:y,entryPoint:"vs"},fragment:{entryPoint:"fs",targets:[{format:m.format}],constants:{SAMPLES:a},module:y}});return h[0]=6*t.width*t.width/(4*Math.PI),Promise.resolve().then((async()=>{const r=e.createBindGroup({label:i,layout:c,entries:[{binding:0,resource:t.createView({dimension:"cube"})},{binding:1,resource:d},{binding:2,resource:{buffer:v}}]});for(let t=1;t<m.mipLevelCount;t+=1){const n=t/(m.mipLevelCount-1);h[1]=n**4,f[1]=m.width>>t;for(let n=0;n<6;n+=1){await e.queue.onSubmittedWorkDone(),f[0]=n,e.queue.writeBuffer(v,0,p);const i=m.createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:n,mipLevelCount:1,baseMipLevel:t}),a=e.createCommandEncoder(),o=a.beginRenderPass({colorAttachments:[{view:i,loadOp:"clear",storeOp:"store"}]});o.setPipeline(x),o.setBindGroup(0,r),o.draw(3),o.end(),e.queue.submit([a.finish()])}}})),m}({texture:e,device:this.device,usage:GPUTextureUsage.TEXTURE_BINDING}),this.irradianceView=this.irradianceTexture.createView({dimension:"cube"}),this.radianceView=this.radianceTexture.createView({dimension:"cube"}),this.bindgroup=this.device.createBindGroup({layout:this.bindgroupLayout,entries:[{binding:0,resource:this.radianceView},{binding:1,resource:this.irradianceView},{binding:2,resource:this.bfrdLutView},{binding:3,resource:this.sampler}]})}constructor(e,t,r,n,i){this.device=e,this.globals=t,this.gbuffer=r,this.target={view:void 0,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},this.bfrdLut=function({device:e,label:t,sampleCount:r,width:n=1024,height:i=1024,format:a="rg32float"}){const o=e.createTexture({label:t,format:a,dimension:"2d",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,size:{width:n,height:i}}),s=e.createShaderModule({label:"bfrdLut shader",code:P}),u=e.createRenderPipeline({label:"bfrd lut pipeline",layout:"auto",vertex:{entryPoint:"vs",module:s},fragment:{entryPoint:"fs",targets:[{format:a}],constants:r?{SAMPLE_COUNT:r}:void 0,module:s}}),l=e.createCommandEncoder(),c=l.beginRenderPass({label:"brdf lut render pass",colorAttachments:[{view:o.createView(),loadOp:"clear",storeOp:"store"}]});return c.setPipeline(u),c.draw(3),c.end(),e.queue.submit([l.finish()]),o}({device:this.device}),this.bfrdLutView=this.bfrdLut.createView(),this.passDescriptor={colorAttachments:[this.target]},this.sampler=e.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"}),null!=i&&(this.skybox=i),this.bindgroupLayout=e.createBindGroupLayout({label:"deferred pass",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{}}]});const a=e.createPipelineLayout({label:"deferred pass bindgroup layout",bindGroupLayouts:[this.globals.bindGroupLayout,this.gbuffer.bindGroupLayout,this.bindgroupLayout]}),o=e.createShaderModule({code:N.code,label:"deferred pass shader"});this.pipeline=e.createRenderPipeline({layout:a,vertex:{entryPoint:"vs",module:o},fragment:{entryPoint:"fs",targets:[{format:n}],module:o}})}render(e){null!=this.bindgroup&&(e.setPipeline(this.pipeline),e.setBindGroup(0,this.globals.bindgroup),e.setBindGroup(1,this.gbuffer.bindgroup),e.setBindGroup(2,this.bindgroup),e.draw(3))}}N.code=`\n        ${i.A.code(0)}\n        ${w.code(1)}\n\n        @group(2) @binding(0) var radianceTexture: texture_cube<f32>;\n        @group(2) @binding(1) var irradianceTexture: texture_cube<f32>;\n        @group(2) @binding(2) var brdfTexture: texture_2d<f32>;\n        @group(2) @binding(3) var generalSampler: sampler;\n\n        ${T}\n        ${a.A}\n\n        @fragment\n        fn fs(@builtin(position) pos: vec4f, @location(0) uv: vec2f) -> @location(0) vec4f {\n            let uvi = vec2<u32>(pos.xy);\n            let depth = textureLoad(gBufferDepth, uvi, 0);\n\n            if (depth >= 1.0) { discard; }\n\n            let uvClip = vec2(uv.x * 2.0 - 1.0, 1.0 - uv.y * 2.0);\n            let clipPos = vec4(uvClip, depth, 1.0);\n            let viewPos = globals.inverseViewToClip * clipPos;\n            let worldDir = globals.inverseWorldToView * vec4(viewPos.xyz / viewPos.w, 0.0);\n            let view = -normalize(worldDir.xyz);\n\n            let normal = textureLoad(gBufferNormal, uvi, 0).rgb;\n            let albedo = textureLoad(gBufferAlbedo, uvi, 0).rgb;\n            let emission = textureLoad(gBufferEmission, uvi, 0).rgb;\n            let metallicRoughnessSample = textureLoad(gBufferMetallicRoughness, uvi, 0);\n            let metallic = metallicRoughnessSample.r;\n            let roughness = metallicRoughnessSample.g;\n            let alpha = roughness * roughness;\n            let a2 = alpha * alpha;\n\n            let NoV = saturate(dot(normal, view));\n            let F0 = mix(vec3f(0.04), albedo, metallic);\n            let R = reflect(-view, normal);\n\n            let level = roughness * f32(textureNumLevels(radianceTexture) - 1u);\n            let radiance = textureSampleLevel(radianceTexture, generalSampler, R, level).rgb;\n            let irradiance = textureSample(irradianceTexture, generalSampler, normal).rgb;\n            let brdf = textureSample(brdfTexture, generalSampler, saturate(vec2f(NoV, roughness))).xy;\n\n            // Roughness dependent fresnel\n            let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n            let kS = F0 + Fr * pow(1.0 - NoV, 5.0);\n            let FssEss = kS * brdf.x + brdf.y;\n\n            // Multiple scattering, originally proposed by Fdez-Aguera\n            // and here adapted from https://bruop.github.io/ibl\n            let Ems = 1.0 - (brdf.x + brdf.y);\n            let Favg = F0 + (1.0 - F0) / 21.0;\n            let FmsEms = Ems * FssEss * Favg / (1.0 - Favg * Ems);\n            let kD = albedo * (1.0 - 0.04) * (1.0 - metallic) * (1.0 - FssEss + FmsEms);\n\n            let specular = FssEss * radiance;\n            let diffuse = (FmsEms + kD) * irradiance;\n            let ambient = specular + diffuse + emission;\n\n            return vec4f(ambient, 1.0);\n        }\n    `;const E=N;var F,U,D=r(825),B=function(e,t,r,n){if("a"===r&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?n:"a"===r?n.call(e):n?n.value:t.get(e)};class C{set skybox(e){this.deferredPass.skybox=e,this.skyboxPass.skyTexture=this.deferredPass.radianceView}constructor(e,t){F.add(this),this.canvas=e,this.device=t,this.colorAttachment={clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store",view:void 0},this.passDescriptor={colorAttachments:[this.colorAttachment]},this.forwardPasses=[],this.render=()=>{requestAnimationFrame(this.render),this.globals.updateDeviceBuffer(this.device.queue,this.camera);const e=this.device.createCommandEncoder({label:"main render encoder"}),t={encoder:e,globals:this.globals,gbuffer:this.gbuffer};for(const e of this.forwardPasses)e.render(t);const r=e.beginRenderPass(this.passDescriptor);this.deferredPass.render(r),this.skyboxPass.render(r),r.end(),this.tonemapPass.render(e,this.context.getCurrentTexture()),this.device.queue.submit([e.finish()])};const r={width:this.canvas.width,height:this.canvas.height};this.camera=new n.A(r),this.globals=new i.A(this.device),this.gbuffer=new w(t,r),this.deferredPass=new E(t,this.globals,this.gbuffer,C.postProcessFormat),this.skyboxPass=new y(this.device,this.globals,C.postProcessFormat),this.tonemapPass=new u(this.device,C.outputFormat);const a=this.canvas.getContext("webgpu");if(null==a)throw new Error("renderer -- given canvas already initialized to non-webgpu context");this.context=a,this.context.configure({device:this.device,format:C.outputFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:"opaque",colorSpace:"srgb"}),this.updateBackings(r),B(this,F,"m",U).call(this)}static async CreateInitialized(e){const t=await navigator.gpu.requestAdapter();if(null==t)throw new Error("Could not initialize GPU.");const{maxComputeWorkgroupSizeX:r,maxComputeWorkgroupsPerDimension:n,maxComputeInvocationsPerWorkgroup:i}=t.limits,a=await t.requestDevice({label:"main logical device",requiredFeatures:C.requiredFeatures,requiredLimits:{maxComputeWorkgroupSizeX:r,maxComputeWorkgroupsPerDimension:n,maxComputeInvocationsPerWorkgroup:i}});return new C(e,a)}updateBackings(e){this.camera.updateParams(e),this.postprocessTarget=this.device.createTexture({dimension:"2d",format:C.postProcessFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,size:e}),this.colorAttachment.view=this.postprocessTarget.createView(),this.tonemapPass.updateInput(this.colorAttachment.view),this.gbuffer.size=e,this.skyboxPass.depthTexture=this.gbuffer.depth.view}addForwardPass(e){(0,D.nn)(this.forwardPasses,e,((e,t)=>e.priority-t.priority))}}F=new WeakSet,U=function(){const e=(0,D.sg)(((e,t)=>{const r=Math.max(1,Math.min(0|e,this.device.limits.maxTextureDimension2D)),n=Math.max(1,Math.min(0|t,this.device.limits.maxTextureDimension2D)),i={width:r,height:n};this.canvas.width=r,this.canvas.height=n,this.updateBackings(i)}),20);try{new ResizeObserver((t=>{const[{inlineSize:r,blockSize:n}]=t[t.length-1].devicePixelContentBoxSize;e(r,n)})).observe(this.canvas,{box:"device-pixel-content-box"})}catch{new ResizeObserver((t=>{const[{inlineSize:r,blockSize:n}]=t[t.length-1].contentBoxSize;e(r*devicePixelRatio,n*devicePixelRatio)})).observe(this.canvas,{box:"content-box"})}},C.requiredFeatures=["float32-filterable"],C.outputFormat=navigator.gpu.getPreferredCanvasFormat(),C.postProcessFormat="rgba32float";const V=C},5360:(e,t,r)=>{r.d(t,{A:()=>n});const n="\n    struct VertOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n    }\n\n    @vertex\n    fn vs(@builtin(vertex_index) idx: u32) -> VertOut {\n        const pos = array(\n            vec2f(-1,  3),\n            vec2f(3, -1),\n            vec2f(-1, -1),\n        );\n        var res: VertOut;\n        res.pos = vec4f(pos[idx], 0.0, 1.0);\n        res.uv = pos[idx] * vec2f(0.5, -0.5) + 0.5;\n        return res;\n    }\n"},3654:(e,t,r)=>{r.d(t,{V:()=>n,X:()=>i});const n="\n    fn toWorldDir(coord: vec3u, size: u32) -> vec3f {\n        let uv = (2.0 / f32(size)) * (vec2f(coord.xy) + 0.5) - 1.0;\n\n        var pos: vec3f;\n        switch (coord.z) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n\n    fn toWorldDirF32(coord: vec2f, face: u32) -> vec3f {\n        let uv = 2.0 * coord - 1.0;\n\n        var pos: vec3f;\n        switch (face) {\n            case 0  { pos = vec3(  1.0, -uv.y, -uv.x); }\n            case 1  { pos = vec3( -1.0, -uv.y,  uv.x); }\n            case 2  { pos = vec3( uv.x,   1.0,  uv.y); }\n            case 3  { pos = vec3( uv.x,  -1.0, -uv.y); }\n            case 4  { pos = vec3( uv.x, -uv.y,   1.0); }\n            default { pos = vec3(-uv.x, -uv.y,  -1.0); }\n        }\n\n        return normalize(pos);\n    }\n",i="\n    const INVALID_FACE = 6;\n    const INVALID_IDX = 4294967295u; // max u32\n\n    fn cubeSampleCoord(coord: vec3i, w: u32) -> vec3u {\n        // a flattened matrix of destination faces based on\n        // starting face and direction\n        const dfaces = array(\n            //                               I  Up Down Left Right Invalid\n            0, 2, 3, 4, 5, INVALID_FACE, // +X  +Y   -Y   +Z   -Z   \n            1, 2, 3, 5, 4, INVALID_FACE, // -X  +Y   -Y   -Z   +Z \n            2, 5, 4, 1, 0, INVALID_FACE, // +Y  -Z   +Z   -X   +X \n            3, 4, 5, 1, 0, INVALID_FACE, // -Y  +Z   -Z   -X   +X \n            4, 2, 3, 1, 0, INVALID_FACE, // +Z  +Y   -Y   -X   +X \n            5, 2, 3, 0, 1, INVALID_FACE, // -Z  +Y   -Y   +X   -X \n        );\n\n        // a flattened matrix in the same form as dfaces\n        // giving the index of the dmat array containing \n        // the transformation from the starting face to \n        // the destination face\n        const dindices = array(\n            0, 1,  2,  3,  4,  0,\n            0, 5,  6,  3,  4,  0,\n            0, 7,  8,  9,  10, 0,\n            0, 11, 12, 13, 14, 0,\n            0, 11, 8,  3,  4,  0,\n            0, 7,  12, 3,  4,  0,\n        );\n\n        // 2x4 matrices transforming a coordinate vector <u, v, w, 1>\n        // from one face to another\n        const dmats = array(\n            array(// 0\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 1\n                vec4(0, 1, 1, 0),   // u = v + w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 2\n                vec4(0, -1, 2, -1), // u = 2w - v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 3\n                vec4(1, 0, 1, 0),   // u = u + w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 4\n                vec4(1, 0, -1, 0),  // u = u - w\n                vec4(0, 1, 0, 0),   // v = v\n            ),\n            array(// 5\n                vec4(0, -1, 0, -1), // u = -v - 1\n                vec4(1, 0, 0, 0),   // v = u\n            ),\n            array(// 6\n                vec4(0, 1, -1, 0),  // u = v - w\n                vec4(-1, 0, 1, -1), // v = w - u - 1\n            ),\n            array(// 7\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 0, -1), // v = -v - 1\n            ),\n            array(// 8\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, -1, 0),  // v = v - w\n            ),\n            array(// 9\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 0, -1), // v = -u - 1\n            ),\n            array(// 10\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, -1, 0),  // v = u - w\n            ),\n            array(// 11\n                vec4(1, 0, 0, 0),   // u = u\n                vec4(0, 1, 1, 0),   // v = v + w\n            ),\n            array(// 12\n                vec4(-1, 0, 1, -1), // u = w - u - 1\n                vec4(0, -1, 2, -1), // v = 2w - v - 1\n            ),\n            array(// 13\n                vec4(0, -1, 1, -1), // u = w - v - 1\n                vec4(1, 0, 1, 0),   // v = u + w\n            ),\n            array(// 14\n                vec4(0, 1, 0, 0),   // u = v\n                vec4(-1, 0, 2, -1), // v = 2w - u - 1\n            ),\n        );\n\n        let iw = i32(w);\n\n        var dir = 0;\n        if (\n            coord.y >= iw * 2 - 1 \n            || coord.y <= -iw \n            || coord.x >= iw * 2 - 1 \n            || coord.x <= -iw\n        ) {\n            dir = 5;\n        } else {\n            if (coord.y < 0) {\n                dir = 1;\n            } else if (coord.y >= iw) {\n                dir = 2;\n            }\n            if (coord.x < 0) {\n                dir = select(5, 3, dir == 0);\n            } else if (coord.x >= iw) {\n                dir = select(5, 4, dir == 0);\n            }\n        }\n\n        let idx = coord.z * 6 + dir;\n        let samp = vec4(coord.xy, iw, 1);\n        let dmat = dmats[dindices[idx]];\n        return vec3u(vec3(dot(dmat[0], samp), dot(dmat[1], samp), dfaces[idx]));\n    }\n\n    fn cubeCoordToIdx(coord: vec3u, w: u32) -> u32 {\n        return coord.x + coord.y * w + coord.z * w * w;\n    }\n\n    fn cubeIdxToCoord(idx: u32, w: u32) -> vec3u {\n        let w2 = w * w;\n        let fidx = idx % w2;\n        return vec3u(fidx % w, fidx / w, idx / w2);\n    }\n\n    fn cubeSampleIdx(uvf: vec3i, w: u32) -> u32 {\n        let coord = cubeSampleCoord(uvf, w);\n        return select(\n            cubeCoordToIdx(coord, w), \n            INVALID_IDX, \n            coord.z == INVALID_FACE,\n        );\n    }\n"},1575:(e,t,r)=>{if(r.d(t,{Lr:()=>o,gU:()=>u}),344==r.j)var n=r(9253);var i=r(8617);if(344==r.j)var a=r(825);function o(e,t,r,n,i=4){const a=i-1,o=r.createBuffer({label:n,usage:t,size:e.byteLength+a&~a,mappedAtCreation:!0}),s=new Uint8Array(o.getMappedRange()),u=e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength);return s.set(u),o.unmap(),o}async function s({device:e,texture:t,mipLevel:r=0,returnBuffer:n,storageBuffer:o,resultBuffer:s,description:u}){const l=i.T2[t.format],c=a.OY`[textureToKTX${u??""}${t.label}] --`;if(null==l)throw new Error(`${c} format ${t.format} unsupported`);const d=t.width>>r,p=t.height>>r,f=d*l,h=Math.max(f,256),v=p,m=v*h*t.depthOrArrayLayers,g=f*p*t.depthOrArrayLayers;if(null!=s&&s.byteLength<m)throw new Error(`${c} given result array not large enough.\n${s.byteLength} < ${m}`);if(null!=o&&o.size<m)throw new Error(`${c} given storage buffer not large enough.\n${o.size} < ${m}`);const b=GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ;if(null!=o&&(o.usage&b)!==b)throw new Error(`${c} given storage does not have correct usage flags.\nGiven: ${o.usage}\nRequired: ${b}`);let y=s??new Uint8Array(m);const x=o??e.createBuffer({label:`${c} storage buffer`,size:m,usage:b}),w=e.createCommandEncoder({label:`${c} encoder`});w.copyTextureToBuffer({texture:t,mipLevel:r},{buffer:x,rowsPerImage:v,bytesPerRow:h},{width:d,height:p,depthOrArrayLayers:t.depthOrArrayLayers}),e.queue.submit([w.finish()]),await Promise.all([x.mapAsync(GPUMapMode.READ,0,m),e.queue.onSubmittedWorkDone()]);const T=x.getMappedRange(0,m);if(y.set(new Uint8Array(T)),x.unmap(),h>f){for(let e=0;e<p*t.depthOrArrayLayers;e+=1)for(let t=0;t<f;t+=1)y[t+e*f]=y[t+e*h];y=y.slice(0,g)}return{imageData:y,storageBuffer:n?x:void 0}}async function u(e,t,r=!1){const a=i.T2[t.format],o=i.GE[t.format];if(null==a||null==o)throw new Error(`textureToKTX -- format ${t.format} of ${t.label} unsupported`);const u=new n.nYd;u.pixelWidth=t.width,u.pixelHeight=t.height,u.vkFormat=i.KO[t.format],u.typeSize=o,delete u.keyValue.KTXswizzle;const l=u.dataFormatDescriptor[0];if(l.colorModel=n.Tre,l.transferFunction=n.T5j,l.bytesPlane[0]=a,l.samples=[0,1,2,3].map((e=>({channelType:[192,193,194,207][e],samplePosition:[0,0,0,0],bitLength:8*u.typeSize-1,bitOffset:8*u.typeSize*e,sampleLower:-1082130432,sampleUpper:1065353216}))),"3d"===t.dimension)u.faceCount=1,u.pixelDepth=t.depthOrArrayLayers;else if(r){const e=t.depthOrArrayLayers/6;u.layerCount=1===e?0:e,u.faceCount=6}else u.layerCount=t.depthOrArrayLayers,u.faceCount=1;let c,d;for(let r=0;r<t.mipLevelCount;r+=1)({imageData:d,storageBuffer:c}=await s({mipLevel:r,returnBuffer:!0,device:e,texture:t,storageBuffer:c})),u.levels.push({levelData:d,uncompressedByteLength:d.byteLength});return n.M98(u)}}}]);
//# sourceMappingURL=438.bundle.js.map